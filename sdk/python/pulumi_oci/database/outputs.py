# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AutonomousContainerDatabaseAddStandbyBackupConfig',
    'AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail',
    'AutonomousContainerDatabaseAddStandbyDataguard',
    'AutonomousContainerDatabaseAddStandbyDataguardGroupMember',
    'AutonomousContainerDatabaseAddStandbyKeyHistoryEntry',
    'AutonomousContainerDatabaseAddStandbyMaintenanceWindow',
    'AutonomousContainerDatabaseAddStandbyMaintenanceWindowDaysOfWeek',
    'AutonomousContainerDatabaseAddStandbyMaintenanceWindowMonth',
    'AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfig',
    'AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail',
    'AutonomousContainerDatabaseAssociatedBackupConfigurationDetail',
    'AutonomousContainerDatabaseBackupConfig',
    'AutonomousContainerDatabaseBackupConfigBackupDestinationDetails',
    'AutonomousContainerDatabaseBackupDestinationPropertiesList',
    'AutonomousContainerDatabaseCustomerContact',
    'AutonomousContainerDatabaseDataguard',
    'AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfig',
    'AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail',
    'AutonomousContainerDatabaseDataguardGroupMember',
    'AutonomousContainerDatabaseKeyHistoryEntry',
    'AutonomousContainerDatabaseMaintenanceWindow',
    'AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek',
    'AutonomousContainerDatabaseMaintenanceWindowDetails',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsMonth',
    'AutonomousContainerDatabaseMaintenanceWindowMonth',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail',
    'AutonomousContainerDatabaseRecoveryApplianceDetail',
    'AutonomousDatabaseApexDetail',
    'AutonomousDatabaseBackupBackupDestinationDetails',
    'AutonomousDatabaseBackupConfig',
    'AutonomousDatabaseConnectionString',
    'AutonomousDatabaseConnectionStringProfile',
    'AutonomousDatabaseConnectionUrl',
    'AutonomousDatabaseCustomerContact',
    'AutonomousDatabaseDbToolsDetail',
    'AutonomousDatabaseEncryptionKey',
    'AutonomousDatabaseEncryptionKeyHistoryEntry',
    'AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey',
    'AutonomousDatabaseKeyHistoryEntry',
    'AutonomousDatabaseLocalStandbyDb',
    'AutonomousDatabaseLongTermBackupSchedule',
    'AutonomousDatabasePublicConnectionUrl',
    'AutonomousDatabaseRemoteDisasterRecoveryConfiguration',
    'AutonomousDatabaseResourcePoolSummary',
    'AutonomousDatabaseScheduledOperation',
    'AutonomousDatabaseScheduledOperationDayOfWeek',
    'AutonomousDatabaseStandbyDb',
    'AutonomousExadataInfrastructureMaintenanceWindow',
    'AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek',
    'AutonomousExadataInfrastructureMaintenanceWindowDetails',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth',
    'AutonomousExadataInfrastructureMaintenanceWindowMonth',
    'AutonomousVmClusterMaintenanceWindow',
    'AutonomousVmClusterMaintenanceWindowDaysOfWeek',
    'AutonomousVmClusterMaintenanceWindowDetail',
    'AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek',
    'AutonomousVmClusterMaintenanceWindowDetailMonth',
    'AutonomousVmClusterMaintenanceWindowMonth',
    'BackupDestinationAssociatedDatabase',
    'BackupDestinationMountTypeDetails',
    'BackupEncryptionKeyLocationDetail',
    'CloudAutonomousVmClusterMaintenanceWindow',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek',
    'CloudAutonomousVmClusterMaintenanceWindowDetails',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsMonth',
    'CloudAutonomousVmClusterMaintenanceWindowMonth',
    'CloudDatabaseManagementCredentialdetails',
    'CloudExadataInfrastructureCustomerContact',
    'CloudExadataInfrastructureDefinedFileSystemConfiguration',
    'CloudExadataInfrastructureMaintenanceWindow',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeek',
    'CloudExadataInfrastructureMaintenanceWindowMonth',
    'CloudVmClusterCloudAutomationUpdateDetails',
    'CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference',
    'CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod',
    'CloudVmClusterDataCollectionOptions',
    'CloudVmClusterFileSystemConfigurationDetail',
    'CloudVmClusterIormConfigCach',
    'CloudVmClusterIormConfigCachDbPlan',
    'CloudVmClusterIormConfigDbPlan',
    'CloudVmClusterMultiCloudIdentityConnectorConfig',
    'DataGuardAssociationDataCollectionOptions',
    'DatabaseConnectionString',
    'DatabaseDataGuardGroup',
    'DatabaseDataGuardGroupMember',
    'DatabaseDatabase',
    'DatabaseDatabaseDbBackupConfig',
    'DatabaseDatabaseDbBackupConfigBackupDestinationDetail',
    'DatabaseDatabaseEncryptionKeyLocationDetails',
    'DatabaseDatabaseManagementConfig',
    'DatabaseDatabaseSourceEncryptionKeyLocationDetails',
    'DatabaseDbBackupConfig',
    'DatabaseDbBackupConfigBackupDestinationDetail',
    'DatabaseUpgradeConnectionString',
    'DatabaseUpgradeDataGuardGroup',
    'DatabaseUpgradeDataGuardGroupMember',
    'DatabaseUpgradeDatabaseUpgradeSourceDetails',
    'DatabaseUpgradeDbBackupConfig',
    'DatabaseUpgradeDbBackupConfigBackupDestinationDetail',
    'DbHomeDatabase',
    'DbHomeDatabaseConnectionString',
    'DbHomeDatabaseDbBackupConfig',
    'DbHomeDatabaseDbBackupConfigBackupDestinationDetail',
    'DbHomeDatabaseEncryptionKeyLocationDetails',
    'DbSystemDataCollectionOptions',
    'DbSystemDbHome',
    'DbSystemDbHomeDatabase',
    'DbSystemDbHomeDatabaseConnectionString',
    'DbSystemDbHomeDatabaseDbBackupConfig',
    'DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail',
    'DbSystemDbSystemOptions',
    'DbSystemIormConfigCach',
    'DbSystemIormConfigCachDbPlan',
    'DbSystemMaintenanceWindow',
    'DbSystemMaintenanceWindowDaysOfWeek',
    'DbSystemMaintenanceWindowDetails',
    'DbSystemMaintenanceWindowDetailsDaysOfWeek',
    'DbSystemMaintenanceWindowDetailsMonth',
    'DbSystemMaintenanceWindowMonth',
    'DbSystemsUpgradeDbSystemOption',
    'DbSystemsUpgradeIormConfigCach',
    'DbSystemsUpgradeIormConfigCachDbPlan',
    'DbSystemsUpgradeMaintenanceWindow',
    'DbSystemsUpgradeMaintenanceWindowDaysOfWeek',
    'DbSystemsUpgradeMaintenanceWindowMonth',
    'ExadataInfrastructureComputeContact',
    'ExadataInfrastructureComputeMaintenanceWindow',
    'ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureComputeMaintenanceWindowMonth',
    'ExadataInfrastructureConfigureExascaleManagementContact',
    'ExadataInfrastructureConfigureExascaleManagementDefinedFileSystemConfiguration',
    'ExadataInfrastructureConfigureExascaleManagementExascaleConfig',
    'ExadataInfrastructureConfigureExascaleManagementMaintenanceWindow',
    'ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowMonth',
    'ExadataInfrastructureConfigureExascaleManagementNetworkBondingModeDetail',
    'ExadataInfrastructureContact',
    'ExadataInfrastructureDefinedFileSystemConfiguration',
    'ExadataInfrastructureExascaleConfig',
    'ExadataInfrastructureMaintenanceWindow',
    'ExadataInfrastructureMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureMaintenanceWindowMonth',
    'ExadataInfrastructureNetworkBondingModeDetails',
    'ExadataInfrastructureStorageContact',
    'ExadataInfrastructureStorageMaintenanceWindow',
    'ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureStorageMaintenanceWindowMonth',
    'ExadataIormConfigDbPlan',
    'ExadbVmClusterDataCollectionOptions',
    'ExadbVmClusterIormConfigCach',
    'ExadbVmClusterIormConfigCachDbPlan',
    'ExadbVmClusterNodeConfig',
    'ExadbVmClusterNodeResource',
    'ExascaleDbStorageVaultHighCapacityDatabaseStorage',
    'ExecutionActionActionMember',
    'ExternalContainerDatabaseDatabaseManagementConfig',
    'ExternalContainerDatabaseStackMonitoringConfig',
    'ExternalDatabaseConnectorConnectionCredentials',
    'ExternalDatabaseConnectorConnectionString',
    'ExternalNonContainerDatabaseDatabaseManagementConfig',
    'ExternalNonContainerDatabaseOperationsInsightsConfig',
    'ExternalNonContainerDatabaseStackMonitoringConfig',
    'ExternalPluggableDatabaseDatabaseManagementConfig',
    'ExternalPluggableDatabaseOperationsInsightsConfig',
    'ExternalPluggableDatabaseStackMonitoringConfig',
    'KeyStoreAssociatedDatabase',
    'KeyStoreTypeDetails',
    'MaintenanceRunEstimatedPatchingTime',
    'PluggableDatabaseConnectionString',
    'PluggableDatabaseManagementsManagementConnectionString',
    'PluggableDatabaseManagementsManagementCredentialDetails',
    'PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig',
    'PluggableDatabasePdbCreationTypeDetails',
    'PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails',
    'PluggableDatabasePdbNodeLevelDetail',
    'PluggableDatabasePluggableDatabaseManagementConfig',
    'PluggableDatabaseRefreshableCloneConfig',
    'PluggableDatabasesLocalCloneConnectionString',
    'PluggableDatabasesLocalClonePdbNodeLevelDetail',
    'PluggableDatabasesLocalClonePluggableDatabaseManagementConfig',
    'PluggableDatabasesLocalCloneRefreshableCloneConfig',
    'PluggableDatabasesRemoteCloneConnectionString',
    'PluggableDatabasesRemoteClonePdbNodeLevelDetail',
    'PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig',
    'PluggableDatabasesRemoteCloneRefreshableCloneConfig',
    'ScheduledActionActionMember',
    'SchedulingPolicyCadenceStartMonth',
    'SchedulingPolicySchedulingWindowWindowPreference',
    'SchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeek',
    'SchedulingPolicySchedulingWindowWindowPreferenceMonth',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetail',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod',
    'VmClusterAddVirtualNetworkDataCollectionOption',
    'VmClusterAddVirtualNetworkDbServer',
    'VmClusterAddVirtualNetworkFileSystemConfigurationDetail',
    'VmClusterCloudAutomationUpdateDetails',
    'VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference',
    'VmClusterCloudAutomationUpdateDetailsFreezePeriod',
    'VmClusterDataCollectionOptions',
    'VmClusterFileSystemConfigurationDetail',
    'VmClusterNetworkDrScan',
    'VmClusterNetworkScan',
    'VmClusterNetworkVmNetwork',
    'VmClusterNetworkVmNetworkNode',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetail',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod',
    'VmClusterRemoveVirtualMachineDataCollectionOption',
    'VmClusterRemoveVirtualMachineDbServer',
    'VmClusterRemoveVirtualMachineFileSystemConfigurationDetail',
    'GetApplicationVipsApplicationVipResult',
    'GetApplicationVipsFilterResult',
    'GetAutonomousCharacterSetsAutonomousDatabaseCharacterSetResult',
    'GetAutonomousCharacterSetsFilterResult',
    'GetAutonomousContainerDatabaseAssociatedBackupConfigurationDetailResult',
    'GetAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabaseBackupDestinationPropertiesListResult',
    'GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionResult',
    'GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemResult',
    'GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemAutonomousDatabaseResult',
    'GetAutonomousContainerDatabaseBackupsFilterResult',
    'GetAutonomousContainerDatabaseCustomerContactResult',
    'GetAutonomousContainerDatabaseDataguardResult',
    'GetAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationResult',
    'GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabaseDataguardAssociationsFilterResult',
    'GetAutonomousContainerDatabaseDataguardGroupMemberResult',
    'GetAutonomousContainerDatabaseKeyHistoryEntryResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDetailResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowMonthResult',
    'GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabaseRecoveryApplianceDetailResult',
    'GetAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult',
    'GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionResult',
    'GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult',
    'GetAutonomousContainerDatabaseVersionsFilterResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseAssociatedBackupConfigurationDetailResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupDestinationPropertiesListResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseCustomerContactResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardGroupMemberResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseRecoveryApplianceDetailResult',
    'GetAutonomousContainerDatabasesFilterResult',
    'GetAutonomousContainerPatchesAutonomousPatchResult',
    'GetAutonomousContainerPatchesFilterResult',
    'GetAutonomousDatabaseApexDetailResult',
    'GetAutonomousDatabaseBackupBackupDestinationDetailResult',
    'GetAutonomousDatabaseBackupConfigResult',
    'GetAutonomousDatabaseBackupsAutonomousDatabaseBackupResult',
    'GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult',
    'GetAutonomousDatabaseBackupsFilterResult',
    'GetAutonomousDatabaseConnectionStringResult',
    'GetAutonomousDatabaseConnectionStringProfileResult',
    'GetAutonomousDatabaseConnectionUrlResult',
    'GetAutonomousDatabaseCustomerContactResult',
    'GetAutonomousDatabaseDataguardAssociationsAutonomousDatabaseDataguardAssociationResult',
    'GetAutonomousDatabaseDataguardAssociationsFilterResult',
    'GetAutonomousDatabaseDbToolsDetailResult',
    'GetAutonomousDatabaseEncryptionKeyResult',
    'GetAutonomousDatabaseEncryptionKeyHistoryEntryResult',
    'GetAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult',
    'GetAutonomousDatabaseKeyHistoryEntryResult',
    'GetAutonomousDatabaseLocalStandbyDbResult',
    'GetAutonomousDatabaseLongTermBackupScheduleResult',
    'GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionResult',
    'GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionItemResult',
    'GetAutonomousDatabasePeersFilterResult',
    'GetAutonomousDatabasePublicConnectionUrlResult',
    'GetAutonomousDatabaseRefreshableClonesFilterResult',
    'GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionResult',
    'GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult',
    'GetAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult',
    'GetAutonomousDatabaseResourcePoolMembersFilterResult',
    'GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionResult',
    'GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionItemResult',
    'GetAutonomousDatabaseResourcePoolSummaryResult',
    'GetAutonomousDatabaseScheduledOperationResult',
    'GetAutonomousDatabaseScheduledOperationDayOfWeekResult',
    'GetAutonomousDatabaseSoftwareImagesAutonomousDatabaseSoftwareImageCollectionResult',
    'GetAutonomousDatabaseSoftwareImagesAutonomousDatabaseSoftwareImageCollectionItemResult',
    'GetAutonomousDatabaseSoftwareImagesFilterResult',
    'GetAutonomousDatabaseStandbyDbResult',
    'GetAutonomousDatabasesAutonomousDatabaseResult',
    'GetAutonomousDatabasesAutonomousDatabaseApexDetailResult',
    'GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult',
    'GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult',
    'GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult',
    'GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult',
    'GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult',
    'GetAutonomousDatabasesAutonomousDatabaseDbToolsDetailResult',
    'GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyResult',
    'GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryResult',
    'GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult',
    'GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult',
    'GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult',
    'GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult',
    'GetAutonomousDatabasesAutonomousDatabasePublicConnectionUrlResult',
    'GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult',
    'GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult',
    'GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult',
    'GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult',
    'GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseDbToolsDetailResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult',
    'GetAutonomousDatabasesClonesAutonomousDatabasePublicConnectionUrlResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult',
    'GetAutonomousDatabasesClonesFilterResult',
    'GetAutonomousDatabasesFilterResult',
    'GetAutonomousDbPreviewVersionsAutonomousDbPreviewVersionResult',
    'GetAutonomousDbPreviewVersionsFilterResult',
    'GetAutonomousDbVersionsAutonomousDbVersionResult',
    'GetAutonomousDbVersionsFilterResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDetailResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult',
    'GetAutonomousExadataInfrastructureOcpuByWorkloadTypeResult',
    'GetAutonomousExadataInfrastructureShapesAutonomousExadataInfrastructureShapeResult',
    'GetAutonomousExadataInfrastructureShapesFilterResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult',
    'GetAutonomousExadataInfrastructuresFilterResult',
    'GetAutonomousVirtualMachinesAutonomousVirtualMachineResult',
    'GetAutonomousVirtualMachinesFilterResult',
    'GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult',
    'GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult',
    'GetAutonomousVmClusterAcdResourceUsagesFilterResult',
    'GetAutonomousVmClusterMaintenanceWindowResult',
    'GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult',
    'GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult',
    'GetAutonomousVmClustersAutonomousVmClusterResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetAutonomousVmClustersFilterResult',
    'GetBackupDestinationAssociatedDatabaseResult',
    'GetBackupDestinationMountTypeDetailResult',
    'GetBackupDestinationsBackupDestinationResult',
    'GetBackupDestinationsBackupDestinationAssociatedDatabaseResult',
    'GetBackupDestinationsBackupDestinationMountTypeDetailResult',
    'GetBackupDestinationsFilterResult',
    'GetBackupsBackupResult',
    'GetBackupsBackupEncryptionKeyLocationDetailResult',
    'GetBackupsFilterResult',
    'GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult',
    'GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult',
    'GetCloudAutonomousVmClusterAcdResourceUsagesFilterResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult',
    'GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetCloudAutonomousVmClustersFilterResult',
    'GetCloudExadataInfrastructureCustomerContactResult',
    'GetCloudExadataInfrastructureDefinedFileSystemConfigurationResult',
    'GetCloudExadataInfrastructureMaintenanceWindowResult',
    'GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetCloudExadataInfrastructureMaintenanceWindowMonthResult',
    'GetCloudExadataInfrastructureUnAllocatedResourceCloudAutonomousVmClusterResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureDefinedFileSystemConfigurationResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult',
    'GetCloudExadataInfrastructuresFilterResult',
    'GetCloudVmClusterCloudAutomationUpdateDetailResult',
    'GetCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult',
    'GetCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult',
    'GetCloudVmClusterDataCollectionOptionResult',
    'GetCloudVmClusterFileSystemConfigurationDetailResult',
    'GetCloudVmClusterIormConfigCachResult',
    'GetCloudVmClusterIormConfigCachDbPlanResult',
    'GetCloudVmClusterIormConfigDbPlanResult',
    'GetCloudVmClusterMultiCloudIdentityConnectorConfigResult',
    'GetCloudVmClustersCloudVmClusterResult',
    'GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailResult',
    'GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult',
    'GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult',
    'GetCloudVmClustersCloudVmClusterDataCollectionOptionResult',
    'GetCloudVmClustersCloudVmClusterFileSystemConfigurationDetailResult',
    'GetCloudVmClustersCloudVmClusterIormConfigCachResult',
    'GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult',
    'GetCloudVmClustersCloudVmClusterMultiCloudIdentityConnectorConfigResult',
    'GetCloudVmClustersFilterResult',
    'GetDataGuardAssociationDataCollectionOptionResult',
    'GetDataGuardAssociationsDataGuardAssociationResult',
    'GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult',
    'GetDataGuardAssociationsFilterResult',
    'GetDatabaseConnectionStringResult',
    'GetDatabaseDataGuardGroupResult',
    'GetDatabaseDataGuardGroupMemberResult',
    'GetDatabaseDatabaseResult',
    'GetDatabaseDatabaseDbBackupConfigResult',
    'GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabaseDatabaseEncryptionKeyLocationDetailResult',
    'GetDatabaseDatabaseManagementConfigResult',
    'GetDatabaseDatabaseSourceEncryptionKeyLocationDetailResult',
    'GetDatabaseDbBackupConfigResult',
    'GetDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabaseMaintenanceRunHistoriesFilterResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult',
    'GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailResult',
    'GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult',
    'GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryResult',
    'GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult',
    'GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult',
    'GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult',
    'GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailResult',
    'GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult',
    'GetDatabasePdbConversionHistoryEntriesFilterResult',
    'GetDatabasePdbConversionHistoryEntriesPdbConversionHistoryEntryResult',
    'GetDatabaseSoftwareImagesDatabaseSoftwareImageResult',
    'GetDatabaseSoftwareImagesFilterResult',
    'GetDatabaseUpgradeHistoryEntriesDatabaseUpgradeHistoryEntryResult',
    'GetDatabaseUpgradeHistoryEntriesFilterResult',
    'GetDatabasesDatabaseResult',
    'GetDatabasesDatabaseConnectionStringResult',
    'GetDatabasesDatabaseDataGuardGroupResult',
    'GetDatabasesDatabaseDataGuardGroupMemberResult',
    'GetDatabasesDatabaseDatabaseResult',
    'GetDatabasesDatabaseDatabaseDbBackupConfigResult',
    'GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabasesDatabaseDatabaseEncryptionKeyLocationDetailResult',
    'GetDatabasesDatabaseDatabaseManagementConfigResult',
    'GetDatabasesDatabaseDatabaseSourceEncryptionKeyLocationDetailResult',
    'GetDatabasesDatabaseDbBackupConfigResult',
    'GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabasesFilterResult',
    'GetDbHomeDatabaseResult',
    'GetDbHomeDatabaseConnectionStringResult',
    'GetDbHomeDatabaseDbBackupConfigResult',
    'GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDbHomeDatabaseEncryptionKeyLocationDetailResult',
    'GetDbHomePatchHistoryEntriesFilterResult',
    'GetDbHomePatchHistoryEntriesPatchHistoryEntryResult',
    'GetDbHomePatchesFilterResult',
    'GetDbHomePatchesPatchResult',
    'GetDbHomesDbHomeResult',
    'GetDbHomesDbHomeDatabaseResult',
    'GetDbHomesDbHomeDatabaseConnectionStringResult',
    'GetDbHomesDbHomeDatabaseDbBackupConfigResult',
    'GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDbHomesDbHomeDatabaseEncryptionKeyLocationDetailResult',
    'GetDbHomesFilterResult',
    'GetDbNodeConsoleConnectionsConsoleConnectionResult',
    'GetDbNodeConsoleConnectionsFilterResult',
    'GetDbNodeConsoleHistoriesConsoleHistoryCollectionResult',
    'GetDbNodeConsoleHistoriesConsoleHistoryCollectionItemResult',
    'GetDbNodeConsoleHistoriesFilterResult',
    'GetDbNodesDbNodeResult',
    'GetDbNodesFilterResult',
    'GetDbServerDbServerPatchingDetailResult',
    'GetDbServersDbServerResult',
    'GetDbServersDbServerDbServerPatchingDetailResult',
    'GetDbServersFilterResult',
    'GetDbSystemComputePerformancesDbSystemComputePerformanceResult',
    'GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult',
    'GetDbSystemComputePerformancesFilterResult',
    'GetDbSystemHistoryEntriesFilterResult',
    'GetDbSystemHistoryEntriesPatchHistoryEntryResult',
    'GetDbSystemPatchesFilterResult',
    'GetDbSystemPatchesPatchResult',
    'GetDbSystemShapesDbSystemShapeResult',
    'GetDbSystemShapesFilterResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult',
    'GetDbSystemStoragePerformancesFilterResult',
    'GetDbSystemsDbSystemResult',
    'GetDbSystemsDbSystemDataCollectionOptionResult',
    'GetDbSystemsDbSystemDbHomeResult',
    'GetDbSystemsDbSystemDbHomeDatabaseResult',
    'GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult',
    'GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult',
    'GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDbSystemsDbSystemDbSystemOptionResult',
    'GetDbSystemsDbSystemIormConfigCachResult',
    'GetDbSystemsDbSystemIormConfigCachDbPlanResult',
    'GetDbSystemsDbSystemMaintenanceWindowResult',
    'GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult',
    'GetDbSystemsDbSystemMaintenanceWindowDetailResult',
    'GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult',
    'GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult',
    'GetDbSystemsDbSystemMaintenanceWindowMonthResult',
    'GetDbSystemsFilterResult',
    'GetDbSystemsUpgradeHistoryEntriesDbSystemUpgradeHistoryEntryResult',
    'GetDbSystemsUpgradeHistoryEntriesFilterResult',
    'GetDbVersionsDbVersionResult',
    'GetDbVersionsFilterResult',
    'GetExadataInfrastructureContactResult',
    'GetExadataInfrastructureDefinedFileSystemConfigurationResult',
    'GetExadataInfrastructureExascaleConfigResult',
    'GetExadataInfrastructureMaintenanceWindowResult',
    'GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetExadataInfrastructureMaintenanceWindowMonthResult',
    'GetExadataInfrastructureNetworkBondingModeDetailResult',
    'GetExadataInfrastructureUnAllocatedResourceAutonomousVmClusterResult',
    'GetExadataInfrastructuresExadataInfrastructureResult',
    'GetExadataInfrastructuresExadataInfrastructureContactResult',
    'GetExadataInfrastructuresExadataInfrastructureDefinedFileSystemConfigurationResult',
    'GetExadataInfrastructuresExadataInfrastructureExascaleConfigResult',
    'GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult',
    'GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult',
    'GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult',
    'GetExadataInfrastructuresFilterResult',
    'GetExadataIormConfigDbPlanResult',
    'GetExadbVmClusterDataCollectionOptionResult',
    'GetExadbVmClusterIormConfigCachResult',
    'GetExadbVmClusterIormConfigCachDbPlanResult',
    'GetExadbVmClusterNodeConfigResult',
    'GetExadbVmClusterNodeResourceResult',
    'GetExadbVmClusterUpdateHistoryEntriesExadbVmClusterUpdateHistoryEntryResult',
    'GetExadbVmClusterUpdateHistoryEntriesFilterResult',
    'GetExadbVmClusterUpdatesExadbVmClusterUpdateResult',
    'GetExadbVmClusterUpdatesFilterResult',
    'GetExadbVmClustersExadbVmClusterResult',
    'GetExadbVmClustersExadbVmClusterDataCollectionOptionResult',
    'GetExadbVmClustersExadbVmClusterIormConfigCachResult',
    'GetExadbVmClustersExadbVmClusterIormConfigCachDbPlanResult',
    'GetExadbVmClustersExadbVmClusterNodeConfigResult',
    'GetExadbVmClustersExadbVmClusterNodeResourceResult',
    'GetExadbVmClustersFilterResult',
    'GetExascaleDbStorageVaultHighCapacityDatabaseStorageResult',
    'GetExascaleDbStorageVaultsExascaleDbStorageVaultResult',
    'GetExascaleDbStorageVaultsExascaleDbStorageVaultHighCapacityDatabaseStorageResult',
    'GetExascaleDbStorageVaultsFilterResult',
    'GetExecutionActionActionMemberResult',
    'GetExecutionActionsExecutionActionResult',
    'GetExecutionActionsExecutionActionActionMemberResult',
    'GetExecutionActionsFilterResult',
    'GetExecutionWindowsExecutionWindowResult',
    'GetExecutionWindowsFilterResult',
    'GetExternalContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalContainerDatabaseStackMonitoringConfigResult',
    'GetExternalContainerDatabasesExternalContainerDatabaseResult',
    'GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult',
    'GetExternalContainerDatabasesFilterResult',
    'GetExternalDatabaseConnectorConnectionCredentialResult',
    'GetExternalDatabaseConnectorConnectionStringResult',
    'GetExternalDatabaseConnectorsExternalDatabaseConnectorResult',
    'GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult',
    'GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult',
    'GetExternalDatabaseConnectorsFilterResult',
    'GetExternalNonContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalNonContainerDatabaseOperationsInsightsConfigResult',
    'GetExternalNonContainerDatabaseStackMonitoringConfigResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult',
    'GetExternalNonContainerDatabasesFilterResult',
    'GetExternalPluggableDatabaseDatabaseManagementConfigResult',
    'GetExternalPluggableDatabaseOperationsInsightsConfigResult',
    'GetExternalPluggableDatabaseStackMonitoringConfigResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult',
    'GetExternalPluggableDatabasesFilterResult',
    'GetFlexComponentsFilterResult',
    'GetFlexComponentsFlexComponentCollectionResult',
    'GetFlexComponentsFlexComponentCollectionItemResult',
    'GetGiVersionMinorVersionsFilterResult',
    'GetGiVersionMinorVersionsGiMinorVersionResult',
    'GetGiVersionsFilterResult',
    'GetGiVersionsGiVersionResult',
    'GetKeyStoreAssociatedDatabaseResult',
    'GetKeyStoreTypeDetailResult',
    'GetKeyStoresFilterResult',
    'GetKeyStoresKeyStoreResult',
    'GetKeyStoresKeyStoreAssociatedDatabaseResult',
    'GetKeyStoresKeyStoreTypeDetailResult',
    'GetMaintenanceRunEstimatedPatchingTimeResult',
    'GetMaintenanceRunsFilterResult',
    'GetMaintenanceRunsMaintenanceRunResult',
    'GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult',
    'GetManagedPreferredCredentialsFilterResult',
    'GetManagedPreferredCredentialsPreferredCredentialCollectionResult',
    'GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult',
    'GetOneoffPatchesFilterResult',
    'GetOneoffPatchesOneoffPatchResult',
    'GetPluggableDatabaseConnectionStringResult',
    'GetPluggableDatabasePdbCreationTypeDetailResult',
    'GetPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult',
    'GetPluggableDatabasePdbNodeLevelDetailResult',
    'GetPluggableDatabasePluggableDatabaseManagementConfigResult',
    'GetPluggableDatabaseRefreshableCloneConfigResult',
    'GetPluggableDatabaseSnapshotsFilterResult',
    'GetPluggableDatabaseSnapshotsPluggableDatabaseSnapshotResult',
    'GetPluggableDatabasesFilterResult',
    'GetPluggableDatabasesPluggableDatabaseResult',
    'GetPluggableDatabasesPluggableDatabaseConnectionStringResult',
    'GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailResult',
    'GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult',
    'GetPluggableDatabasesPluggableDatabasePdbNodeLevelDetailResult',
    'GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult',
    'GetPluggableDatabasesPluggableDatabaseRefreshableCloneConfigResult',
    'GetScheduledActionActionMemberResult',
    'GetScheduledActionParamsActionParamValuesCollectionResult',
    'GetScheduledActionParamsActionParamValuesCollectionItemResult',
    'GetScheduledActionParamsFilterResult',
    'GetScheduledActionsFilterResult',
    'GetScheduledActionsScheduledActionCollectionResult',
    'GetScheduledActionsScheduledActionCollectionItemResult',
    'GetScheduledActionsScheduledActionCollectionItemActionMemberResult',
    'GetSchedulingPlansFilterResult',
    'GetSchedulingPlansSchedulingPlanCollectionResult',
    'GetSchedulingPlansSchedulingPlanCollectionItemResult',
    'GetSchedulingPoliciesFilterResult',
    'GetSchedulingPoliciesSchedulingPolicyResult',
    'GetSchedulingPoliciesSchedulingPolicyCadenceStartMonthResult',
    'GetSchedulingPolicyCadenceStartMonthResult',
    'GetSchedulingPolicyRecommendedScheduledActionsFilterResult',
    'GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionResult',
    'GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemResult',
    'GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemActionMemberResult',
    'GetSchedulingPolicySchedulingWindowWindowPreferenceResult',
    'GetSchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeekResult',
    'GetSchedulingPolicySchedulingWindowWindowPreferenceMonthResult',
    'GetSchedulingPolicySchedulingWindowsFilterResult',
    'GetSchedulingPolicySchedulingWindowsSchedulingWindowResult',
    'GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceResult',
    'GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceDaysOfWeekResult',
    'GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceMonthResult',
    'GetSystemVersionMinorVersionsFilterResult',
    'GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionResult',
    'GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionItemResult',
    'GetSystemVersionsFilterResult',
    'GetSystemVersionsSystemVersionCollectionResult',
    'GetSystemVersionsSystemVersionCollectionItemResult',
    'GetVmClusterCloudAutomationUpdateDetailResult',
    'GetVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult',
    'GetVmClusterCloudAutomationUpdateDetailFreezePeriodResult',
    'GetVmClusterDataCollectionOptionResult',
    'GetVmClusterFileSystemConfigurationDetailResult',
    'GetVmClusterNetworkDrScanResult',
    'GetVmClusterNetworkScanResult',
    'GetVmClusterNetworkVmNetworkResult',
    'GetVmClusterNetworkVmNetworkNodeResult',
    'GetVmClusterNetworksFilterResult',
    'GetVmClusterNetworksVmClusterNetworkResult',
    'GetVmClusterNetworksVmClusterNetworkDrScanResult',
    'GetVmClusterNetworksVmClusterNetworkScanResult',
    'GetVmClusterNetworksVmClusterNetworkVmNetworkResult',
    'GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult',
    'GetVmClusterPatchHistoryEntriesFilterResult',
    'GetVmClusterPatchHistoryEntriesPatchHistoryEntryResult',
    'GetVmClusterPatchesFilterResult',
    'GetVmClusterPatchesPatchResult',
    'GetVmClusterRecommendedNetworkDrScanResult',
    'GetVmClusterRecommendedNetworkNetworkResult',
    'GetVmClusterRecommendedNetworkScanResult',
    'GetVmClusterRecommendedNetworkVmNetworkResult',
    'GetVmClusterRecommendedNetworkVmNetworkNodeResult',
    'GetVmClusterUpdateHistoryEntriesFilterResult',
    'GetVmClusterUpdateHistoryEntriesVmClusterUpdateHistoryEntryResult',
    'GetVmClusterUpdatesFilterResult',
    'GetVmClusterUpdatesVmClusterUpdateResult',
    'GetVmClustersFilterResult',
    'GetVmClustersVmClusterResult',
    'GetVmClustersVmClusterCloudAutomationUpdateDetailResult',
    'GetVmClustersVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult',
    'GetVmClustersVmClusterCloudAutomationUpdateDetailFreezePeriodResult',
    'GetVmClustersVmClusterDataCollectionOptionResult',
    'GetVmClustersVmClusterFileSystemConfigurationDetailResult',
]

@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None):
        """
        :param Sequence['AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyDataguard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyLag":
            suggest = "apply_lag"
        elif key == "applyRate":
            suggest = "apply_rate"
        elif key == "automaticFailoverTarget":
            suggest = "automatic_failover_target"
        elif key == "autonomousContainerDatabaseId":
            suggest = "autonomous_container_database_id"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "fastStartFailOverLagLimitInSeconds":
            suggest = "fast_start_fail_over_lag_limit_in_seconds"
        elif key == "isAutomaticFailoverEnabled":
            suggest = "is_automatic_failover_enabled"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "redoTransportMode":
            suggest = "redo_transport_mode"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeLagRefreshedOn":
            suggest = "time_lag_refreshed_on"
        elif key == "timeLastRoleChanged":
            suggest = "time_last_role_changed"
        elif key == "timeLastSynced":
            suggest = "time_last_synced"
        elif key == "transportLag":
            suggest = "transport_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyDataguard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyDataguard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyDataguard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_lag: Optional[_builtins.str] = None,
                 apply_rate: Optional[_builtins.str] = None,
                 automatic_failover_target: Optional[_builtins.str] = None,
                 autonomous_container_database_id: Optional[_builtins.str] = None,
                 availability_domain: Optional[_builtins.str] = None,
                 fast_start_fail_over_lag_limit_in_seconds: Optional[_builtins.int] = None,
                 is_automatic_failover_enabled: Optional[_builtins.bool] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 protection_mode: Optional[_builtins.str] = None,
                 redo_transport_mode: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_lag_refreshed_on: Optional[_builtins.str] = None,
                 time_last_role_changed: Optional[_builtins.str] = None,
                 time_last_synced: Optional[_builtins.str] = None,
                 transport_lag: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str availability_domain: The domain of the Autonomous Container Database
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of the Autonomous Container Database.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        if apply_lag is not None:
            pulumi.set(__self__, "apply_lag", apply_lag)
        if apply_rate is not None:
            pulumi.set(__self__, "apply_rate", apply_rate)
        if automatic_failover_target is not None:
            pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        if autonomous_container_database_id is not None:
            pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fast_start_fail_over_lag_limit_in_seconds is not None:
            pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        if is_automatic_failover_enabled is not None:
            pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if redo_transport_mode is not None:
            pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_lag_refreshed_on is not None:
            pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        if time_last_role_changed is not None:
            pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        if time_last_synced is not None:
            pulumi.set(__self__, "time_last_synced", time_last_synced)
        if transport_lag is not None:
            pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> Optional[_builtins.str]:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> Optional[_builtins.str]:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The domain of the Autonomous Container Database
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> Optional[_builtins.int]:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> Optional[_builtins.str]:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> Optional[_builtins.str]:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> Optional[_builtins.str]:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyDataguardGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyLag":
            suggest = "apply_lag"
        elif key == "applyRate":
            suggest = "apply_rate"
        elif key == "automaticFailoverTarget":
            suggest = "automatic_failover_target"
        elif key == "autonomousContainerDatabaseId":
            suggest = "autonomous_container_database_id"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "fastStartFailOverLagLimitInSeconds":
            suggest = "fast_start_fail_over_lag_limit_in_seconds"
        elif key == "isAutomaticFailoverEnabled":
            suggest = "is_automatic_failover_enabled"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "redoTransportMode":
            suggest = "redo_transport_mode"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeLagRefreshedOn":
            suggest = "time_lag_refreshed_on"
        elif key == "timeLastRoleChanged":
            suggest = "time_last_role_changed"
        elif key == "timeLastSynced":
            suggest = "time_last_synced"
        elif key == "transportLag":
            suggest = "transport_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyDataguardGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyDataguardGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyDataguardGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_lag: Optional[_builtins.str] = None,
                 apply_rate: Optional[_builtins.str] = None,
                 automatic_failover_target: Optional[_builtins.str] = None,
                 autonomous_container_database_id: Optional[_builtins.str] = None,
                 availability_domain: Optional[_builtins.str] = None,
                 fast_start_fail_over_lag_limit_in_seconds: Optional[_builtins.int] = None,
                 is_automatic_failover_enabled: Optional[_builtins.bool] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 protection_mode: Optional[_builtins.str] = None,
                 redo_transport_mode: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_lag_refreshed_on: Optional[_builtins.str] = None,
                 time_last_role_changed: Optional[_builtins.str] = None,
                 time_last_synced: Optional[_builtins.str] = None,
                 transport_lag: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str availability_domain: The domain of the Autonomous Container Database
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of the Autonomous Container Database.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        if apply_lag is not None:
            pulumi.set(__self__, "apply_lag", apply_lag)
        if apply_rate is not None:
            pulumi.set(__self__, "apply_rate", apply_rate)
        if automatic_failover_target is not None:
            pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        if autonomous_container_database_id is not None:
            pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fast_start_fail_over_lag_limit_in_seconds is not None:
            pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        if is_automatic_failover_enabled is not None:
            pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if redo_transport_mode is not None:
            pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_lag_refreshed_on is not None:
            pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        if time_last_role_changed is not None:
            pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        if time_last_synced is not None:
            pulumi.set(__self__, "time_last_synced", time_last_synced)
        if transport_lag is not None:
            pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> Optional[_builtins.str]:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> Optional[_builtins.str]:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The domain of the Autonomous Container Database
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> Optional[_builtins.int]:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> Optional[_builtins.str]:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> Optional[_builtins.str]:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> Optional[_builtins.str]:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyKeyHistoryEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyKeyHistoryEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyKeyHistoryEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyKeyHistoryEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 kms_key_version_id: Optional[_builtins.str] = None,
                 time_activated: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[_builtins.str]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousContainerDatabaseAddStandbyMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are - 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousContainerDatabaseAddStandbyMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are - 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None):
        """
        :param Sequence['AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAddStandbyPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseAssociatedBackupConfigurationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationAttachHistories":
            suggest = "backup_destination_attach_histories"
        elif key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "spaceUtilizedInGbs":
            suggest = "space_utilized_in_gbs"
        elif key == "timeAtWhichStorageDetailsAreUpdated":
            suggest = "time_at_which_storage_details_are_updated"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseAssociatedBackupConfigurationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseAssociatedBackupConfigurationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseAssociatedBackupConfigurationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_attach_histories: Optional[Sequence[_builtins.str]] = None,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 space_utilized_in_gbs: Optional[_builtins.int] = None,
                 time_at_which_storage_details_are_updated: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] backup_destination_attach_histories: The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        :param _builtins.int space_utilized_in_gbs: The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        :param _builtins.str time_at_which_storage_details_are_updated: The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if backup_destination_attach_histories is not None:
            pulumi.set(__self__, "backup_destination_attach_histories", backup_destination_attach_histories)
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if space_utilized_in_gbs is not None:
            pulumi.set(__self__, "space_utilized_in_gbs", space_utilized_in_gbs)
        if time_at_which_storage_details_are_updated is not None:
            pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="backupDestinationAttachHistories")
    def backup_destination_attach_histories(self) -> Optional[Sequence[_builtins.str]]:
        """
        The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        """
        return pulumi.get(self, "backup_destination_attach_histories")

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="spaceUtilizedInGbs")
    def space_utilized_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        """
        return pulumi.get(self, "space_utilized_in_gbs")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> Optional[_builtins.str]:
        """
        The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional['outputs.AutonomousContainerDatabaseBackupConfigBackupDestinationDetails'] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None):
        """
        :param 'AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs' backup_destination_details: (Updatable) Backup destination details.
        :param _builtins.int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional['outputs.AutonomousContainerDatabaseBackupConfigBackupDestinationDetails']:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabaseBackupConfigBackupDestinationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseBackupConfigBackupDestinationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseBackupConfigBackupDestinationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseBackupConfigBackupDestinationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: (Updatable) Type of the database backup destination.
        :param _builtins.str id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.str internet_proxy: (Updatable) Proxy URL to connect to object store.
        :param _builtins.bool is_remote: (Updatable) Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: (Updatable) The name of the remote region where the remote automatic incremental backups will be stored.
               
               For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        :param _builtins.str vpc_password: (Updatable) For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: (Updatable) For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (Updatable) Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        (Updatable) Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        (Updatable) The name of the remote region where the remote automatic incremental backups will be stored.

        For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        (Updatable) For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        (Updatable) For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseBackupDestinationPropertiesList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationAttachHistories":
            suggest = "backup_destination_attach_histories"
        elif key == "spaceUtilizedInGbs":
            suggest = "space_utilized_in_gbs"
        elif key == "timeAtWhichStorageDetailsAreUpdated":
            suggest = "time_at_which_storage_details_are_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseBackupDestinationPropertiesList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseBackupDestinationPropertiesList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseBackupDestinationPropertiesList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_attach_histories: Optional[Sequence[_builtins.str]] = None,
                 space_utilized_in_gbs: Optional[_builtins.int] = None,
                 time_at_which_storage_details_are_updated: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] backup_destination_attach_histories: The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        :param _builtins.int space_utilized_in_gbs: The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        :param _builtins.str time_at_which_storage_details_are_updated: The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        if backup_destination_attach_histories is not None:
            pulumi.set(__self__, "backup_destination_attach_histories", backup_destination_attach_histories)
        if space_utilized_in_gbs is not None:
            pulumi.set(__self__, "space_utilized_in_gbs", space_utilized_in_gbs)
        if time_at_which_storage_details_are_updated is not None:
            pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)

    @_builtins.property
    @pulumi.getter(name="backupDestinationAttachHistories")
    def backup_destination_attach_histories(self) -> Optional[Sequence[_builtins.str]]:
        """
        The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        """
        return pulumi.get(self, "backup_destination_attach_histories")

    @_builtins.property
    @pulumi.getter(name="spaceUtilizedInGbs")
    def space_utilized_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        """
        return pulumi.get(self, "space_utilized_in_gbs")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> Optional[_builtins.str]:
        """
        The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")


@pulumi.output_type
class AutonomousContainerDatabaseCustomerContact(dict):
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class AutonomousContainerDatabaseDataguard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyLag":
            suggest = "apply_lag"
        elif key == "applyRate":
            suggest = "apply_rate"
        elif key == "automaticFailoverTarget":
            suggest = "automatic_failover_target"
        elif key == "autonomousContainerDatabaseId":
            suggest = "autonomous_container_database_id"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "fastStartFailOverLagLimitInSeconds":
            suggest = "fast_start_fail_over_lag_limit_in_seconds"
        elif key == "isAutomaticFailoverEnabled":
            suggest = "is_automatic_failover_enabled"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "redoTransportMode":
            suggest = "redo_transport_mode"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeLagRefreshedOn":
            suggest = "time_lag_refreshed_on"
        elif key == "timeLastRoleChanged":
            suggest = "time_last_role_changed"
        elif key == "timeLastSynced":
            suggest = "time_last_synced"
        elif key == "transportLag":
            suggest = "transport_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseDataguard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseDataguard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseDataguard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_lag: Optional[_builtins.str] = None,
                 apply_rate: Optional[_builtins.str] = None,
                 automatic_failover_target: Optional[_builtins.str] = None,
                 autonomous_container_database_id: Optional[_builtins.str] = None,
                 availability_domain: Optional[_builtins.str] = None,
                 fast_start_fail_over_lag_limit_in_seconds: Optional[_builtins.int] = None,
                 is_automatic_failover_enabled: Optional[_builtins.bool] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 protection_mode: Optional[_builtins.str] = None,
                 redo_transport_mode: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_lag_refreshed_on: Optional[_builtins.str] = None,
                 time_last_role_changed: Optional[_builtins.str] = None,
                 time_last_synced: Optional[_builtins.str] = None,
                 transport_lag: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        :param _builtins.str availability_domain: The domain of the Autonomous Container Database
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: (Updatable) The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Input DataType: boolean. Example : is_automatic_failover_enabled = true.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: (Updatable) The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of the Autonomous Container Database.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        if apply_lag is not None:
            pulumi.set(__self__, "apply_lag", apply_lag)
        if apply_rate is not None:
            pulumi.set(__self__, "apply_rate", apply_rate)
        if automatic_failover_target is not None:
            pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        if autonomous_container_database_id is not None:
            pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fast_start_fail_over_lag_limit_in_seconds is not None:
            pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        if is_automatic_failover_enabled is not None:
            pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if redo_transport_mode is not None:
            pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_lag_refreshed_on is not None:
            pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        if time_last_role_changed is not None:
            pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        if time_last_synced is not None:
            pulumi.set(__self__, "time_last_synced", time_last_synced)
        if transport_lag is not None:
            pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> Optional[_builtins.str]:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The domain of the Autonomous Container Database
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> Optional[_builtins.int]:
        """
        (Updatable) The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Input DataType: boolean. Example : is_automatic_failover_enabled = true.
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> Optional[_builtins.str]:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> Optional[_builtins.str]:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> Optional[_builtins.str]:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional[Sequence['outputs.AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None):
        """
        :param Sequence['AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
               
               For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.

        For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseDataguardGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyLag":
            suggest = "apply_lag"
        elif key == "applyRate":
            suggest = "apply_rate"
        elif key == "automaticFailoverTarget":
            suggest = "automatic_failover_target"
        elif key == "autonomousContainerDatabaseId":
            suggest = "autonomous_container_database_id"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "fastStartFailOverLagLimitInSeconds":
            suggest = "fast_start_fail_over_lag_limit_in_seconds"
        elif key == "isAutomaticFailoverEnabled":
            suggest = "is_automatic_failover_enabled"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "redoTransportMode":
            suggest = "redo_transport_mode"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeLagRefreshedOn":
            suggest = "time_lag_refreshed_on"
        elif key == "timeLastRoleChanged":
            suggest = "time_last_role_changed"
        elif key == "timeLastSynced":
            suggest = "time_last_synced"
        elif key == "transportLag":
            suggest = "transport_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseDataguardGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseDataguardGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseDataguardGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_lag: Optional[_builtins.str] = None,
                 apply_rate: Optional[_builtins.str] = None,
                 automatic_failover_target: Optional[_builtins.str] = None,
                 autonomous_container_database_id: Optional[_builtins.str] = None,
                 availability_domain: Optional[_builtins.str] = None,
                 fast_start_fail_over_lag_limit_in_seconds: Optional[_builtins.int] = None,
                 is_automatic_failover_enabled: Optional[_builtins.bool] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 protection_mode: Optional[_builtins.str] = None,
                 redo_transport_mode: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_lag_refreshed_on: Optional[_builtins.str] = None,
                 time_last_role_changed: Optional[_builtins.str] = None,
                 time_last_synced: Optional[_builtins.str] = None,
                 transport_lag: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        :param _builtins.str availability_domain: The domain of the Autonomous Container Database
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: (Updatable) The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Input DataType: boolean. Example : is_automatic_failover_enabled = true.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: (Updatable) The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of the Autonomous Container Database.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        if apply_lag is not None:
            pulumi.set(__self__, "apply_lag", apply_lag)
        if apply_rate is not None:
            pulumi.set(__self__, "apply_rate", apply_rate)
        if automatic_failover_target is not None:
            pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        if autonomous_container_database_id is not None:
            pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fast_start_fail_over_lag_limit_in_seconds is not None:
            pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        if is_automatic_failover_enabled is not None:
            pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if redo_transport_mode is not None:
            pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_lag_refreshed_on is not None:
            pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        if time_last_role_changed is not None:
            pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        if time_last_synced is not None:
            pulumi.set(__self__, "time_last_synced", time_last_synced)
        if transport_lag is not None:
            pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> Optional[_builtins.str]:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The domain of the Autonomous Container Database
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> Optional[_builtins.int]:
        """
        (Updatable) The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Input DataType: boolean. Example : is_automatic_failover_enabled = true.
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> Optional[_builtins.str]:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> Optional[_builtins.str]:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> Optional[_builtins.str]:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> Optional[_builtins.str]:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class AutonomousContainerDatabaseKeyHistoryEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseKeyHistoryEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseKeyHistoryEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseKeyHistoryEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 kms_key_version_id: Optional[_builtins.str] = None,
                 time_activated: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[_builtins.str]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional[Sequence['outputs.AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None):
        """
        :param Sequence['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
               
               For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.

        For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseRecoveryApplianceDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedStorageSizeInGbs":
            suggest = "allocated_storage_size_in_gbs"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "timeRecoveryApplianceDetailsUpdated":
            suggest = "time_recovery_appliance_details_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseRecoveryApplianceDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseRecoveryApplianceDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseRecoveryApplianceDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_storage_size_in_gbs: Optional[_builtins.int] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 time_recovery_appliance_details_updated: Optional[_builtins.str] = None):
        """
        :param _builtins.int allocated_storage_size_in_gbs: The storage size of the backup destination allocated for an Autonomous Container Database to store backups on the recovery appliance, in GBs, rounded to the nearest integer.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        :param _builtins.str time_recovery_appliance_details_updated: The time when the recovery appliance details are updated.
        """
        if allocated_storage_size_in_gbs is not None:
            pulumi.set(__self__, "allocated_storage_size_in_gbs", allocated_storage_size_in_gbs)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if time_recovery_appliance_details_updated is not None:
            pulumi.set(__self__, "time_recovery_appliance_details_updated", time_recovery_appliance_details_updated)

    @_builtins.property
    @pulumi.getter(name="allocatedStorageSizeInGbs")
    def allocated_storage_size_in_gbs(self) -> Optional[_builtins.int]:
        """
        The storage size of the backup destination allocated for an Autonomous Container Database to store backups on the recovery appliance, in GBs, rounded to the nearest integer.
        """
        return pulumi.get(self, "allocated_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="timeRecoveryApplianceDetailsUpdated")
    def time_recovery_appliance_details_updated(self) -> Optional[_builtins.str]:
        """
        The time when the recovery appliance details are updated.
        """
        return pulumi.get(self, "time_recovery_appliance_details_updated")


@pulumi.output_type
class AutonomousDatabaseApexDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apexVersion":
            suggest = "apex_version"
        elif key == "ordsVersion":
            suggest = "ords_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseApexDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseApexDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseApexDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apex_version: Optional[_builtins.str] = None,
                 ords_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str apex_version: The Oracle APEX Application Development version.
        :param _builtins.str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        if apex_version is not None:
            pulumi.set(__self__, "apex_version", apex_version)
        if ords_version is not None:
            pulumi.set(__self__, "ords_version", ords_version)

    @_builtins.property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> Optional[_builtins.str]:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @_builtins.property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> Optional[_builtins.str]:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class AutonomousDatabaseBackupBackupDestinationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseBackupBackupDestinationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseBackupBackupDestinationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseBackupBackupDestinationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualBackupBucketName":
            suggest = "manual_backup_bucket_name"
        elif key == "manualBackupType":
            suggest = "manual_backup_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manual_backup_bucket_name: Optional[_builtins.str] = None,
                 manual_backup_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param _builtins.str manual_backup_type: The manual backup destination type.
        """
        if manual_backup_bucket_name is not None:
            pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        if manual_backup_type is not None:
            pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @_builtins.property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> Optional[_builtins.str]:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @_builtins.property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> Optional[_builtins.str]:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class AutonomousDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 dedicated: Optional[_builtins.str] = None,
                 high: Optional[_builtins.str] = None,
                 low: Optional[_builtins.str] = None,
                 medium: Optional[_builtins.str] = None,
                 profiles: Optional[Sequence['outputs.AutonomousDatabaseConnectionStringProfile']] = None):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param _builtins.str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param _builtins.str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['AutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if high is not None:
            pulumi.set(__self__, "high", high)
        if low is not None:
            pulumi.set(__self__, "low", low)
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter
    def dedicated(self) -> Optional[_builtins.str]:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @_builtins.property
    @pulumi.getter
    def high(self) -> Optional[_builtins.str]:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @_builtins.property
    @pulumi.getter
    def low(self) -> Optional[_builtins.str]:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @_builtins.property
    @pulumi.getter
    def medium(self) -> Optional[_builtins.str]:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @_builtins.property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence['outputs.AutonomousDatabaseConnectionStringProfile']]:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class AutonomousDatabaseConnectionStringProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "hostFormat":
            suggest = "host_format"
        elif key == "isRegional":
            suggest = "is_regional"
        elif key == "sessionMode":
            suggest = "session_mode"
        elif key == "syntaxFormat":
            suggest = "syntax_format"
        elif key == "tlsAuthentication":
            suggest = "tls_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseConnectionStringProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseConnectionStringProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseConnectionStringProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 host_format: Optional[_builtins.str] = None,
                 is_regional: Optional[_builtins.bool] = None,
                 protocol: Optional[_builtins.str] = None,
                 session_mode: Optional[_builtins.str] = None,
                 syntax_format: Optional[_builtins.str] = None,
                 tls_authentication: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str consumer_group: Consumer group used by the connection.
        :param _builtins.str display_name: (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        :param _builtins.str host_format: Host format used in connection string.
        :param _builtins.bool is_regional: True for a regional connection string, applicable to cross-region DG only.
        :param _builtins.str protocol: Protocol used by the connection.
        :param _builtins.str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param _builtins.str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        :param _builtins.str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param _builtins.str value: Connection string value.
        """
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if host_format is not None:
            pulumi.set(__self__, "host_format", host_format)
        if is_regional is not None:
            pulumi.set(__self__, "is_regional", is_regional)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if session_mode is not None:
            pulumi.set(__self__, "session_mode", session_mode)
        if syntax_format is not None:
            pulumi.set(__self__, "syntax_format", syntax_format)
        if tls_authentication is not None:
            pulumi.set(__self__, "tls_authentication", tls_authentication)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[_builtins.str]:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> Optional[_builtins.str]:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @_builtins.property
    @pulumi.getter(name="isRegional")
    def is_regional(self) -> Optional[_builtins.bool]:
        """
        True for a regional connection string, applicable to cross-region DG only.
        """
        return pulumi.get(self, "is_regional")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> Optional[_builtins.str]:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @_builtins.property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> Optional[_builtins.str]:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @_builtins.property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> Optional[_builtins.str]:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutonomousDatabaseConnectionUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apexUrl":
            suggest = "apex_url"
        elif key == "databaseTransformsUrl":
            suggest = "database_transforms_url"
        elif key == "graphStudioUrl":
            suggest = "graph_studio_url"
        elif key == "machineLearningNotebookUrl":
            suggest = "machine_learning_notebook_url"
        elif key == "machineLearningUserManagementUrl":
            suggest = "machine_learning_user_management_url"
        elif key == "mongoDbUrl":
            suggest = "mongo_db_url"
        elif key == "ordsUrl":
            suggest = "ords_url"
        elif key == "sqlDevWebUrl":
            suggest = "sql_dev_web_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseConnectionUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseConnectionUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseConnectionUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apex_url: Optional[_builtins.str] = None,
                 database_transforms_url: Optional[_builtins.str] = None,
                 graph_studio_url: Optional[_builtins.str] = None,
                 machine_learning_notebook_url: Optional[_builtins.str] = None,
                 machine_learning_user_management_url: Optional[_builtins.str] = None,
                 mongo_db_url: Optional[_builtins.str] = None,
                 ords_url: Optional[_builtins.str] = None,
                 sql_dev_web_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        if apex_url is not None:
            pulumi.set(__self__, "apex_url", apex_url)
        if database_transforms_url is not None:
            pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        if graph_studio_url is not None:
            pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        if machine_learning_notebook_url is not None:
            pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        if machine_learning_user_management_url is not None:
            pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        if mongo_db_url is not None:
            pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        if ords_url is not None:
            pulumi.set(__self__, "ords_url", ords_url)
        if sql_dev_web_url is not None:
            pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[_builtins.str]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[_builtins.str]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> Optional[_builtins.str]:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> Optional[_builtins.str]:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[_builtins.str]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class AutonomousDatabaseCustomerContact(dict):
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class AutonomousDatabaseDbToolsDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeCount":
            suggest = "compute_count"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "maxIdleTimeInMinutes":
            suggest = "max_idle_time_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseDbToolsDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseDbToolsDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseDbToolsDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 compute_count: Optional[_builtins.float] = None,
                 is_enabled: Optional[_builtins.bool] = None,
                 max_idle_time_in_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: (Updatable) Name of database tool.
        :param _builtins.float compute_count: (Updatable) Compute used by database tools.
        :param _builtins.bool is_enabled: (Updatable) Indicates whether tool is enabled.
        :param _builtins.int max_idle_time_in_minutes: (Updatable) The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        pulumi.set(__self__, "name", name)
        if compute_count is not None:
            pulumi.set(__self__, "compute_count", compute_count)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_idle_time_in_minutes is not None:
            pulumi.set(__self__, "max_idle_time_in_minutes", max_idle_time_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of database tool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> Optional[_builtins.float]:
        """
        (Updatable) Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether tool is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="maxIdleTimeInMinutes")
    def max_idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        (Updatable) The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        return pulumi.get(self, "max_idle_time_in_minutes")


@pulumi.output_type
class AutonomousDatabaseEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arnRole":
            suggest = "arn_role"
        elif key == "autonomousDatabaseProvider":
            suggest = "autonomous_database_provider"
        elif key == "certificateDirectoryName":
            suggest = "certificate_directory_name"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "directoryName":
            suggest = "directory_name"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "keyArn":
            suggest = "key_arn"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "okvKmsKey":
            suggest = "okv_kms_key"
        elif key == "okvUri":
            suggest = "okv_uri"
        elif key == "serviceEndpointUri":
            suggest = "service_endpoint_uri"
        elif key == "vaultId":
            suggest = "vault_id"
        elif key == "vaultUri":
            suggest = "vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn_role: Optional[_builtins.str] = None,
                 autonomous_database_provider: Optional[_builtins.str] = None,
                 certificate_directory_name: Optional[_builtins.str] = None,
                 certificate_id: Optional[_builtins.str] = None,
                 directory_name: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 key_arn: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 okv_kms_key: Optional[_builtins.str] = None,
                 okv_uri: Optional[_builtins.str] = None,
                 service_endpoint_uri: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None,
                 vault_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn_role: (Updatable) AWS ARN role
        :param _builtins.str autonomous_database_provider: (Updatable) The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: (Updatable) OKV certificate directory name
        :param _builtins.str certificate_id: (Updatable) OKV certificate id
        :param _builtins.str directory_name: (Updatable) OKV wallet directory name
        :param _builtins.str external_id: (Updatable) AWS external ID
        :param _builtins.str key_arn: (Updatable) AWS key ARN
        :param _builtins.str key_name: (Updatable) Azure key name
        :param _builtins.str kms_key_id: (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: (Updatable) UUID of OKV KMS Key
        :param _builtins.str okv_uri: (Updatable) URI of OKV server
        :param _builtins.str service_endpoint_uri: (Updatable) AWS key service endpoint URI
        :param _builtins.str vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vault_uri: (Updatable) Azure vault URI
        """
        if arn_role is not None:
            pulumi.set(__self__, "arn_role", arn_role)
        if autonomous_database_provider is not None:
            pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        if certificate_directory_name is not None:
            pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if directory_name is not None:
            pulumi.set(__self__, "directory_name", directory_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if okv_kms_key is not None:
            pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        if okv_uri is not None:
            pulumi.set(__self__, "okv_uri", okv_uri)
        if service_endpoint_uri is not None:
            pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> Optional[_builtins.str]:
        """
        (Updatable) The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> Optional[_builtins.str]:
        """
        (Updatable) UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> Optional[_builtins.str]:
        """
        (Updatable) URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[_builtins.str]:
        """
        (Updatable) Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class AutonomousDatabaseEncryptionKeyHistoryEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeys":
            suggest = "encryption_keys"
        elif key == "timeActivated":
            suggest = "time_activated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseEncryptionKeyHistoryEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseEncryptionKeyHistoryEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseEncryptionKeyHistoryEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_keys: Optional[Sequence['outputs.AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey']] = None,
                 time_activated: Optional[_builtins.str] = None):
        """
        :param Sequence['AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs'] encryption_keys: (Updatable) Details of the Autonomous Database encryption key.
        :param _builtins.str time_activated: The date and time the kms key activated.
        """
        if encryption_keys is not None:
            pulumi.set(__self__, "encryption_keys", encryption_keys)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Optional[Sequence['outputs.AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey']]:
        """
        (Updatable) Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[_builtins.str]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")


@pulumi.output_type
class AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arnRole":
            suggest = "arn_role"
        elif key == "autonomousDatabaseProvider":
            suggest = "autonomous_database_provider"
        elif key == "certificateDirectoryName":
            suggest = "certificate_directory_name"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "directoryName":
            suggest = "directory_name"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "keyArn":
            suggest = "key_arn"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "okvKmsKey":
            suggest = "okv_kms_key"
        elif key == "okvUri":
            suggest = "okv_uri"
        elif key == "serviceEndpointUri":
            suggest = "service_endpoint_uri"
        elif key == "vaultId":
            suggest = "vault_id"
        elif key == "vaultUri":
            suggest = "vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn_role: Optional[_builtins.str] = None,
                 autonomous_database_provider: Optional[_builtins.str] = None,
                 certificate_directory_name: Optional[_builtins.str] = None,
                 certificate_id: Optional[_builtins.str] = None,
                 directory_name: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 key_arn: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 okv_kms_key: Optional[_builtins.str] = None,
                 okv_uri: Optional[_builtins.str] = None,
                 service_endpoint_uri: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None,
                 vault_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn_role: (Updatable) AWS ARN role
        :param _builtins.str autonomous_database_provider: (Updatable) The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: (Updatable) OKV certificate directory name
        :param _builtins.str certificate_id: (Updatable) OKV certificate id
        :param _builtins.str directory_name: (Updatable) OKV wallet directory name
        :param _builtins.str external_id: (Updatable) AWS external ID
        :param _builtins.str key_arn: (Updatable) AWS key ARN
        :param _builtins.str key_name: (Updatable) Azure key name
        :param _builtins.str kms_key_id: (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: (Updatable) UUID of OKV KMS Key
        :param _builtins.str okv_uri: (Updatable) URI of OKV server
        :param _builtins.str service_endpoint_uri: (Updatable) AWS key service endpoint URI
        :param _builtins.str vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vault_uri: (Updatable) Azure vault URI
        """
        if arn_role is not None:
            pulumi.set(__self__, "arn_role", arn_role)
        if autonomous_database_provider is not None:
            pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        if certificate_directory_name is not None:
            pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if directory_name is not None:
            pulumi.set(__self__, "directory_name", directory_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if okv_kms_key is not None:
            pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        if okv_uri is not None:
            pulumi.set(__self__, "okv_uri", okv_uri)
        if service_endpoint_uri is not None:
            pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> Optional[_builtins.str]:
        """
        (Updatable) The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> Optional[_builtins.str]:
        """
        (Updatable) UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> Optional[_builtins.str]:
        """
        (Updatable) URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> Optional[_builtins.str]:
        """
        (Updatable) AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[_builtins.str]:
        """
        (Updatable) Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class AutonomousDatabaseKeyHistoryEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseKeyHistoryEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseKeyHistoryEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseKeyHistoryEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 kms_key_version_id: Optional[_builtins.str] = None,
                 time_activated: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[_builtins.str]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class AutonomousDatabaseLocalStandbyDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "lagTimeInSeconds":
            suggest = "lag_time_in_seconds"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "maintenanceTargetComponent":
            suggest = "maintenance_target_component"
        elif key == "timeDataGuardRoleChanged":
            suggest = "time_data_guard_role_changed"
        elif key == "timeDisasterRecoveryRoleChanged":
            suggest = "time_disaster_recovery_role_changed"
        elif key == "timeMaintenanceBegin":
            suggest = "time_maintenance_begin"
        elif key == "timeMaintenanceEnd":
            suggest = "time_maintenance_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseLocalStandbyDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseLocalStandbyDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseLocalStandbyDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain: Optional[_builtins.str] = None,
                 lag_time_in_seconds: Optional[_builtins.int] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 maintenance_target_component: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_data_guard_role_changed: Optional[_builtins.str] = None,
                 time_disaster_recovery_role_changed: Optional[_builtins.str] = None,
                 time_maintenance_begin: Optional[_builtins.str] = None,
                 time_maintenance_end: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: The current state of the Autonomous Database.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if maintenance_target_component is not None:
            pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_data_guard_role_changed is not None:
            pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        if time_maintenance_begin is not None:
            pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        if time_maintenance_end is not None:
            pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[_builtins.int]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> Optional[_builtins.str]:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> Optional[_builtins.str]:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> Optional[_builtins.str]:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class AutonomousDatabaseLongTermBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDisabled":
            suggest = "is_disabled"
        elif key == "repeatCadence":
            suggest = "repeat_cadence"
        elif key == "retentionPeriodInDays":
            suggest = "retention_period_in_days"
        elif key == "timeOfBackup":
            suggest = "time_of_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseLongTermBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseLongTermBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseLongTermBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_disabled: Optional[_builtins.bool] = None,
                 repeat_cadence: Optional[_builtins.str] = None,
                 retention_period_in_days: Optional[_builtins.int] = None,
                 time_of_backup: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.str repeat_cadence: The frequency of the long-term backup schedule
        :param _builtins.int retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if repeat_cadence is not None:
            pulumi.set(__self__, "repeat_cadence", repeat_cadence)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if time_of_backup is not None:
            pulumi.set(__self__, "time_of_backup", time_of_backup)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[_builtins.bool]:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> Optional[_builtins.str]:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[_builtins.int]:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> Optional[_builtins.str]:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class AutonomousDatabasePublicConnectionUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apexUrl":
            suggest = "apex_url"
        elif key == "databaseTransformsUrl":
            suggest = "database_transforms_url"
        elif key == "graphStudioUrl":
            suggest = "graph_studio_url"
        elif key == "machineLearningNotebookUrl":
            suggest = "machine_learning_notebook_url"
        elif key == "machineLearningUserManagementUrl":
            suggest = "machine_learning_user_management_url"
        elif key == "mongoDbUrl":
            suggest = "mongo_db_url"
        elif key == "ordsUrl":
            suggest = "ords_url"
        elif key == "sqlDevWebUrl":
            suggest = "sql_dev_web_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabasePublicConnectionUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabasePublicConnectionUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabasePublicConnectionUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apex_url: Optional[_builtins.str] = None,
                 database_transforms_url: Optional[_builtins.str] = None,
                 graph_studio_url: Optional[_builtins.str] = None,
                 machine_learning_notebook_url: Optional[_builtins.str] = None,
                 machine_learning_user_management_url: Optional[_builtins.str] = None,
                 mongo_db_url: Optional[_builtins.str] = None,
                 ords_url: Optional[_builtins.str] = None,
                 sql_dev_web_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        if apex_url is not None:
            pulumi.set(__self__, "apex_url", apex_url)
        if database_transforms_url is not None:
            pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        if graph_studio_url is not None:
            pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        if machine_learning_notebook_url is not None:
            pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        if machine_learning_user_management_url is not None:
            pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        if mongo_db_url is not None:
            pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        if ords_url is not None:
            pulumi.set(__self__, "ords_url", ords_url)
        if sql_dev_web_url is not None:
            pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[_builtins.str]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[_builtins.str]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> Optional[_builtins.str]:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> Optional[_builtins.str]:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[_builtins.str]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class AutonomousDatabaseRemoteDisasterRecoveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disasterRecoveryType":
            suggest = "disaster_recovery_type"
        elif key == "isReplicateAutomaticBackups":
            suggest = "is_replicate_automatic_backups"
        elif key == "isSnapshotStandby":
            suggest = "is_snapshot_standby"
        elif key == "timeSnapshotStandbyEnabledTill":
            suggest = "time_snapshot_standby_enabled_till"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseRemoteDisasterRecoveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseRemoteDisasterRecoveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseRemoteDisasterRecoveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disaster_recovery_type: Optional[_builtins.str] = None,
                 is_replicate_automatic_backups: Optional[_builtins.bool] = None,
                 is_snapshot_standby: Optional[_builtins.bool] = None,
                 time_snapshot_standby_enabled_till: Optional[_builtins.str] = None):
        """
        :param _builtins.str disaster_recovery_type: Indicates the disaster recovery (DR) type of the standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param _builtins.bool is_replicate_automatic_backups: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        :param _builtins.bool is_snapshot_standby: Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        :param _builtins.str time_snapshot_standby_enabled_till: Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        if disaster_recovery_type is not None:
            pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)
        if is_replicate_automatic_backups is not None:
            pulumi.set(__self__, "is_replicate_automatic_backups", is_replicate_automatic_backups)
        if is_snapshot_standby is not None:
            pulumi.set(__self__, "is_snapshot_standby", is_snapshot_standby)
        if time_snapshot_standby_enabled_till is not None:
            pulumi.set(__self__, "time_snapshot_standby_enabled_till", time_snapshot_standby_enabled_till)

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> Optional[_builtins.str]:
        """
        Indicates the disaster recovery (DR) type of the standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="isReplicateAutomaticBackups")
    def is_replicate_automatic_backups(self) -> Optional[_builtins.bool]:
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        return pulumi.get(self, "is_replicate_automatic_backups")

    @_builtins.property
    @pulumi.getter(name="isSnapshotStandby")
    def is_snapshot_standby(self) -> Optional[_builtins.bool]:
        """
        Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        """
        return pulumi.get(self, "is_snapshot_standby")

    @_builtins.property
    @pulumi.getter(name="timeSnapshotStandbyEnabledTill")
    def time_snapshot_standby_enabled_till(self) -> Optional[_builtins.str]:
        """
        Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        return pulumi.get(self, "time_snapshot_standby_enabled_till")


@pulumi.output_type
class AutonomousDatabaseResourcePoolSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDisabled":
            suggest = "is_disabled"
        elif key == "poolSize":
            suggest = "pool_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseResourcePoolSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseResourcePoolSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseResourcePoolSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_disabled: Optional[_builtins.bool] = None,
                 pool_size: Optional[_builtins.int] = None):
        """
        :param _builtins.bool is_disabled: (Updatable) Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.int pool_size: (Updatable) Resource pool size.
        """
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class AutonomousDatabaseScheduledOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "scheduledStartTime":
            suggest = "scheduled_start_time"
        elif key == "scheduledStopTime":
            suggest = "scheduled_stop_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseScheduledOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseScheduledOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseScheduledOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional['outputs.AutonomousDatabaseScheduledOperationDayOfWeek'] = None,
                 scheduled_start_time: Optional[_builtins.str] = None,
                 scheduled_stop_time: Optional[_builtins.str] = None):
        """
        :param 'AutonomousDatabaseScheduledOperationDayOfWeekArgs' day_of_week: (Updatable) Day of the week.
        :param _builtins.str scheduled_start_time: (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        :param _builtins.str scheduled_stop_time: (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if scheduled_start_time is not None:
            pulumi.set(__self__, "scheduled_start_time", scheduled_start_time)
        if scheduled_stop_time is not None:
            pulumi.set(__self__, "scheduled_stop_time", scheduled_stop_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional['outputs.AutonomousDatabaseScheduledOperationDayOfWeek']:
        """
        (Updatable) Day of the week.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @_builtins.property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class AutonomousDatabaseScheduledOperationDayOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousDatabaseStandbyDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "lagTimeInSeconds":
            suggest = "lag_time_in_seconds"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "maintenanceTargetComponent":
            suggest = "maintenance_target_component"
        elif key == "timeDataGuardRoleChanged":
            suggest = "time_data_guard_role_changed"
        elif key == "timeDisasterRecoveryRoleChanged":
            suggest = "time_disaster_recovery_role_changed"
        elif key == "timeMaintenanceBegin":
            suggest = "time_maintenance_begin"
        elif key == "timeMaintenanceEnd":
            suggest = "time_maintenance_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseStandbyDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseStandbyDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseStandbyDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain: Optional[_builtins.str] = None,
                 lag_time_in_seconds: Optional[_builtins.int] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 maintenance_target_component: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_data_guard_role_changed: Optional[_builtins.str] = None,
                 time_disaster_recovery_role_changed: Optional[_builtins.str] = None,
                 time_maintenance_begin: Optional[_builtins.str] = None,
                 time_maintenance_end: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: The current state of the Autonomous Database.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if maintenance_target_component is not None:
            pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_data_guard_role_changed is not None:
            pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        if time_maintenance_begin is not None:
            pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        if time_maintenance_end is not None:
            pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[_builtins.int]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> Optional[_builtins.str]:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[_builtins.str]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> Optional[_builtins.str]:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> Optional[_builtins.str]:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousExadataInfrastructureMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousExadataInfrastructureMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousVmClusterMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousVmClusterMaintenanceWindowDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousVmClusterMaintenanceWindowDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousVmClusterMaintenanceWindowDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDetailMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BackupDestinationAssociatedDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupDestinationAssociatedDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupDestinationAssociatedDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupDestinationAssociatedDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str db_name: The display name of the database that is associated with the backup destination.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupDestinationMountTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountType":
            suggest = "mount_type"
        elif key == "localMountPointPath":
            suggest = "local_mount_point_path"
        elif key == "nfsServerExport":
            suggest = "nfs_server_export"
        elif key == "nfsServers":
            suggest = "nfs_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupDestinationMountTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupDestinationMountTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupDestinationMountTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_type: _builtins.str,
                 local_mount_point_path: Optional[_builtins.str] = None,
                 nfs_server_export: Optional[_builtins.str] = None,
                 nfs_servers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str mount_type: Mount type for backup destination.
        :param _builtins.str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param _builtins.str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[_builtins.str] nfs_servers: IP addresses for NFS Auto mount.
        """
        pulumi.set(__self__, "mount_type", mount_type)
        if local_mount_point_path is not None:
            pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        if nfs_server_export is not None:
            pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        if nfs_servers is not None:
            pulumi.set(__self__, "nfs_servers", nfs_servers)

    @_builtins.property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> _builtins.str:
        """
        Mount type for backup destination.
        """
        return pulumi.get(self, "mount_type")

    @_builtins.property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> Optional[_builtins.str]:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @_builtins.property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> Optional[_builtins.str]:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @_builtins.property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")


@pulumi.output_type
class BackupEncryptionKeyLocationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureEncryptionKeyId":
            suggest = "azure_encryption_key_id"
        elif key == "hsmPassword":
            suggest = "hsm_password"
        elif key == "providerType":
            suggest = "provider_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupEncryptionKeyLocationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupEncryptionKeyLocationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupEncryptionKeyLocationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_encryption_key_id: Optional[_builtins.str] = None,
                 hsm_password: Optional[_builtins.str] = None,
                 provider_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str azure_encryption_key_id: The key OCID of a registered Azure key.
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        if azure_encryption_key_id is not None:
            pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        if hsm_password is not None:
            pulumi.set(__self__, "hsm_password", hsm_password)
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> Optional[_builtins.str]:
        """
        The key OCID of a registered Azure key.
        """
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> Optional[_builtins.str]:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[_builtins.str]:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAutonomousVmClusterMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAutonomousVmClusterMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAutonomousVmClusterMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAutonomousVmClusterMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudDatabaseManagementCredentialdetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretId":
            suggest = "password_secret_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudDatabaseManagementCredentialdetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudDatabaseManagementCredentialdetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudDatabaseManagementCredentialdetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_secret_id: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str password_secret_id: Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str user_name: Database username
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> _builtins.str:
        """
        Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "password_secret_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Database username
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class CloudExadataInfrastructureCustomerContact(dict):
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class CloudExadataInfrastructureDefinedFileSystemConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBackupPartition":
            suggest = "is_backup_partition"
        elif key == "isResizable":
            suggest = "is_resizable"
        elif key == "minSizeGb":
            suggest = "min_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudExadataInfrastructureDefinedFileSystemConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudExadataInfrastructureDefinedFileSystemConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudExadataInfrastructureDefinedFileSystemConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_backup_partition: Optional[_builtins.bool] = None,
                 is_resizable: Optional[_builtins.bool] = None,
                 min_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        if is_backup_partition is not None:
            pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        if is_resizable is not None:
            pulumi.set(__self__, "is_resizable", is_resizable)
        if min_size_gb is not None:
            pulumi.set(__self__, "min_size_gb", min_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> Optional[_builtins.bool]:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> Optional[_builtins.bool]:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> Optional[_builtins.int]:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class CloudExadataInfrastructureMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudExadataInfrastructureMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['CloudExadataInfrastructureMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class CloudExadataInfrastructureMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudExadataInfrastructureMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudVmClusterCloudAutomationUpdateDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdateTimePreference":
            suggest = "apply_update_time_preference"
        elif key == "freezePeriod":
            suggest = "freeze_period"
        elif key == "isEarlyAdoptionEnabled":
            suggest = "is_early_adoption_enabled"
        elif key == "isFreezePeriodEnabled":
            suggest = "is_freeze_period_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterCloudAutomationUpdateDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterCloudAutomationUpdateDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterCloudAutomationUpdateDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_time_preference: Optional['outputs.CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference'] = None,
                 freeze_period: Optional['outputs.CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod'] = None,
                 is_early_adoption_enabled: Optional[_builtins.bool] = None,
                 is_freeze_period_enabled: Optional[_builtins.bool] = None):
        """
        :param 'CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs' apply_update_time_preference: (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param 'CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs' freeze_period: (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preference is not None:
            pulumi.set(__self__, "apply_update_time_preference", apply_update_time_preference)
        if freeze_period is not None:
            pulumi.set(__self__, "freeze_period", freeze_period)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreference")
    def apply_update_time_preference(self) -> Optional['outputs.CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference']:
        """
        (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preference")

    @_builtins.property
    @pulumi.getter(name="freezePeriod")
    def freeze_period(self) -> Optional['outputs.CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod']:
        """
        (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_period")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdatePreferredEndTime":
            suggest = "apply_update_preferred_end_time"
        elif key == "applyUpdatePreferredStartTime":
            suggest = "apply_update_preferred_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[_builtins.str] = None,
                 apply_update_preferred_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_update_preferred_end_time: (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freezePeriodEndTime":
            suggest = "freeze_period_end_time"
        elif key == "freezePeriodStartTime":
            suggest = "freeze_period_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterCloudAutomationUpdateDetailsFreezePeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 freeze_period_end_time: Optional[_builtins.str] = None,
                 freeze_period_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str freeze_period_end_time: (Updatable) End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: (Updatable) Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class CloudVmClusterDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class CloudVmClusterFileSystemConfigurationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemSizeGb":
            suggest = "file_system_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterFileSystemConfigurationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterFileSystemConfigurationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterFileSystemConfigurationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.int file_system_size_gb: (Updatable) The file system size to be allocated in GBs.
        :param _builtins.str mount_point: (Updatable) The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[_builtins.int]:
        """
        (Updatable) The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        (Updatable) The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class CloudVmClusterIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.CloudVmClusterIormConfigCachDbPlan']] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 objective: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param Sequence['CloudVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: The current state of the cloud VM cluster.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.CloudVmClusterIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> Optional[_builtins.str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CloudVmClusterIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[_builtins.str] = None,
                 flash_cache_limit: Optional[_builtins.str] = None,
                 share: Optional[_builtins.int] = None):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[_builtins.str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> Optional[_builtins.int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class CloudVmClusterIormConfigDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterIormConfigDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterIormConfigDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterIormConfigDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: _builtins.str,
                 share: _builtins.int,
                 flash_cache_limit: Optional[_builtins.str] = None):
        """
        :param _builtins.str db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.int share: (Updatable) The relative priority of this database.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[_builtins.str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")


@pulumi.output_type
class CloudVmClusterMultiCloudIdentityConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterMultiCloudIdentityConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterMultiCloudIdentityConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterMultiCloudIdentityConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_provider: Cloud provider
        :param _builtins.str id: The OCID of the identity connector
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[_builtins.str]:
        """
        Cloud provider
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The OCID of the identity connector
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DataGuardAssociationDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataGuardAssociationDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataGuardAssociationDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataGuardAssociationDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class DatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 cdb_default: Optional[_builtins.str] = None,
                 cdb_ip_default: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the Database.
        :param _builtins.str cdb_default: Host name based CDB Connection String.
        :param _builtins.str cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[_builtins.str]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[_builtins.str]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DatabaseDataGuardGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protectionMode":
            suggest = "protection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDataGuardGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDataGuardGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDataGuardGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 members: Optional[Sequence['outputs.DatabaseDataGuardGroupMember']] = None,
                 protection_mode: Optional[_builtins.str] = None):
        """
        :param Sequence['DatabaseDataGuardGroupMemberArgs'] members: List of Data Guard members, representing each database that is part of Data Guard.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        if members is not None:
            pulumi.set(__self__, "members", members)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[Sequence['outputs.DatabaseDataGuardGroupMember']]:
        """
        List of Data Guard members, representing each database that is part of Data Guard.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")


@pulumi.output_type
class DatabaseDataGuardGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyLag":
            suggest = "apply_lag"
        elif key == "applyRate":
            suggest = "apply_rate"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "isActiveDataGuardEnabled":
            suggest = "is_active_data_guard_enabled"
        elif key == "transportLag":
            suggest = "transport_lag"
        elif key == "transportLagRefresh":
            suggest = "transport_lag_refresh"
        elif key == "transportType":
            suggest = "transport_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDataGuardGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDataGuardGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDataGuardGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_lag: Optional[_builtins.str] = None,
                 apply_rate: Optional[_builtins.str] = None,
                 database_id: Optional[_builtins.str] = None,
                 db_system_id: Optional[_builtins.str] = None,
                 is_active_data_guard_enabled: Optional[_builtins.bool] = None,
                 role: Optional[_builtins.str] = None,
                 transport_lag: Optional[_builtins.str] = None,
                 transport_lag_refresh: Optional[_builtins.str] = None,
                 transport_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        :param _builtins.str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        :param _builtins.str database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database.
        :param _builtins.str db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str role: The role of the reporting database in this Data Guard association.
        :param _builtins.str transport_lag: The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        :param _builtins.str transport_lag_refresh: The date and time when last redo transport has been done.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
        """
        if apply_lag is not None:
            pulumi.set(__self__, "apply_lag", apply_lag)
        if apply_rate is not None:
            pulumi.set(__self__, "apply_rate", apply_rate)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if is_active_data_guard_enabled is not None:
            pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if transport_lag is not None:
            pulumi.set(__self__, "transport_lag", transport_lag)
        if transport_lag_refresh is not None:
            pulumi.set(__self__, "transport_lag_refresh", transport_lag_refresh)
        if transport_type is not None:
            pulumi.set(__self__, "transport_type", transport_type)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> Optional[_builtins.str]:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database.
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> Optional[_builtins.bool]:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The role of the reporting database in this Data Guard association.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        """
        return pulumi.get(self, "transport_lag")

    @_builtins.property
    @pulumi.getter(name="transportLagRefresh")
    def transport_lag_refresh(self) -> Optional[_builtins.str]:
        """
        The date and time when last redo transport has been done.
        """
        return pulumi.get(self, "transport_lag_refresh")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> Optional[_builtins.str]:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC
        """
        return pulumi.get(self, "transport_type")


@pulumi.output_type
class DatabaseDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "backupTdePassword":
            suggest = "backup_tde_password"
        elif key == "characterSet":
            suggest = "character_set"
        elif key == "databaseAdminPassword":
            suggest = "database_admin_password"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbBackupConfig":
            suggest = "db_backup_config"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"
        elif key == "dbWorkload":
            suggest = "db_workload"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "encryptionKeyLocationDetails":
            suggest = "encryption_key_location_details"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isActiveDataGuardEnabled":
            suggest = "is_active_data_guard_enabled"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "ncharacterSet":
            suggest = "ncharacter_set"
        elif key == "pdbName":
            suggest = "pdb_name"
        elif key == "pluggableDatabases":
            suggest = "pluggable_databases"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "sidPrefix":
            suggest = "sid_prefix"
        elif key == "sourceDatabaseId":
            suggest = "source_database_id"
        elif key == "sourceEncryptionKeyLocationDetails":
            suggest = "source_encryption_key_location_details"
        elif key == "sourceTdeWalletPassword":
            suggest = "source_tde_wallet_password"
        elif key == "tdeWalletPassword":
            suggest = "tde_wallet_password"
        elif key == "transportType":
            suggest = "transport_type"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[_builtins.str] = None,
                 backup_id: Optional[_builtins.str] = None,
                 backup_tde_password: Optional[_builtins.str] = None,
                 character_set: Optional[_builtins.str] = None,
                 database_admin_password: Optional[_builtins.str] = None,
                 database_software_image_id: Optional[_builtins.str] = None,
                 db_backup_config: Optional['outputs.DatabaseDatabaseDbBackupConfig'] = None,
                 db_name: Optional[_builtins.str] = None,
                 db_unique_name: Optional[_builtins.str] = None,
                 db_workload: Optional[_builtins.str] = None,
                 defined_tags: Optional[Mapping[str, _builtins.str]] = None,
                 encryption_key_location_details: Optional['outputs.DatabaseDatabaseEncryptionKeyLocationDetails'] = None,
                 freeform_tags: Optional[Mapping[str, _builtins.str]] = None,
                 is_active_data_guard_enabled: Optional[_builtins.bool] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 kms_key_version_id: Optional[_builtins.str] = None,
                 ncharacter_set: Optional[_builtins.str] = None,
                 pdb_name: Optional[_builtins.str] = None,
                 pluggable_databases: Optional[Sequence[_builtins.str]] = None,
                 protection_mode: Optional[_builtins.str] = None,
                 sid_prefix: Optional[_builtins.str] = None,
                 source_database_id: Optional[_builtins.str] = None,
                 source_encryption_key_location_details: Optional['outputs.DatabaseDatabaseSourceEncryptionKeyLocationDetails'] = None,
                 source_tde_wallet_password: Optional[_builtins.str] = None,
                 tde_wallet_password: Optional[_builtins.str] = None,
                 transport_type: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param _builtins.str backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str backup_tde_password: The password to open the TDE wallet.
        :param _builtins.str character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param _builtins.str database_admin_password: The administrator password of the primary database in this Data Guard association.
               
               **The password MUST be the same as the primary admin password.**
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param 'DatabaseDatabaseDbBackupConfigArgs' db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param _builtins.str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param _builtins.str db_unique_name: Specifies the `DB_UNIQUE_NAME` of the peer database to be created.
        :param _builtins.str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param Mapping[str, _builtins.str] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param 'DatabaseDatabaseEncryptionKeyLocationDetailsArgs' encryption_key_location_details: Types of providers supported for managing database encryption keys
        :param Mapping[str, _builtins.str] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param _builtins.str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param Sequence[_builtins.str] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param _builtins.str source_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source database.
        :param 'DatabaseDatabaseSourceEncryptionKeyLocationDetailsArgs' source_encryption_key_location_details: Types of providers supported for managing database encryption keys
        :param _builtins.str source_tde_wallet_password: The TDE wallet password of the source database specified by 'sourceDatabaseId'.
        :param _builtins.str tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
               
               For more information, see [Redo Transport Services](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-redo-transport-services.htm#SBYDB00400) in the Oracle Data Guard documentation.
               
               **IMPORTANT** - The only transport type currently supported by the Database service is ASYNC.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if database_admin_password is not None:
            pulumi.set(__self__, "database_admin_password", database_admin_password)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if encryption_key_location_details is not None:
            pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if is_active_data_guard_enabled is not None:
            pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if sid_prefix is not None:
            pulumi.set(__self__, "sid_prefix", sid_prefix)
        if source_database_id is not None:
            pulumi.set(__self__, "source_database_id", source_database_id)
        if source_encryption_key_location_details is not None:
            pulumi.set(__self__, "source_encryption_key_location_details", source_encryption_key_location_details)
        if source_tde_wallet_password is not None:
            pulumi.set(__self__, "source_tde_wallet_password", source_tde_wallet_password)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if transport_type is not None:
            pulumi.set(__self__, "transport_type", transport_type)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[_builtins.str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[_builtins.str]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[_builtins.str]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[_builtins.str]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="databaseAdminPassword")
    def database_admin_password(self) -> Optional[_builtins.str]:
        """
        The administrator password of the primary database in this Data Guard association.

        **The password MUST be the same as the primary admin password.**
        """
        return pulumi.get(self, "database_admin_password")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[_builtins.str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional['outputs.DatabaseDatabaseDbBackupConfig']:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[_builtins.str]:
        """
        Specifies the `DB_UNIQUE_NAME` of the peer database to be created.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[_builtins.str]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Optional['outputs.DatabaseDatabaseEncryptionKeyLocationDetails']:
        """
        Types of providers supported for managing database encryption keys
        """
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> Optional[_builtins.bool]:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[_builtins.str]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[_builtins.str]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[_builtins.str]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source database.
        """
        return pulumi.get(self, "source_database_id")

    @_builtins.property
    @pulumi.getter(name="sourceEncryptionKeyLocationDetails")
    def source_encryption_key_location_details(self) -> Optional['outputs.DatabaseDatabaseSourceEncryptionKeyLocationDetails']:
        """
        Types of providers supported for managing database encryption keys
        """
        return pulumi.get(self, "source_encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="sourceTdeWalletPassword")
    def source_tde_wallet_password(self) -> Optional[_builtins.str]:
        """
        The TDE wallet password of the source database specified by 'sourceDatabaseId'.
        """
        return pulumi.get(self, "source_tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[_builtins.str]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> Optional[_builtins.str]:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC

        For more information, see [Redo Transport Services](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-redo-transport-services.htm#SBYDB00400) in the Oracle Data Guard documentation.

        **IMPORTANT** - The only transport type currently supported by the Database service is ASYNC.
        """
        return pulumi.get(self, "transport_type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class DatabaseDatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[_builtins.bool] = None,
                 auto_backup_window: Optional[_builtins.str] = None,
                 auto_full_backup_day: Optional[_builtins.str] = None,
                 auto_full_backup_window: Optional[_builtins.str] = None,
                 backup_deletion_policy: Optional[_builtins.str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DatabaseDatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 run_immediate_full_backup: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[_builtins.str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[_builtins.str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[_builtins.str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DatabaseDatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DatabaseDatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
               
               For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.

        For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DatabaseDatabaseEncryptionKeyLocationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerType":
            suggest = "provider_type"
        elif key == "azureEncryptionKeyId":
            suggest = "azure_encryption_key_id"
        elif key == "hsmPassword":
            suggest = "hsm_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseEncryptionKeyLocationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseEncryptionKeyLocationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseEncryptionKeyLocationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_type: _builtins.str,
                 azure_encryption_key_id: Optional[_builtins.str] = None,
                 hsm_password: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        :param _builtins.str azure_encryption_key_id: Provide the key OCID of a registered Azure key.
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        """
        pulumi.set(__self__, "provider_type", provider_type)
        if azure_encryption_key_id is not None:
            pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        if hsm_password is not None:
            pulumi.set(__self__, "hsm_password", hsm_password)

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> Optional[_builtins.str]:
        """
        Provide the key OCID of a registered Azure key.
        """
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> Optional[_builtins.str]:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")


@pulumi.output_type
class DatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"
        elif key == "managementType":
            suggest = "management_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[_builtins.str] = None,
                 management_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str management_status: The status of the Database Management service.
        :param _builtins.str management_type: The Database Management type.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)
        if management_type is not None:
            pulumi.set(__self__, "management_type", management_type)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @_builtins.property
    @pulumi.getter(name="managementType")
    def management_type(self) -> Optional[_builtins.str]:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")


@pulumi.output_type
class DatabaseDatabaseSourceEncryptionKeyLocationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hsmPassword":
            suggest = "hsm_password"
        elif key == "providerType":
            suggest = "provider_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseSourceEncryptionKeyLocationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseSourceEncryptionKeyLocationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseSourceEncryptionKeyLocationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        """
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class DatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[_builtins.bool] = None,
                 auto_backup_window: Optional[_builtins.str] = None,
                 auto_full_backup_day: Optional[_builtins.str] = None,
                 auto_full_backup_window: Optional[_builtins.str] = None,
                 backup_deletion_policy: Optional[_builtins.str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 run_immediate_full_backup: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[_builtins.str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[_builtins.str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DatabaseUpgradeConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 cdb_default: Optional[_builtins.str] = None,
                 cdb_ip_default: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the Database.
        :param _builtins.str cdb_default: Host name based CDB Connection String.
        :param _builtins.str cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[_builtins.str]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[_builtins.str]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DatabaseUpgradeDataGuardGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protectionMode":
            suggest = "protection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDataGuardGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDataGuardGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDataGuardGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 members: Optional[Sequence['outputs.DatabaseUpgradeDataGuardGroupMember']] = None,
                 protection_mode: Optional[_builtins.str] = None):
        """
        :param Sequence['DatabaseUpgradeDataGuardGroupMemberArgs'] members: List of Data Guard members, representing each database that is part of Data Guard.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        if members is not None:
            pulumi.set(__self__, "members", members)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[Sequence['outputs.DatabaseUpgradeDataGuardGroupMember']]:
        """
        List of Data Guard members, representing each database that is part of Data Guard.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[_builtins.str]:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")


@pulumi.output_type
class DatabaseUpgradeDataGuardGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyLag":
            suggest = "apply_lag"
        elif key == "applyRate":
            suggest = "apply_rate"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "isActiveDataGuardEnabled":
            suggest = "is_active_data_guard_enabled"
        elif key == "transportLag":
            suggest = "transport_lag"
        elif key == "transportLagRefresh":
            suggest = "transport_lag_refresh"
        elif key == "transportType":
            suggest = "transport_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDataGuardGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDataGuardGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDataGuardGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_lag: Optional[_builtins.str] = None,
                 apply_rate: Optional[_builtins.str] = None,
                 database_id: Optional[_builtins.str] = None,
                 db_system_id: Optional[_builtins.str] = None,
                 is_active_data_guard_enabled: Optional[_builtins.bool] = None,
                 role: Optional[_builtins.str] = None,
                 transport_lag: Optional[_builtins.str] = None,
                 transport_lag_refresh: Optional[_builtins.str] = None,
                 transport_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        :param _builtins.str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        :param _builtins.str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str role: The role of the reporting database in this Data Guard association.
        :param _builtins.str transport_lag: The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        :param _builtins.str transport_lag_refresh: The date and time when last redo transport has been done.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
        """
        if apply_lag is not None:
            pulumi.set(__self__, "apply_lag", apply_lag)
        if apply_rate is not None:
            pulumi.set(__self__, "apply_rate", apply_rate)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if is_active_data_guard_enabled is not None:
            pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if transport_lag is not None:
            pulumi.set(__self__, "transport_lag", transport_lag)
        if transport_lag_refresh is not None:
            pulumi.set(__self__, "transport_lag_refresh", transport_lag_refresh)
        if transport_type is not None:
            pulumi.set(__self__, "transport_type", transport_type)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> Optional[_builtins.str]:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> Optional[_builtins.bool]:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The role of the reporting database in this Data Guard association.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> Optional[_builtins.str]:
        """
        The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        """
        return pulumi.get(self, "transport_lag")

    @_builtins.property
    @pulumi.getter(name="transportLagRefresh")
    def transport_lag_refresh(self) -> Optional[_builtins.str]:
        """
        The date and time when last redo transport has been done.
        """
        return pulumi.get(self, "transport_lag_refresh")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> Optional[_builtins.str]:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC
        """
        return pulumi.get(self, "transport_type")


@pulumi.output_type
class DatabaseUpgradeDatabaseUpgradeSourceDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbVersion":
            suggest = "db_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDatabaseUpgradeSourceDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDatabaseUpgradeSourceDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDatabaseUpgradeSourceDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_software_image_id: Optional[_builtins.str] = None,
                 db_version: Optional[_builtins.str] = None,
                 options: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        :param _builtins.str db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param _builtins.str options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param _builtins.str source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[_builtins.str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[_builtins.str]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[_builtins.str]:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DatabaseUpgradeDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[_builtins.bool] = None,
                 auto_backup_window: Optional[_builtins.str] = None,
                 auto_full_backup_day: Optional[_builtins.str] = None,
                 auto_full_backup_window: Optional[_builtins.str] = None,
                 backup_deletion_policy: Optional[_builtins.str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DatabaseUpgradeDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 run_immediate_full_backup: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[_builtins.str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[_builtins.str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DatabaseUpgradeDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DatabaseUpgradeDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 internet_proxy: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[_builtins.str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DbHomeDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "backupTdePassword":
            suggest = "backup_tde_password"
        elif key == "characterSet":
            suggest = "character_set"
        elif key == "connectionStrings":
            suggest = "connection_strings"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbBackupConfig":
            suggest = "db_backup_config"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"
        elif key == "dbWorkload":
            suggest = "db_workload"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "encryptionKeyLocationDetails":
            suggest = "encryption_key_location_details"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "keyStoreId":
            suggest = "key_store_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "ncharacterSet":
            suggest = "ncharacter_set"
        elif key == "oneOffPatches":
            suggest = "one_off_patches"
        elif key == "pdbName":
            suggest = "pdb_name"
        elif key == "pluggableDatabases":
            suggest = "pluggable_databases"
        elif key == "sidPrefix":
            suggest = "sid_prefix"
        elif key == "tdeWalletPassword":
            suggest = "tde_wallet_password"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeStampForPointInTimeRecovery":
            suggest = "time_stamp_for_point_in_time_recovery"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: Optional[_builtins.str] = None,
                 backup_tde_password: Optional[_builtins.str] = None,
                 character_set: Optional[_builtins.str] = None,
                 connection_strings: Optional[Sequence['outputs.DbHomeDatabaseConnectionString']] = None,
                 database_id: Optional[_builtins.str] = None,
                 database_software_image_id: Optional[_builtins.str] = None,
                 db_backup_config: Optional['outputs.DbHomeDatabaseDbBackupConfig'] = None,
                 db_name: Optional[_builtins.str] = None,
                 db_unique_name: Optional[_builtins.str] = None,
                 db_workload: Optional[_builtins.str] = None,
                 defined_tags: Optional[Mapping[str, _builtins.str]] = None,
                 encryption_key_location_details: Optional['outputs.DbHomeDatabaseEncryptionKeyLocationDetails'] = None,
                 freeform_tags: Optional[Mapping[str, _builtins.str]] = None,
                 id: Optional[_builtins.str] = None,
                 key_store_id: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 kms_key_version_id: Optional[_builtins.str] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 ncharacter_set: Optional[_builtins.str] = None,
                 one_off_patches: Optional[Sequence[_builtins.str]] = None,
                 pdb_name: Optional[_builtins.str] = None,
                 pluggable_databases: Optional[Sequence[_builtins.str]] = None,
                 sid_prefix: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 tde_wallet_password: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_stamp_for_point_in_time_recovery: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param _builtins.str backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str backup_tde_password: The password to open the TDE wallet.
        :param _builtins.str character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param _builtins.str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param 'DbHomeDatabaseDbBackupConfigArgs' db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param _builtins.str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param _builtins.str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param Mapping[str, _builtins.str] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param 'DbHomeDatabaseEncryptionKeyLocationDetailsArgs' encryption_key_location_details: Types of providers supported for managing database encryption keys
        :param Mapping[str, _builtins.str] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param Sequence[_builtins.str] one_off_patches: List of one-off patches for Database Homes.
        :param _builtins.str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param Sequence[_builtins.str] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param _builtins.str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param _builtins.str state: The current state of the Database Home.
        :param _builtins.str tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param _builtins.str time_created: The date and time the Database Home was created.
        :param _builtins.str time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if encryption_key_location_details is not None:
            pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_store_id is not None:
            pulumi.set(__self__, "key_store_id", key_store_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if one_off_patches is not None:
            pulumi.set(__self__, "one_off_patches", one_off_patches)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if sid_prefix is not None:
            pulumi.set(__self__, "sid_prefix", sid_prefix)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[_builtins.str]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[_builtins.str]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[_builtins.str]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[Sequence['outputs.DbHomeDatabaseConnectionString']]:
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[_builtins.str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional['outputs.DbHomeDatabaseDbBackupConfig']:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[_builtins.str]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Optional['outputs.DbHomeDatabaseEncryptionKeyLocationDetails']:
        """
        Types of providers supported for managing database encryption keys
        """
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[_builtins.str]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[_builtins.str]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[_builtins.str]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[_builtins.str]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[_builtins.str]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class DbHomeDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 cdb_default: Optional[_builtins.str] = None,
                 cdb_ip_default: Optional[_builtins.str] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DbHomeDatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[_builtins.bool] = None,
                 auto_backup_window: Optional[_builtins.str] = None,
                 auto_full_backup_day: Optional[_builtins.str] = None,
                 auto_full_backup_window: Optional[_builtins.str] = None,
                 backup_deletion_policy: Optional[_builtins.str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DbHomeDatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 run_immediate_full_backup: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[_builtins.str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[_builtins.str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[_builtins.str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DbHomeDatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DbHomeDatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpc_password: Optional[_builtins.str] = None,
                 vpc_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
               
               For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        :param _builtins.str type: Type of the database backup destination. Supported values: `NFS`.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.

        For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination. Supported values: `NFS`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DbHomeDatabaseEncryptionKeyLocationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerType":
            suggest = "provider_type"
        elif key == "azureEncryptionKeyId":
            suggest = "azure_encryption_key_id"
        elif key == "hsmPassword":
            suggest = "hsm_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseEncryptionKeyLocationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseEncryptionKeyLocationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseEncryptionKeyLocationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_type: _builtins.str,
                 azure_encryption_key_id: Optional[_builtins.str] = None,
                 hsm_password: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        :param _builtins.str azure_encryption_key_id: Provide the key OCID of a registered Azure key.
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        """
        pulumi.set(__self__, "provider_type", provider_type)
        if azure_encryption_key_id is not None:
            pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        if hsm_password is not None:
            pulumi.set(__self__, "hsm_password", hsm_password)

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> Optional[_builtins.str]:
        """
        Provide the key OCID of a registered Azure key.
        """
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> Optional[_builtins.str]:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")


@pulumi.output_type
class DbSystemDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class DbSystemDbHome(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createAsync":
            suggest = "create_async"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbHomeLocation":
            suggest = "db_home_location"
        elif key == "dbVersion":
            suggest = "db_version"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isUnifiedAuditingEnabled":
            suggest = "is_unified_auditing_enabled"
        elif key == "lastPatchHistoryEntryId":
            suggest = "last_patch_history_entry_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "timeCreated":
            suggest = "time_created"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHome. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHome.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHome.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: 'outputs.DbSystemDbHomeDatabase',
                 create_async: Optional[_builtins.bool] = None,
                 database_software_image_id: Optional[_builtins.str] = None,
                 db_home_location: Optional[_builtins.str] = None,
                 db_version: Optional[_builtins.str] = None,
                 defined_tags: Optional[Mapping[str, _builtins.str]] = None,
                 display_name: Optional[_builtins.str] = None,
                 freeform_tags: Optional[Mapping[str, _builtins.str]] = None,
                 id: Optional[_builtins.str] = None,
                 is_unified_auditing_enabled: Optional[_builtins.bool] = None,
                 last_patch_history_entry_id: Optional[_builtins.str] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None):
        """
        :param 'DbSystemDbHomeDatabaseArgs' database: (Updatable) Details for creating a database by restoring from a source database system.
               
               **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        :param _builtins.str db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: The user-provided name of the Database Home.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.bool is_unified_auditing_enabled: Indicates whether unified auditing is enabled or not
        :param _builtins.str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: The current state of the DB system.
        :param _builtins.str time_created: The date and time the DB system was created.
        """
        pulumi.set(__self__, "database", database)
        if create_async is not None:
            pulumi.set(__self__, "create_async", create_async)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_home_location is not None:
            pulumi.set(__self__, "db_home_location", db_home_location)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_unified_auditing_enabled is not None:
            pulumi.set(__self__, "is_unified_auditing_enabled", is_unified_auditing_enabled)
        if last_patch_history_entry_id is not None:
            pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def database(self) -> 'outputs.DbSystemDbHomeDatabase':
        """
        (Updatable) Details for creating a database by restoring from a source database system.

        **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_async")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[_builtins.str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "db_home_location")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[_builtins.str]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The user-provided name of the Database Home.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isUnifiedAuditingEnabled")
    def is_unified_auditing_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether unified auditing is enabled or not
        """
        return pulumi.get(self, "is_unified_auditing_enabled")

    @_builtins.property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class DbSystemDbHomeDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "backupTdePassword":
            suggest = "backup_tde_password"
        elif key == "characterSet":
            suggest = "character_set"
        elif key == "connectionStrings":
            suggest = "connection_strings"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbBackupConfig":
            suggest = "db_backup_config"
        elif key == "dbDomain":
            suggest = "db_domain"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"
        elif key == "dbWorkload":
            suggest = "db_workload"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "ncharacterSet":
            suggest = "ncharacter_set"
        elif key == "pdbName":
            suggest = "pdb_name"
        elif key == "pluggableDatabases":
            suggest = "pluggable_databases"
        elif key == "tdeWalletPassword":
            suggest = "tde_wallet_password"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeStampForPointInTimeRecovery":
            suggest = "time_stamp_for_point_in_time_recovery"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: Optional[_builtins.str] = None,
                 backup_tde_password: Optional[_builtins.str] = None,
                 character_set: Optional[_builtins.str] = None,
                 connection_strings: Optional[Sequence['outputs.DbSystemDbHomeDatabaseConnectionString']] = None,
                 database_id: Optional[_builtins.str] = None,
                 database_software_image_id: Optional[_builtins.str] = None,
                 db_backup_config: Optional['outputs.DbSystemDbHomeDatabaseDbBackupConfig'] = None,
                 db_domain: Optional[_builtins.str] = None,
                 db_name: Optional[_builtins.str] = None,
                 db_unique_name: Optional[_builtins.str] = None,
                 db_workload: Optional[_builtins.str] = None,
                 defined_tags: Optional[Mapping[str, _builtins.str]] = None,
                 freeform_tags: Optional[Mapping[str, _builtins.str]] = None,
                 id: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 kms_key_version_id: Optional[_builtins.str] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 ncharacter_set: Optional[_builtins.str] = None,
                 pdb_name: Optional[_builtins.str] = None,
                 pluggable_databases: Optional[Sequence[_builtins.str]] = None,
                 state: Optional[_builtins.str] = None,
                 tde_wallet_password: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_stamp_for_point_in_time_recovery: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param _builtins.str backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str backup_tde_password: The password to open the TDE wallet.
        :param _builtins.str character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param _builtins.str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param 'DbSystemDbHomeDatabaseDbBackupConfigArgs' db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param _builtins.str db_domain: The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        :param _builtins.str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param _builtins.str db_unique_name: The `DB_UNIQUE_NAME` of the Oracle Database.
        :param _builtins.str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param Mapping[str, _builtins.str] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param _builtins.str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param Sequence[_builtins.str] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param _builtins.str state: The current state of the DB system.
        :param _builtins.str tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param _builtins.str time_created: The date and time the DB system was created.
        :param _builtins.str time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_domain is not None:
            pulumi.set(__self__, "db_domain", db_domain)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[_builtins.str]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[_builtins.str]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[_builtins.str]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[Sequence['outputs.DbSystemDbHomeDatabaseConnectionString']]:
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[_builtins.str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional['outputs.DbSystemDbHomeDatabaseDbBackupConfig']:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @_builtins.property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> Optional[_builtins.str]:
        """
        The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        """
        return pulumi.get(self, "db_domain")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[_builtins.str]:
        """
        The `DB_UNIQUE_NAME` of the Oracle Database.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[_builtins.str]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[_builtins.str]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[_builtins.str]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[_builtins.str]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[_builtins.str]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class DbSystemDbHomeDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 cdb_default: Optional[_builtins.str] = None,
                 cdb_ip_default: Optional[_builtins.str] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DbSystemDbHomeDatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[_builtins.bool] = None,
                 auto_backup_window: Optional[_builtins.str] = None,
                 auto_full_backup_day: Optional[_builtins.str] = None,
                 auto_full_backup_window: Optional[_builtins.str] = None,
                 backup_deletion_policy: Optional[_builtins.str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[_builtins.int] = None,
                 run_immediate_full_backup: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: (Updatable) Backup destination details.
        :param _builtins.int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[_builtins.str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[_builtins.str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[_builtins.str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[_builtins.str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[_builtins.int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[_builtins.bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "isRemote":
            suggest = "is_remote"
        elif key == "remoteRegion":
            suggest = "remote_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_remote: Optional[_builtins.bool] = None,
                 remote_region: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
               
               For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        :param _builtins.str type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_remote is not None:
            pulumi.set(__self__, "is_remote", is_remote)
        if remote_region is not None:
            pulumi.set(__self__, "remote_region", remote_region)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> Optional[_builtins.str]:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.

        For information about valid region names, see [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DbSystemDbSystemOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageManagement":
            suggest = "storage_management"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbSystemOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbSystemOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbSystemOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_management: Optional[_builtins.str] = None):
        """
        :param _builtins.str storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @_builtins.property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[_builtins.str]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")


@pulumi.output_type
class DbSystemIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.DbSystemIormConfigCachDbPlan']] = None,
                 db_system_id: Optional[_builtins.str] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 objective: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param Sequence['DbSystemIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.DbSystemIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> Optional[_builtins.str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DbSystemIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[_builtins.str] = None,
                 flash_cache_limit: Optional[_builtins.str] = None,
                 share: Optional[_builtins.int] = None):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[_builtins.str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> Optional[_builtins.int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class DbSystemMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.DbSystemMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.DbSystemMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['DbSystemMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['DbSystemMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class DbSystemMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['DbSystemMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class DbSystemMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemsUpgradeDbSystemOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageManagement":
            suggest = "storage_management"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeDbSystemOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeDbSystemOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeDbSystemOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_management: Optional[_builtins.str] = None):
        """
        :param _builtins.str storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @_builtins.property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[_builtins.str]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")


@pulumi.output_type
class DbSystemsUpgradeIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.DbSystemsUpgradeIormConfigCachDbPlan']] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 objective: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param Sequence['DbSystemsUpgradeIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.DbSystemsUpgradeIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> Optional[_builtins.str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DbSystemsUpgradeIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[_builtins.str] = None,
                 flash_cache_limit: Optional[_builtins.str] = None,
                 share: Optional[_builtins.int] = None):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[_builtins.str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> Optional[_builtins.int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class DbSystemsUpgradeMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowMonth']] = None,
                 preference: Optional[_builtins.str] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['DbSystemsUpgradeMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class DbSystemsUpgradeMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemsUpgradeMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureComputeContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureComputeContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureComputeContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureComputeContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 is_contact_mos_validated: Optional[_builtins.bool] = None,
                 is_primary: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 phone_number: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email for the Exadata Infrastructure contact.
        :param _builtins.bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param _builtins.bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param _builtins.str name: Name of the month of the year.
        :param _builtins.str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[_builtins.bool]:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[_builtins.bool]:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.str]:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureComputeMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureComputeMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureComputeMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureComputeMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['ExadataInfrastructureComputeMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureComputeMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureConfigureExascaleManagementContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureConfigureExascaleManagementContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureConfigureExascaleManagementContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 is_contact_mos_validated: Optional[_builtins.bool] = None,
                 is_primary: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 phone_number: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email for the Exadata Infrastructure contact.
        :param _builtins.bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param _builtins.bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param _builtins.str name: Name of the month of the year.
        :param _builtins.str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[_builtins.bool]:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[_builtins.bool]:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.str]:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementDefinedFileSystemConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBackupPartition":
            suggest = "is_backup_partition"
        elif key == "isResizable":
            suggest = "is_resizable"
        elif key == "minSizeGb":
            suggest = "min_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureConfigureExascaleManagementDefinedFileSystemConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureConfigureExascaleManagementDefinedFileSystemConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureConfigureExascaleManagementDefinedFileSystemConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_backup_partition: Optional[_builtins.bool] = None,
                 is_resizable: Optional[_builtins.bool] = None,
                 min_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        if is_backup_partition is not None:
            pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        if is_resizable is not None:
            pulumi.set(__self__, "is_resizable", is_resizable)
        if min_size_gb is not None:
            pulumi.set(__self__, "min_size_gb", min_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> Optional[_builtins.bool]:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> Optional[_builtins.bool]:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> Optional[_builtins.int]:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementExascaleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableStorageInGbs":
            suggest = "available_storage_in_gbs"
        elif key == "totalStorageInGbs":
            suggest = "total_storage_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureConfigureExascaleManagementExascaleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureConfigureExascaleManagementExascaleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureConfigureExascaleManagementExascaleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_storage_in_gbs: Optional[_builtins.int] = None,
                 total_storage_in_gbs: Optional[_builtins.int] = None):
        """
        :param _builtins.int available_storage_in_gbs: Available storage size for Exascale in GBs.
        :param _builtins.int total_storage_in_gbs: Storage size needed for Exascale in GBs.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if available_storage_in_gbs is not None:
            pulumi.set(__self__, "available_storage_in_gbs", available_storage_in_gbs)
        if total_storage_in_gbs is not None:
            pulumi.set(__self__, "total_storage_in_gbs", total_storage_in_gbs)

    @_builtins.property
    @pulumi.getter(name="availableStorageInGbs")
    def available_storage_in_gbs(self) -> Optional[_builtins.int]:
        """
        Available storage size for Exascale in GBs.
        """
        return pulumi.get(self, "available_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="totalStorageInGbs")
    def total_storage_in_gbs(self) -> Optional[_builtins.int]:
        """
        Storage size needed for Exascale in GBs.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "total_storage_in_gbs")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureConfigureExascaleManagementMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureConfigureExascaleManagementMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureConfigureExascaleManagementMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are - 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are - 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureConfigureExascaleManagementNetworkBondingModeDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupNetworkBondingMode":
            suggest = "backup_network_bonding_mode"
        elif key == "clientNetworkBondingMode":
            suggest = "client_network_bonding_mode"
        elif key == "drNetworkBondingMode":
            suggest = "dr_network_bonding_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureConfigureExascaleManagementNetworkBondingModeDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureConfigureExascaleManagementNetworkBondingModeDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureConfigureExascaleManagementNetworkBondingModeDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_network_bonding_mode: Optional[_builtins.str] = None,
                 client_network_bonding_mode: Optional[_builtins.str] = None,
                 dr_network_bonding_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str backup_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param _builtins.str client_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param _builtins.str dr_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        """
        if backup_network_bonding_mode is not None:
            pulumi.set(__self__, "backup_network_bonding_mode", backup_network_bonding_mode)
        if client_network_bonding_mode is not None:
            pulumi.set(__self__, "client_network_bonding_mode", client_network_bonding_mode)
        if dr_network_bonding_mode is not None:
            pulumi.set(__self__, "dr_network_bonding_mode", dr_network_bonding_mode)

    @_builtins.property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> Optional[_builtins.str]:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> Optional[_builtins.str]:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> Optional[_builtins.str]:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class ExadataInfrastructureContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimary":
            suggest = "is_primary"
        elif key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 is_primary: _builtins.bool,
                 name: _builtins.str,
                 is_contact_mos_validated: Optional[_builtins.bool] = None,
                 phone_number: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: (Updatable) The email for the Exadata Infrastructure contact.
        :param _builtins.bool is_primary: (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param _builtins.str name: (Updatable) The name of the Exadata Infrastructure contact.
        :param _builtins.bool is_contact_mos_validated: (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param _builtins.str phone_number: (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        (Updatable) The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> _builtins.bool:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) The name of the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.str]:
        """
        (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureDefinedFileSystemConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBackupPartition":
            suggest = "is_backup_partition"
        elif key == "isResizable":
            suggest = "is_resizable"
        elif key == "minSizeGb":
            suggest = "min_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureDefinedFileSystemConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureDefinedFileSystemConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureDefinedFileSystemConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_backup_partition: Optional[_builtins.bool] = None,
                 is_resizable: Optional[_builtins.bool] = None,
                 min_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        if is_backup_partition is not None:
            pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        if is_resizable is not None:
            pulumi.set(__self__, "is_resizable", is_resizable)
        if min_size_gb is not None:
            pulumi.set(__self__, "min_size_gb", min_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> Optional[_builtins.bool]:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> Optional[_builtins.bool]:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> Optional[_builtins.int]:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class ExadataInfrastructureExascaleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableStorageInGbs":
            suggest = "available_storage_in_gbs"
        elif key == "totalStorageInGbs":
            suggest = "total_storage_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureExascaleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureExascaleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureExascaleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_storage_in_gbs: Optional[_builtins.int] = None,
                 total_storage_in_gbs: Optional[_builtins.int] = None):
        """
        :param _builtins.int available_storage_in_gbs: Available storage size for Exascale in GBs.
        :param _builtins.int total_storage_in_gbs: Storage size needed for Exascale in GBs.
        """
        if available_storage_in_gbs is not None:
            pulumi.set(__self__, "available_storage_in_gbs", available_storage_in_gbs)
        if total_storage_in_gbs is not None:
            pulumi.set(__self__, "total_storage_in_gbs", total_storage_in_gbs)

    @_builtins.property
    @pulumi.getter(name="availableStorageInGbs")
    def available_storage_in_gbs(self) -> Optional[_builtins.int]:
        """
        Available storage size for Exascale in GBs.
        """
        return pulumi.get(self, "available_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="totalStorageInGbs")
    def total_storage_in_gbs(self) -> Optional[_builtins.int]:
        """
        Storage size needed for Exascale in GBs.
        """
        return pulumi.get(self, "total_storage_in_gbs")


@pulumi.output_type
class ExadataInfrastructureMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "skipRus":
            suggest = "skip_rus"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[_builtins.int] = None,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 is_custom_action_timeout_enabled: Optional[_builtins.bool] = None,
                 is_monthly_patching_enabled: Optional[_builtins.bool] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None,
                 skip_rus: Optional[Sequence[_builtins.bool]] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['ExadataInfrastructureMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param _builtins.str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[Sequence[_builtins.bool]]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureNetworkBondingModeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupNetworkBondingMode":
            suggest = "backup_network_bonding_mode"
        elif key == "clientNetworkBondingMode":
            suggest = "client_network_bonding_mode"
        elif key == "drNetworkBondingMode":
            suggest = "dr_network_bonding_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureNetworkBondingModeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureNetworkBondingModeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureNetworkBondingModeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_network_bonding_mode: Optional[_builtins.str] = None,
                 client_network_bonding_mode: Optional[_builtins.str] = None,
                 dr_network_bonding_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str backup_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param _builtins.str client_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param _builtins.str dr_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        if backup_network_bonding_mode is not None:
            pulumi.set(__self__, "backup_network_bonding_mode", backup_network_bonding_mode)
        if client_network_bonding_mode is not None:
            pulumi.set(__self__, "client_network_bonding_mode", client_network_bonding_mode)
        if dr_network_bonding_mode is not None:
            pulumi.set(__self__, "dr_network_bonding_mode", dr_network_bonding_mode)

    @_builtins.property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class ExadataInfrastructureStorageContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimary":
            suggest = "is_primary"
        elif key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureStorageContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureStorageContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureStorageContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 is_primary: _builtins.bool,
                 name: _builtins.str,
                 is_contact_mos_validated: Optional[_builtins.bool] = None,
                 phone_number: Optional[_builtins.str] = None):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> _builtins.bool:
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_contact_mos_validated")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureStorageMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureStorageMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureStorageMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureStorageMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preference: _builtins.str,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[_builtins.int]] = None,
                 lead_time_in_weeks: Optional[_builtins.int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowMonth']] = None,
                 weeks_of_months: Optional[Sequence[_builtins.int]] = None):
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek']]:
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowMonth']]:
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureStorageMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataIormConfigDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataIormConfigDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataIormConfigDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataIormConfigDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: _builtins.str,
                 share: _builtins.int,
                 flash_cache_limit: Optional[_builtins.str] = None):
        """
        :param _builtins.str db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.int share: (Updatable) The relative priority of this database.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[_builtins.str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")


@pulumi.output_type
class ExadbVmClusterDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadbVmClusterDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadbVmClusterDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadbVmClusterDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class ExadbVmClusterIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadbVmClusterIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadbVmClusterIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadbVmClusterIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.ExadbVmClusterIormConfigCachDbPlan']] = None,
                 lifecycle_details: Optional[_builtins.str] = None,
                 objective: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param Sequence['ExadbVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.ExadbVmClusterIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[_builtins.str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> Optional[_builtins.str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ExadbVmClusterIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadbVmClusterIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadbVmClusterIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadbVmClusterIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[_builtins.str] = None,
                 flash_cache_limit: Optional[_builtins.str] = None,
                 share: Optional[_builtins.int] = None):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[_builtins.str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> Optional[_builtins.int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class ExadbVmClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledEcpuCountPerNode":
            suggest = "enabled_ecpu_count_per_node"
        elif key == "totalEcpuCountPerNode":
            suggest = "total_ecpu_count_per_node"
        elif key == "vmFileSystemStorageSizeGbsPerNode":
            suggest = "vm_file_system_storage_size_gbs_per_node"
        elif key == "memorySizeInGbsPerNode":
            suggest = "memory_size_in_gbs_per_node"
        elif key == "snapshotFileSystemStorageSizeGbsPerNode":
            suggest = "snapshot_file_system_storage_size_gbs_per_node"
        elif key == "totalFileSystemStorageSizeGbsPerNode":
            suggest = "total_file_system_storage_size_gbs_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadbVmClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadbVmClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadbVmClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_ecpu_count_per_node: _builtins.int,
                 total_ecpu_count_per_node: _builtins.int,
                 vm_file_system_storage_size_gbs_per_node: _builtins.int,
                 memory_size_in_gbs_per_node: Optional[_builtins.int] = None,
                 snapshot_file_system_storage_size_gbs_per_node: Optional[_builtins.int] = None,
                 total_file_system_storage_size_gbs_per_node: Optional[_builtins.int] = None):
        """
        :param _builtins.int enabled_ecpu_count_per_node: (Updatable) The number of ECPUs to enable for each node.
        :param _builtins.int total_ecpu_count_per_node: (Updatable) The number of Total ECPUs for each node.
        :param _builtins.int vm_file_system_storage_size_gbs_per_node: (Updatable) The file system storage in GBs for each node.
        :param _builtins.int memory_size_in_gbs_per_node: The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        :param _builtins.int snapshot_file_system_storage_size_gbs_per_node: The file system storage in GBs for snapshot for each node.
        :param _builtins.int total_file_system_storage_size_gbs_per_node: Total file system storage in GBs for each node.
        """
        pulumi.set(__self__, "enabled_ecpu_count_per_node", enabled_ecpu_count_per_node)
        pulumi.set(__self__, "total_ecpu_count_per_node", total_ecpu_count_per_node)
        pulumi.set(__self__, "vm_file_system_storage_size_gbs_per_node", vm_file_system_storage_size_gbs_per_node)
        if memory_size_in_gbs_per_node is not None:
            pulumi.set(__self__, "memory_size_in_gbs_per_node", memory_size_in_gbs_per_node)
        if snapshot_file_system_storage_size_gbs_per_node is not None:
            pulumi.set(__self__, "snapshot_file_system_storage_size_gbs_per_node", snapshot_file_system_storage_size_gbs_per_node)
        if total_file_system_storage_size_gbs_per_node is not None:
            pulumi.set(__self__, "total_file_system_storage_size_gbs_per_node", total_file_system_storage_size_gbs_per_node)

    @_builtins.property
    @pulumi.getter(name="enabledEcpuCountPerNode")
    def enabled_ecpu_count_per_node(self) -> _builtins.int:
        """
        (Updatable) The number of ECPUs to enable for each node.
        """
        return pulumi.get(self, "enabled_ecpu_count_per_node")

    @_builtins.property
    @pulumi.getter(name="totalEcpuCountPerNode")
    def total_ecpu_count_per_node(self) -> _builtins.int:
        """
        (Updatable) The number of Total ECPUs for each node.
        """
        return pulumi.get(self, "total_ecpu_count_per_node")

    @_builtins.property
    @pulumi.getter(name="vmFileSystemStorageSizeGbsPerNode")
    def vm_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        (Updatable) The file system storage in GBs for each node.
        """
        return pulumi.get(self, "vm_file_system_storage_size_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbsPerNode")
    def memory_size_in_gbs_per_node(self) -> Optional[_builtins.int]:
        """
        The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        """
        return pulumi.get(self, "memory_size_in_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="snapshotFileSystemStorageSizeGbsPerNode")
    def snapshot_file_system_storage_size_gbs_per_node(self) -> Optional[_builtins.int]:
        """
        The file system storage in GBs for snapshot for each node.
        """
        return pulumi.get(self, "snapshot_file_system_storage_size_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="totalFileSystemStorageSizeGbsPerNode")
    def total_file_system_storage_size_gbs_per_node(self) -> Optional[_builtins.int]:
        """
        Total file system storage in GBs for each node.
        """
        return pulumi.get(self, "total_file_system_storage_size_gbs_per_node")


@pulumi.output_type
class ExadbVmClusterNodeResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"
        elif key == "nodeHostname":
            suggest = "node_hostname"
        elif key == "nodeId":
            suggest = "node_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadbVmClusterNodeResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadbVmClusterNodeResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadbVmClusterNodeResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_name: _builtins.str,
                 node_hostname: Optional[_builtins.str] = None,
                 node_id: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str node_hostname: The host name for the node.
        :param _builtins.str node_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        :param _builtins.str state: The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        pulumi.set(__self__, "node_name", node_name)
        if node_hostname is not None:
            pulumi.set(__self__, "node_hostname", node_hostname)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="nodeHostname")
    def node_hostname(self) -> Optional[_builtins.str]:
        """
        The host name for the node.
        """
        return pulumi.get(self, "node_hostname")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ExascaleDbStorageVaultHighCapacityDatabaseStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalSizeInGbs":
            suggest = "total_size_in_gbs"
        elif key == "availableSizeInGbs":
            suggest = "available_size_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExascaleDbStorageVaultHighCapacityDatabaseStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExascaleDbStorageVaultHighCapacityDatabaseStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExascaleDbStorageVaultHighCapacityDatabaseStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_size_in_gbs: _builtins.int,
                 available_size_in_gbs: Optional[_builtins.int] = None):
        """
        :param _builtins.int total_size_in_gbs: (Updatable) Total Capacity
        :param _builtins.int available_size_in_gbs: Available Capacity
        """
        pulumi.set(__self__, "total_size_in_gbs", total_size_in_gbs)
        if available_size_in_gbs is not None:
            pulumi.set(__self__, "available_size_in_gbs", available_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="totalSizeInGbs")
    def total_size_in_gbs(self) -> _builtins.int:
        """
        (Updatable) Total Capacity
        """
        return pulumi.get(self, "total_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="availableSizeInGbs")
    def available_size_in_gbs(self) -> Optional[_builtins.int]:
        """
        Available Capacity
        """
        return pulumi.get(self, "available_size_in_gbs")


@pulumi.output_type
class ExecutionActionActionMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memberId":
            suggest = "member_id"
        elif key == "memberOrder":
            suggest = "member_order"
        elif key == "estimatedTimeInMins":
            suggest = "estimated_time_in_mins"
        elif key == "totalTimeTakenInMins":
            suggest = "total_time_taken_in_mins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExecutionActionActionMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExecutionActionActionMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExecutionActionActionMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 member_id: _builtins.str,
                 member_order: _builtins.int,
                 estimated_time_in_mins: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None,
                 total_time_taken_in_mins: Optional[_builtins.int] = None):
        """
        :param _builtins.str member_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        :param _builtins.int member_order: (Updatable) The priority order of the execution action member.
        :param _builtins.int estimated_time_in_mins: (Updatable) The estimated time of the execution action member in minutes.
        :param _builtins.str status: (Updatable) The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
               * SCHEDULED
               * IN_PROGRESS
               * FAILED
               * CANCELED
               * DURATION_EXCEEDED
               * RESCHEDULED
               * SUCCEEDED
        :param _builtins.int total_time_taken_in_mins: (Updatable) The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)
        if estimated_time_in_mins is not None:
            pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if total_time_taken_in_mins is not None:
            pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        (Updatable) The priority order of the execution action member.
        """
        return pulumi.get(self, "member_order")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) The estimated time of the execution action member in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        (Updatable) The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
        * SCHEDULED
        * IN_PROGRESS
        * FAILED
        * CANCELED
        * DURATION_EXCEEDED
        * RESCHEDULED
        * SUCCEEDED
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class ExternalContainerDatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseManagementConnectionId":
            suggest = "database_management_connection_id"
        elif key == "databaseManagementStatus":
            suggest = "database_management_status"
        elif key == "licenseModel":
            suggest = "license_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalContainerDatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_management_connection_id: Optional[_builtins.str] = None,
                 database_management_status: Optional[_builtins.str] = None,
                 license_model: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[_builtins.str]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class ExternalContainerDatabaseStackMonitoringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMonitoringConnectorId":
            suggest = "stack_monitoring_connector_id"
        elif key == "stackMonitoringStatus":
            suggest = "stack_monitoring_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalContainerDatabaseStackMonitoringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[_builtins.str] = None,
                 stack_monitoring_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[_builtins.str]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class ExternalDatabaseConnectorConnectionCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialName":
            suggest = "credential_name"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "sslSecretId":
            suggest = "ssl_secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalDatabaseConnectorConnectionCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalDatabaseConnectorConnectionCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalDatabaseConnectorConnectionCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_name: Optional[_builtins.str] = None,
                 credential_type: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 ssl_secret_id: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str credential_name: (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
               
               For example: inventorydb.abc112233445566778899
        :param _builtins.str credential_type: (Updatable) The type of credential used to connect to the database.
        :param _builtins.str password: (Updatable) The password that will be used to connect to the database.
        :param _builtins.str role: (Updatable) The role of the user that will be connecting to the database.
        :param _builtins.str ssl_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str username: (Updatable) The username that will be used to connect to the database.
        """
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if ssl_secret_id is not None:
            pulumi.set(__self__, "ssl_secret_id", ssl_secret_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.

        For example: inventorydb.abc112233445566778899
        """
        return pulumi.get(self, "credential_name")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        (Updatable) The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        (Updatable) The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        (Updatable) The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ExternalDatabaseConnectorConnectionString(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 service: _builtins.str):
        """
        :param _builtins.str hostname: (Updatable) The host name of the database.
        :param _builtins.int port: (Updatable) The port used to connect to the database.
        :param _builtins.str protocol: (Updatable) The protocol used to connect to the database.
        :param _builtins.str service: (Updatable) The name of the service alias used to connect to the database.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        (Updatable) The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        (Updatable) The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        (Updatable) The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        (Updatable) The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ExternalNonContainerDatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseManagementConnectionId":
            suggest = "database_management_connection_id"
        elif key == "databaseManagementStatus":
            suggest = "database_management_status"
        elif key == "licenseModel":
            suggest = "license_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNonContainerDatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNonContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNonContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_management_connection_id: Optional[_builtins.str] = None,
                 database_management_status: Optional[_builtins.str] = None,
                 license_model: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[_builtins.str]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class ExternalNonContainerDatabaseOperationsInsightsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationsInsightsConnectorId":
            suggest = "operations_insights_connector_id"
        elif key == "operationsInsightsStatus":
            suggest = "operations_insights_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNonContainerDatabaseOperationsInsightsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNonContainerDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNonContainerDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[_builtins.str] = None,
                 operations_insights_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[_builtins.str]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class ExternalNonContainerDatabaseStackMonitoringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMonitoringConnectorId":
            suggest = "stack_monitoring_connector_id"
        elif key == "stackMonitoringStatus":
            suggest = "stack_monitoring_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNonContainerDatabaseStackMonitoringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNonContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNonContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[_builtins.str] = None,
                 stack_monitoring_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[_builtins.str]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class ExternalPluggableDatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseManagementConnectionId":
            suggest = "database_management_connection_id"
        elif key == "databaseManagementStatus":
            suggest = "database_management_status"
        elif key == "licenseModel":
            suggest = "license_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalPluggableDatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalPluggableDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalPluggableDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_management_connection_id: Optional[_builtins.str] = None,
                 database_management_status: Optional[_builtins.str] = None,
                 license_model: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[_builtins.str]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class ExternalPluggableDatabaseOperationsInsightsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationsInsightsConnectorId":
            suggest = "operations_insights_connector_id"
        elif key == "operationsInsightsStatus":
            suggest = "operations_insights_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalPluggableDatabaseOperationsInsightsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalPluggableDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalPluggableDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[_builtins.str] = None,
                 operations_insights_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[_builtins.str]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class ExternalPluggableDatabaseStackMonitoringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMonitoringConnectorId":
            suggest = "stack_monitoring_connector_id"
        elif key == "stackMonitoringStatus":
            suggest = "stack_monitoring_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalPluggableDatabaseStackMonitoringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalPluggableDatabaseStackMonitoringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalPluggableDatabaseStackMonitoringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[_builtins.str] = None,
                 stack_monitoring_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[_builtins.str]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class KeyStoreAssociatedDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyStoreAssociatedDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyStoreAssociatedDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyStoreAssociatedDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[_builtins.str] = None,
                 db_unique_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str db_name: The name of the database that is associated with the key store.
        :param _builtins.str db_unique_name: The unique name of the database that is associated with the key store.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[_builtins.str]:
        """
        The unique name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KeyStoreTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "connectionIps":
            suggest = "connection_ips"
        elif key == "secretId":
            suggest = "secret_id"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyStoreTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyStoreTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyStoreTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 connection_ips: Sequence[_builtins.str],
                 secret_id: _builtins.str,
                 type: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str admin_username: (Updatable) The administrator username to connect to Oracle Key Vault
        :param Sequence[_builtins.str] connection_ips: (Updatable) The list of Oracle Key Vault connection IP addresses.
        :param _builtins.str secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str type: (Updatable) The type of key store.
        :param _builtins.str vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "connection_ips", connection_ips)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        (Updatable) The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> Sequence[_builtins.str]:
        """
        (Updatable) The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (Updatable) The type of key store.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class MaintenanceRunEstimatedPatchingTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedDbServerPatchingTime":
            suggest = "estimated_db_server_patching_time"
        elif key == "estimatedNetworkSwitchesPatchingTime":
            suggest = "estimated_network_switches_patching_time"
        elif key == "estimatedStorageServerPatchingTime":
            suggest = "estimated_storage_server_patching_time"
        elif key == "totalEstimatedPatchingTime":
            suggest = "total_estimated_patching_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceRunEstimatedPatchingTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceRunEstimatedPatchingTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceRunEstimatedPatchingTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_db_server_patching_time: Optional[_builtins.int] = None,
                 estimated_network_switches_patching_time: Optional[_builtins.int] = None,
                 estimated_storage_server_patching_time: Optional[_builtins.int] = None,
                 total_estimated_patching_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param _builtins.int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param _builtins.int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param _builtins.int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        if estimated_db_server_patching_time is not None:
            pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        if estimated_network_switches_patching_time is not None:
            pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        if estimated_storage_server_patching_time is not None:
            pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        if total_estimated_patching_time is not None:
            pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @_builtins.property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> Optional[_builtins.int]:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> Optional[_builtins.int]:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> Optional[_builtins.int]:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> Optional[_builtins.int]:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class PluggableDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 pdb_default: Optional[_builtins.str] = None,
                 pdb_ip_default: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param _builtins.str pdb_default: A host name-based PDB connection string.
        :param _builtins.str pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[_builtins.str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @_builtins.property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[_builtins.str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabaseManagementsManagementConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enablePluggabledatabasemanagement":
            suggest = "enable_pluggabledatabasemanagement"
        elif key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseManagementsManagementConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseManagementsManagementConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseManagementsManagementConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: _builtins.bool,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 pdb_default: Optional[_builtins.str] = None,
                 pdb_ip_default: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param _builtins.str pdb_default: A host name-based PDB connection string.
        :param _builtins.str pdb_ip_default: An IP-based PDB connection string.
        """
        pulumi.set(__self__, "enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> _builtins.bool:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[_builtins.str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @_builtins.property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[_builtins.str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabaseManagementsManagementCredentialDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretId":
            suggest = "password_secret_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseManagementsManagementCredentialDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseManagementsManagementCredentialDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseManagementsManagementCredentialDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_secret_id: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str password_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str user_name: The name of the Oracle Database user that will be used to connect to the database.
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "password_secret_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The name of the Oracle Database user that will be used to connect to the database.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enablePluggabledatabasemanagement":
            suggest = "enable_pluggabledatabasemanagement"
        elif key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: _builtins.bool,
                 management_status: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param _builtins.str management_status: The status of the Pluggable Database Management service.
        """
        pulumi.set(__self__, "enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @_builtins.property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> _builtins.bool:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabasePdbCreationTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationType":
            suggest = "creation_type"
        elif key == "sourcePluggableDatabaseId":
            suggest = "source_pluggable_database_id"
        elif key == "dblinkUserPassword":
            suggest = "dblink_user_password"
        elif key == "dblinkUsername":
            suggest = "dblink_username"
        elif key == "isThinClone":
            suggest = "is_thin_clone"
        elif key == "refreshableCloneDetails":
            suggest = "refreshable_clone_details"
        elif key == "sourceContainerDatabaseAdminPassword":
            suggest = "source_container_database_admin_password"
        elif key == "sourcePluggableDatabaseSnapshotId":
            suggest = "source_pluggable_database_snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasePdbCreationTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasePdbCreationTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasePdbCreationTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_type: _builtins.str,
                 source_pluggable_database_id: _builtins.str,
                 dblink_user_password: Optional[_builtins.str] = None,
                 dblink_username: Optional[_builtins.str] = None,
                 is_thin_clone: Optional[_builtins.bool] = None,
                 refreshable_clone_details: Optional['outputs.PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails'] = None,
                 source_container_database_admin_password: Optional[_builtins.str] = None,
                 source_pluggable_database_snapshot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str creation_type: The Pluggable Database creation type.
        :param _builtins.str source_pluggable_database_id: The OCID of the Source Pluggable Database.
        :param _builtins.str dblink_user_password: The DB link user password.
        :param _builtins.str dblink_username: The name of the DB link user.
        :param _builtins.bool is_thin_clone: True if Pluggable Database needs to be thin cloned and false if Pluggable Database needs to be thick cloned.
        :param 'PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs' refreshable_clone_details: Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param _builtins.str source_container_database_admin_password: The DB system administrator password of the source Container Database.
        :param _builtins.str source_pluggable_database_snapshot_id: The OCID of the Source Pluggable Database Snapshot id.
        """
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "source_pluggable_database_id", source_pluggable_database_id)
        if dblink_user_password is not None:
            pulumi.set(__self__, "dblink_user_password", dblink_user_password)
        if dblink_username is not None:
            pulumi.set(__self__, "dblink_username", dblink_username)
        if is_thin_clone is not None:
            pulumi.set(__self__, "is_thin_clone", is_thin_clone)
        if refreshable_clone_details is not None:
            pulumi.set(__self__, "refreshable_clone_details", refreshable_clone_details)
        if source_container_database_admin_password is not None:
            pulumi.set(__self__, "source_container_database_admin_password", source_container_database_admin_password)
        if source_pluggable_database_snapshot_id is not None:
            pulumi.set(__self__, "source_pluggable_database_snapshot_id", source_pluggable_database_snapshot_id)

    @_builtins.property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> _builtins.str:
        """
        The Pluggable Database creation type.
        """
        return pulumi.get(self, "creation_type")

    @_builtins.property
    @pulumi.getter(name="sourcePluggableDatabaseId")
    def source_pluggable_database_id(self) -> _builtins.str:
        """
        The OCID of the Source Pluggable Database.
        """
        return pulumi.get(self, "source_pluggable_database_id")

    @_builtins.property
    @pulumi.getter(name="dblinkUserPassword")
    def dblink_user_password(self) -> Optional[_builtins.str]:
        """
        The DB link user password.
        """
        return pulumi.get(self, "dblink_user_password")

    @_builtins.property
    @pulumi.getter(name="dblinkUsername")
    def dblink_username(self) -> Optional[_builtins.str]:
        """
        The name of the DB link user.
        """
        return pulumi.get(self, "dblink_username")

    @_builtins.property
    @pulumi.getter(name="isThinClone")
    def is_thin_clone(self) -> Optional[_builtins.bool]:
        """
        True if Pluggable Database needs to be thin cloned and false if Pluggable Database needs to be thick cloned.
        """
        return pulumi.get(self, "is_thin_clone")

    @_builtins.property
    @pulumi.getter(name="refreshableCloneDetails")
    def refreshable_clone_details(self) -> Optional['outputs.PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails']:
        """
        Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "refreshable_clone_details")

    @_builtins.property
    @pulumi.getter(name="sourceContainerDatabaseAdminPassword")
    def source_container_database_admin_password(self) -> Optional[_builtins.str]:
        """
        The DB system administrator password of the source Container Database.
        """
        return pulumi.get(self, "source_container_database_admin_password")

    @_builtins.property
    @pulumi.getter(name="sourcePluggableDatabaseSnapshotId")
    def source_pluggable_database_snapshot_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the Source Pluggable Database Snapshot id.
        """
        return pulumi.get(self, "source_pluggable_database_snapshot_id")


@pulumi.output_type
class PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRefreshableClone":
            suggest = "is_refreshable_clone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_refreshable_clone: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class PluggableDatabasePdbNodeLevelDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"
        elif key == "openMode":
            suggest = "open_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasePdbNodeLevelDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasePdbNodeLevelDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasePdbNodeLevelDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_name: Optional[_builtins.str] = None,
                 open_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str node_name: The Node name of the Database Instance.
        :param _builtins.str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[_builtins.str]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[_builtins.str]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")


@pulumi.output_type
class PluggableDatabasePluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasePluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasePluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasePluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabaseRefreshableCloneConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRefreshableClone":
            suggest = "is_refreshable_clone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseRefreshableCloneConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseRefreshableCloneConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseRefreshableCloneConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_refreshable_clone: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class PluggableDatabasesLocalCloneConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesLocalCloneConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesLocalCloneConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesLocalCloneConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 pdb_default: Optional[_builtins.str] = None,
                 pdb_ip_default: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param _builtins.str pdb_default: A host name-based PDB connection string.
        :param _builtins.str pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[_builtins.str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @_builtins.property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[_builtins.str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabasesLocalClonePdbNodeLevelDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"
        elif key == "openMode":
            suggest = "open_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesLocalClonePdbNodeLevelDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesLocalClonePdbNodeLevelDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesLocalClonePdbNodeLevelDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_name: Optional[_builtins.str] = None,
                 open_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str node_name: The Node name of the Database Instance.
        :param _builtins.str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[_builtins.str]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[_builtins.str]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")


@pulumi.output_type
class PluggableDatabasesLocalClonePluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesLocalClonePluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesLocalClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesLocalClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabasesLocalCloneRefreshableCloneConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRefreshableClone":
            suggest = "is_refreshable_clone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesLocalCloneRefreshableCloneConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesLocalCloneRefreshableCloneConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesLocalCloneRefreshableCloneConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_refreshable_clone: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class PluggableDatabasesRemoteCloneConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesRemoteCloneConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesRemoteCloneConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesRemoteCloneConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, _builtins.str]] = None,
                 pdb_default: Optional[_builtins.str] = None,
                 pdb_ip_default: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param _builtins.str pdb_default: A host name-based PDB connection string.
        :param _builtins.str pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[_builtins.str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @_builtins.property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[_builtins.str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabasesRemoteClonePdbNodeLevelDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"
        elif key == "openMode":
            suggest = "open_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesRemoteClonePdbNodeLevelDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesRemoteClonePdbNodeLevelDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesRemoteClonePdbNodeLevelDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_name: Optional[_builtins.str] = None,
                 open_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str node_name: The Node name of the Database Instance.
        :param _builtins.str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[_builtins.str]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[_builtins.str]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")


@pulumi.output_type
class PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[_builtins.str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabasesRemoteCloneRefreshableCloneConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRefreshableClone":
            suggest = "is_refreshable_clone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesRemoteCloneRefreshableCloneConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesRemoteCloneRefreshableCloneConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesRemoteCloneRefreshableCloneConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_refreshable_clone: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class ScheduledActionActionMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memberId":
            suggest = "member_id"
        elif key == "memberOrder":
            suggest = "member_order"
        elif key == "estimatedTimeInMins":
            suggest = "estimated_time_in_mins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledActionActionMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledActionActionMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledActionActionMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 member_id: _builtins.str,
                 member_order: _builtins.int,
                 estimated_time_in_mins: Optional[_builtins.int] = None):
        """
        :param _builtins.str member_id: (Updatable) The ocid of the action member.
        :param _builtins.int member_order: (Updatable) The order of the action member in a scheduled action.
        :param _builtins.int estimated_time_in_mins: (Updatable) The estimated time for the intended action member.
        """
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)
        if estimated_time_in_mins is not None:
            pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        (Updatable) The ocid of the action member.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        (Updatable) The order of the action member in a scheduled action.
        """
        return pulumi.get(self, "member_order")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> Optional[_builtins.int]:
        """
        (Updatable) The estimated time for the intended action member.
        """
        return pulumi.get(self, "estimated_time_in_mins")


@pulumi.output_type
class SchedulingPolicyCadenceStartMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SchedulingPolicySchedulingWindowWindowPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "isEnforcedDuration":
            suggest = "is_enforced_duration"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchedulingPolicySchedulingWindowWindowPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchedulingPolicySchedulingWindowWindowPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchedulingPolicySchedulingWindowWindowPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Sequence['outputs.SchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeek'],
                 duration: _builtins.int,
                 is_enforced_duration: _builtins.bool,
                 months: Sequence['outputs.SchedulingPolicySchedulingWindowWindowPreferenceMonth'],
                 start_time: _builtins.str,
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['SchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when scheduling window should be performed.
        :param _builtins.int duration: (Updatable) Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        :param _builtins.bool is_enforced_duration: (Updatable) Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        :param Sequence['SchedulingPolicySchedulingWindowWindowPreferenceMonthArgs'] months: (Updatable) Months during the year when scheduled window should be performed.
        :param _builtins.str start_time: (Updatable) The scheduling window start time. The value must use the ISO-8601 format "hh:mm".
        :param Sequence[_builtins.int] weeks_of_months: (Updatable) Weeks during the month when scheduled window should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow scheduling window during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Scheduling window cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and startTime parameters to allow you to specify specific days of the week and hours that scheduled window will be performed. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "is_enforced_duration", is_enforced_duration)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.SchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeek']:
        """
        (Updatable) Days during the week when scheduling window should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        (Updatable) Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="isEnforcedDuration")
    def is_enforced_duration(self) -> _builtins.bool:
        """
        (Updatable) Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_enforced_duration")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.SchedulingPolicySchedulingWindowWindowPreferenceMonth']:
        """
        (Updatable) Months during the year when scheduled window should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        (Updatable) The scheduling window start time. The value must use the ISO-8601 format "hh:mm".
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        (Updatable) Weeks during the month when scheduled window should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow scheduling window during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Scheduling window cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and startTime parameters to allow you to specify specific days of the week and hours that scheduled window will be performed. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class SchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SchedulingPolicySchedulingWindowWindowPreferenceMonth(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VmClusterAddVirtualNetworkCloudAutomationUpdateDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdateTimePreferences":
            suggest = "apply_update_time_preferences"
        elif key == "freezePeriods":
            suggest = "freeze_periods"
        elif key == "isEarlyAdoptionEnabled":
            suggest = "is_early_adoption_enabled"
        elif key == "isFreezePeriodEnabled":
            suggest = "is_freeze_period_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkCloudAutomationUpdateDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkCloudAutomationUpdateDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkCloudAutomationUpdateDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_time_preferences: Optional[Sequence['outputs.VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference']] = None,
                 freeze_periods: Optional[Sequence['outputs.VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod']] = None,
                 is_early_adoption_enabled: Optional[_builtins.bool] = None,
                 is_freeze_period_enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs'] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param Sequence['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs'] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preferences is not None:
            pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        if freeze_periods is not None:
            pulumi.set(__self__, "freeze_periods", freeze_periods)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Optional[Sequence['outputs.VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference']]:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @_builtins.property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Optional[Sequence['outputs.VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod']]:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[_builtins.bool]:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdatePreferredEndTime":
            suggest = "apply_update_preferred_end_time"
        elif key == "applyUpdatePreferredStartTime":
            suggest = "apply_update_preferred_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[_builtins.str] = None,
                 apply_update_preferred_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[_builtins.str]:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[_builtins.str]:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freezePeriodEndTime":
            suggest = "freeze_period_end_time"
        elif key == "freezePeriodStartTime":
            suggest = "freeze_period_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 freeze_period_end_time: Optional[_builtins.str] = None,
                 freeze_period_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str freeze_period_end_time: End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[_builtins.str]:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[_builtins.str]:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class VmClusterAddVirtualNetworkDataCollectionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkDataCollectionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkDataCollectionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkDataCollectionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class VmClusterAddVirtualNetworkDbServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbServerId":
            suggest = "db_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkDbServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkDbServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkDbServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_server_id: _builtins.str):
        """
        :param _builtins.str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")


@pulumi.output_type
class VmClusterAddVirtualNetworkFileSystemConfigurationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemSizeGb":
            suggest = "file_system_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkFileSystemConfigurationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkFileSystemConfigurationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkFileSystemConfigurationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.int file_system_size_gb: The file system size to be allocated in GBs.
        :param _builtins.str mount_point: The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[_builtins.int]:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class VmClusterCloudAutomationUpdateDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdateTimePreference":
            suggest = "apply_update_time_preference"
        elif key == "freezePeriod":
            suggest = "freeze_period"
        elif key == "isEarlyAdoptionEnabled":
            suggest = "is_early_adoption_enabled"
        elif key == "isFreezePeriodEnabled":
            suggest = "is_freeze_period_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterCloudAutomationUpdateDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterCloudAutomationUpdateDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterCloudAutomationUpdateDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_time_preference: Optional['outputs.VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference'] = None,
                 freeze_period: Optional['outputs.VmClusterCloudAutomationUpdateDetailsFreezePeriod'] = None,
                 is_early_adoption_enabled: Optional[_builtins.bool] = None,
                 is_freeze_period_enabled: Optional[_builtins.bool] = None):
        """
        :param 'VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs' apply_update_time_preference: (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param 'VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs' freeze_period: (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preference is not None:
            pulumi.set(__self__, "apply_update_time_preference", apply_update_time_preference)
        if freeze_period is not None:
            pulumi.set(__self__, "freeze_period", freeze_period)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreference")
    def apply_update_time_preference(self) -> Optional['outputs.VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference']:
        """
        (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preference")

    @_builtins.property
    @pulumi.getter(name="freezePeriod")
    def freeze_period(self) -> Optional['outputs.VmClusterCloudAutomationUpdateDetailsFreezePeriod']:
        """
        (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_period")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdatePreferredEndTime":
            suggest = "apply_update_preferred_end_time"
        elif key == "applyUpdatePreferredStartTime":
            suggest = "apply_update_preferred_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[_builtins.str] = None,
                 apply_update_preferred_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_update_preferred_end_time: (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class VmClusterCloudAutomationUpdateDetailsFreezePeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freezePeriodEndTime":
            suggest = "freeze_period_end_time"
        elif key == "freezePeriodStartTime":
            suggest = "freeze_period_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterCloudAutomationUpdateDetailsFreezePeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterCloudAutomationUpdateDetailsFreezePeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterCloudAutomationUpdateDetailsFreezePeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 freeze_period_end_time: Optional[_builtins.str] = None,
                 freeze_period_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str freeze_period_end_time: (Updatable) End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: (Updatable) Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[_builtins.str]:
        """
        (Updatable) Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class VmClusterDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class VmClusterFileSystemConfigurationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemSizeGb":
            suggest = "file_system_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterFileSystemConfigurationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterFileSystemConfigurationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterFileSystemConfigurationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.int file_system_size_gb: (Updatable) The file system size to be allocated in GBs.
        :param _builtins.str mount_point: (Updatable) The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[_builtins.int]:
        """
        (Updatable) The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        (Updatable) The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class VmClusterNetworkDrScan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanListenerPortTcp":
            suggest = "scan_listener_port_tcp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkDrScan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkDrScan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkDrScan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 scan_listener_port_tcp: _builtins.int):
        """
        :param _builtins.str hostname: (Updatable) The Disaster recovery SCAN hostname.
        :param Sequence[_builtins.str] ips: (Updatable) The list of Disaster recovery SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int scan_listener_port_tcp: (Updatable) The Disaster recovery SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        (Updatable) The Disaster recovery SCAN hostname.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        (Updatable) The list of Disaster recovery SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        (Updatable) The Disaster recovery SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class VmClusterNetworkScan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanListenerPortTcp":
            suggest = "scan_listener_port_tcp"
        elif key == "scanListenerPortTcpSsl":
            suggest = "scan_listener_port_tcp_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkScan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkScan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkScan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 port: Optional[_builtins.int] = None,
                 scan_listener_port_tcp: Optional[_builtins.int] = None,
                 scan_listener_port_tcp_ssl: Optional[_builtins.int] = None):
        """
        :param _builtins.str hostname: (Updatable) The SCAN hostname.
        :param Sequence[_builtins.str] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int port: (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp: (Updatable) The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp_ssl: (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scan_listener_port_tcp is not None:
            pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        if scan_listener_port_tcp_ssl is not None:
            pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        (Updatable) The SCAN hostname.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> Optional[_builtins.int]:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> Optional[_builtins.int]:
        """
        (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class VmClusterNetworkVmNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkType":
            suggest = "network_type"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkVmNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkVmNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkVmNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_type: _builtins.str,
                 nodes: Sequence['outputs.VmClusterNetworkVmNetworkNode'],
                 domain_name: Optional[_builtins.str] = None,
                 gateway: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_type: (Updatable) The network type.
        :param Sequence['VmClusterNetworkVmNetworkNodeArgs'] nodes: (Updatable) The list of node details.
        :param _builtins.str domain_name: (Updatable) The network domain name.
        :param _builtins.str gateway: (Updatable) The network gateway.
        :param _builtins.str netmask: (Updatable) The network netmask.
        :param _builtins.str vlan_id: (Updatable) The network VLAN ID.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        (Updatable) The network type.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.VmClusterNetworkVmNetworkNode']:
        """
        (Updatable) The list of node details.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network gateway.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network netmask.
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The network VLAN ID.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class VmClusterNetworkVmNetworkNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbServerId":
            suggest = "db_server_id"
        elif key == "vipHostname":
            suggest = "vip_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkVmNetworkNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkVmNetworkNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkVmNetworkNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ip: _builtins.str,
                 db_server_id: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 vip: Optional[_builtins.str] = None,
                 vip_hostname: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: (Updatable) The node host name.
        :param _builtins.str ip: (Updatable) The node IP address.
        :param _builtins.str db_server_id: (Updatable) The Db server associated with the node.
        :param _builtins.str state: (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param _builtins.str vip: (Updatable) The node virtual IP (VIP) address.
        :param _builtins.str vip_hostname: (Updatable) The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        if db_server_id is not None:
            pulumi.set(__self__, "db_server_id", db_server_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)
        if vip_hostname is not None:
            pulumi.set(__self__, "vip_hostname", vip_hostname)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        (Updatable) The node IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> Optional[_builtins.str]:
        """
        (Updatable) The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> Optional[_builtins.str]:
        """
        (Updatable) The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdateTimePreferences":
            suggest = "apply_update_time_preferences"
        elif key == "freezePeriods":
            suggest = "freeze_periods"
        elif key == "isEarlyAdoptionEnabled":
            suggest = "is_early_adoption_enabled"
        elif key == "isFreezePeriodEnabled":
            suggest = "is_freeze_period_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineCloudAutomationUpdateDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineCloudAutomationUpdateDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineCloudAutomationUpdateDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_time_preferences: Optional[Sequence['outputs.VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference']] = None,
                 freeze_periods: Optional[Sequence['outputs.VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod']] = None,
                 is_early_adoption_enabled: Optional[_builtins.bool] = None,
                 is_freeze_period_enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs'] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param Sequence['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs'] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preferences is not None:
            pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        if freeze_periods is not None:
            pulumi.set(__self__, "freeze_periods", freeze_periods)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Optional[Sequence['outputs.VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference']]:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @_builtins.property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Optional[Sequence['outputs.VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod']]:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[_builtins.bool]:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyUpdatePreferredEndTime":
            suggest = "apply_update_preferred_end_time"
        elif key == "applyUpdatePreferredStartTime":
            suggest = "apply_update_preferred_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[_builtins.str] = None,
                 apply_update_preferred_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[_builtins.str]:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[_builtins.str]:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freezePeriodEndTime":
            suggest = "freeze_period_end_time"
        elif key == "freezePeriodStartTime":
            suggest = "freeze_period_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 freeze_period_end_time: Optional[_builtins.str] = None,
                 freeze_period_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str freeze_period_end_time: End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[_builtins.str]:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[_builtins.str]:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class VmClusterRemoveVirtualMachineDataCollectionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineDataCollectionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineDataCollectionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineDataCollectionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[_builtins.bool] = None,
                 is_health_monitoring_enabled: Optional[_builtins.bool] = None,
                 is_incident_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class VmClusterRemoveVirtualMachineDbServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbServerId":
            suggest = "db_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineDbServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineDbServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineDbServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_server_id: _builtins.str):
        """
        :param _builtins.str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")


@pulumi.output_type
class VmClusterRemoveVirtualMachineFileSystemConfigurationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemSizeGb":
            suggest = "file_system_size_gb"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineFileSystemConfigurationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineFileSystemConfigurationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineFileSystemConfigurationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_size_gb: Optional[_builtins.int] = None,
                 mount_point: Optional[_builtins.str] = None):
        """
        :param _builtins.int file_system_size_gb: The file system size to be allocated in GBs.
        :param _builtins.str mount_point: The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[_builtins.int]:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetApplicationVipsApplicationVipResult(dict):
    def __init__(__self__, *,
                 cloud_vm_cluster_id: _builtins.str,
                 compartment_id: _builtins.str,
                 db_node_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 hostname_label: _builtins.str,
                 id: _builtins.str,
                 ip_address: _builtins.str,
                 ipv6address: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 time_assigned: _builtins.str):
        """
        :param _builtins.str cloud_vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster associated with the application virtual IP (VIP) address.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str hostname_label: The hostname of the application virtual IP (VIP) address.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the application virtual IP (VIP) address.
        :param _builtins.str ip_address: The application virtual IP (VIP) IPv4 address.
        :param _builtins.str ipv6address: The application virtual IP (VIP) IPv6 address.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state of the application virtual IP (VIP) address.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the application virtual IP (VIP) address.
        :param _builtins.str time_assigned: The date and time when the create operation for the application virtual IP (VIP) address completed.
        """
        pulumi.set(__self__, "cloud_vm_cluster_id", cloud_vm_cluster_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "db_node_id", db_node_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname_label", hostname_label)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv6address", ipv6address)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_assigned", time_assigned)

    @_builtins.property
    @pulumi.getter(name="cloudVmClusterId")
    def cloud_vm_cluster_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster associated with the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "cloud_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> _builtins.str:
        return pulumi.get(self, "db_node_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> _builtins.str:
        """
        The hostname of the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "hostname_label")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        The application virtual IP (VIP) IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv6address(self) -> _builtins.str:
        """
        The application virtual IP (VIP) IPv6 address.
        """
        return pulumi.get(self, "ipv6address")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state of the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="timeAssigned")
    def time_assigned(self) -> _builtins.str:
        """
        The date and time when the create operation for the application virtual IP (VIP) address completed.
        """
        return pulumi.get(self, "time_assigned")


@pulumi.output_type
class GetApplicationVipsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousCharacterSetsAutonomousDatabaseCharacterSetResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: A valid Oracle character set.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A valid Oracle character set.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousCharacterSetsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A valid Oracle character set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A valid Oracle character set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabaseAssociatedBackupConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 backup_destination_attach_histories: Sequence[_builtins.str],
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 recovery_window_in_days: _builtins.int,
                 space_utilized_in_gbs: _builtins.int,
                 time_at_which_storage_details_are_updated: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param Sequence[_builtins.str] backup_destination_attach_histories: The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        :param _builtins.int space_utilized_in_gbs: The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        :param _builtins.str time_at_which_storage_details_are_updated: The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "backup_destination_attach_histories", backup_destination_attach_histories)
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "space_utilized_in_gbs", space_utilized_in_gbs)
        pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="backupDestinationAttachHistories")
    def backup_destination_attach_histories(self) -> Sequence[_builtins.str]:
        """
        The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        """
        return pulumi.get(self, "backup_destination_attach_histories")

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="spaceUtilizedInGbs")
    def space_utilized_in_gbs(self) -> _builtins.int:
        """
        The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        """
        return pulumi.get(self, "space_utilized_in_gbs")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> _builtins.str:
        """
        The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int):
        """
        :param Sequence['GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupDestinationPropertiesListResult(dict):
    def __init__(__self__, *,
                 backup_destination_attach_histories: Sequence[_builtins.str],
                 space_utilized_in_gbs: _builtins.int,
                 time_at_which_storage_details_are_updated: _builtins.str):
        """
        :param Sequence[_builtins.str] backup_destination_attach_histories: The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        :param _builtins.int space_utilized_in_gbs: The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        :param _builtins.str time_at_which_storage_details_are_updated: The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        pulumi.set(__self__, "backup_destination_attach_histories", backup_destination_attach_histories)
        pulumi.set(__self__, "space_utilized_in_gbs", space_utilized_in_gbs)
        pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)

    @_builtins.property
    @pulumi.getter(name="backupDestinationAttachHistories")
    def backup_destination_attach_histories(self) -> Sequence[_builtins.str]:
        """
        The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        """
        return pulumi.get(self, "backup_destination_attach_histories")

    @_builtins.property
    @pulumi.getter(name="spaceUtilizedInGbs")
    def space_utilized_in_gbs(self) -> _builtins.int:
        """
        The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        """
        return pulumi.get(self, "space_utilized_in_gbs")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> _builtins.str:
        """
        The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemResult']):
        """
        :param Sequence['GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemArgs'] items: List of Autonomous container database backups.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemResult']:
        """
        List of Autonomous container database backups.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemResult(dict):
    def __init__(__self__, *,
                 acd_display_name: _builtins.str,
                 autonomous_container_database_id: _builtins.str,
                 autonomous_databases: Sequence['outputs.GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemAutonomousDatabaseResult'],
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 infrastructure_type: _builtins.str,
                 is_automatic: _builtins.bool,
                 is_remote_backup: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 retention_period_in_days: _builtins.int,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_ended: _builtins.str,
                 time_started: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str acd_display_name: The user-friendly name for the Autonomous Container Database when the Backup was initiated. This name need not be unique. This field captures the name at the time of backup creation, accounting for possible later updates to the display name.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemAutonomousDatabaseArgs'] autonomous_databases: List of Autonomous Databases that is part of this Autonomous Container Database Backup
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param _builtins.str infrastructure_type: A filter to return only resources that match the given Infrastructure Type.
        :param _builtins.bool is_automatic: Indicates whether the backup is user-initiated or automatic.
        :param _builtins.bool is_remote_backup: Whether backup is for remote-region or local region
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_ended: The date and time the backup completed.
        :param _builtins.str time_started: The date and time the backup started.
        :param _builtins.str type: The type of backup.
        """
        pulumi.set(__self__, "acd_display_name", acd_display_name)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "autonomous_databases", autonomous_databases)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        pulumi.set(__self__, "is_automatic", is_automatic)
        pulumi.set(__self__, "is_remote_backup", is_remote_backup)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="acdDisplayName")
    def acd_display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Container Database when the Backup was initiated. This name need not be unique. This field captures the name at the time of backup creation, accounting for possible later updates to the display name.
        """
        return pulumi.get(self, "acd_display_name")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabases")
    def autonomous_databases(self) -> Sequence['outputs.GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemAutonomousDatabaseResult']:
        """
        List of Autonomous Databases that is part of this Autonomous Container Database Backup
        """
        return pulumi.get(self, "autonomous_databases")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given Infrastructure Type.
        """
        return pulumi.get(self, "infrastructure_type")

    @_builtins.property
    @pulumi.getter(name="isAutomatic")
    def is_automatic(self) -> _builtins.bool:
        """
        Indicates whether the backup is user-initiated or automatic.
        """
        return pulumi.get(self, "is_automatic")

    @_builtins.property
    @pulumi.getter(name="isRemoteBackup")
    def is_remote_backup(self) -> _builtins.bool:
        """
        Whether backup is for remote-region or local region
        """
        return pulumi.get(self, "is_remote_backup")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the backup completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the backup started.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupsAutonomousContainerDatabaseBackupCollectionItemAutonomousDatabaseResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 display_name: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 automatic_failover_target: _builtins.str,
                 autonomous_container_database_id: _builtins.str,
                 availability_domain: _builtins.str,
                 fast_start_fail_over_lag_limit_in_seconds: _builtins.int,
                 is_automatic_failover_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 protection_mode: _builtins.str,
                 redo_transport_mode: _builtins.str,
                 role: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_lag_refreshed_on: _builtins.str,
                 time_last_role_changed: _builtins.str,
                 time_last_synced: _builtins.str,
                 transport_lag: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str availability_domain: The domain of the Autonomous Container Database
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of the Autonomous Container Database.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        pulumi.set(__self__, "time_last_synced", time_last_synced)
        pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> _builtins.str:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The domain of the Autonomous Container Database
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> _builtins.int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> _builtins.str:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> _builtins.str:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> _builtins.str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> _builtins.str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int):
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 autonomous_container_database_dataguard_association_id: _builtins.str,
                 autonomous_container_database_id: _builtins.str,
                 fast_start_fail_over_lag_limit_in_seconds: _builtins.int,
                 id: _builtins.str,
                 is_automatic_failover_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 migrate_trigger: _builtins.int,
                 peer_autonomous_container_database_backup_configs: Sequence['outputs.GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigResult'],
                 peer_autonomous_container_database_compartment_id: _builtins.str,
                 peer_autonomous_container_database_dataguard_association_id: _builtins.str,
                 peer_autonomous_container_database_display_name: _builtins.str,
                 peer_autonomous_container_database_id: _builtins.str,
                 peer_autonomous_vm_cluster_id: _builtins.str,
                 peer_cloud_autonomous_vm_cluster_id: _builtins.str,
                 peer_db_unique_name: _builtins.str,
                 peer_lifecycle_state: _builtins.str,
                 peer_role: _builtins.str,
                 protection_mode: _builtins.str,
                 role: _builtins.str,
                 standby_maintenance_buffer_in_days: _builtins.int,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_last_role_changed: _builtins.str,
                 time_last_synced: _builtins.str,
                 transport_lag: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database.  Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases.  Example: `180 Mb per second`
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.str id: The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : is_automatic_failover_enabled = true.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycleState, if available.
        :param _builtins.str peer_autonomous_container_database_dataguard_association_id: The OCID of the peer Autonomous Container Database-Autonomous Data Guard association.
        :param _builtins.str peer_autonomous_container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Container Database.
        :param _builtins.str peer_lifecycle_state: The current state of the Autonomous Container Database.
        :param _builtins.str peer_role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of Autonomous Data Guard.
        :param _builtins.str time_created: The date and time the Autonomous DataGuard association was created.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "autonomous_container_database_dataguard_association_id", autonomous_container_database_dataguard_association_id)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "migrate_trigger", migrate_trigger)
        pulumi.set(__self__, "peer_autonomous_container_database_backup_configs", peer_autonomous_container_database_backup_configs)
        pulumi.set(__self__, "peer_autonomous_container_database_compartment_id", peer_autonomous_container_database_compartment_id)
        pulumi.set(__self__, "peer_autonomous_container_database_dataguard_association_id", peer_autonomous_container_database_dataguard_association_id)
        pulumi.set(__self__, "peer_autonomous_container_database_display_name", peer_autonomous_container_database_display_name)
        pulumi.set(__self__, "peer_autonomous_container_database_id", peer_autonomous_container_database_id)
        pulumi.set(__self__, "peer_autonomous_vm_cluster_id", peer_autonomous_vm_cluster_id)
        pulumi.set(__self__, "peer_cloud_autonomous_vm_cluster_id", peer_cloud_autonomous_vm_cluster_id)
        pulumi.set(__self__, "peer_db_unique_name", peer_db_unique_name)
        pulumi.set(__self__, "peer_lifecycle_state", peer_lifecycle_state)
        pulumi.set(__self__, "peer_role", peer_role)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "standby_maintenance_buffer_in_days", standby_maintenance_buffer_in_days)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        pulumi.set(__self__, "time_last_synced", time_last_synced)
        pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database.  Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases.  Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseDataguardAssociationId")
    def autonomous_container_database_dataguard_association_id(self) -> _builtins.str:
        return pulumi.get(self, "autonomous_container_database_dataguard_association_id")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> _builtins.int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : is_automatic_failover_enabled = true.
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycleState, if available.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="migrateTrigger")
    def migrate_trigger(self) -> _builtins.int:
        return pulumi.get(self, "migrate_trigger")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseBackupConfigs")
    def peer_autonomous_container_database_backup_configs(self) -> Sequence['outputs.GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigResult']:
        return pulumi.get(self, "peer_autonomous_container_database_backup_configs")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseCompartmentId")
    def peer_autonomous_container_database_compartment_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_container_database_compartment_id")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseDataguardAssociationId")
    def peer_autonomous_container_database_dataguard_association_id(self) -> _builtins.str:
        """
        The OCID of the peer Autonomous Container Database-Autonomous Data Guard association.
        """
        return pulumi.get(self, "peer_autonomous_container_database_dataguard_association_id")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseDisplayName")
    def peer_autonomous_container_database_display_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_container_database_display_name")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseId")
    def peer_autonomous_container_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Container Database.
        """
        return pulumi.get(self, "peer_autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousVmClusterId")
    def peer_autonomous_vm_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="peerCloudAutonomousVmClusterId")
    def peer_cloud_autonomous_vm_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_cloud_autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="peerDbUniqueName")
    def peer_db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_db_unique_name")

    @_builtins.property
    @pulumi.getter(name="peerLifecycleState")
    def peer_lifecycle_state(self) -> _builtins.str:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "peer_lifecycle_state")

    @_builtins.property
    @pulumi.getter(name="peerRole")
    def peer_role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "peer_role")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="standbyMaintenanceBufferInDays")
    def standby_maintenance_buffer_in_days(self) -> _builtins.int:
        return pulumi.get(self, "standby_maintenance_buffer_in_days")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of Autonomous Data Guard.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous DataGuard association was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> _builtins.str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> _builtins.str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int):
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardGroupMemberResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 automatic_failover_target: _builtins.str,
                 autonomous_container_database_id: _builtins.str,
                 availability_domain: _builtins.str,
                 fast_start_fail_over_lag_limit_in_seconds: _builtins.int,
                 is_automatic_failover_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 protection_mode: _builtins.str,
                 redo_transport_mode: _builtins.str,
                 role: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_lag_refreshed_on: _builtins.str,
                 time_last_role_changed: _builtins.str,
                 time_last_synced: _builtins.str,
                 transport_lag: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str availability_domain: The domain of the Autonomous Container Database
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of the Autonomous Container Database.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        pulumi.set(__self__, "time_last_synced", time_last_synced)
        pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> _builtins.str:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The domain of the Autonomous Container Database
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> _builtins.int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> _builtins.str:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Autonomous Container Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> _builtins.str:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> _builtins.str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> _builtins.str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousContainerDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 time_activated: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int):
        """
        :param Sequence['GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseRecoveryApplianceDetailResult(dict):
    def __init__(__self__, *,
                 allocated_storage_size_in_gbs: _builtins.int,
                 recovery_window_in_days: _builtins.int,
                 time_recovery_appliance_details_updated: _builtins.str):
        """
        :param _builtins.int allocated_storage_size_in_gbs: The storage size of the backup destination allocated for an Autonomous Container Database to store backups on the recovery appliance, in GBs, rounded to the nearest integer.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        :param _builtins.str time_recovery_appliance_details_updated: The time when the recovery appliance details are updated.
        """
        pulumi.set(__self__, "allocated_storage_size_in_gbs", allocated_storage_size_in_gbs)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "time_recovery_appliance_details_updated", time_recovery_appliance_details_updated)

    @_builtins.property
    @pulumi.getter(name="allocatedStorageSizeInGbs")
    def allocated_storage_size_in_gbs(self) -> _builtins.int:
        """
        The storage size of the backup destination allocated for an Autonomous Container Database to store backups on the recovery appliance, in GBs, rounded to the nearest integer.
        """
        return pulumi.get(self, "allocated_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="timeRecoveryApplianceDetailsUpdated")
    def time_recovery_appliance_details_updated(self) -> _builtins.str:
        """
        The time when the recovery appliance details are updated.
        """
        return pulumi.get(self, "time_recovery_appliance_details_updated")


@pulumi.output_type
class GetAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param _builtins.str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param _builtins.float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param _builtins.float reclaimable_cpus: Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        :param _builtins.float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param _builtins.float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionResult(dict):
    def __init__(__self__, *,
                 details: _builtins.str,
                 supported_apps: Sequence['outputs.GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult'],
                 version: _builtins.str):
        """
        :param _builtins.str details: A URL that points to a detailed description of the Autonomous Container Database version.
        :param Sequence['GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppArgs'] supported_apps: The list of applications supported for the given version.
        :param _builtins.str version: A valid Oracle Database version for provisioning an Autonomous Container Database.
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "supported_apps", supported_apps)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def details(self) -> _builtins.str:
        """
        A URL that points to a detailed description of the Autonomous Container Database version.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="supportedApps")
    def supported_apps(self) -> Sequence['outputs.GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult']:
        """
        The list of applications supported for the given version.
        """
        return pulumi.get(self, "supported_apps")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A valid Oracle Database version for provisioning an Autonomous Container Database.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult(dict):
    def __init__(__self__, *,
                 end_of_support: _builtins.str,
                 is_certified: _builtins.bool,
                 release_date: _builtins.str,
                 supported_app_name: _builtins.str):
        """
        :param _builtins.str end_of_support: The Autonomous Container Database version end of support date.
        :param _builtins.bool is_certified: Indicates if the image is certified.
        :param _builtins.str release_date: The Autonomous Container Database version release date.
        :param _builtins.str supported_app_name: The name of the supported application.
        """
        pulumi.set(__self__, "end_of_support", end_of_support)
        pulumi.set(__self__, "is_certified", is_certified)
        pulumi.set(__self__, "release_date", release_date)
        pulumi.set(__self__, "supported_app_name", supported_app_name)

    @_builtins.property
    @pulumi.getter(name="endOfSupport")
    def end_of_support(self) -> _builtins.str:
        """
        The Autonomous Container Database version end of support date.
        """
        return pulumi.get(self, "end_of_support")

    @_builtins.property
    @pulumi.getter(name="isCertified")
    def is_certified(self) -> _builtins.bool:
        """
        Indicates if the image is certified.
        """
        return pulumi.get(self, "is_certified")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        The Autonomous Container Database version release date.
        """
        return pulumi.get(self, "release_date")

    @_builtins.property
    @pulumi.getter(name="supportedAppName")
    def supported_app_name(self) -> _builtins.str:
        """
        The name of the supported application.
        """
        return pulumi.get(self, "supported_app_name")


@pulumi.output_type
class GetAutonomousContainerDatabaseVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseResult(dict):
    def __init__(__self__, *,
                 associated_backup_configuration_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseAssociatedBackupConfigurationDetailResult'],
                 autonomous_container_database_backup_id: _builtins.str,
                 autonomous_exadata_infrastructure_id: _builtins.str,
                 autonomous_vm_cluster_id: _builtins.str,
                 availability_domain: _builtins.str,
                 available_cpus: _builtins.float,
                 backup_configs: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult'],
                 backup_destination_properties_lists: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupDestinationPropertiesListResult'],
                 cloud_autonomous_vm_cluster_id: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_model: _builtins.str,
                 customer_contacts: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseCustomerContactResult'],
                 database_software_image_id: _builtins.str,
                 dataguard_group_members: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardGroupMemberResult'],
                 dataguards: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardResult'],
                 db_name: _builtins.str,
                 db_split_threshold: _builtins.int,
                 db_unique_name: _builtins.str,
                 db_version: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 distribution_affinity: _builtins.str,
                 dst_file_version: _builtins.str,
                 failover_trigger: _builtins.int,
                 fast_start_fail_over_lag_limit_in_seconds: _builtins.int,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 infrastructure_type: _builtins.str,
                 is_automatic_failover_enabled: _builtins.bool,
                 is_data_guard_enabled: _builtins.bool,
                 is_dst_file_update_enabled: _builtins.bool,
                 is_multiple_standby: _builtins.bool,
                 key_history_entries: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult'],
                 key_store_id: _builtins.str,
                 key_store_wallet_name: _builtins.str,
                 key_version_id: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 largest_provisionable_autonomous_database_in_cpus: _builtins.float,
                 last_maintenance_run_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 list_one_off_patches: Sequence[_builtins.str],
                 maintenance_window_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult'],
                 memory_per_oracle_compute_unit_in_gbs: _builtins.int,
                 net_services_architecture: _builtins.str,
                 next_maintenance_run_id: _builtins.str,
                 okv_end_point_group_name: _builtins.str,
                 patch_id: _builtins.str,
                 patch_model: _builtins.str,
                 peer_autonomous_container_database_backup_configs: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult'],
                 peer_autonomous_container_database_compartment_id: _builtins.str,
                 peer_autonomous_container_database_display_name: _builtins.str,
                 peer_autonomous_exadata_infrastructure_id: _builtins.str,
                 peer_autonomous_vm_cluster_id: _builtins.str,
                 peer_cloud_autonomous_vm_cluster_id: _builtins.str,
                 peer_db_unique_name: _builtins.str,
                 protection_mode: _builtins.str,
                 provisionable_cpuses: Sequence[_builtins.float],
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 recovery_appliance_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseRecoveryApplianceDetailResult'],
                 reinstate_trigger: _builtins.int,
                 reserved_cpus: _builtins.float,
                 role: _builtins.str,
                 rotate_key_trigger: _builtins.bool,
                 service_level_agreement_type: _builtins.str,
                 source: _builtins.str,
                 standby_maintenance_buffer_in_days: _builtins.int,
                 state: _builtins.str,
                 switchover_trigger: _builtins.int,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_of_last_backup: _builtins.str,
                 time_snapshot_standby_revert: _builtins.str,
                 total_cpus: _builtins.int,
                 vault_id: _builtins.str,
                 version_preference: _builtins.str,
                 vm_failover_reservation: _builtins.int):
        """
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseAssociatedBackupConfigurationDetailArgs'] associated_backup_configuration_details: A backup config object holds information about preferred backup destinations only. This object holds information about the associated backup destinations, such as secondary backup destinations created for local backups or remote replicated backups.
        :param _builtins.str autonomous_exadata_infrastructure_id: The Autonomous Exadata Infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str autonomous_vm_cluster_id: The Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param _builtins.float available_cpus: Sum of CPUs available on the Autonomous VM Cluster + Sum of reclaimable CPUs available in the Autonomous Container Database.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigArgs'] backup_configs: Backup options for the Autonomous Container Database.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupDestinationPropertiesListArgs'] backup_destination_properties_lists: This list describes the backup destination properties associated with the Autonomous Container Database (ACD) 's preferred backup destination. The object at a given index is associated with the destination present at the same index in the backup destination details list of the ACD Backup Configuration.
        :param _builtins.str cloud_autonomous_vm_cluster_id: The cloud Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compute_model: The compute model of the Autonomous Container Database. For Autonomous Database on Dedicated Exadata Infrastructure, the CPU type (ECPUs or OCPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model. ECPU compute model is the recommended model and OCPU compute model is legacy. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseCustomerContactArgs'] customer_contacts: Customer Contacts. Setting this to an empty list removes all customer contacts.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardGroupMemberArgs'] dataguard_group_members: Array of Dg associations.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardArgs'] dataguards: The properties that define Autonomous Container Databases Dataguard.
        :param _builtins.str db_name: The Database name for the Autonomous Container Database. The name must be unique within the Cloud Autonomous VM Cluster, starting with an alphabetic character, followed by 1 to 7 alphanumeric characters.
        :param _builtins.int db_split_threshold: The CPU value beyond which an Autonomous Database will be opened across multiple nodes. The default value of this attribute is 16 for OCPUs and 64 for ECPUs.
        :param _builtins.str db_version: Oracle Database version of the Autonomous Container Database.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str distribution_affinity: Determines whether an Autonomous Database must be opened across the maximum number of nodes or the least number of nodes. By default, Minimum nodes is selected.
        :param _builtins.str dst_file_version: DST Time-zone File version of the Autonomous Container Database.
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str infrastructure_type: A filter to return only resources that match the given Infrastructure Type.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.bool is_data_guard_enabled: **Deprecated.** Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param _builtins.bool is_dst_file_update_enabled: Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        :param _builtins.bool is_multiple_standby: Indicates if it is multiple standby Autonomous Dataguard
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryArgs'] key_history_entries: Key History Entry.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.float largest_provisionable_autonomous_database_in_cpus: The largest Autonomous Database (CPU) that can be created in a new Autonomous Container Database.
        :param _builtins.str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[_builtins.str] list_one_off_patches: List of One-Off patches that has been successfully applied to Autonomous Container Database
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per ECPU or OCPU in the Autonomous VM Cluster.
        :param _builtins.str net_services_architecture: Enabling SHARED server architecture enables a database server to allow many client processes to share very few server processes, thereby increasing the number of supported users.
        :param _builtins.str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param _builtins.str okv_end_point_group_name: The OKV End Point Group name for the Autonomous Container Database.
        :param _builtins.str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch applied on the system.
        :param _builtins.str patch_model: Database patch model preference.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param Sequence[_builtins.float] provisionable_cpuses: An array of CPU values that can be used to successfully provision a single Autonomous Database.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous Container Database.
        :param _builtins.float reclaimable_cpus: CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseRecoveryApplianceDetailArgs'] recovery_appliance_details: Information about the recovery appliance configuration associated with the Autonomous Container Database.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous Container Database.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str service_level_agreement_type: A filter to return only resources that match the given service level agreement type exactly.
        :param _builtins.int standby_maintenance_buffer_in_days: The scheduling detail for the quarterly maintenance window of the standby Autonomous Container Database. This value represents the number of days before scheduled maintenance of the primary database.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_of_last_backup: The timestamp of last successful backup. Here NULL value represents either there are no successful backups or backups are not configured for this Autonomous Container Database.
        :param _builtins.str time_snapshot_standby_revert: The date and time the Autonomous Container Database will be reverted to Standby from Snapshot Standby.
        :param _builtins.int total_cpus: The number of CPUs allocated to the Autonomous VM cluster.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str version_preference: The next maintenance version preference.
        :param _builtins.int vm_failover_reservation: The percentage of CPUs reserved across nodes to support node failover. Allowed values are 0%, 25%, and 50%, with 50% being the default option.
        """
        pulumi.set(__self__, "associated_backup_configuration_details", associated_backup_configuration_details)
        pulumi.set(__self__, "autonomous_container_database_backup_id", autonomous_container_database_backup_id)
        pulumi.set(__self__, "autonomous_exadata_infrastructure_id", autonomous_exadata_infrastructure_id)
        pulumi.set(__self__, "autonomous_vm_cluster_id", autonomous_vm_cluster_id)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "backup_configs", backup_configs)
        pulumi.set(__self__, "backup_destination_properties_lists", backup_destination_properties_lists)
        pulumi.set(__self__, "cloud_autonomous_vm_cluster_id", cloud_autonomous_vm_cluster_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "customer_contacts", customer_contacts)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "dataguard_group_members", dataguard_group_members)
        pulumi.set(__self__, "dataguards", dataguards)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_split_threshold", db_split_threshold)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "distribution_affinity", distribution_affinity)
        pulumi.set(__self__, "dst_file_version", dst_file_version)
        pulumi.set(__self__, "failover_trigger", failover_trigger)
        pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "is_data_guard_enabled", is_data_guard_enabled)
        pulumi.set(__self__, "is_dst_file_update_enabled", is_dst_file_update_enabled)
        pulumi.set(__self__, "is_multiple_standby", is_multiple_standby)
        pulumi.set(__self__, "key_history_entries", key_history_entries)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "key_store_wallet_name", key_store_wallet_name)
        pulumi.set(__self__, "key_version_id", key_version_id)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "largest_provisionable_autonomous_database_in_cpus", largest_provisionable_autonomous_database_in_cpus)
        pulumi.set(__self__, "last_maintenance_run_id", last_maintenance_run_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "list_one_off_patches", list_one_off_patches)
        pulumi.set(__self__, "maintenance_window_details", maintenance_window_details)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        pulumi.set(__self__, "net_services_architecture", net_services_architecture)
        pulumi.set(__self__, "next_maintenance_run_id", next_maintenance_run_id)
        pulumi.set(__self__, "okv_end_point_group_name", okv_end_point_group_name)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "patch_model", patch_model)
        pulumi.set(__self__, "peer_autonomous_container_database_backup_configs", peer_autonomous_container_database_backup_configs)
        pulumi.set(__self__, "peer_autonomous_container_database_compartment_id", peer_autonomous_container_database_compartment_id)
        pulumi.set(__self__, "peer_autonomous_container_database_display_name", peer_autonomous_container_database_display_name)
        pulumi.set(__self__, "peer_autonomous_exadata_infrastructure_id", peer_autonomous_exadata_infrastructure_id)
        pulumi.set(__self__, "peer_autonomous_vm_cluster_id", peer_autonomous_vm_cluster_id)
        pulumi.set(__self__, "peer_cloud_autonomous_vm_cluster_id", peer_cloud_autonomous_vm_cluster_id)
        pulumi.set(__self__, "peer_db_unique_name", peer_db_unique_name)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "provisionable_cpuses", provisionable_cpuses)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "recovery_appliance_details", recovery_appliance_details)
        pulumi.set(__self__, "reinstate_trigger", reinstate_trigger)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "rotate_key_trigger", rotate_key_trigger)
        pulumi.set(__self__, "service_level_agreement_type", service_level_agreement_type)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "standby_maintenance_buffer_in_days", standby_maintenance_buffer_in_days)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "switchover_trigger", switchover_trigger)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_of_last_backup", time_of_last_backup)
        pulumi.set(__self__, "time_snapshot_standby_revert", time_snapshot_standby_revert)
        pulumi.set(__self__, "total_cpus", total_cpus)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "version_preference", version_preference)
        pulumi.set(__self__, "vm_failover_reservation", vm_failover_reservation)

    @_builtins.property
    @pulumi.getter(name="associatedBackupConfigurationDetails")
    def associated_backup_configuration_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseAssociatedBackupConfigurationDetailResult']:
        """
        A backup config object holds information about preferred backup destinations only. This object holds information about the associated backup destinations, such as secondary backup destinations created for local backups or remote replicated backups.
        """
        return pulumi.get(self, "associated_backup_configuration_details")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseBackupId")
    def autonomous_container_database_backup_id(self) -> _builtins.str:
        return pulumi.get(self, "autonomous_container_database_backup_id")

    @_builtins.property
    @pulumi.getter(name="autonomousExadataInfrastructureId")
    def autonomous_exadata_infrastructure_id(self) -> _builtins.str:
        """
        The Autonomous Exadata Infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="autonomousVmClusterId")
    def autonomous_vm_cluster_id(self) -> _builtins.str:
        """
        The Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        Sum of CPUs available on the Autonomous VM Cluster + Sum of reclaimable CPUs available in the Autonomous Container Database.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="backupConfigs")
    def backup_configs(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult']:
        """
        Backup options for the Autonomous Container Database.
        """
        return pulumi.get(self, "backup_configs")

    @_builtins.property
    @pulumi.getter(name="backupDestinationPropertiesLists")
    def backup_destination_properties_lists(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupDestinationPropertiesListResult']:
        """
        This list describes the backup destination properties associated with the Autonomous Container Database (ACD) 's preferred backup destination. The object at a given index is associated with the destination present at the same index in the backup destination details list of the ACD Backup Configuration.
        """
        return pulumi.get(self, "backup_destination_properties_lists")

    @_builtins.property
    @pulumi.getter(name="cloudAutonomousVmClusterId")
    def cloud_autonomous_vm_cluster_id(self) -> _builtins.str:
        """
        The cloud Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "cloud_autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Container Database. For Autonomous Database on Dedicated Exadata Infrastructure, the CPU type (ECPUs or OCPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model. ECPU compute model is the recommended model and OCPU compute model is legacy. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseCustomerContactResult']:
        """
        Customer Contacts. Setting this to an empty list removes all customer contacts.
        """
        return pulumi.get(self, "customer_contacts")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dataguardGroupMembers")
    def dataguard_group_members(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardGroupMemberResult']:
        """
        Array of Dg associations.
        """
        return pulumi.get(self, "dataguard_group_members")

    @_builtins.property
    @pulumi.getter
    def dataguards(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardResult']:
        """
        The properties that define Autonomous Container Databases Dataguard.
        """
        return pulumi.get(self, "dataguards")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The Database name for the Autonomous Container Database. The name must be unique within the Cloud Autonomous VM Cluster, starting with an alphabetic character, followed by 1 to 7 alphanumeric characters.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbSplitThreshold")
    def db_split_threshold(self) -> _builtins.int:
        """
        The CPU value beyond which an Autonomous Database will be opened across multiple nodes. The default value of this attribute is 16 for OCPUs and 64 for ECPUs.
        """
        return pulumi.get(self, "db_split_threshold")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        Oracle Database version of the Autonomous Container Database.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="distributionAffinity")
    def distribution_affinity(self) -> _builtins.str:
        """
        Determines whether an Autonomous Database must be opened across the maximum number of nodes or the least number of nodes. By default, Minimum nodes is selected.
        """
        return pulumi.get(self, "distribution_affinity")

    @_builtins.property
    @pulumi.getter(name="dstFileVersion")
    def dst_file_version(self) -> _builtins.str:
        """
        DST Time-zone File version of the Autonomous Container Database.
        """
        return pulumi.get(self, "dst_file_version")

    @_builtins.property
    @pulumi.getter(name="failoverTrigger")
    def failover_trigger(self) -> _builtins.int:
        return pulumi.get(self, "failover_trigger")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> _builtins.int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given Infrastructure Type.
        """
        return pulumi.get(self, "infrastructure_type")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="isDataGuardEnabled")
    def is_data_guard_enabled(self) -> _builtins.bool:
        """
        **Deprecated.** Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="isDstFileUpdateEnabled")
    def is_dst_file_update_enabled(self) -> _builtins.bool:
        """
        Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        """
        return pulumi.get(self, "is_dst_file_update_enabled")

    @_builtins.property
    @pulumi.getter(name="isMultipleStandby")
    def is_multiple_standby(self) -> _builtins.bool:
        """
        Indicates if it is multiple standby Autonomous Dataguard
        """
        return pulumi.get(self, "is_multiple_standby")

    @_builtins.property
    @pulumi.getter(name="keyHistoryEntries")
    def key_history_entries(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "key_history_entries")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> _builtins.str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @_builtins.property
    @pulumi.getter(name="keyVersionId")
    def key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "key_version_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="largestProvisionableAutonomousDatabaseInCpus")
    def largest_provisionable_autonomous_database_in_cpus(self) -> _builtins.float:
        """
        The largest Autonomous Database (CPU) that can be created in a new Autonomous Container Database.
        """
        return pulumi.get(self, "largest_provisionable_autonomous_database_in_cpus")

    @_builtins.property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="listOneOffPatches")
    def list_one_off_patches(self) -> Sequence[_builtins.str]:
        """
        List of One-Off patches that has been successfully applied to Autonomous Container Database
        """
        return pulumi.get(self, "list_one_off_patches")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> _builtins.int:
        """
        The amount of memory (in GBs) enabled per ECPU or OCPU in the Autonomous VM Cluster.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @_builtins.property
    @pulumi.getter(name="netServicesArchitecture")
    def net_services_architecture(self) -> _builtins.str:
        """
        Enabling SHARED server architecture enables a database server to allow many client processes to share very few server processes, thereby increasing the number of supported users.
        """
        return pulumi.get(self, "net_services_architecture")

    @_builtins.property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="okvEndPointGroupName")
    def okv_end_point_group_name(self) -> _builtins.str:
        """
        The OKV End Point Group name for the Autonomous Container Database.
        """
        return pulumi.get(self, "okv_end_point_group_name")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch applied on the system.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter(name="patchModel")
    def patch_model(self) -> _builtins.str:
        """
        Database patch model preference.
        """
        return pulumi.get(self, "patch_model")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseBackupConfigs")
    def peer_autonomous_container_database_backup_configs(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult']:
        return pulumi.get(self, "peer_autonomous_container_database_backup_configs")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseCompartmentId")
    def peer_autonomous_container_database_compartment_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_container_database_compartment_id")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousContainerDatabaseDisplayName")
    def peer_autonomous_container_database_display_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_container_database_display_name")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousExadataInfrastructureId")
    def peer_autonomous_exadata_infrastructure_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousVmClusterId")
    def peer_autonomous_vm_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="peerCloudAutonomousVmClusterId")
    def peer_cloud_autonomous_vm_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_cloud_autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="peerDbUniqueName")
    def peer_db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_db_unique_name")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[_builtins.float]:
        """
        An array of CPU values that can be used to successfully provision a single Autonomous Database.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="recoveryApplianceDetails")
    def recovery_appliance_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseRecoveryApplianceDetailResult']:
        """
        Information about the recovery appliance configuration associated with the Autonomous Container Database.
        """
        return pulumi.get(self, "recovery_appliance_details")

    @_builtins.property
    @pulumi.getter(name="reinstateTrigger")
    def reinstate_trigger(self) -> _builtins.int:
        return pulumi.get(self, "reinstate_trigger")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous Container Database.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="rotateKeyTrigger")
    def rotate_key_trigger(self) -> _builtins.bool:
        return pulumi.get(self, "rotate_key_trigger")

    @_builtins.property
    @pulumi.getter(name="serviceLevelAgreementType")
    def service_level_agreement_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given service level agreement type exactly.
        """
        return pulumi.get(self, "service_level_agreement_type")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="standbyMaintenanceBufferInDays")
    def standby_maintenance_buffer_in_days(self) -> _builtins.int:
        """
        The scheduling detail for the quarterly maintenance window of the standby Autonomous Container Database. This value represents the number of days before scheduled maintenance of the primary database.
        """
        return pulumi.get(self, "standby_maintenance_buffer_in_days")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="switchoverTrigger")
    def switchover_trigger(self) -> _builtins.int:
        return pulumi.get(self, "switchover_trigger")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeOfLastBackup")
    def time_of_last_backup(self) -> _builtins.str:
        """
        The timestamp of last successful backup. Here NULL value represents either there are no successful backups or backups are not configured for this Autonomous Container Database.
        """
        return pulumi.get(self, "time_of_last_backup")

    @_builtins.property
    @pulumi.getter(name="timeSnapshotStandbyRevert")
    def time_snapshot_standby_revert(self) -> _builtins.str:
        """
        The date and time the Autonomous Container Database will be reverted to Standby from Snapshot Standby.
        """
        return pulumi.get(self, "time_snapshot_standby_revert")

    @_builtins.property
    @pulumi.getter(name="totalCpus")
    def total_cpus(self) -> _builtins.int:
        """
        The number of CPUs allocated to the Autonomous VM cluster.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "total_cpus")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="versionPreference")
    def version_preference(self) -> _builtins.str:
        """
        The next maintenance version preference.
        """
        return pulumi.get(self, "version_preference")

    @_builtins.property
    @pulumi.getter(name="vmFailoverReservation")
    def vm_failover_reservation(self) -> _builtins.int:
        """
        The percentage of CPUs reserved across nodes to support node failover. Allowed values are 0%, 25%, and 50%, with 50% being the default option.
        """
        return pulumi.get(self, "vm_failover_reservation")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseAssociatedBackupConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 backup_destination_attach_histories: Sequence[_builtins.str],
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 recovery_window_in_days: _builtins.int,
                 space_utilized_in_gbs: _builtins.int,
                 time_at_which_storage_details_are_updated: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param Sequence[_builtins.str] backup_destination_attach_histories: The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        :param _builtins.int space_utilized_in_gbs: The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        :param _builtins.str time_at_which_storage_details_are_updated: The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "backup_destination_attach_histories", backup_destination_attach_histories)
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "space_utilized_in_gbs", space_utilized_in_gbs)
        pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="backupDestinationAttachHistories")
    def backup_destination_attach_histories(self) -> Sequence[_builtins.str]:
        """
        The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        """
        return pulumi.get(self, "backup_destination_attach_histories")

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="spaceUtilizedInGbs")
    def space_utilized_in_gbs(self) -> _builtins.int:
        """
        The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        """
        return pulumi.get(self, "space_utilized_in_gbs")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> _builtins.str:
        """
        The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int):
        """
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupDestinationPropertiesListResult(dict):
    def __init__(__self__, *,
                 backup_destination_attach_histories: Sequence[_builtins.str],
                 space_utilized_in_gbs: _builtins.int,
                 time_at_which_storage_details_are_updated: _builtins.str):
        """
        :param Sequence[_builtins.str] backup_destination_attach_histories: The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        :param _builtins.int space_utilized_in_gbs: The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        :param _builtins.str time_at_which_storage_details_are_updated: The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        pulumi.set(__self__, "backup_destination_attach_histories", backup_destination_attach_histories)
        pulumi.set(__self__, "space_utilized_in_gbs", space_utilized_in_gbs)
        pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)

    @_builtins.property
    @pulumi.getter(name="backupDestinationAttachHistories")
    def backup_destination_attach_histories(self) -> Sequence[_builtins.str]:
        """
        The timestamps at which this backup destination is used as the preferred destination to host the Autonomous Container Database backups.
        """
        return pulumi.get(self, "backup_destination_attach_histories")

    @_builtins.property
    @pulumi.getter(name="spaceUtilizedInGbs")
    def space_utilized_in_gbs(self) -> _builtins.int:
        """
        The total space utilized (in GBs) by this Autonomous Container Database on this backup destination, rounded to the nearest integer.
        """
        return pulumi.get(self, "space_utilized_in_gbs")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> _builtins.str:
        """
        The latest timestamp when the backup destination details, such as 'spaceUtilized,' are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 automatic_failover_target: _builtins.str,
                 autonomous_container_database_id: _builtins.str,
                 availability_domain: _builtins.str,
                 fast_start_fail_over_lag_limit_in_seconds: _builtins.int,
                 is_automatic_failover_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 protection_mode: _builtins.str,
                 redo_transport_mode: _builtins.str,
                 role: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_lag_refreshed_on: _builtins.str,
                 time_last_role_changed: _builtins.str,
                 time_last_synced: _builtins.str,
                 transport_lag: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        :param _builtins.str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        pulumi.set(__self__, "time_last_synced", time_last_synced)
        pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> _builtins.str:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> _builtins.int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> _builtins.str:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> _builtins.str:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> _builtins.str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> _builtins.str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseDataguardGroupMemberResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 automatic_failover_target: _builtins.str,
                 autonomous_container_database_id: _builtins.str,
                 availability_domain: _builtins.str,
                 fast_start_fail_over_lag_limit_in_seconds: _builtins.int,
                 is_automatic_failover_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 protection_mode: _builtins.str,
                 redo_transport_mode: _builtins.str,
                 role: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_lag_refreshed_on: _builtins.str,
                 time_last_role_changed: _builtins.str,
                 time_last_synced: _builtins.str,
                 transport_lag: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        :param _builtins.str automatic_failover_target: Automatically selected by backend when observer is enabled.
        :param _builtins.str autonomous_container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        :param _builtins.str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param _builtins.int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str redo_transport_mode: Automatically selected by backend based on the protection mode.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the Autonomous Container Database was created.
        :param _builtins.str time_lag_refreshed_on: Timestamp when the lags were last calculated for a standby.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "automatic_failover_target", automatic_failover_target)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "redo_transport_mode", redo_transport_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_lag_refreshed_on", time_lag_refreshed_on)
        pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        pulumi.set(__self__, "time_last_synced", time_last_synced)
        pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database. Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases. Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="automaticFailoverTarget")
    def automatic_failover_target(self) -> _builtins.str:
        """
        Automatically selected by backend when observer is enabled.
        """
        return pulumi.get(self, "automatic_failover_target")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database that has a relationship with the peer Autonomous Container Database. Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> _builtins.int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="redoTransportMode")
    def redo_transport_mode(self) -> _builtins.str:
        """
        Automatically selected by backend based on the protection mode.
        """
        return pulumi.get(self, "redo_transport_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLagRefreshedOn")
    def time_lag_refreshed_on(self) -> _builtins.str:
        """
        Timestamp when the lags were last calculated for a standby.
        """
        return pulumi.get(self, "time_lag_refreshed_on")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> _builtins.str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> _builtins.str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database. Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 time_activated: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int):
        """
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseRecoveryApplianceDetailResult(dict):
    def __init__(__self__, *,
                 allocated_storage_size_in_gbs: _builtins.int,
                 recovery_window_in_days: _builtins.int,
                 time_recovery_appliance_details_updated: _builtins.str):
        """
        :param _builtins.int allocated_storage_size_in_gbs: The storage size of the backup destination allocated for an Autonomous Container Database to store backups on the recovery appliance, in GBs, rounded to the nearest integer.
        :param _builtins.int recovery_window_in_days: Number of days between the current and earliest point of recoverability covered by automatic backups.
        :param _builtins.str time_recovery_appliance_details_updated: The time when the recovery appliance details are updated.
        """
        pulumi.set(__self__, "allocated_storage_size_in_gbs", allocated_storage_size_in_gbs)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "time_recovery_appliance_details_updated", time_recovery_appliance_details_updated)

    @_builtins.property
    @pulumi.getter(name="allocatedStorageSizeInGbs")
    def allocated_storage_size_in_gbs(self) -> _builtins.int:
        """
        The storage size of the backup destination allocated for an Autonomous Container Database to store backups on the recovery appliance, in GBs, rounded to the nearest integer.
        """
        return pulumi.get(self, "allocated_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and earliest point of recoverability covered by automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="timeRecoveryApplianceDetailsUpdated")
    def time_recovery_appliance_details_updated(self) -> _builtins.str:
        """
        The time when the recovery appliance details are updated.
        """
        return pulumi.get(self, "time_recovery_appliance_details_updated")


@pulumi.output_type
class GetAutonomousContainerDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerPatchesAutonomousPatchResult(dict):
    def __init__(__self__, *,
                 autonomous_patch_type: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 patch_model: _builtins.str,
                 quarter: _builtins.str,
                 state: _builtins.str,
                 time_released: _builtins.str,
                 type: _builtins.str,
                 version: _builtins.str,
                 year: _builtins.str):
        """
        :param _builtins.str autonomous_patch_type: Autonomous patch type, either "QUARTERLY" or "TIMEZONE".
        :param _builtins.str description: The text describing this patch package.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param _builtins.str patch_model: Database patching model preference. See [My Oracle Support note 2285040.1](https://support.oracle.com/rs?type=doc&id=2285040.1) for information on the Release Update (RU) and Release Update Revision (RUR) patching models.
        :param _builtins.str quarter: First month of the quarter in which the patch was released.
        :param _builtins.str state: The current state of the patch as a result of lastAction.
        :param _builtins.str time_released: The date and time that the patch was released.
        :param _builtins.str type: The type of patch. BUNDLE is one example.
        :param _builtins.str version: The version of this patch package.
        :param _builtins.str year: Year in which the patch was released.
        """
        pulumi.set(__self__, "autonomous_patch_type", autonomous_patch_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "patch_model", patch_model)
        pulumi.set(__self__, "quarter", quarter)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter(name="autonomousPatchType")
    def autonomous_patch_type(self) -> _builtins.str:
        """
        Autonomous patch type, either "QUARTERLY" or "TIMEZONE".
        """
        return pulumi.get(self, "autonomous_patch_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="patchModel")
    def patch_model(self) -> _builtins.str:
        """
        Database patching model preference. See [My Oracle Support note 2285040.1](https://support.oracle.com/rs?type=doc&id=2285040.1) for information on the Release Update (RU) and Release Update Revision (RUR) patching models.
        """
        return pulumi.get(self, "patch_model")

    @_builtins.property
    @pulumi.getter
    def quarter(self) -> _builtins.str:
        """
        First month of the quarter in which the patch was released.
        """
        return pulumi.get(self, "quarter")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of patch. BUNDLE is one example.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def year(self) -> _builtins.str:
        """
        Year in which the patch was released.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class GetAutonomousContainerPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseApexDetailResult(dict):
    def __init__(__self__, *,
                 apex_version: _builtins.str,
                 ords_version: _builtins.str):
        """
        :param _builtins.str apex_version: The Oracle APEX Application Development version.
        :param _builtins.str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        pulumi.set(__self__, "apex_version", apex_version)
        pulumi.set(__self__, "ords_version", ords_version)

    @_builtins.property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> _builtins.str:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @_builtins.property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class GetAutonomousDatabaseBackupBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: The type of backup.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 manual_backup_bucket_name: _builtins.str,
                 manual_backup_type: _builtins.str):
        """
        :param _builtins.str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param _builtins.str manual_backup_type: The manual backup destination type.
        """
        pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @_builtins.property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> _builtins.str:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @_builtins.property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> _builtins.str:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class GetAutonomousDatabaseBackupsAutonomousDatabaseBackupResult(dict):
    def __init__(__self__, *,
                 autonomous_database_id: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult'],
                 compartment_id: _builtins.str,
                 database_size_in_tbs: _builtins.float,
                 db_version: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 is_automatic: _builtins.bool,
                 is_long_term_backup: _builtins.bool,
                 is_restorable: _builtins.bool,
                 key_store_id: _builtins.str,
                 key_store_wallet_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 retention_period_in_days: _builtins.int,
                 size_in_tbs: _builtins.float,
                 state: _builtins.str,
                 time_available_till: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str,
                 type: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str autonomous_database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailArgs'] backup_destination_details: Backup destination details
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.float database_size_in_tbs: The size of the database in terabytes at the time the backup was taken.
        :param _builtins.str db_version: A valid Oracle Database version for Autonomous Database.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param _builtins.bool is_automatic: Indicates whether the backup is user-initiated or automatic.
        :param _builtins.bool is_restorable: Indicates whether the backup can be used to restore the associated Autonomous Database.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.float size_in_tbs: The backup size in terrabytes (TB).
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_available_till: Timestamp until when the backup will be available
        :param _builtins.str time_ended: The date and time the backup completed.
        :param _builtins.str time_started: The date and time the backup started.
        :param _builtins.str type: A filter to return only backups that matches with the given type of Backup.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_size_in_tbs", database_size_in_tbs)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_automatic", is_automatic)
        pulumi.set(__self__, "is_long_term_backup", is_long_term_backup)
        pulumi.set(__self__, "is_restorable", is_restorable)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "key_store_wallet_name", key_store_wallet_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "size_in_tbs", size_in_tbs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_available_till", time_available_till)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> _builtins.str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_database_id")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult']:
        """
        Backup destination details
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseSizeInTbs")
    def database_size_in_tbs(self) -> _builtins.float:
        """
        The size of the database in terabytes at the time the backup was taken.
        """
        return pulumi.get(self, "database_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAutomatic")
    def is_automatic(self) -> _builtins.bool:
        """
        Indicates whether the backup is user-initiated or automatic.
        """
        return pulumi.get(self, "is_automatic")

    @_builtins.property
    @pulumi.getter(name="isLongTermBackup")
    def is_long_term_backup(self) -> _builtins.bool:
        return pulumi.get(self, "is_long_term_backup")

    @_builtins.property
    @pulumi.getter(name="isRestorable")
    def is_restorable(self) -> _builtins.bool:
        """
        Indicates whether the backup can be used to restore the associated Autonomous Database.
        """
        return pulumi.get(self, "is_restorable")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> _builtins.str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="sizeInTbs")
    def size_in_tbs(self) -> _builtins.float:
        """
        The backup size in terrabytes (TB).
        """
        return pulumi.get(self, "size_in_tbs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeAvailableTill")
    def time_available_till(self) -> _builtins.str:
        """
        Timestamp until when the backup will be available
        """
        return pulumi.get(self, "time_available_till")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the backup completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the backup started.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        A filter to return only backups that matches with the given type of Backup.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 internet_proxy: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param _builtins.str internet_proxy: Proxy URL to connect to object store.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: A filter to return only backups that matches with the given type of Backup.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internet_proxy", internet_proxy)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> _builtins.str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        A filter to return only backups that matches with the given type of Backup.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousDatabaseBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 dedicated: _builtins.str,
                 high: _builtins.str,
                 low: _builtins.str,
                 medium: _builtins.str,
                 profiles: Sequence['outputs.GetAutonomousDatabaseConnectionStringProfileResult']):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param _builtins.str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param _builtins.str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['GetAutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "dedicated", dedicated)
        pulumi.set(__self__, "high", high)
        pulumi.set(__self__, "low", low)
        pulumi.set(__self__, "medium", medium)
        pulumi.set(__self__, "profiles", profiles)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter
    def dedicated(self) -> _builtins.str:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @_builtins.property
    @pulumi.getter
    def high(self) -> _builtins.str:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @_builtins.property
    @pulumi.getter
    def low(self) -> _builtins.str:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @_builtins.property
    @pulumi.getter
    def medium(self) -> _builtins.str:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @_builtins.property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetAutonomousDatabaseConnectionStringProfileResult']:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class GetAutonomousDatabaseConnectionStringProfileResult(dict):
    def __init__(__self__, *,
                 consumer_group: _builtins.str,
                 display_name: _builtins.str,
                 host_format: _builtins.str,
                 is_regional: _builtins.bool,
                 protocol: _builtins.str,
                 session_mode: _builtins.str,
                 syntax_format: _builtins.str,
                 tls_authentication: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str consumer_group: Consumer group used by the connection.
        :param _builtins.str display_name: The user-friendly name for the Autonomous Database. The name does not have to be unique.
        :param _builtins.str host_format: Host format used in connection string.
        :param _builtins.str protocol: Protocol used by the connection.
        :param _builtins.str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param _builtins.str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        :param _builtins.str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param _builtins.str value: Connection string value.
        """
        pulumi.set(__self__, "consumer_group", consumer_group)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "host_format", host_format)
        pulumi.set(__self__, "is_regional", is_regional)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "session_mode", session_mode)
        pulumi.set(__self__, "syntax_format", syntax_format)
        pulumi.set(__self__, "tls_authentication", tls_authentication)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> _builtins.str:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> _builtins.str:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @_builtins.property
    @pulumi.getter(name="isRegional")
    def is_regional(self) -> _builtins.bool:
        return pulumi.get(self, "is_regional")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> _builtins.str:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @_builtins.property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> _builtins.str:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @_builtins.property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> _builtins.str:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutonomousDatabaseConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: _builtins.str,
                 database_transforms_url: _builtins.str,
                 graph_studio_url: _builtins.str,
                 machine_learning_notebook_url: _builtins.str,
                 machine_learning_user_management_url: _builtins.str,
                 mongo_db_url: _builtins.str,
                 ords_url: _builtins.str,
                 sql_dev_web_url: _builtins.str):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        pulumi.set(__self__, "apex_url", apex_url)
        pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        pulumi.set(__self__, "ords_url", ords_url)
        pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> _builtins.str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> _builtins.str:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> _builtins.str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> _builtins.str:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> _builtins.str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> _builtins.str:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> _builtins.str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousDatabaseDataguardAssociationsAutonomousDatabaseDataguardAssociationResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 autonomous_database_id: _builtins.str,
                 id: _builtins.str,
                 is_automatic_failover_enabled: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 peer_autonomous_database_id: _builtins.str,
                 peer_autonomous_database_life_cycle_state: _builtins.str,
                 peer_role: _builtins.str,
                 protection_mode: _builtins.str,
                 role: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_last_role_changed: _builtins.str,
                 time_last_synced: _builtins.str,
                 transport_lag: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        :param _builtins.str autonomous_database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str id: The OCID of the Autonomous Dataguard created for Autonomous Container Database where given Autonomous Database resides in.
        :param _builtins.bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : `is_automatic_failover_enabled = true`.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycleState, if available.
        :param _builtins.str peer_autonomous_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Database.
        :param _builtins.str peer_autonomous_database_life_cycle_state: The current state of the Autonomous Database.
        :param _builtins.str peer_role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param _builtins.str state: The current state of Autonomous Data Guard.
        :param _builtins.str time_created: The date and time the Data Guard association was created.
        :param _builtins.str time_last_role_changed: The date and time when the last role change action happened.
        :param _builtins.str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param _builtins.str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_automatic_failover_enabled", is_automatic_failover_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "peer_autonomous_database_id", peer_autonomous_database_id)
        pulumi.set(__self__, "peer_autonomous_database_life_cycle_state", peer_autonomous_database_life_cycle_state)
        pulumi.set(__self__, "peer_role", peer_role)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_last_role_changed", time_last_role_changed)
        pulumi.set(__self__, "time_last_synced", time_last_synced)
        pulumi.set(__self__, "transport_lag", transport_lag)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> _builtins.str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_database_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the Autonomous Dataguard created for Autonomous Container Database where given Autonomous Database resides in.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> _builtins.bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : `is_automatic_failover_enabled = true`.
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycleState, if available.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousDatabaseId")
    def peer_autonomous_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Database.
        """
        return pulumi.get(self, "peer_autonomous_database_id")

    @_builtins.property
    @pulumi.getter(name="peerAutonomousDatabaseLifeCycleState")
    def peer_autonomous_database_life_cycle_state(self) -> _builtins.str:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "peer_autonomous_database_life_cycle_state")

    @_builtins.property
    @pulumi.getter(name="peerRole")
    def peer_role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "peer_role")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of Autonomous Data Guard.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Data Guard association was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> _builtins.str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> _builtins.str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousDatabaseDataguardAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseDbToolsDetailResult(dict):
    def __init__(__self__, *,
                 compute_count: _builtins.float,
                 is_enabled: _builtins.bool,
                 max_idle_time_in_minutes: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.float compute_count: Compute used by database tools.
        :param _builtins.bool is_enabled: Indicates whether tool is enabled.
        :param _builtins.int max_idle_time_in_minutes: The max idle time, in minutes, after which the VM used by database tools will be terminated.
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "max_idle_time_in_minutes", max_idle_time_in_minutes)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.float:
        """
        Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Indicates whether tool is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="maxIdleTimeInMinutes")
    def max_idle_time_in_minutes(self) -> _builtins.int:
        """
        The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        return pulumi.get(self, "max_idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabaseEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 arn_role: _builtins.str,
                 autonomous_database_provider: _builtins.str,
                 certificate_directory_name: _builtins.str,
                 certificate_id: _builtins.str,
                 directory_name: _builtins.str,
                 external_id: _builtins.str,
                 key_arn: _builtins.str,
                 key_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 okv_kms_key: _builtins.str,
                 okv_uri: _builtins.str,
                 service_endpoint_uri: _builtins.str,
                 vault_id: _builtins.str,
                 vault_uri: _builtins.str):
        """
        :param _builtins.str arn_role: AWS ARN role
        :param _builtins.str autonomous_database_provider: The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: OKV certificate directory name
        :param _builtins.str certificate_id: OKV certificate id
        :param _builtins.str directory_name: OKV wallet directory name
        :param _builtins.str external_id: AWS external ID
        :param _builtins.str key_arn: AWS key ARN
        :param _builtins.str key_name: Azure key name
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: UUID of OKV KMS Key
        :param _builtins.str okv_uri: URI of OKV server
        :param _builtins.str service_endpoint_uri: AWS key service endpoint URI
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str vault_uri: Azure vault URI
        """
        pulumi.set(__self__, "arn_role", arn_role)
        pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        pulumi.set(__self__, "okv_uri", okv_uri)
        pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> _builtins.str:
        """
        AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> _builtins.str:
        """
        The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> _builtins.str:
        """
        OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> _builtins.str:
        """
        OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> _builtins.str:
        """
        UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> _builtins.str:
        """
        URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> _builtins.str:
        """
        AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetAutonomousDatabaseEncryptionKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 encryption_keys: Sequence['outputs.GetAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult'],
                 time_activated: _builtins.str):
        """
        :param Sequence['GetAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs'] encryption_keys: Details of the Autonomous Database encryption key.
        :param _builtins.str time_activated: The date and time the kms key activated.
        """
        pulumi.set(__self__, "encryption_keys", encryption_keys)
        pulumi.set(__self__, "time_activated", time_activated)

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Sequence['outputs.GetAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult']:
        """
        Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")


@pulumi.output_type
class GetAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 arn_role: _builtins.str,
                 autonomous_database_provider: _builtins.str,
                 certificate_directory_name: _builtins.str,
                 certificate_id: _builtins.str,
                 directory_name: _builtins.str,
                 external_id: _builtins.str,
                 key_arn: _builtins.str,
                 key_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 okv_kms_key: _builtins.str,
                 okv_uri: _builtins.str,
                 service_endpoint_uri: _builtins.str,
                 vault_id: _builtins.str,
                 vault_uri: _builtins.str):
        """
        :param _builtins.str arn_role: AWS ARN role
        :param _builtins.str autonomous_database_provider: The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: OKV certificate directory name
        :param _builtins.str certificate_id: OKV certificate id
        :param _builtins.str directory_name: OKV wallet directory name
        :param _builtins.str external_id: AWS external ID
        :param _builtins.str key_arn: AWS key ARN
        :param _builtins.str key_name: Azure key name
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: UUID of OKV KMS Key
        :param _builtins.str okv_uri: URI of OKV server
        :param _builtins.str service_endpoint_uri: AWS key service endpoint URI
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str vault_uri: Azure vault URI
        """
        pulumi.set(__self__, "arn_role", arn_role)
        pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        pulumi.set(__self__, "okv_uri", okv_uri)
        pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> _builtins.str:
        """
        AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> _builtins.str:
        """
        The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> _builtins.str:
        """
        OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> _builtins.str:
        """
        OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> _builtins.str:
        """
        UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> _builtins.str:
        """
        URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> _builtins.str:
        """
        AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetAutonomousDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 time_activated: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabaseLocalStandbyDbResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 lag_time_in_seconds: _builtins.int,
                 lifecycle_details: _builtins.str,
                 maintenance_target_component: _builtins.str,
                 state: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: The current state of the Autonomous Database.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> _builtins.int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class GetAutonomousDatabaseLongTermBackupScheduleResult(dict):
    def __init__(__self__, *,
                 is_disabled: _builtins.bool,
                 repeat_cadence: _builtins.str,
                 retention_period_in_days: _builtins.int,
                 time_of_backup: _builtins.str):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.str repeat_cadence: The frequency of the long-term backup schedule
        :param _builtins.int retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "repeat_cadence", repeat_cadence)
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "time_of_backup", time_of_backup)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> _builtins.bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> _builtins.str:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> _builtins.str:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionItemResult']):
        """
        :param Sequence['GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionItemArgs'] items: This array holds details about Autonomous Database Peers for Oracle an Autonomous Database.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionItemResult']:
        """
        This array holds details about Autonomous Database Peers for Oracle an Autonomous Database.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAutonomousDatabasePeersAutonomousDatabasePeerCollectionItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        :param _builtins.str region: The name of the region where this peer Autonomous Database clone exists.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The name of the region where this peer Autonomous Database clone exists.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAutonomousDatabasePeersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabasePublicConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: _builtins.str,
                 database_transforms_url: _builtins.str,
                 graph_studio_url: _builtins.str,
                 machine_learning_notebook_url: _builtins.str,
                 machine_learning_user_management_url: _builtins.str,
                 mongo_db_url: _builtins.str,
                 ords_url: _builtins.str,
                 sql_dev_web_url: _builtins.str):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        pulumi.set(__self__, "apex_url", apex_url)
        pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        pulumi.set(__self__, "ords_url", ords_url)
        pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> _builtins.str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> _builtins.str:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> _builtins.str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> _builtins.str:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> _builtins.str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> _builtins.str:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> _builtins.str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabaseRefreshableClonesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        :param _builtins.str region: The name of the region where the refreshable clone exists.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The name of the region where the refreshable clone exists.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult(dict):
    def __init__(__self__, *,
                 disaster_recovery_type: _builtins.str,
                 is_replicate_automatic_backups: _builtins.bool,
                 is_snapshot_standby: _builtins.bool,
                 time_snapshot_standby_enabled_till: _builtins.str):
        """
        :param _builtins.str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param _builtins.bool is_replicate_automatic_backups: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        :param _builtins.bool is_snapshot_standby: Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        :param _builtins.str time_snapshot_standby_enabled_till: Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)
        pulumi.set(__self__, "is_replicate_automatic_backups", is_replicate_automatic_backups)
        pulumi.set(__self__, "is_snapshot_standby", is_snapshot_standby)
        pulumi.set(__self__, "time_snapshot_standby_enabled_till", time_snapshot_standby_enabled_till)

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> _builtins.str:
        """
        Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="isReplicateAutomaticBackups")
    def is_replicate_automatic_backups(self) -> _builtins.bool:
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        return pulumi.get(self, "is_replicate_automatic_backups")

    @_builtins.property
    @pulumi.getter(name="isSnapshotStandby")
    def is_snapshot_standby(self) -> _builtins.bool:
        """
        Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        """
        return pulumi.get(self, "is_snapshot_standby")

    @_builtins.property
    @pulumi.getter(name="timeSnapshotStandbyEnabledTill")
    def time_snapshot_standby_enabled_till(self) -> _builtins.str:
        """
        Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        return pulumi.get(self, "time_snapshot_standby_enabled_till")


@pulumi.output_type
class GetAutonomousDatabaseResourcePoolMembersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionItemResult']):
        """
        :param Sequence['GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionItemArgs'] items: List of resource pool member summary.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionItemResult']:
        """
        List of resource pool member summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAutonomousDatabaseResourcePoolMembersResourcePoolMemberCollectionItemResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAutonomousDatabaseResourcePoolSummaryResult(dict):
    def __init__(__self__, *,
                 is_disabled: _builtins.bool,
                 pool_size: _builtins.int):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.int pool_size: Resource pool size.
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "pool_size", pool_size)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> _builtins.bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> _builtins.int:
        """
        Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class GetAutonomousDatabaseScheduledOperationResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetAutonomousDatabaseScheduledOperationDayOfWeekResult'],
                 scheduled_start_time: _builtins.str,
                 scheduled_stop_time: _builtins.str):
        """
        :param Sequence['GetAutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_weeks: Day of the week.
        :param _builtins.str scheduled_start_time: auto start time. value must be of ISO-8601 format "HH:mm"
        :param _builtins.str scheduled_stop_time: auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "scheduled_start_time", scheduled_start_time)
        pulumi.set(__self__, "scheduled_stop_time", scheduled_stop_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetAutonomousDatabaseScheduledOperationDayOfWeekResult']:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @_builtins.property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> _builtins.str:
        """
        auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @_builtins.property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> _builtins.str:
        """
        auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class GetAutonomousDatabaseScheduledOperationDayOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabaseSoftwareImagesAutonomousDatabaseSoftwareImageCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAutonomousDatabaseSoftwareImagesAutonomousDatabaseSoftwareImageCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAutonomousDatabaseSoftwareImagesAutonomousDatabaseSoftwareImageCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAutonomousDatabaseSoftwareImagesAutonomousDatabaseSoftwareImageCollectionItemResult(dict):
    def __init__(__self__, *,
                 autonomous_dsi_one_off_patches: Sequence[_builtins.str],
                 compartment_id: _builtins.str,
                 database_version: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 image_shape_family: _builtins.str,
                 lifecycle_details: _builtins.str,
                 release_update: _builtins.str,
                 source_cdb_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str):
        """
        :param Sequence[_builtins.str] autonomous_dsi_one_off_patches: One-off patches included in the Autonomous Database Software Image
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_version: The database version with which the Autonomous Database Software Image is to be built.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database Software Image.
        :param _builtins.str image_shape_family: A filter to return only resources that match the given image shape family exactly.
        :param _builtins.str lifecycle_details: Detailed message for the lifecycle state.
        :param _builtins.str release_update: The Release Updates.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Autonomous Database Software Image was created.
        """
        pulumi.set(__self__, "autonomous_dsi_one_off_patches", autonomous_dsi_one_off_patches)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_version", database_version)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_shape_family", image_shape_family)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "release_update", release_update)
        pulumi.set(__self__, "source_cdb_id", source_cdb_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="autonomousDsiOneOffPatches")
    def autonomous_dsi_one_off_patches(self) -> Sequence[_builtins.str]:
        """
        One-off patches included in the Autonomous Database Software Image
        """
        return pulumi.get(self, "autonomous_dsi_one_off_patches")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> _builtins.str:
        """
        The database version with which the Autonomous Database Software Image is to be built.
        """
        return pulumi.get(self, "database_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database Software Image.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="imageShapeFamily")
    def image_shape_family(self) -> _builtins.str:
        """
        A filter to return only resources that match the given image shape family exactly.
        """
        return pulumi.get(self, "image_shape_family")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="releaseUpdate")
    def release_update(self) -> _builtins.str:
        """
        The Release Updates.
        """
        return pulumi.get(self, "release_update")

    @_builtins.property
    @pulumi.getter(name="sourceCdbId")
    def source_cdb_id(self) -> _builtins.str:
        return pulumi.get(self, "source_cdb_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Database Software Image was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetAutonomousDatabaseSoftwareImagesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseStandbyDbResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 lag_time_in_seconds: _builtins.int,
                 lifecycle_details: _builtins.str,
                 maintenance_target_component: _builtins.str,
                 state: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: The current state of the Autonomous Database.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> _builtins.int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseResult(dict):
    def __init__(__self__, *,
                 actual_used_data_storage_size_in_tbs: _builtins.float,
                 admin_password: _builtins.str,
                 allocated_storage_size_in_tbs: _builtins.float,
                 apex_details: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseApexDetailResult'],
                 are_primary_whitelisted_ips_used: _builtins.bool,
                 auto_refresh_frequency_in_seconds: _builtins.int,
                 auto_refresh_point_lag_in_seconds: _builtins.int,
                 autonomous_container_database_id: _builtins.str,
                 autonomous_database_backup_id: _builtins.str,
                 autonomous_database_id: _builtins.str,
                 autonomous_maintenance_schedule_type: _builtins.str,
                 availability_domain: _builtins.str,
                 available_upgrade_versions: Sequence[_builtins.str],
                 backup_configs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult'],
                 backup_retention_period_in_days: _builtins.int,
                 byol_compute_count_limit: _builtins.float,
                 character_set: _builtins.str,
                 clone_table_space_lists: Sequence[_builtins.int],
                 clone_type: _builtins.str,
                 cluster_placement_group_id: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_count: _builtins.float,
                 compute_model: _builtins.str,
                 connection_strings: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult'],
                 connection_urls: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult'],
                 cpu_core_count: _builtins.int,
                 customer_contacts: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult'],
                 data_safe_status: _builtins.str,
                 data_storage_size_in_gb: _builtins.int,
                 data_storage_size_in_tbs: _builtins.int,
                 database_edition: _builtins.str,
                 database_management_status: _builtins.str,
                 dataguard_region_type: _builtins.str,
                 db_name: _builtins.str,
                 db_tools_details: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseDbToolsDetailResult'],
                 db_version: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 disaster_recovery_region_type: _builtins.str,
                 disaster_recovery_type: _builtins.str,
                 display_name: _builtins.str,
                 enable_delete_scheduled_operations: _builtins.bool,
                 encryption_key_history_entries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryResult'],
                 encryption_keys: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyResult'],
                 failed_data_recovery_in_seconds: _builtins.int,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 in_memory_area_in_gbs: _builtins.int,
                 in_memory_percentage: _builtins.int,
                 infrastructure_type: _builtins.str,
                 is_access_control_enabled: _builtins.bool,
                 is_auto_scaling_enabled: _builtins.bool,
                 is_auto_scaling_for_storage_enabled: _builtins.bool,
                 is_backup_retention_locked: _builtins.bool,
                 is_data_guard_enabled: _builtins.bool,
                 is_dedicated: _builtins.bool,
                 is_dev_tier: _builtins.bool,
                 is_disable_db_version_upgrade_schedule: _builtins.bool,
                 is_disconnect_peer: _builtins.bool,
                 is_free_tier: _builtins.bool,
                 is_local_data_guard_enabled: _builtins.bool,
                 is_mtls_connection_required: _builtins.bool,
                 is_preview: _builtins.bool,
                 is_preview_version_with_service_terms_accepted: _builtins.bool,
                 is_reconnect_clone_enabled: _builtins.bool,
                 is_refreshable_clone: _builtins.bool,
                 is_remote_data_guard_enabled: _builtins.bool,
                 is_replicate_automatic_backups: _builtins.bool,
                 is_schedule_db_version_upgrade_to_earliest: _builtins.bool,
                 is_shrink_only: _builtins.bool,
                 key_history_entries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult'],
                 key_store_id: _builtins.str,
                 key_store_wallet_name: _builtins.str,
                 key_version_id: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_lifecycle_details: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 local_adg_auto_failover_max_data_loss_limit: _builtins.int,
                 local_disaster_recovery_type: _builtins.str,
                 local_standby_dbs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult'],
                 long_term_backup_schedules: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult'],
                 maintenance_target_component: _builtins.str,
                 max_cpu_core_count: _builtins.int,
                 memory_per_oracle_compute_unit_in_gbs: _builtins.int,
                 ncharacter_set: _builtins.str,
                 net_services_architecture: _builtins.str,
                 next_long_term_backup_time_stamp: _builtins.str,
                 nsg_ids: Sequence[_builtins.str],
                 ocpu_count: _builtins.float,
                 open_mode: _builtins.str,
                 operations_insights_status: _builtins.str,
                 peer_db_id: _builtins.str,
                 peer_db_ids: Sequence[_builtins.str],
                 permission_level: _builtins.str,
                 private_endpoint: _builtins.str,
                 private_endpoint_ip: _builtins.str,
                 private_endpoint_label: _builtins.str,
                 provisionable_cpuses: Sequence[_builtins.float],
                 public_connection_urls: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabasePublicConnectionUrlResult'],
                 public_endpoint: _builtins.str,
                 refreshable_mode: _builtins.str,
                 refreshable_status: _builtins.str,
                 remote_disaster_recovery_configurations: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult'],
                 remote_disaster_recovery_type: _builtins.str,
                 resource_pool_leader_id: _builtins.str,
                 resource_pool_summaries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult'],
                 role: _builtins.str,
                 rotate_key_trigger: _builtins.bool,
                 scheduled_operations: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult'],
                 secret_id: _builtins.str,
                 secret_version_number: _builtins.int,
                 security_attributes: Mapping[str, _builtins.str],
                 service_console_url: _builtins.str,
                 shrink_adb_trigger: _builtins.int,
                 source: _builtins.str,
                 source_id: _builtins.str,
                 standby_dbs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult'],
                 standby_whitelisted_ips: Sequence[_builtins.str],
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 subscription_id: _builtins.str,
                 supported_regions_to_clone_tos: Sequence[_builtins.str],
                 switchover_to: _builtins.str,
                 switchover_to_remote_peer_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_deletion_of_free_autonomous_database: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_earliest_available_db_version_upgrade: _builtins.str,
                 time_latest_available_db_version_upgrade: _builtins.str,
                 time_local_data_guard_enabled: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str,
                 time_of_auto_refresh_start: _builtins.str,
                 time_of_joining_resource_pool: _builtins.str,
                 time_of_last_failover: _builtins.str,
                 time_of_last_refresh: _builtins.str,
                 time_of_last_refresh_point: _builtins.str,
                 time_of_last_switchover: _builtins.str,
                 time_of_next_refresh: _builtins.str,
                 time_reclamation_of_free_autonomous_database: _builtins.str,
                 time_scheduled_db_version_upgrade: _builtins.str,
                 time_undeleted: _builtins.str,
                 time_until_reconnect_clone_enabled: _builtins.str,
                 timestamp: _builtins.str,
                 total_backup_storage_size_in_gbs: _builtins.float,
                 use_latest_available_backup_time_stamp: _builtins.bool,
                 used_data_storage_size_in_gbs: _builtins.int,
                 used_data_storage_size_in_tbs: _builtins.int,
                 vault_id: _builtins.str,
                 whitelisted_ips: Sequence[_builtins.str]):
        """
        :param _builtins.float actual_used_data_storage_size_in_tbs: The current amount of storage in use for user and system data, in terabytes (TB).
        :param _builtins.float allocated_storage_size_in_tbs: The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseApexDetailArgs'] apex_details: Information about Oracle APEX Application Development.
        :param _builtins.bool are_primary_whitelisted_ips_used: This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        :param _builtins.int auto_refresh_frequency_in_seconds: The frequency a refreshable clone is refreshed after auto-refresh is enabled. The minimum is 1 hour. The maximum is 7 days. The date and time that auto-refresh is enabled is controlled by the `timeOfAutoRefreshStart` parameter.
        :param _builtins.int auto_refresh_point_lag_in_seconds: The time, in seconds, the data of the refreshable clone lags the primary database at the point of refresh. The minimum is 0 minutes (0 mins means refresh to the latest available timestamp). The maximum is 7 days. The lag time increases after refreshing until the next data refresh happens.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str autonomous_maintenance_schedule_type: The maintenance schedule type of the Autonomous Database Serverless. An EARLY maintenance schedule follows a schedule applying patches prior to the REGULAR schedule. A REGULAR maintenance schedule follows the normal cycle
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param Sequence[_builtins.str] available_upgrade_versions: List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseBackupConfigArgs'] backup_configs: Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        :param _builtins.int backup_retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.float byol_compute_count_limit: The maximum number of CPUs allowed with a Bring Your Own License (BYOL), including those used for auto-scaling, disaster recovery, tools, etc. Any CPU usage above this limit is considered as License Included and billed.
        :param _builtins.str character_set: The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        :param Sequence[_builtins.int] clone_table_space_lists: A list of the source Autonomous Database's table space number(s) used to create this partial clone from the backup.
        :param _builtins.str cluster_placement_group_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cluster placement group of the Autonomous Serverless Database.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.float compute_count: Compute used by database tools.
        :param _builtins.str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseConnectionStringArgs'] connection_strings: The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseConnectionUrlArgs'] connection_urls: The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        :param _builtins.int cpu_core_count: The number of CPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Database on Dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseCustomerContactArgs'] customer_contacts: Customer Contacts.
        :param _builtins.str data_safe_status: Status of the Data Safe registration for this Autonomous Database. Could be REGISTERED or NOT_REGISTERED.
        :param _builtins.int data_storage_size_in_gb: The quantity of data in the database, in gigabytes.
        :param _builtins.int data_storage_size_in_tbs: The quantity of data in the database, in terabytes.
        :param _builtins.str database_edition: The Oracle Database Edition that applies to the Autonomous databases.
        :param _builtins.str database_management_status: Status of Database Management for this Autonomous Database.
        :param _builtins.str dataguard_region_type: **Deprecated.** The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Database Serverless, Autonomous Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Autonomous Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Autonomous Data Guard association, and cannot be performed when the database using the primary role is operating in a remote Autonomous Data Guard standby region.
        :param _builtins.str db_name: The database name.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseDbToolsDetailArgs'] db_tools_details: The list of database tools details.
        :param _builtins.str db_version: A filter to return only autonomous database resources that match the specified dbVersion.
        :param _builtins.str db_workload: A filter to return only autonomous database resources that match the specified workload type.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str disaster_recovery_region_type: **Deprecated.** The disaster recovery (DR) region type of the Autonomous Database. For Autonomous Database Serverless instances, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        :param _builtins.str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryArgs'] encryption_key_history_entries: Key History Entry.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyArgs'] encryption_keys: Details of the Autonomous Database encryption key.
        :param _builtins.int failed_data_recovery_in_seconds: Indicates the number of seconds of data loss for a Data Guard failover.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.int in_memory_area_in_gbs: The area assigned to In-Memory tables in Autonomous Database.
        :param _builtins.int in_memory_percentage: The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database. This property is applicable only to Autonomous Databases on the Exadata Cloud@Customer platform.
        :param _builtins.str infrastructure_type: A filter to return only resources that match the given Infrastructure Type.
        :param _builtins.bool is_access_control_enabled: Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        :param _builtins.bool is_auto_scaling_enabled: Indicates if auto scaling is enabled for the Autonomous Database CPU core count. The default value is `TRUE`.
        :param _builtins.bool is_auto_scaling_for_storage_enabled: Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        :param _builtins.bool is_backup_retention_locked: Indicates if the Autonomous Database is backup retention locked.
        :param _builtins.bool is_data_guard_enabled: A filter to return only resources that have Data Guard enabled.
        :param _builtins.bool is_dedicated: True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        :param _builtins.bool is_dev_tier: Autonomous Database for Developers are fixed-shape Autonomous Databases that developers can use to build and test new applications. On Serverless, these are low-cost and billed per instance, on Dedicated and Cloud@Customer there is no additional cost to create Developer databases. Developer databases come with limited resources and is not intended for large-scale testing and production deployments. When you need more compute or storage resources, you may upgrade to a full paid production database.
        :param _builtins.bool is_free_tier: Filter on the value of the resource's 'isFreeTier' property. A value of `true` returns only Always Free resources. A value of `false` excludes Always Free resources from the returned results. Omitting this parameter returns both Always Free and paid resources.
        :param _builtins.bool is_local_data_guard_enabled: Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param _builtins.bool is_mtls_connection_required: Specifies if the Autonomous Database requires mTLS connections.
        :param _builtins.bool is_preview: Indicates if the Autonomous Database version is a preview version.
        :param _builtins.bool is_reconnect_clone_enabled: Indicates if the refreshable clone can be reconnected to its source database.
        :param _builtins.bool is_refreshable_clone: Filter on the value of the resource's 'isRefreshableClone' property. A value of `true` returns only refreshable clones. A value of `false` excludes refreshable clones from the returned results. Omitting this parameter returns both refreshable clones and databases that are not refreshable clones.
        :param _builtins.bool is_remote_data_guard_enabled: Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param _builtins.bool is_replicate_automatic_backups: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryArgs'] key_history_entries: Key History Entry.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_lifecycle_details: KMS key lifecycle details.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str license_model: The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Oracle Database service. Note that when provisioning an [Autonomous Database on dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null. It is already set at the Autonomous Exadata Infrastructure level. When provisioning an [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) database, if a value is not specified, the system defaults the value to `BRING_YOUR_OWN_LICENSE`. Bring your own license (BYOL) also allows you to select the DB edition using the optional parameter.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int local_adg_auto_failover_max_data_loss_limit: Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        :param _builtins.str local_disaster_recovery_type: Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbArgs'] local_standby_dbs: Autonomous Data Guard standby database details.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleArgs'] long_term_backup_schedules: Details for the long-term backup schedule.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per ECPU or OCPU.
        :param _builtins.str ncharacter_set: The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param _builtins.str net_services_architecture: Enabling SHARED server architecture enables a database server to allow many client processes to share very few server processes, thereby increasing the number of supported users.
        :param _builtins.str next_long_term_backup_time_stamp: The date and time when the next long-term backup would be created.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.float ocpu_count: The number of OCPU cores to be made available to the database.
        :param _builtins.str open_mode: Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        :param _builtins.str operations_insights_status: Status of Operations Insights for this Autonomous Database.
        :param Sequence[_builtins.str] peer_db_ids: The list of [OCIDs](https://docs.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for Autonomous Database Serverless instances, standby databases located in the same region as the source primary database do not have OCIDs.
        :param _builtins.str permission_level: The Autonomous Database permission level. Restricted mode allows access only by admin users.
        :param _builtins.str private_endpoint: The private endpoint for the resource.
        :param _builtins.str private_endpoint_ip: The private endpoint Ip address for the resource.
        :param _builtins.str private_endpoint_label: The private endpoint label for the resource.
        :param Sequence[_builtins.float] provisionable_cpuses: An array of CPU values that an Autonomous Database can be scaled to.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabasePublicConnectionUrlArgs'] public_connection_urls: The Public URLs of Private Endpoint database for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN.
        :param _builtins.str public_endpoint: The public endpoint for the private endpoint enabled resource.
        :param _builtins.str refreshable_mode: The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        :param _builtins.str refreshable_status: The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs'] remote_disaster_recovery_configurations: Configurations of a Disaster Recovery.
        :param _builtins.str resource_pool_leader_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resourcepool Leader Autonomous Database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryArgs'] resource_pool_summaries: The configuration details for resource pool
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseScheduledOperationArgs'] scheduled_operations: The list of scheduled operations. Consists of values such as dayOfWeek, scheduledStartTime, scheduledStopTime.
        :param Mapping[str, _builtins.str] security_attributes: Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        :param _builtins.str service_console_url: The URL of the Service Console for the Autonomous Database.
        :param _builtins.str source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseStandbyDbArgs'] standby_dbs: **Deprecated** Autonomous Data Guard standby database details.
        :param Sequence[_builtins.str] standby_whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Sequence[_builtins.str] supported_regions_to_clone_tos: The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Autonomous Database was created.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_deletion_of_free_autonomous_database: The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_earliest_available_db_version_upgrade: The earliest(min) date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        :param _builtins.str time_latest_available_db_version_upgrade: The max date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        :param _builtins.str time_local_data_guard_enabled: The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        :param _builtins.str time_of_auto_refresh_start: The the date and time that auto-refreshing will begin for an Autonomous Database refreshable clone. This value controls only the start time for the first refresh operation. Subsequent (ongoing) refresh operations have start times controlled by the value of the `autoRefreshFrequencyInSeconds` parameter.
        :param _builtins.str time_of_joining_resource_pool: The time the member joined the resource pool.
        :param _builtins.str time_of_last_failover: The timestamp of the last failover operation.
        :param _builtins.str time_of_last_refresh: The date and time when last refresh happened.
        :param _builtins.str time_of_last_refresh_point: The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        :param _builtins.str time_of_last_switchover: The timestamp of the last switchover operation for the Autonomous Database.
        :param _builtins.str time_of_next_refresh: The date and time of next refresh.
        :param _builtins.str time_reclamation_of_free_autonomous_database: The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        :param _builtins.str time_scheduled_db_version_upgrade: The date and time the Autonomous Database scheduled to upgrade to 23ai.
        :param _builtins.str time_undeleted: The date and time the Autonomous Database was most recently undeleted.
        :param _builtins.str time_until_reconnect_clone_enabled: The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        :param _builtins.float total_backup_storage_size_in_gbs: The backup storage to the database.
        :param _builtins.int used_data_storage_size_in_gbs: The storage space consumed by Autonomous Database in GBs.
        :param _builtins.int used_data_storage_size_in_tbs: The amount of storage that has been used for Autonomous Databases in dedicated infrastructure, in terabytes.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param Sequence[_builtins.str] whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        """
        pulumi.set(__self__, "actual_used_data_storage_size_in_tbs", actual_used_data_storage_size_in_tbs)
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "allocated_storage_size_in_tbs", allocated_storage_size_in_tbs)
        pulumi.set(__self__, "apex_details", apex_details)
        pulumi.set(__self__, "are_primary_whitelisted_ips_used", are_primary_whitelisted_ips_used)
        pulumi.set(__self__, "auto_refresh_frequency_in_seconds", auto_refresh_frequency_in_seconds)
        pulumi.set(__self__, "auto_refresh_point_lag_in_seconds", auto_refresh_point_lag_in_seconds)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "autonomous_database_backup_id", autonomous_database_backup_id)
        pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        pulumi.set(__self__, "autonomous_maintenance_schedule_type", autonomous_maintenance_schedule_type)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "available_upgrade_versions", available_upgrade_versions)
        pulumi.set(__self__, "backup_configs", backup_configs)
        pulumi.set(__self__, "backup_retention_period_in_days", backup_retention_period_in_days)
        pulumi.set(__self__, "byol_compute_count_limit", byol_compute_count_limit)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "clone_table_space_lists", clone_table_space_lists)
        pulumi.set(__self__, "clone_type", clone_type)
        pulumi.set(__self__, "cluster_placement_group_id", cluster_placement_group_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "connection_urls", connection_urls)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "customer_contacts", customer_contacts)
        pulumi.set(__self__, "data_safe_status", data_safe_status)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "dataguard_region_type", dataguard_region_type)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_tools_details", db_tools_details)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "disaster_recovery_region_type", disaster_recovery_region_type)
        pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "enable_delete_scheduled_operations", enable_delete_scheduled_operations)
        pulumi.set(__self__, "encryption_key_history_entries", encryption_key_history_entries)
        pulumi.set(__self__, "encryption_keys", encryption_keys)
        pulumi.set(__self__, "failed_data_recovery_in_seconds", failed_data_recovery_in_seconds)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "in_memory_area_in_gbs", in_memory_area_in_gbs)
        pulumi.set(__self__, "in_memory_percentage", in_memory_percentage)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        pulumi.set(__self__, "is_access_control_enabled", is_access_control_enabled)
        pulumi.set(__self__, "is_auto_scaling_enabled", is_auto_scaling_enabled)
        pulumi.set(__self__, "is_auto_scaling_for_storage_enabled", is_auto_scaling_for_storage_enabled)
        pulumi.set(__self__, "is_backup_retention_locked", is_backup_retention_locked)
        pulumi.set(__self__, "is_data_guard_enabled", is_data_guard_enabled)
        pulumi.set(__self__, "is_dedicated", is_dedicated)
        pulumi.set(__self__, "is_dev_tier", is_dev_tier)
        pulumi.set(__self__, "is_disable_db_version_upgrade_schedule", is_disable_db_version_upgrade_schedule)
        pulumi.set(__self__, "is_disconnect_peer", is_disconnect_peer)
        pulumi.set(__self__, "is_free_tier", is_free_tier)
        pulumi.set(__self__, "is_local_data_guard_enabled", is_local_data_guard_enabled)
        pulumi.set(__self__, "is_mtls_connection_required", is_mtls_connection_required)
        pulumi.set(__self__, "is_preview", is_preview)
        pulumi.set(__self__, "is_preview_version_with_service_terms_accepted", is_preview_version_with_service_terms_accepted)
        pulumi.set(__self__, "is_reconnect_clone_enabled", is_reconnect_clone_enabled)
        pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)
        pulumi.set(__self__, "is_remote_data_guard_enabled", is_remote_data_guard_enabled)
        pulumi.set(__self__, "is_replicate_automatic_backups", is_replicate_automatic_backups)
        pulumi.set(__self__, "is_schedule_db_version_upgrade_to_earliest", is_schedule_db_version_upgrade_to_earliest)
        pulumi.set(__self__, "is_shrink_only", is_shrink_only)
        pulumi.set(__self__, "key_history_entries", key_history_entries)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "key_store_wallet_name", key_store_wallet_name)
        pulumi.set(__self__, "key_version_id", key_version_id)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_lifecycle_details", kms_key_lifecycle_details)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "local_adg_auto_failover_max_data_loss_limit", local_adg_auto_failover_max_data_loss_limit)
        pulumi.set(__self__, "local_disaster_recovery_type", local_disaster_recovery_type)
        pulumi.set(__self__, "local_standby_dbs", local_standby_dbs)
        pulumi.set(__self__, "long_term_backup_schedules", long_term_backup_schedules)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "max_cpu_core_count", max_cpu_core_count)
        pulumi.set(__self__, "memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "net_services_architecture", net_services_architecture)
        pulumi.set(__self__, "next_long_term_backup_time_stamp", next_long_term_backup_time_stamp)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        pulumi.set(__self__, "open_mode", open_mode)
        pulumi.set(__self__, "operations_insights_status", operations_insights_status)
        pulumi.set(__self__, "peer_db_id", peer_db_id)
        pulumi.set(__self__, "peer_db_ids", peer_db_ids)
        pulumi.set(__self__, "permission_level", permission_level)
        pulumi.set(__self__, "private_endpoint", private_endpoint)
        pulumi.set(__self__, "private_endpoint_ip", private_endpoint_ip)
        pulumi.set(__self__, "private_endpoint_label", private_endpoint_label)
        pulumi.set(__self__, "provisionable_cpuses", provisionable_cpuses)
        pulumi.set(__self__, "public_connection_urls", public_connection_urls)
        pulumi.set(__self__, "public_endpoint", public_endpoint)
        pulumi.set(__self__, "refreshable_mode", refreshable_mode)
        pulumi.set(__self__, "refreshable_status", refreshable_status)
        pulumi.set(__self__, "remote_disaster_recovery_configurations", remote_disaster_recovery_configurations)
        pulumi.set(__self__, "remote_disaster_recovery_type", remote_disaster_recovery_type)
        pulumi.set(__self__, "resource_pool_leader_id", resource_pool_leader_id)
        pulumi.set(__self__, "resource_pool_summaries", resource_pool_summaries)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "rotate_key_trigger", rotate_key_trigger)
        pulumi.set(__self__, "scheduled_operations", scheduled_operations)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "secret_version_number", secret_version_number)
        pulumi.set(__self__, "security_attributes", security_attributes)
        pulumi.set(__self__, "service_console_url", service_console_url)
        pulumi.set(__self__, "shrink_adb_trigger", shrink_adb_trigger)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "standby_dbs", standby_dbs)
        pulumi.set(__self__, "standby_whitelisted_ips", standby_whitelisted_ips)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "supported_regions_to_clone_tos", supported_regions_to_clone_tos)
        pulumi.set(__self__, "switchover_to", switchover_to)
        pulumi.set(__self__, "switchover_to_remote_peer_id", switchover_to_remote_peer_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_deletion_of_free_autonomous_database", time_deletion_of_free_autonomous_database)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_earliest_available_db_version_upgrade", time_earliest_available_db_version_upgrade)
        pulumi.set(__self__, "time_latest_available_db_version_upgrade", time_latest_available_db_version_upgrade)
        pulumi.set(__self__, "time_local_data_guard_enabled", time_local_data_guard_enabled)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)
        pulumi.set(__self__, "time_of_auto_refresh_start", time_of_auto_refresh_start)
        pulumi.set(__self__, "time_of_joining_resource_pool", time_of_joining_resource_pool)
        pulumi.set(__self__, "time_of_last_failover", time_of_last_failover)
        pulumi.set(__self__, "time_of_last_refresh", time_of_last_refresh)
        pulumi.set(__self__, "time_of_last_refresh_point", time_of_last_refresh_point)
        pulumi.set(__self__, "time_of_last_switchover", time_of_last_switchover)
        pulumi.set(__self__, "time_of_next_refresh", time_of_next_refresh)
        pulumi.set(__self__, "time_reclamation_of_free_autonomous_database", time_reclamation_of_free_autonomous_database)
        pulumi.set(__self__, "time_scheduled_db_version_upgrade", time_scheduled_db_version_upgrade)
        pulumi.set(__self__, "time_undeleted", time_undeleted)
        pulumi.set(__self__, "time_until_reconnect_clone_enabled", time_until_reconnect_clone_enabled)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "total_backup_storage_size_in_gbs", total_backup_storage_size_in_gbs)
        pulumi.set(__self__, "use_latest_available_backup_time_stamp", use_latest_available_backup_time_stamp)
        pulumi.set(__self__, "used_data_storage_size_in_gbs", used_data_storage_size_in_gbs)
        pulumi.set(__self__, "used_data_storage_size_in_tbs", used_data_storage_size_in_tbs)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "whitelisted_ips", whitelisted_ips)

    @_builtins.property
    @pulumi.getter(name="actualUsedDataStorageSizeInTbs")
    def actual_used_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The current amount of storage in use for user and system data, in terabytes (TB).
        """
        return pulumi.get(self, "actual_used_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="allocatedStorageSizeInTbs")
    def allocated_storage_size_in_tbs(self) -> _builtins.float:
        """
        The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        """
        return pulumi.get(self, "allocated_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="apexDetails")
    def apex_details(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseApexDetailResult']:
        """
        Information about Oracle APEX Application Development.
        """
        return pulumi.get(self, "apex_details")

    @_builtins.property
    @pulumi.getter(name="arePrimaryWhitelistedIpsUsed")
    def are_primary_whitelisted_ips_used(self) -> _builtins.bool:
        """
        This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        """
        return pulumi.get(self, "are_primary_whitelisted_ips_used")

    @_builtins.property
    @pulumi.getter(name="autoRefreshFrequencyInSeconds")
    def auto_refresh_frequency_in_seconds(self) -> _builtins.int:
        """
        The frequency a refreshable clone is refreshed after auto-refresh is enabled. The minimum is 1 hour. The maximum is 7 days. The date and time that auto-refresh is enabled is controlled by the `timeOfAutoRefreshStart` parameter.
        """
        return pulumi.get(self, "auto_refresh_frequency_in_seconds")

    @_builtins.property
    @pulumi.getter(name="autoRefreshPointLagInSeconds")
    def auto_refresh_point_lag_in_seconds(self) -> _builtins.int:
        """
        The time, in seconds, the data of the refreshable clone lags the primary database at the point of refresh. The minimum is 0 minutes (0 mins means refresh to the latest available timestamp). The maximum is 7 days. The lag time increases after refreshing until the next data refresh happens.
        """
        return pulumi.get(self, "auto_refresh_point_lag_in_seconds")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseBackupId")
    def autonomous_database_backup_id(self) -> _builtins.str:
        return pulumi.get(self, "autonomous_database_backup_id")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> _builtins.str:
        return pulumi.get(self, "autonomous_database_id")

    @_builtins.property
    @pulumi.getter(name="autonomousMaintenanceScheduleType")
    def autonomous_maintenance_schedule_type(self) -> _builtins.str:
        """
        The maintenance schedule type of the Autonomous Database Serverless. An EARLY maintenance schedule follows a schedule applying patches prior to the REGULAR schedule. A REGULAR maintenance schedule follows the normal cycle
        """
        return pulumi.get(self, "autonomous_maintenance_schedule_type")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="availableUpgradeVersions")
    def available_upgrade_versions(self) -> Sequence[_builtins.str]:
        """
        List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        """
        return pulumi.get(self, "available_upgrade_versions")

    @_builtins.property
    @pulumi.getter(name="backupConfigs")
    def backup_configs(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult']:
        """
        Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        """
        return pulumi.get(self, "backup_configs")

    @_builtins.property
    @pulumi.getter(name="backupRetentionPeriodInDays")
    def backup_retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "backup_retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="byolComputeCountLimit")
    def byol_compute_count_limit(self) -> _builtins.float:
        """
        The maximum number of CPUs allowed with a Bring Your Own License (BYOL), including those used for auto-scaling, disaster recovery, tools, etc. Any CPU usage above this limit is considered as License Included and billed.
        """
        return pulumi.get(self, "byol_compute_count_limit")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="cloneTableSpaceLists")
    def clone_table_space_lists(self) -> Sequence[_builtins.int]:
        """
        A list of the source Autonomous Database's table space number(s) used to create this partial clone from the backup.
        """
        return pulumi.get(self, "clone_table_space_lists")

    @_builtins.property
    @pulumi.getter(name="cloneType")
    def clone_type(self) -> _builtins.str:
        return pulumi.get(self, "clone_type")

    @_builtins.property
    @pulumi.getter(name="clusterPlacementGroupId")
    def cluster_placement_group_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cluster placement group of the Autonomous Serverless Database.
        """
        return pulumi.get(self, "cluster_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.float:
        """
        Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult']:
        """
        The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="connectionUrls")
    def connection_urls(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult']:
        """
        The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        """
        return pulumi.get(self, "connection_urls")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Database on Dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult']:
        """
        Customer Contacts.
        """
        return pulumi.get(self, "customer_contacts")

    @_builtins.property
    @pulumi.getter(name="dataSafeStatus")
    def data_safe_status(self) -> _builtins.str:
        """
        Status of the Data Safe registration for this Autonomous Database. Could be REGISTERED or NOT_REGISTERED.
        """
        return pulumi.get(self, "data_safe_status")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> _builtins.int:
        """
        The quantity of data in the database, in gigabytes.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.int:
        """
        The quantity of data in the database, in terabytes.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to the Autonomous databases.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        Status of Database Management for this Autonomous Database.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="dataguardRegionType")
    def dataguard_region_type(self) -> _builtins.str:
        """
        **Deprecated.** The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Database Serverless, Autonomous Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Autonomous Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Autonomous Data Guard association, and cannot be performed when the database using the primary role is operating in a remote Autonomous Data Guard standby region.
        """
        return pulumi.get(self, "dataguard_region_type")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbToolsDetails")
    def db_tools_details(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseDbToolsDetailResult']:
        """
        The list of database tools details.
        """
        return pulumi.get(self, "db_tools_details")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        A filter to return only autonomous database resources that match the specified dbVersion.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        A filter to return only autonomous database resources that match the specified workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryRegionType")
    def disaster_recovery_region_type(self) -> _builtins.str:
        """
        **Deprecated.** The disaster recovery (DR) region type of the Autonomous Database. For Autonomous Database Serverless instances, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        """
        return pulumi.get(self, "disaster_recovery_region_type")

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> _builtins.str:
        """
        Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="enableDeleteScheduledOperations")
    def enable_delete_scheduled_operations(self) -> _builtins.bool:
        return pulumi.get(self, "enable_delete_scheduled_operations")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyHistoryEntries")
    def encryption_key_history_entries(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "encryption_key_history_entries")

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyResult']:
        """
        Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter(name="failedDataRecoveryInSeconds")
    def failed_data_recovery_in_seconds(self) -> _builtins.int:
        """
        Indicates the number of seconds of data loss for a Data Guard failover.
        """
        return pulumi.get(self, "failed_data_recovery_in_seconds")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inMemoryAreaInGbs")
    def in_memory_area_in_gbs(self) -> _builtins.int:
        """
        The area assigned to In-Memory tables in Autonomous Database.
        """
        return pulumi.get(self, "in_memory_area_in_gbs")

    @_builtins.property
    @pulumi.getter(name="inMemoryPercentage")
    def in_memory_percentage(self) -> _builtins.int:
        """
        The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database. This property is applicable only to Autonomous Databases on the Exadata Cloud@Customer platform.
        """
        return pulumi.get(self, "in_memory_percentage")

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given Infrastructure Type.
        """
        return pulumi.get(self, "infrastructure_type")

    @_builtins.property
    @pulumi.getter(name="isAccessControlEnabled")
    def is_access_control_enabled(self) -> _builtins.bool:
        """
        Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        """
        return pulumi.get(self, "is_access_control_enabled")

    @_builtins.property
    @pulumi.getter(name="isAutoScalingEnabled")
    def is_auto_scaling_enabled(self) -> _builtins.bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database CPU core count. The default value is `TRUE`.
        """
        return pulumi.get(self, "is_auto_scaling_enabled")

    @_builtins.property
    @pulumi.getter(name="isAutoScalingForStorageEnabled")
    def is_auto_scaling_for_storage_enabled(self) -> _builtins.bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_auto_scaling_for_storage_enabled")

    @_builtins.property
    @pulumi.getter(name="isBackupRetentionLocked")
    def is_backup_retention_locked(self) -> _builtins.bool:
        """
        Indicates if the Autonomous Database is backup retention locked.
        """
        return pulumi.get(self, "is_backup_retention_locked")

    @_builtins.property
    @pulumi.getter(name="isDataGuardEnabled")
    def is_data_guard_enabled(self) -> _builtins.bool:
        """
        A filter to return only resources that have Data Guard enabled.
        """
        return pulumi.get(self, "is_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="isDedicated")
    def is_dedicated(self) -> _builtins.bool:
        """
        True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        """
        return pulumi.get(self, "is_dedicated")

    @_builtins.property
    @pulumi.getter(name="isDevTier")
    def is_dev_tier(self) -> _builtins.bool:
        """
        Autonomous Database for Developers are fixed-shape Autonomous Databases that developers can use to build and test new applications. On Serverless, these are low-cost and billed per instance, on Dedicated and Cloud@Customer there is no additional cost to create Developer databases. Developer databases come with limited resources and is not intended for large-scale testing and production deployments. When you need more compute or storage resources, you may upgrade to a full paid production database.
        """
        return pulumi.get(self, "is_dev_tier")

    @_builtins.property
    @pulumi.getter(name="isDisableDbVersionUpgradeSchedule")
    def is_disable_db_version_upgrade_schedule(self) -> _builtins.bool:
        return pulumi.get(self, "is_disable_db_version_upgrade_schedule")

    @_builtins.property
    @pulumi.getter(name="isDisconnectPeer")
    def is_disconnect_peer(self) -> _builtins.bool:
        return pulumi.get(self, "is_disconnect_peer")

    @_builtins.property
    @pulumi.getter(name="isFreeTier")
    def is_free_tier(self) -> _builtins.bool:
        """
        Filter on the value of the resource's 'isFreeTier' property. A value of `true` returns only Always Free resources. A value of `false` excludes Always Free resources from the returned results. Omitting this parameter returns both Always Free and paid resources.
        """
        return pulumi.get(self, "is_free_tier")

    @_builtins.property
    @pulumi.getter(name="isLocalDataGuardEnabled")
    def is_local_data_guard_enabled(self) -> _builtins.bool:
        """
        Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_local_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="isMtlsConnectionRequired")
    def is_mtls_connection_required(self) -> _builtins.bool:
        """
        Specifies if the Autonomous Database requires mTLS connections.
        """
        return pulumi.get(self, "is_mtls_connection_required")

    @_builtins.property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> _builtins.bool:
        """
        Indicates if the Autonomous Database version is a preview version.
        """
        return pulumi.get(self, "is_preview")

    @_builtins.property
    @pulumi.getter(name="isPreviewVersionWithServiceTermsAccepted")
    def is_preview_version_with_service_terms_accepted(self) -> _builtins.bool:
        return pulumi.get(self, "is_preview_version_with_service_terms_accepted")

    @_builtins.property
    @pulumi.getter(name="isReconnectCloneEnabled")
    def is_reconnect_clone_enabled(self) -> _builtins.bool:
        """
        Indicates if the refreshable clone can be reconnected to its source database.
        """
        return pulumi.get(self, "is_reconnect_clone_enabled")

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> _builtins.bool:
        """
        Filter on the value of the resource's 'isRefreshableClone' property. A value of `true` returns only refreshable clones. A value of `false` excludes refreshable clones from the returned results. Omitting this parameter returns both refreshable clones and databases that are not refreshable clones.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @_builtins.property
    @pulumi.getter(name="isRemoteDataGuardEnabled")
    def is_remote_data_guard_enabled(self) -> _builtins.bool:
        """
        Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_remote_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="isReplicateAutomaticBackups")
    def is_replicate_automatic_backups(self) -> _builtins.bool:
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        return pulumi.get(self, "is_replicate_automatic_backups")

    @_builtins.property
    @pulumi.getter(name="isScheduleDbVersionUpgradeToEarliest")
    def is_schedule_db_version_upgrade_to_earliest(self) -> _builtins.bool:
        return pulumi.get(self, "is_schedule_db_version_upgrade_to_earliest")

    @_builtins.property
    @pulumi.getter(name="isShrinkOnly")
    @_utilities.deprecated("""The 'is_shrink_only' field has been deprecated. Please use 'shrink_adb_trigger' instead.""")
    def is_shrink_only(self) -> _builtins.bool:
        return pulumi.get(self, "is_shrink_only")

    @_builtins.property
    @pulumi.getter(name="keyHistoryEntries")
    def key_history_entries(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "key_history_entries")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> _builtins.str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @_builtins.property
    @pulumi.getter(name="keyVersionId")
    def key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "key_version_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyLifecycleDetails")
    def kms_key_lifecycle_details(self) -> _builtins.str:
        """
        KMS key lifecycle details.
        """
        return pulumi.get(self, "kms_key_lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Oracle Database service. Note that when provisioning an [Autonomous Database on dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null. It is already set at the Autonomous Exadata Infrastructure level. When provisioning an [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) database, if a value is not specified, the system defaults the value to `BRING_YOUR_OWN_LICENSE`. Bring your own license (BYOL) also allows you to select the DB edition using the optional parameter.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="localAdgAutoFailoverMaxDataLossLimit")
    def local_adg_auto_failover_max_data_loss_limit(self) -> _builtins.int:
        """
        Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        """
        return pulumi.get(self, "local_adg_auto_failover_max_data_loss_limit")

    @_builtins.property
    @pulumi.getter(name="localDisasterRecoveryType")
    def local_disaster_recovery_type(self) -> _builtins.str:
        """
        Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "local_disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="localStandbyDbs")
    def local_standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult']:
        """
        Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "local_standby_dbs")

    @_builtins.property
    @pulumi.getter(name="longTermBackupSchedules")
    def long_term_backup_schedules(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult']:
        """
        Details for the long-term backup schedule.
        """
        return pulumi.get(self, "long_term_backup_schedules")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter(name="maxCpuCoreCount")
    def max_cpu_core_count(self) -> _builtins.int:
        return pulumi.get(self, "max_cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> _builtins.int:
        """
        The amount of memory (in GBs) enabled per ECPU or OCPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="netServicesArchitecture")
    def net_services_architecture(self) -> _builtins.str:
        """
        Enabling SHARED server architecture enables a database server to allow many client processes to share very few server processes, thereby increasing the number of supported users.
        """
        return pulumi.get(self, "net_services_architecture")

    @_builtins.property
    @pulumi.getter(name="nextLongTermBackupTimeStamp")
    def next_long_term_backup_time_stamp(self) -> _builtins.str:
        """
        The date and time when the next long-term backup would be created.
        """
        return pulumi.get(self, "next_long_term_backup_time_stamp")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> _builtins.float:
        """
        The number of OCPU cores to be made available to the database.
        """
        return pulumi.get(self, "ocpu_count")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> _builtins.str:
        """
        Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        """
        return pulumi.get(self, "open_mode")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> _builtins.str:
        """
        Status of Operations Insights for this Autonomous Database.
        """
        return pulumi.get(self, "operations_insights_status")

    @_builtins.property
    @pulumi.getter(name="peerDbId")
    def peer_db_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_db_id")

    @_builtins.property
    @pulumi.getter(name="peerDbIds")
    def peer_db_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for Autonomous Database Serverless instances, standby databases located in the same region as the source primary database do not have OCIDs.
        """
        return pulumi.get(self, "peer_db_ids")

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> _builtins.str:
        """
        The Autonomous Database permission level. Restricted mode allows access only by admin users.
        """
        return pulumi.get(self, "permission_level")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> _builtins.str:
        """
        The private endpoint for the resource.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> _builtins.str:
        """
        The private endpoint Ip address for the resource.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @_builtins.property
    @pulumi.getter(name="privateEndpointLabel")
    def private_endpoint_label(self) -> _builtins.str:
        """
        The private endpoint label for the resource.
        """
        return pulumi.get(self, "private_endpoint_label")

    @_builtins.property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[_builtins.float]:
        """
        An array of CPU values that an Autonomous Database can be scaled to.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @_builtins.property
    @pulumi.getter(name="publicConnectionUrls")
    def public_connection_urls(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabasePublicConnectionUrlResult']:
        """
        The Public URLs of Private Endpoint database for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN.
        """
        return pulumi.get(self, "public_connection_urls")

    @_builtins.property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> _builtins.str:
        """
        The public endpoint for the private endpoint enabled resource.
        """
        return pulumi.get(self, "public_endpoint")

    @_builtins.property
    @pulumi.getter(name="refreshableMode")
    def refreshable_mode(self) -> _builtins.str:
        """
        The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_mode")

    @_builtins.property
    @pulumi.getter(name="refreshableStatus")
    def refreshable_status(self) -> _builtins.str:
        """
        The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_status")

    @_builtins.property
    @pulumi.getter(name="remoteDisasterRecoveryConfigurations")
    def remote_disaster_recovery_configurations(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult']:
        """
        Configurations of a Disaster Recovery.
        """
        return pulumi.get(self, "remote_disaster_recovery_configurations")

    @_builtins.property
    @pulumi.getter(name="remoteDisasterRecoveryType")
    def remote_disaster_recovery_type(self) -> _builtins.str:
        return pulumi.get(self, "remote_disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="resourcePoolLeaderId")
    def resource_pool_leader_id(self) -> _builtins.str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resourcepool Leader Autonomous Database.
        """
        return pulumi.get(self, "resource_pool_leader_id")

    @_builtins.property
    @pulumi.getter(name="resourcePoolSummaries")
    def resource_pool_summaries(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult']:
        """
        The configuration details for resource pool
        """
        return pulumi.get(self, "resource_pool_summaries")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="rotateKeyTrigger")
    def rotate_key_trigger(self) -> _builtins.bool:
        return pulumi.get(self, "rotate_key_trigger")

    @_builtins.property
    @pulumi.getter(name="scheduledOperations")
    def scheduled_operations(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult']:
        """
        The list of scheduled operations. Consists of values such as dayOfWeek, scheduledStartTime, scheduledStopTime.
        """
        return pulumi.get(self, "scheduled_operations")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter(name="secretVersionNumber")
    def secret_version_number(self) -> _builtins.int:
        return pulumi.get(self, "secret_version_number")

    @_builtins.property
    @pulumi.getter(name="securityAttributes")
    def security_attributes(self) -> Mapping[str, _builtins.str]:
        """
        Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        """
        return pulumi.get(self, "security_attributes")

    @_builtins.property
    @pulumi.getter(name="serviceConsoleUrl")
    def service_console_url(self) -> _builtins.str:
        """
        The URL of the Service Console for the Autonomous Database.
        """
        return pulumi.get(self, "service_console_url")

    @_builtins.property
    @pulumi.getter(name="shrinkAdbTrigger")
    def shrink_adb_trigger(self) -> _builtins.int:
        return pulumi.get(self, "shrink_adb_trigger")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="standbyDbs")
    def standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult']:
        """
        **Deprecated** Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "standby_dbs")

    @_builtins.property
    @pulumi.getter(name="standbyWhitelistedIps")
    def standby_whitelisted_ips(self) -> Sequence[_builtins.str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        """
        return pulumi.get(self, "standby_whitelisted_ips")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="supportedRegionsToCloneTos")
    def supported_regions_to_clone_tos(self) -> Sequence[_builtins.str]:
        """
        The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        """
        return pulumi.get(self, "supported_regions_to_clone_tos")

    @_builtins.property
    @pulumi.getter(name="switchoverTo")
    def switchover_to(self) -> _builtins.str:
        return pulumi.get(self, "switchover_to")

    @_builtins.property
    @pulumi.getter(name="switchoverToRemotePeerId")
    def switchover_to_remote_peer_id(self) -> _builtins.str:
        return pulumi.get(self, "switchover_to_remote_peer_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDeletionOfFreeAutonomousDatabase")
    def time_deletion_of_free_autonomous_database(self) -> _builtins.str:
        """
        The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        """
        return pulumi.get(self, "time_deletion_of_free_autonomous_database")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeEarliestAvailableDbVersionUpgrade")
    def time_earliest_available_db_version_upgrade(self) -> _builtins.str:
        """
        The earliest(min) date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        """
        return pulumi.get(self, "time_earliest_available_db_version_upgrade")

    @_builtins.property
    @pulumi.getter(name="timeLatestAvailableDbVersionUpgrade")
    def time_latest_available_db_version_upgrade(self) -> _builtins.str:
        """
        The max date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        """
        return pulumi.get(self, "time_latest_available_db_version_upgrade")

    @_builtins.property
    @pulumi.getter(name="timeLocalDataGuardEnabled")
    def time_local_data_guard_enabled(self) -> _builtins.str:
        """
        The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        """
        return pulumi.get(self, "time_local_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")

    @_builtins.property
    @pulumi.getter(name="timeOfAutoRefreshStart")
    def time_of_auto_refresh_start(self) -> _builtins.str:
        """
        The the date and time that auto-refreshing will begin for an Autonomous Database refreshable clone. This value controls only the start time for the first refresh operation. Subsequent (ongoing) refresh operations have start times controlled by the value of the `autoRefreshFrequencyInSeconds` parameter.
        """
        return pulumi.get(self, "time_of_auto_refresh_start")

    @_builtins.property
    @pulumi.getter(name="timeOfJoiningResourcePool")
    def time_of_joining_resource_pool(self) -> _builtins.str:
        """
        The time the member joined the resource pool.
        """
        return pulumi.get(self, "time_of_joining_resource_pool")

    @_builtins.property
    @pulumi.getter(name="timeOfLastFailover")
    def time_of_last_failover(self) -> _builtins.str:
        """
        The timestamp of the last failover operation.
        """
        return pulumi.get(self, "time_of_last_failover")

    @_builtins.property
    @pulumi.getter(name="timeOfLastRefresh")
    def time_of_last_refresh(self) -> _builtins.str:
        """
        The date and time when last refresh happened.
        """
        return pulumi.get(self, "time_of_last_refresh")

    @_builtins.property
    @pulumi.getter(name="timeOfLastRefreshPoint")
    def time_of_last_refresh_point(self) -> _builtins.str:
        """
        The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        """
        return pulumi.get(self, "time_of_last_refresh_point")

    @_builtins.property
    @pulumi.getter(name="timeOfLastSwitchover")
    def time_of_last_switchover(self) -> _builtins.str:
        """
        The timestamp of the last switchover operation for the Autonomous Database.
        """
        return pulumi.get(self, "time_of_last_switchover")

    @_builtins.property
    @pulumi.getter(name="timeOfNextRefresh")
    def time_of_next_refresh(self) -> _builtins.str:
        """
        The date and time of next refresh.
        """
        return pulumi.get(self, "time_of_next_refresh")

    @_builtins.property
    @pulumi.getter(name="timeReclamationOfFreeAutonomousDatabase")
    def time_reclamation_of_free_autonomous_database(self) -> _builtins.str:
        """
        The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        """
        return pulumi.get(self, "time_reclamation_of_free_autonomous_database")

    @_builtins.property
    @pulumi.getter(name="timeScheduledDbVersionUpgrade")
    def time_scheduled_db_version_upgrade(self) -> _builtins.str:
        """
        The date and time the Autonomous Database scheduled to upgrade to 23ai.
        """
        return pulumi.get(self, "time_scheduled_db_version_upgrade")

    @_builtins.property
    @pulumi.getter(name="timeUndeleted")
    def time_undeleted(self) -> _builtins.str:
        """
        The date and time the Autonomous Database was most recently undeleted.
        """
        return pulumi.get(self, "time_undeleted")

    @_builtins.property
    @pulumi.getter(name="timeUntilReconnectCloneEnabled")
    def time_until_reconnect_clone_enabled(self) -> _builtins.str:
        """
        The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        """
        return pulumi.get(self, "time_until_reconnect_clone_enabled")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="totalBackupStorageSizeInGbs")
    def total_backup_storage_size_in_gbs(self) -> _builtins.float:
        """
        The backup storage to the database.
        """
        return pulumi.get(self, "total_backup_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="useLatestAvailableBackupTimeStamp")
    def use_latest_available_backup_time_stamp(self) -> _builtins.bool:
        return pulumi.get(self, "use_latest_available_backup_time_stamp")

    @_builtins.property
    @pulumi.getter(name="usedDataStorageSizeInGbs")
    def used_data_storage_size_in_gbs(self) -> _builtins.int:
        """
        The storage space consumed by Autonomous Database in GBs.
        """
        return pulumi.get(self, "used_data_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="usedDataStorageSizeInTbs")
    def used_data_storage_size_in_tbs(self) -> _builtins.int:
        """
        The amount of storage that has been used for Autonomous Databases in dedicated infrastructure, in terabytes.
        """
        return pulumi.get(self, "used_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="whitelistedIps")
    def whitelisted_ips(self) -> Sequence[_builtins.str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        """
        return pulumi.get(self, "whitelisted_ips")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseApexDetailResult(dict):
    def __init__(__self__, *,
                 apex_version: _builtins.str,
                 ords_version: _builtins.str):
        """
        :param _builtins.str apex_version: The Oracle APEX Application Development version.
        :param _builtins.str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        pulumi.set(__self__, "apex_version", apex_version)
        pulumi.set(__self__, "ords_version", ords_version)

    @_builtins.property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> _builtins.str:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @_builtins.property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 manual_backup_bucket_name: _builtins.str,
                 manual_backup_type: _builtins.str):
        """
        :param _builtins.str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param _builtins.str manual_backup_type: The manual backup destination type.
        """
        pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @_builtins.property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> _builtins.str:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @_builtins.property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> _builtins.str:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 dedicated: _builtins.str,
                 high: _builtins.str,
                 low: _builtins.str,
                 medium: _builtins.str,
                 profiles: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult']):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param _builtins.str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param _builtins.str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "dedicated", dedicated)
        pulumi.set(__self__, "high", high)
        pulumi.set(__self__, "low", low)
        pulumi.set(__self__, "medium", medium)
        pulumi.set(__self__, "profiles", profiles)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter
    def dedicated(self) -> _builtins.str:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @_builtins.property
    @pulumi.getter
    def high(self) -> _builtins.str:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @_builtins.property
    @pulumi.getter
    def low(self) -> _builtins.str:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @_builtins.property
    @pulumi.getter
    def medium(self) -> _builtins.str:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @_builtins.property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult']:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult(dict):
    def __init__(__self__, *,
                 consumer_group: _builtins.str,
                 display_name: _builtins.str,
                 host_format: _builtins.str,
                 is_regional: _builtins.bool,
                 protocol: _builtins.str,
                 session_mode: _builtins.str,
                 syntax_format: _builtins.str,
                 tls_authentication: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str consumer_group: Consumer group used by the connection.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str host_format: Host format used in connection string.
        :param _builtins.bool is_regional: True for a regional connection string, applicable to cross-region DG only.
        :param _builtins.str protocol: Protocol used by the connection.
        :param _builtins.str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param _builtins.str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        :param _builtins.str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param _builtins.str value: Connection string value.
        """
        pulumi.set(__self__, "consumer_group", consumer_group)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "host_format", host_format)
        pulumi.set(__self__, "is_regional", is_regional)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "session_mode", session_mode)
        pulumi.set(__self__, "syntax_format", syntax_format)
        pulumi.set(__self__, "tls_authentication", tls_authentication)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> _builtins.str:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> _builtins.str:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @_builtins.property
    @pulumi.getter(name="isRegional")
    def is_regional(self) -> _builtins.bool:
        """
        True for a regional connection string, applicable to cross-region DG only.
        """
        return pulumi.get(self, "is_regional")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> _builtins.str:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @_builtins.property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> _builtins.str:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @_builtins.property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> _builtins.str:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: _builtins.str,
                 database_transforms_url: _builtins.str,
                 graph_studio_url: _builtins.str,
                 machine_learning_notebook_url: _builtins.str,
                 machine_learning_user_management_url: _builtins.str,
                 mongo_db_url: _builtins.str,
                 ords_url: _builtins.str,
                 sql_dev_web_url: _builtins.str):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        pulumi.set(__self__, "apex_url", apex_url)
        pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        pulumi.set(__self__, "ords_url", ords_url)
        pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> _builtins.str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> _builtins.str:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> _builtins.str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> _builtins.str:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> _builtins.str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> _builtins.str:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> _builtins.str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseDbToolsDetailResult(dict):
    def __init__(__self__, *,
                 compute_count: _builtins.float,
                 is_enabled: _builtins.bool,
                 max_idle_time_in_minutes: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.float compute_count: Compute used by database tools.
        :param _builtins.bool is_enabled: Indicates whether tool is enabled.
        :param _builtins.int max_idle_time_in_minutes: The max idle time, in minutes, after which the VM used by database tools will be terminated.
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "max_idle_time_in_minutes", max_idle_time_in_minutes)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.float:
        """
        Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Indicates whether tool is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="maxIdleTimeInMinutes")
    def max_idle_time_in_minutes(self) -> _builtins.int:
        """
        The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        return pulumi.get(self, "max_idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 arn_role: _builtins.str,
                 autonomous_database_provider: _builtins.str,
                 certificate_directory_name: _builtins.str,
                 certificate_id: _builtins.str,
                 directory_name: _builtins.str,
                 external_id: _builtins.str,
                 key_arn: _builtins.str,
                 key_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 okv_kms_key: _builtins.str,
                 okv_uri: _builtins.str,
                 service_endpoint_uri: _builtins.str,
                 vault_id: _builtins.str,
                 vault_uri: _builtins.str):
        """
        :param _builtins.str arn_role: AWS ARN role
        :param _builtins.str autonomous_database_provider: The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: OKV certificate directory name
        :param _builtins.str certificate_id: OKV certificate id
        :param _builtins.str directory_name: OKV wallet directory name
        :param _builtins.str external_id: AWS external ID
        :param _builtins.str key_arn: AWS key ARN
        :param _builtins.str key_name: Azure key name
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: UUID of OKV KMS Key
        :param _builtins.str okv_uri: URI of OKV server
        :param _builtins.str service_endpoint_uri: AWS key service endpoint URI
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vault_uri: Azure vault URI
        """
        pulumi.set(__self__, "arn_role", arn_role)
        pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        pulumi.set(__self__, "okv_uri", okv_uri)
        pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> _builtins.str:
        """
        AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> _builtins.str:
        """
        The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> _builtins.str:
        """
        OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> _builtins.str:
        """
        OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> _builtins.str:
        """
        UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> _builtins.str:
        """
        URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> _builtins.str:
        """
        AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 encryption_keys: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult'],
                 time_activated: _builtins.str):
        """
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs'] encryption_keys: Details of the Autonomous Database encryption key.
        :param _builtins.str time_activated: The date and time the kms key activated.
        """
        pulumi.set(__self__, "encryption_keys", encryption_keys)
        pulumi.set(__self__, "time_activated", time_activated)

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult']:
        """
        Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 arn_role: _builtins.str,
                 autonomous_database_provider: _builtins.str,
                 certificate_directory_name: _builtins.str,
                 certificate_id: _builtins.str,
                 directory_name: _builtins.str,
                 external_id: _builtins.str,
                 key_arn: _builtins.str,
                 key_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 okv_kms_key: _builtins.str,
                 okv_uri: _builtins.str,
                 service_endpoint_uri: _builtins.str,
                 vault_id: _builtins.str,
                 vault_uri: _builtins.str):
        """
        :param _builtins.str arn_role: AWS ARN role
        :param _builtins.str autonomous_database_provider: The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: OKV certificate directory name
        :param _builtins.str certificate_id: OKV certificate id
        :param _builtins.str directory_name: OKV wallet directory name
        :param _builtins.str external_id: AWS external ID
        :param _builtins.str key_arn: AWS key ARN
        :param _builtins.str key_name: Azure key name
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: UUID of OKV KMS Key
        :param _builtins.str okv_uri: URI of OKV server
        :param _builtins.str service_endpoint_uri: AWS key service endpoint URI
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vault_uri: Azure vault URI
        """
        pulumi.set(__self__, "arn_role", arn_role)
        pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        pulumi.set(__self__, "okv_uri", okv_uri)
        pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> _builtins.str:
        """
        AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> _builtins.str:
        """
        The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> _builtins.str:
        """
        OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> _builtins.str:
        """
        OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> _builtins.str:
        """
        UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> _builtins.str:
        """
        URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> _builtins.str:
        """
        AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 time_activated: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 lag_time_in_seconds: _builtins.int,
                 lifecycle_details: _builtins.str,
                 maintenance_target_component: _builtins.str,
                 state: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> _builtins.int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult(dict):
    def __init__(__self__, *,
                 is_disabled: _builtins.bool,
                 repeat_cadence: _builtins.str,
                 retention_period_in_days: _builtins.int,
                 time_of_backup: _builtins.str):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.str repeat_cadence: The frequency of the long-term backup schedule
        :param _builtins.int retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "repeat_cadence", repeat_cadence)
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "time_of_backup", time_of_backup)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> _builtins.bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> _builtins.str:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> _builtins.str:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabasePublicConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: _builtins.str,
                 database_transforms_url: _builtins.str,
                 graph_studio_url: _builtins.str,
                 machine_learning_notebook_url: _builtins.str,
                 machine_learning_user_management_url: _builtins.str,
                 mongo_db_url: _builtins.str,
                 ords_url: _builtins.str,
                 sql_dev_web_url: _builtins.str):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        pulumi.set(__self__, "apex_url", apex_url)
        pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        pulumi.set(__self__, "ords_url", ords_url)
        pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> _builtins.str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> _builtins.str:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> _builtins.str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> _builtins.str:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> _builtins.str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> _builtins.str:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> _builtins.str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult(dict):
    def __init__(__self__, *,
                 disaster_recovery_type: _builtins.str,
                 is_replicate_automatic_backups: _builtins.bool,
                 is_snapshot_standby: _builtins.bool,
                 time_snapshot_standby_enabled_till: _builtins.str):
        """
        :param _builtins.str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param _builtins.bool is_replicate_automatic_backups: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        :param _builtins.bool is_snapshot_standby: Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        :param _builtins.str time_snapshot_standby_enabled_till: Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)
        pulumi.set(__self__, "is_replicate_automatic_backups", is_replicate_automatic_backups)
        pulumi.set(__self__, "is_snapshot_standby", is_snapshot_standby)
        pulumi.set(__self__, "time_snapshot_standby_enabled_till", time_snapshot_standby_enabled_till)

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> _builtins.str:
        """
        Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="isReplicateAutomaticBackups")
    def is_replicate_automatic_backups(self) -> _builtins.bool:
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        return pulumi.get(self, "is_replicate_automatic_backups")

    @_builtins.property
    @pulumi.getter(name="isSnapshotStandby")
    def is_snapshot_standby(self) -> _builtins.bool:
        """
        Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        """
        return pulumi.get(self, "is_snapshot_standby")

    @_builtins.property
    @pulumi.getter(name="timeSnapshotStandbyEnabledTill")
    def time_snapshot_standby_enabled_till(self) -> _builtins.str:
        """
        Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        return pulumi.get(self, "time_snapshot_standby_enabled_till")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult(dict):
    def __init__(__self__, *,
                 is_disabled: _builtins.bool,
                 pool_size: _builtins.int):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.int pool_size: Resource pool size.
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "pool_size", pool_size)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> _builtins.bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> _builtins.int:
        """
        Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult'],
                 scheduled_start_time: _builtins.str,
                 scheduled_stop_time: _builtins.str):
        """
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_weeks: Day of the week.
        :param _builtins.str scheduled_start_time: auto start time. value must be of ISO-8601 format "HH:mm"
        :param _builtins.str scheduled_stop_time: auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "scheduled_start_time", scheduled_start_time)
        pulumi.set(__self__, "scheduled_stop_time", scheduled_stop_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult']:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @_builtins.property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> _builtins.str:
        """
        auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @_builtins.property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> _builtins.str:
        """
        auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 lag_time_in_seconds: _builtins.int,
                 lifecycle_details: _builtins.str,
                 maintenance_target_component: _builtins.str,
                 state: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> _builtins.int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseResult(dict):
    def __init__(__self__, *,
                 actual_used_data_storage_size_in_tbs: _builtins.float,
                 allocated_storage_size_in_tbs: _builtins.float,
                 apex_details: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult'],
                 are_primary_whitelisted_ips_used: _builtins.bool,
                 auto_refresh_frequency_in_seconds: _builtins.int,
                 auto_refresh_point_lag_in_seconds: _builtins.int,
                 autonomous_container_database_id: _builtins.str,
                 autonomous_maintenance_schedule_type: _builtins.str,
                 availability_domain: _builtins.str,
                 available_upgrade_versions: Sequence[_builtins.str],
                 backup_configs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult'],
                 backup_retention_period_in_days: _builtins.int,
                 byol_compute_count_limit: _builtins.float,
                 character_set: _builtins.str,
                 clone_table_space_lists: Sequence[_builtins.int],
                 cluster_placement_group_id: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_count: _builtins.float,
                 compute_model: _builtins.str,
                 connection_strings: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult'],
                 connection_urls: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult'],
                 cpu_core_count: _builtins.int,
                 customer_contacts: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult'],
                 data_safe_status: _builtins.str,
                 data_storage_size_in_gb: _builtins.int,
                 data_storage_size_in_tbs: _builtins.int,
                 database_edition: _builtins.str,
                 database_management_status: _builtins.str,
                 dataguard_region_type: _builtins.str,
                 db_name: _builtins.str,
                 db_tools_details: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseDbToolsDetailResult'],
                 db_version: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 disaster_recovery_region_type: _builtins.str,
                 display_name: _builtins.str,
                 encryption_key_history_entries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryResult'],
                 encryption_keys: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyResult'],
                 failed_data_recovery_in_seconds: _builtins.int,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 in_memory_area_in_gbs: _builtins.int,
                 in_memory_percentage: _builtins.int,
                 infrastructure_type: _builtins.str,
                 is_access_control_enabled: _builtins.bool,
                 is_auto_scaling_enabled: _builtins.bool,
                 is_auto_scaling_for_storage_enabled: _builtins.bool,
                 is_backup_retention_locked: _builtins.bool,
                 is_data_guard_enabled: _builtins.bool,
                 is_dedicated: _builtins.bool,
                 is_dev_tier: _builtins.bool,
                 is_free_tier: _builtins.bool,
                 is_local_data_guard_enabled: _builtins.bool,
                 is_mtls_connection_required: _builtins.bool,
                 is_preview: _builtins.bool,
                 is_reconnect_clone_enabled: _builtins.bool,
                 is_refreshable_clone: _builtins.bool,
                 is_remote_data_guard_enabled: _builtins.bool,
                 key_history_entries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult'],
                 key_store_id: _builtins.str,
                 key_store_wallet_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_lifecycle_details: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 local_adg_auto_failover_max_data_loss_limit: _builtins.int,
                 local_disaster_recovery_type: _builtins.str,
                 local_standby_dbs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult'],
                 long_term_backup_schedules: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult'],
                 maintenance_target_component: _builtins.str,
                 max_cpu_core_count: _builtins.int,
                 memory_per_oracle_compute_unit_in_gbs: _builtins.int,
                 ncharacter_set: _builtins.str,
                 net_services_architecture: _builtins.str,
                 next_long_term_backup_time_stamp: _builtins.str,
                 nsg_ids: Sequence[_builtins.str],
                 ocpu_count: _builtins.float,
                 open_mode: _builtins.str,
                 peer_db_ids: Sequence[_builtins.str],
                 private_endpoint: _builtins.str,
                 private_endpoint_ip: _builtins.str,
                 private_endpoint_label: _builtins.str,
                 provisionable_cpuses: Sequence[_builtins.float],
                 public_connection_urls: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabasePublicConnectionUrlResult'],
                 public_endpoint: _builtins.str,
                 refreshable_mode: _builtins.str,
                 refreshable_status: _builtins.str,
                 remote_disaster_recovery_configurations: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult'],
                 resource_pool_leader_id: _builtins.str,
                 resource_pool_summaries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult'],
                 role: _builtins.str,
                 scheduled_operations: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult'],
                 security_attributes: Mapping[str, _builtins.str],
                 service_console_url: _builtins.str,
                 source_id: _builtins.str,
                 standby_dbs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult'],
                 standby_whitelisted_ips: Sequence[_builtins.str],
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 subscription_id: _builtins.str,
                 supported_regions_to_clone_tos: Sequence[_builtins.str],
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_deletion_of_free_autonomous_database: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_earliest_available_db_version_upgrade: _builtins.str,
                 time_latest_available_db_version_upgrade: _builtins.str,
                 time_local_data_guard_enabled: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str,
                 time_of_auto_refresh_start: _builtins.str,
                 time_of_joining_resource_pool: _builtins.str,
                 time_of_last_failover: _builtins.str,
                 time_of_last_refresh: _builtins.str,
                 time_of_last_refresh_point: _builtins.str,
                 time_of_last_switchover: _builtins.str,
                 time_of_next_refresh: _builtins.str,
                 time_reclamation_of_free_autonomous_database: _builtins.str,
                 time_scheduled_db_version_upgrade: _builtins.str,
                 time_undeleted: _builtins.str,
                 time_until_reconnect_clone_enabled: _builtins.str,
                 total_backup_storage_size_in_gbs: _builtins.float,
                 used_data_storage_size_in_gbs: _builtins.int,
                 used_data_storage_size_in_tbs: _builtins.int,
                 vault_id: _builtins.str,
                 whitelisted_ips: Sequence[_builtins.str]):
        """
        :param _builtins.float actual_used_data_storage_size_in_tbs: The current amount of storage in use for user and system data, in terabytes (TB).
        :param _builtins.float allocated_storage_size_in_tbs: The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailArgs'] apex_details: Information about Oracle APEX Application Development.
        :param _builtins.bool are_primary_whitelisted_ips_used: This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        :param _builtins.int auto_refresh_frequency_in_seconds: The frequency a refreshable clone is refreshed after auto-refresh is enabled. The minimum is 1 hour. The maximum is 7 days. The date and time that auto-refresh is enabled is controlled by the `timeOfAutoRefreshStart` parameter.
        :param _builtins.int auto_refresh_point_lag_in_seconds: The time, in seconds, the data of the refreshable clone lags the primary database at the point of refresh. The minimum is 0 minutes (0 mins means refresh to the latest available timestamp). The maximum is 7 days. The lag time increases after refreshing until the next data refresh happens.
        :param _builtins.str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        :param _builtins.str autonomous_maintenance_schedule_type: The maintenance schedule type of the Autonomous Database Serverless. An EARLY maintenance schedule follows a schedule applying patches prior to the REGULAR schedule. A REGULAR maintenance schedule follows the normal cycle
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param Sequence[_builtins.str] available_upgrade_versions: List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigArgs'] backup_configs: Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        :param _builtins.int backup_retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.float byol_compute_count_limit: The maximum number of CPUs allowed with a Bring Your Own License (BYOL), including those used for auto-scaling, disaster recovery, tools, etc. Any CPU usage above this limit is considered as License Included and billed.
        :param _builtins.str character_set: The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        :param Sequence[_builtins.int] clone_table_space_lists: A list of the source Autonomous Database's table space number(s) used to create this partial clone from the backup.
        :param _builtins.str cluster_placement_group_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cluster placement group of the Autonomous Serverless Database.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.float compute_count: Compute used by database tools.
        :param _builtins.str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringArgs'] connection_strings: The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlArgs'] connection_urls: The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        :param _builtins.int cpu_core_count: The number of CPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Database on Dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactArgs'] customer_contacts: Customer Contacts.
        :param _builtins.str data_safe_status: Status of the Data Safe registration for this Autonomous Database.
        :param _builtins.int data_storage_size_in_gb: The quantity of data in the database, in gigabytes.
        :param _builtins.int data_storage_size_in_tbs: The quantity of data in the database, in terabytes.
        :param _builtins.str database_edition: The Oracle Database Edition that applies to the Autonomous databases.
        :param _builtins.str database_management_status: Status of Database Management for this Autonomous Database.
        :param _builtins.str dataguard_region_type: **Deprecated.** The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Database Serverless, Autonomous Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Autonomous Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Autonomous Data Guard association, and cannot be performed when the database using the primary role is operating in a remote Autonomous Data Guard standby region.
        :param _builtins.str db_name: The database name.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseDbToolsDetailArgs'] db_tools_details: The list of database tools details.
        :param _builtins.str db_version: A valid Oracle Database version for Autonomous Database.
        :param _builtins.str db_workload: The Autonomous Database workload type. The following values are valid:
               * OLTP - indicates an Autonomous Transaction Processing database
               * DW - indicates an Autonomous Data Warehouse database
               * AJD - indicates an Autonomous JSON Database
               * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str disaster_recovery_region_type: **Deprecated.** The disaster recovery (DR) region type of the Autonomous Database. For Autonomous Database Serverless instances, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryArgs'] encryption_key_history_entries: Key History Entry.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyArgs'] encryption_keys: Details of the Autonomous Database encryption key.
        :param _builtins.int failed_data_recovery_in_seconds: Indicates the number of seconds of data loss for a Data Guard failover.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.int in_memory_area_in_gbs: The area assigned to In-Memory tables in Autonomous Database.
        :param _builtins.int in_memory_percentage: The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database. This property is applicable only to Autonomous Databases on the Exadata Cloud@Customer platform.
        :param _builtins.str infrastructure_type: The infrastructure type this resource belongs to.
        :param _builtins.bool is_access_control_enabled: Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        :param _builtins.bool is_auto_scaling_enabled: Indicates if auto scaling is enabled for the Autonomous Database CPU core count. The default value is `TRUE`.
        :param _builtins.bool is_auto_scaling_for_storage_enabled: Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        :param _builtins.bool is_backup_retention_locked: Indicates if the Autonomous Database is backup retention locked.
        :param _builtins.bool is_data_guard_enabled: **Deprecated.** Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param _builtins.bool is_dedicated: True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        :param _builtins.bool is_dev_tier: Autonomous Database for Developers are fixed-shape Autonomous Databases that developers can use to build and test new applications. On Serverless, these are low-cost and billed per instance, on Dedicated and Cloud@Customer there is no additional cost to create Developer databases. Developer databases come with limited resources and is not intended for large-scale testing and production deployments. When you need more compute or storage resources, you may upgrade to a full paid production database.
        :param _builtins.bool is_free_tier: Indicates if this is an Always Free resource. The default value is false. Note that Always Free Autonomous Databases have 1 CPU and 20GB of memory. For Always Free databases, memory and CPU cannot be scaled.
        :param _builtins.bool is_local_data_guard_enabled: Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param _builtins.bool is_mtls_connection_required: Specifies if the Autonomous Database requires mTLS connections.
        :param _builtins.bool is_preview: Indicates if the Autonomous Database version is a preview version.
        :param _builtins.bool is_reconnect_clone_enabled: Indicates if the refreshable clone can be reconnected to its source database.
        :param _builtins.bool is_refreshable_clone: Indicates if the Autonomous Database is a refreshable clone.
        :param _builtins.bool is_remote_data_guard_enabled: Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryArgs'] key_history_entries: Key History Entry.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_lifecycle_details: KMS key lifecycle details.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str license_model: The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Oracle Database service. Note that when provisioning an [Autonomous Database on dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null. It is already set at the Autonomous Exadata Infrastructure level. When provisioning an [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) database, if a value is not specified, the system defaults the value to `BRING_YOUR_OWN_LICENSE`. Bring your own license (BYOL) also allows you to select the DB edition using the optional parameter.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int local_adg_auto_failover_max_data_loss_limit: Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        :param _builtins.str local_disaster_recovery_type: Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbArgs'] local_standby_dbs: Autonomous Data Guard standby database details.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleArgs'] long_term_backup_schedules: Details for the long-term backup schedule.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per ECPU or OCPU.
        :param _builtins.str ncharacter_set: The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param _builtins.str net_services_architecture: Enabling SHARED server architecture enables a database server to allow many client processes to share very few server processes, thereby increasing the number of supported users.
        :param _builtins.str next_long_term_backup_time_stamp: The date and time when the next long-term backup would be created.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.float ocpu_count: The number of OCPU cores to be made available to the database.
        :param _builtins.str open_mode: Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        :param Sequence[_builtins.str] peer_db_ids: The list of [OCIDs](https://docs.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for Autonomous Database Serverless instances, standby databases located in the same region as the source primary database do not have OCIDs.
        :param _builtins.str private_endpoint: The private endpoint for the resource.
        :param _builtins.str private_endpoint_ip: The private endpoint Ip address for the resource.
        :param _builtins.str private_endpoint_label: The resource's private endpoint label.
               * Setting the endpoint label to a non-empty string creates a private endpoint database.
               * Resetting the endpoint label to an empty string, after the creation of the private endpoint database, changes the private endpoint database to a public endpoint database.
               * Setting the endpoint label to a non-empty string value, updates to a new private endpoint database, when the database is disabled and re-enabled.
        :param Sequence[_builtins.float] provisionable_cpuses: An array of CPU values that an Autonomous Database can be scaled to.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabasePublicConnectionUrlArgs'] public_connection_urls: The Public URLs of Private Endpoint database for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN.
        :param _builtins.str public_endpoint: The public endpoint for the private endpoint enabled resource.
        :param _builtins.str refreshable_mode: The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        :param _builtins.str refreshable_status: The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs'] remote_disaster_recovery_configurations: Configurations of a Disaster Recovery.
        :param _builtins.str resource_pool_leader_id: The unique identifier for leader autonomous database OCID [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryArgs'] resource_pool_summaries: The configuration details for resource pool
        :param _builtins.str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationArgs'] scheduled_operations: The list of scheduled operations. Consists of values such as dayOfWeek, scheduledStartTime, scheduledStopTime.
        :param Mapping[str, _builtins.str] security_attributes: Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        :param _builtins.str service_console_url: The URL of the Service Console for the Autonomous Database.
        :param _builtins.str source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbArgs'] standby_dbs: **Deprecated** Autonomous Data Guard standby database details.
        :param Sequence[_builtins.str] standby_whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Sequence[_builtins.str] supported_regions_to_clone_tos: The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Autonomous Database was created.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_deletion_of_free_autonomous_database: The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_earliest_available_db_version_upgrade: The earliest(min) date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        :param _builtins.str time_latest_available_db_version_upgrade: The max date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        :param _builtins.str time_local_data_guard_enabled: The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        :param _builtins.str time_of_auto_refresh_start: The the date and time that auto-refreshing will begin for an Autonomous Database refreshable clone. This value controls only the start time for the first refresh operation. Subsequent (ongoing) refresh operations have start times controlled by the value of the `autoRefreshFrequencyInSeconds` parameter.
        :param _builtins.str time_of_joining_resource_pool: The time the member joined the resource pool.
        :param _builtins.str time_of_last_failover: The timestamp of the last failover operation.
        :param _builtins.str time_of_last_refresh: The date and time when last refresh happened.
        :param _builtins.str time_of_last_refresh_point: The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        :param _builtins.str time_of_last_switchover: The timestamp of the last switchover operation for the Autonomous Database.
        :param _builtins.str time_of_next_refresh: The date and time of next refresh.
        :param _builtins.str time_reclamation_of_free_autonomous_database: The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        :param _builtins.str time_scheduled_db_version_upgrade: The date and time the Autonomous Database scheduled to upgrade to 23ai.
        :param _builtins.str time_undeleted: The date and time the Autonomous Database was most recently undeleted.
        :param _builtins.str time_until_reconnect_clone_enabled: The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        :param _builtins.float total_backup_storage_size_in_gbs: The backup storage to the database.
        :param _builtins.int used_data_storage_size_in_gbs: The storage space consumed by Autonomous Database in GBs.
        :param _builtins.int used_data_storage_size_in_tbs: The amount of storage that has been used for Autonomous Databases in dedicated infrastructure, in terabytes.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param Sequence[_builtins.str] whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        """
        pulumi.set(__self__, "actual_used_data_storage_size_in_tbs", actual_used_data_storage_size_in_tbs)
        pulumi.set(__self__, "allocated_storage_size_in_tbs", allocated_storage_size_in_tbs)
        pulumi.set(__self__, "apex_details", apex_details)
        pulumi.set(__self__, "are_primary_whitelisted_ips_used", are_primary_whitelisted_ips_used)
        pulumi.set(__self__, "auto_refresh_frequency_in_seconds", auto_refresh_frequency_in_seconds)
        pulumi.set(__self__, "auto_refresh_point_lag_in_seconds", auto_refresh_point_lag_in_seconds)
        pulumi.set(__self__, "autonomous_container_database_id", autonomous_container_database_id)
        pulumi.set(__self__, "autonomous_maintenance_schedule_type", autonomous_maintenance_schedule_type)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "available_upgrade_versions", available_upgrade_versions)
        pulumi.set(__self__, "backup_configs", backup_configs)
        pulumi.set(__self__, "backup_retention_period_in_days", backup_retention_period_in_days)
        pulumi.set(__self__, "byol_compute_count_limit", byol_compute_count_limit)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "clone_table_space_lists", clone_table_space_lists)
        pulumi.set(__self__, "cluster_placement_group_id", cluster_placement_group_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "connection_urls", connection_urls)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "customer_contacts", customer_contacts)
        pulumi.set(__self__, "data_safe_status", data_safe_status)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "dataguard_region_type", dataguard_region_type)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_tools_details", db_tools_details)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "disaster_recovery_region_type", disaster_recovery_region_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "encryption_key_history_entries", encryption_key_history_entries)
        pulumi.set(__self__, "encryption_keys", encryption_keys)
        pulumi.set(__self__, "failed_data_recovery_in_seconds", failed_data_recovery_in_seconds)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "in_memory_area_in_gbs", in_memory_area_in_gbs)
        pulumi.set(__self__, "in_memory_percentage", in_memory_percentage)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        pulumi.set(__self__, "is_access_control_enabled", is_access_control_enabled)
        pulumi.set(__self__, "is_auto_scaling_enabled", is_auto_scaling_enabled)
        pulumi.set(__self__, "is_auto_scaling_for_storage_enabled", is_auto_scaling_for_storage_enabled)
        pulumi.set(__self__, "is_backup_retention_locked", is_backup_retention_locked)
        pulumi.set(__self__, "is_data_guard_enabled", is_data_guard_enabled)
        pulumi.set(__self__, "is_dedicated", is_dedicated)
        pulumi.set(__self__, "is_dev_tier", is_dev_tier)
        pulumi.set(__self__, "is_free_tier", is_free_tier)
        pulumi.set(__self__, "is_local_data_guard_enabled", is_local_data_guard_enabled)
        pulumi.set(__self__, "is_mtls_connection_required", is_mtls_connection_required)
        pulumi.set(__self__, "is_preview", is_preview)
        pulumi.set(__self__, "is_reconnect_clone_enabled", is_reconnect_clone_enabled)
        pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)
        pulumi.set(__self__, "is_remote_data_guard_enabled", is_remote_data_guard_enabled)
        pulumi.set(__self__, "key_history_entries", key_history_entries)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "key_store_wallet_name", key_store_wallet_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_lifecycle_details", kms_key_lifecycle_details)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "local_adg_auto_failover_max_data_loss_limit", local_adg_auto_failover_max_data_loss_limit)
        pulumi.set(__self__, "local_disaster_recovery_type", local_disaster_recovery_type)
        pulumi.set(__self__, "local_standby_dbs", local_standby_dbs)
        pulumi.set(__self__, "long_term_backup_schedules", long_term_backup_schedules)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "max_cpu_core_count", max_cpu_core_count)
        pulumi.set(__self__, "memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "net_services_architecture", net_services_architecture)
        pulumi.set(__self__, "next_long_term_backup_time_stamp", next_long_term_backup_time_stamp)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        pulumi.set(__self__, "open_mode", open_mode)
        pulumi.set(__self__, "peer_db_ids", peer_db_ids)
        pulumi.set(__self__, "private_endpoint", private_endpoint)
        pulumi.set(__self__, "private_endpoint_ip", private_endpoint_ip)
        pulumi.set(__self__, "private_endpoint_label", private_endpoint_label)
        pulumi.set(__self__, "provisionable_cpuses", provisionable_cpuses)
        pulumi.set(__self__, "public_connection_urls", public_connection_urls)
        pulumi.set(__self__, "public_endpoint", public_endpoint)
        pulumi.set(__self__, "refreshable_mode", refreshable_mode)
        pulumi.set(__self__, "refreshable_status", refreshable_status)
        pulumi.set(__self__, "remote_disaster_recovery_configurations", remote_disaster_recovery_configurations)
        pulumi.set(__self__, "resource_pool_leader_id", resource_pool_leader_id)
        pulumi.set(__self__, "resource_pool_summaries", resource_pool_summaries)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "scheduled_operations", scheduled_operations)
        pulumi.set(__self__, "security_attributes", security_attributes)
        pulumi.set(__self__, "service_console_url", service_console_url)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "standby_dbs", standby_dbs)
        pulumi.set(__self__, "standby_whitelisted_ips", standby_whitelisted_ips)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "supported_regions_to_clone_tos", supported_regions_to_clone_tos)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_deletion_of_free_autonomous_database", time_deletion_of_free_autonomous_database)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_earliest_available_db_version_upgrade", time_earliest_available_db_version_upgrade)
        pulumi.set(__self__, "time_latest_available_db_version_upgrade", time_latest_available_db_version_upgrade)
        pulumi.set(__self__, "time_local_data_guard_enabled", time_local_data_guard_enabled)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)
        pulumi.set(__self__, "time_of_auto_refresh_start", time_of_auto_refresh_start)
        pulumi.set(__self__, "time_of_joining_resource_pool", time_of_joining_resource_pool)
        pulumi.set(__self__, "time_of_last_failover", time_of_last_failover)
        pulumi.set(__self__, "time_of_last_refresh", time_of_last_refresh)
        pulumi.set(__self__, "time_of_last_refresh_point", time_of_last_refresh_point)
        pulumi.set(__self__, "time_of_last_switchover", time_of_last_switchover)
        pulumi.set(__self__, "time_of_next_refresh", time_of_next_refresh)
        pulumi.set(__self__, "time_reclamation_of_free_autonomous_database", time_reclamation_of_free_autonomous_database)
        pulumi.set(__self__, "time_scheduled_db_version_upgrade", time_scheduled_db_version_upgrade)
        pulumi.set(__self__, "time_undeleted", time_undeleted)
        pulumi.set(__self__, "time_until_reconnect_clone_enabled", time_until_reconnect_clone_enabled)
        pulumi.set(__self__, "total_backup_storage_size_in_gbs", total_backup_storage_size_in_gbs)
        pulumi.set(__self__, "used_data_storage_size_in_gbs", used_data_storage_size_in_gbs)
        pulumi.set(__self__, "used_data_storage_size_in_tbs", used_data_storage_size_in_tbs)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "whitelisted_ips", whitelisted_ips)

    @_builtins.property
    @pulumi.getter(name="actualUsedDataStorageSizeInTbs")
    def actual_used_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The current amount of storage in use for user and system data, in terabytes (TB).
        """
        return pulumi.get(self, "actual_used_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="allocatedStorageSizeInTbs")
    def allocated_storage_size_in_tbs(self) -> _builtins.float:
        """
        The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        """
        return pulumi.get(self, "allocated_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="apexDetails")
    def apex_details(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult']:
        """
        Information about Oracle APEX Application Development.
        """
        return pulumi.get(self, "apex_details")

    @_builtins.property
    @pulumi.getter(name="arePrimaryWhitelistedIpsUsed")
    def are_primary_whitelisted_ips_used(self) -> _builtins.bool:
        """
        This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        """
        return pulumi.get(self, "are_primary_whitelisted_ips_used")

    @_builtins.property
    @pulumi.getter(name="autoRefreshFrequencyInSeconds")
    def auto_refresh_frequency_in_seconds(self) -> _builtins.int:
        """
        The frequency a refreshable clone is refreshed after auto-refresh is enabled. The minimum is 1 hour. The maximum is 7 days. The date and time that auto-refresh is enabled is controlled by the `timeOfAutoRefreshStart` parameter.
        """
        return pulumi.get(self, "auto_refresh_frequency_in_seconds")

    @_builtins.property
    @pulumi.getter(name="autoRefreshPointLagInSeconds")
    def auto_refresh_point_lag_in_seconds(self) -> _builtins.int:
        """
        The time, in seconds, the data of the refreshable clone lags the primary database at the point of refresh. The minimum is 0 minutes (0 mins means refresh to the latest available timestamp). The maximum is 7 days. The lag time increases after refreshing until the next data refresh happens.
        """
        return pulumi.get(self, "auto_refresh_point_lag_in_seconds")

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> _builtins.str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). Used only by Autonomous Database on Dedicated Exadata Infrastructure.
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @_builtins.property
    @pulumi.getter(name="autonomousMaintenanceScheduleType")
    def autonomous_maintenance_schedule_type(self) -> _builtins.str:
        """
        The maintenance schedule type of the Autonomous Database Serverless. An EARLY maintenance schedule follows a schedule applying patches prior to the REGULAR schedule. A REGULAR maintenance schedule follows the normal cycle
        """
        return pulumi.get(self, "autonomous_maintenance_schedule_type")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="availableUpgradeVersions")
    def available_upgrade_versions(self) -> Sequence[_builtins.str]:
        """
        List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        """
        return pulumi.get(self, "available_upgrade_versions")

    @_builtins.property
    @pulumi.getter(name="backupConfigs")
    def backup_configs(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult']:
        """
        Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        """
        return pulumi.get(self, "backup_configs")

    @_builtins.property
    @pulumi.getter(name="backupRetentionPeriodInDays")
    def backup_retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "backup_retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="byolComputeCountLimit")
    def byol_compute_count_limit(self) -> _builtins.float:
        """
        The maximum number of CPUs allowed with a Bring Your Own License (BYOL), including those used for auto-scaling, disaster recovery, tools, etc. Any CPU usage above this limit is considered as License Included and billed.
        """
        return pulumi.get(self, "byol_compute_count_limit")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="cloneTableSpaceLists")
    def clone_table_space_lists(self) -> Sequence[_builtins.int]:
        """
        A list of the source Autonomous Database's table space number(s) used to create this partial clone from the backup.
        """
        return pulumi.get(self, "clone_table_space_lists")

    @_builtins.property
    @pulumi.getter(name="clusterPlacementGroupId")
    def cluster_placement_group_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cluster placement group of the Autonomous Serverless Database.
        """
        return pulumi.get(self, "cluster_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.float:
        """
        Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult']:
        """
        The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="connectionUrls")
    def connection_urls(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult']:
        """
        The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        """
        return pulumi.get(self, "connection_urls")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Database on Dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult']:
        """
        Customer Contacts.
        """
        return pulumi.get(self, "customer_contacts")

    @_builtins.property
    @pulumi.getter(name="dataSafeStatus")
    def data_safe_status(self) -> _builtins.str:
        """
        Status of the Data Safe registration for this Autonomous Database.
        """
        return pulumi.get(self, "data_safe_status")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> _builtins.int:
        """
        The quantity of data in the database, in gigabytes.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.int:
        """
        The quantity of data in the database, in terabytes.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to the Autonomous databases.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        Status of Database Management for this Autonomous Database.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="dataguardRegionType")
    def dataguard_region_type(self) -> _builtins.str:
        """
        **Deprecated.** The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Database Serverless, Autonomous Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Autonomous Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Autonomous Data Guard association, and cannot be performed when the database using the primary role is operating in a remote Autonomous Data Guard standby region.
        """
        return pulumi.get(self, "dataguard_region_type")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbToolsDetails")
    def db_tools_details(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseDbToolsDetailResult']:
        """
        The list of database tools details.
        """
        return pulumi.get(self, "db_tools_details")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        The Autonomous Database workload type. The following values are valid:
        * OLTP - indicates an Autonomous Transaction Processing database
        * DW - indicates an Autonomous Data Warehouse database
        * AJD - indicates an Autonomous JSON Database
        * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryRegionType")
    def disaster_recovery_region_type(self) -> _builtins.str:
        """
        **Deprecated.** The disaster recovery (DR) region type of the Autonomous Database. For Autonomous Database Serverless instances, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        """
        return pulumi.get(self, "disaster_recovery_region_type")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyHistoryEntries")
    def encryption_key_history_entries(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "encryption_key_history_entries")

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyResult']:
        """
        Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter(name="failedDataRecoveryInSeconds")
    def failed_data_recovery_in_seconds(self) -> _builtins.int:
        """
        Indicates the number of seconds of data loss for a Data Guard failover.
        """
        return pulumi.get(self, "failed_data_recovery_in_seconds")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inMemoryAreaInGbs")
    def in_memory_area_in_gbs(self) -> _builtins.int:
        """
        The area assigned to In-Memory tables in Autonomous Database.
        """
        return pulumi.get(self, "in_memory_area_in_gbs")

    @_builtins.property
    @pulumi.getter(name="inMemoryPercentage")
    def in_memory_percentage(self) -> _builtins.int:
        """
        The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database. This property is applicable only to Autonomous Databases on the Exadata Cloud@Customer platform.
        """
        return pulumi.get(self, "in_memory_percentage")

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> _builtins.str:
        """
        The infrastructure type this resource belongs to.
        """
        return pulumi.get(self, "infrastructure_type")

    @_builtins.property
    @pulumi.getter(name="isAccessControlEnabled")
    def is_access_control_enabled(self) -> _builtins.bool:
        """
        Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        """
        return pulumi.get(self, "is_access_control_enabled")

    @_builtins.property
    @pulumi.getter(name="isAutoScalingEnabled")
    def is_auto_scaling_enabled(self) -> _builtins.bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database CPU core count. The default value is `TRUE`.
        """
        return pulumi.get(self, "is_auto_scaling_enabled")

    @_builtins.property
    @pulumi.getter(name="isAutoScalingForStorageEnabled")
    def is_auto_scaling_for_storage_enabled(self) -> _builtins.bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_auto_scaling_for_storage_enabled")

    @_builtins.property
    @pulumi.getter(name="isBackupRetentionLocked")
    def is_backup_retention_locked(self) -> _builtins.bool:
        """
        Indicates if the Autonomous Database is backup retention locked.
        """
        return pulumi.get(self, "is_backup_retention_locked")

    @_builtins.property
    @pulumi.getter(name="isDataGuardEnabled")
    def is_data_guard_enabled(self) -> _builtins.bool:
        """
        **Deprecated.** Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="isDedicated")
    def is_dedicated(self) -> _builtins.bool:
        """
        True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        """
        return pulumi.get(self, "is_dedicated")

    @_builtins.property
    @pulumi.getter(name="isDevTier")
    def is_dev_tier(self) -> _builtins.bool:
        """
        Autonomous Database for Developers are fixed-shape Autonomous Databases that developers can use to build and test new applications. On Serverless, these are low-cost and billed per instance, on Dedicated and Cloud@Customer there is no additional cost to create Developer databases. Developer databases come with limited resources and is not intended for large-scale testing and production deployments. When you need more compute or storage resources, you may upgrade to a full paid production database.
        """
        return pulumi.get(self, "is_dev_tier")

    @_builtins.property
    @pulumi.getter(name="isFreeTier")
    def is_free_tier(self) -> _builtins.bool:
        """
        Indicates if this is an Always Free resource. The default value is false. Note that Always Free Autonomous Databases have 1 CPU and 20GB of memory. For Always Free databases, memory and CPU cannot be scaled.
        """
        return pulumi.get(self, "is_free_tier")

    @_builtins.property
    @pulumi.getter(name="isLocalDataGuardEnabled")
    def is_local_data_guard_enabled(self) -> _builtins.bool:
        """
        Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_local_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="isMtlsConnectionRequired")
    def is_mtls_connection_required(self) -> _builtins.bool:
        """
        Specifies if the Autonomous Database requires mTLS connections.
        """
        return pulumi.get(self, "is_mtls_connection_required")

    @_builtins.property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> _builtins.bool:
        """
        Indicates if the Autonomous Database version is a preview version.
        """
        return pulumi.get(self, "is_preview")

    @_builtins.property
    @pulumi.getter(name="isReconnectCloneEnabled")
    def is_reconnect_clone_enabled(self) -> _builtins.bool:
        """
        Indicates if the refreshable clone can be reconnected to its source database.
        """
        return pulumi.get(self, "is_reconnect_clone_enabled")

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> _builtins.bool:
        """
        Indicates if the Autonomous Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @_builtins.property
    @pulumi.getter(name="isRemoteDataGuardEnabled")
    def is_remote_data_guard_enabled(self) -> _builtins.bool:
        """
        Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_remote_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="keyHistoryEntries")
    def key_history_entries(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "key_history_entries")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> _builtins.str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyLifecycleDetails")
    def kms_key_lifecycle_details(self) -> _builtins.str:
        """
        KMS key lifecycle details.
        """
        return pulumi.get(self, "kms_key_lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Oracle Database service. Note that when provisioning an [Autonomous Database on dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null. It is already set at the Autonomous Exadata Infrastructure level. When provisioning an [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) database, if a value is not specified, the system defaults the value to `BRING_YOUR_OWN_LICENSE`. Bring your own license (BYOL) also allows you to select the DB edition using the optional parameter.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="localAdgAutoFailoverMaxDataLossLimit")
    def local_adg_auto_failover_max_data_loss_limit(self) -> _builtins.int:
        """
        Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        """
        return pulumi.get(self, "local_adg_auto_failover_max_data_loss_limit")

    @_builtins.property
    @pulumi.getter(name="localDisasterRecoveryType")
    def local_disaster_recovery_type(self) -> _builtins.str:
        """
        Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "local_disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="localStandbyDbs")
    def local_standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult']:
        """
        Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "local_standby_dbs")

    @_builtins.property
    @pulumi.getter(name="longTermBackupSchedules")
    def long_term_backup_schedules(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult']:
        """
        Details for the long-term backup schedule.
        """
        return pulumi.get(self, "long_term_backup_schedules")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter(name="maxCpuCoreCount")
    def max_cpu_core_count(self) -> _builtins.int:
        return pulumi.get(self, "max_cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> _builtins.int:
        """
        The amount of memory (in GBs) enabled per ECPU or OCPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="netServicesArchitecture")
    def net_services_architecture(self) -> _builtins.str:
        """
        Enabling SHARED server architecture enables a database server to allow many client processes to share very few server processes, thereby increasing the number of supported users.
        """
        return pulumi.get(self, "net_services_architecture")

    @_builtins.property
    @pulumi.getter(name="nextLongTermBackupTimeStamp")
    def next_long_term_backup_time_stamp(self) -> _builtins.str:
        """
        The date and time when the next long-term backup would be created.
        """
        return pulumi.get(self, "next_long_term_backup_time_stamp")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> _builtins.float:
        """
        The number of OCPU cores to be made available to the database.
        """
        return pulumi.get(self, "ocpu_count")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> _builtins.str:
        """
        Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        """
        return pulumi.get(self, "open_mode")

    @_builtins.property
    @pulumi.getter(name="peerDbIds")
    def peer_db_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for Autonomous Database Serverless instances, standby databases located in the same region as the source primary database do not have OCIDs.
        """
        return pulumi.get(self, "peer_db_ids")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> _builtins.str:
        """
        The private endpoint for the resource.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> _builtins.str:
        """
        The private endpoint Ip address for the resource.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @_builtins.property
    @pulumi.getter(name="privateEndpointLabel")
    def private_endpoint_label(self) -> _builtins.str:
        """
        The resource's private endpoint label.
        * Setting the endpoint label to a non-empty string creates a private endpoint database.
        * Resetting the endpoint label to an empty string, after the creation of the private endpoint database, changes the private endpoint database to a public endpoint database.
        * Setting the endpoint label to a non-empty string value, updates to a new private endpoint database, when the database is disabled and re-enabled.
        """
        return pulumi.get(self, "private_endpoint_label")

    @_builtins.property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[_builtins.float]:
        """
        An array of CPU values that an Autonomous Database can be scaled to.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @_builtins.property
    @pulumi.getter(name="publicConnectionUrls")
    def public_connection_urls(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabasePublicConnectionUrlResult']:
        """
        The Public URLs of Private Endpoint database for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN.
        """
        return pulumi.get(self, "public_connection_urls")

    @_builtins.property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> _builtins.str:
        """
        The public endpoint for the private endpoint enabled resource.
        """
        return pulumi.get(self, "public_endpoint")

    @_builtins.property
    @pulumi.getter(name="refreshableMode")
    def refreshable_mode(self) -> _builtins.str:
        """
        The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_mode")

    @_builtins.property
    @pulumi.getter(name="refreshableStatus")
    def refreshable_status(self) -> _builtins.str:
        """
        The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_status")

    @_builtins.property
    @pulumi.getter(name="remoteDisasterRecoveryConfigurations")
    def remote_disaster_recovery_configurations(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult']:
        """
        Configurations of a Disaster Recovery.
        """
        return pulumi.get(self, "remote_disaster_recovery_configurations")

    @_builtins.property
    @pulumi.getter(name="resourcePoolLeaderId")
    def resource_pool_leader_id(self) -> _builtins.str:
        """
        The unique identifier for leader autonomous database OCID [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "resource_pool_leader_id")

    @_builtins.property
    @pulumi.getter(name="resourcePoolSummaries")
    def resource_pool_summaries(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult']:
        """
        The configuration details for resource pool
        """
        return pulumi.get(self, "resource_pool_summaries")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="scheduledOperations")
    def scheduled_operations(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult']:
        """
        The list of scheduled operations. Consists of values such as dayOfWeek, scheduledStartTime, scheduledStopTime.
        """
        return pulumi.get(self, "scheduled_operations")

    @_builtins.property
    @pulumi.getter(name="securityAttributes")
    def security_attributes(self) -> Mapping[str, _builtins.str]:
        """
        Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        """
        return pulumi.get(self, "security_attributes")

    @_builtins.property
    @pulumi.getter(name="serviceConsoleUrl")
    def service_console_url(self) -> _builtins.str:
        """
        The URL of the Service Console for the Autonomous Database.
        """
        return pulumi.get(self, "service_console_url")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="standbyDbs")
    def standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult']:
        """
        **Deprecated** Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "standby_dbs")

    @_builtins.property
    @pulumi.getter(name="standbyWhitelistedIps")
    def standby_whitelisted_ips(self) -> Sequence[_builtins.str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        """
        return pulumi.get(self, "standby_whitelisted_ips")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="supportedRegionsToCloneTos")
    def supported_regions_to_clone_tos(self) -> Sequence[_builtins.str]:
        """
        The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        """
        return pulumi.get(self, "supported_regions_to_clone_tos")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDeletionOfFreeAutonomousDatabase")
    def time_deletion_of_free_autonomous_database(self) -> _builtins.str:
        """
        The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        """
        return pulumi.get(self, "time_deletion_of_free_autonomous_database")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeEarliestAvailableDbVersionUpgrade")
    def time_earliest_available_db_version_upgrade(self) -> _builtins.str:
        """
        The earliest(min) date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        """
        return pulumi.get(self, "time_earliest_available_db_version_upgrade")

    @_builtins.property
    @pulumi.getter(name="timeLatestAvailableDbVersionUpgrade")
    def time_latest_available_db_version_upgrade(self) -> _builtins.str:
        """
        The max date and time the Autonomous Database can be scheduled to upgrade to 23ai.
        """
        return pulumi.get(self, "time_latest_available_db_version_upgrade")

    @_builtins.property
    @pulumi.getter(name="timeLocalDataGuardEnabled")
    def time_local_data_guard_enabled(self) -> _builtins.str:
        """
        The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        """
        return pulumi.get(self, "time_local_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")

    @_builtins.property
    @pulumi.getter(name="timeOfAutoRefreshStart")
    def time_of_auto_refresh_start(self) -> _builtins.str:
        """
        The the date and time that auto-refreshing will begin for an Autonomous Database refreshable clone. This value controls only the start time for the first refresh operation. Subsequent (ongoing) refresh operations have start times controlled by the value of the `autoRefreshFrequencyInSeconds` parameter.
        """
        return pulumi.get(self, "time_of_auto_refresh_start")

    @_builtins.property
    @pulumi.getter(name="timeOfJoiningResourcePool")
    def time_of_joining_resource_pool(self) -> _builtins.str:
        """
        The time the member joined the resource pool.
        """
        return pulumi.get(self, "time_of_joining_resource_pool")

    @_builtins.property
    @pulumi.getter(name="timeOfLastFailover")
    def time_of_last_failover(self) -> _builtins.str:
        """
        The timestamp of the last failover operation.
        """
        return pulumi.get(self, "time_of_last_failover")

    @_builtins.property
    @pulumi.getter(name="timeOfLastRefresh")
    def time_of_last_refresh(self) -> _builtins.str:
        """
        The date and time when last refresh happened.
        """
        return pulumi.get(self, "time_of_last_refresh")

    @_builtins.property
    @pulumi.getter(name="timeOfLastRefreshPoint")
    def time_of_last_refresh_point(self) -> _builtins.str:
        """
        The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        """
        return pulumi.get(self, "time_of_last_refresh_point")

    @_builtins.property
    @pulumi.getter(name="timeOfLastSwitchover")
    def time_of_last_switchover(self) -> _builtins.str:
        """
        The timestamp of the last switchover operation for the Autonomous Database.
        """
        return pulumi.get(self, "time_of_last_switchover")

    @_builtins.property
    @pulumi.getter(name="timeOfNextRefresh")
    def time_of_next_refresh(self) -> _builtins.str:
        """
        The date and time of next refresh.
        """
        return pulumi.get(self, "time_of_next_refresh")

    @_builtins.property
    @pulumi.getter(name="timeReclamationOfFreeAutonomousDatabase")
    def time_reclamation_of_free_autonomous_database(self) -> _builtins.str:
        """
        The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        """
        return pulumi.get(self, "time_reclamation_of_free_autonomous_database")

    @_builtins.property
    @pulumi.getter(name="timeScheduledDbVersionUpgrade")
    def time_scheduled_db_version_upgrade(self) -> _builtins.str:
        """
        The date and time the Autonomous Database scheduled to upgrade to 23ai.
        """
        return pulumi.get(self, "time_scheduled_db_version_upgrade")

    @_builtins.property
    @pulumi.getter(name="timeUndeleted")
    def time_undeleted(self) -> _builtins.str:
        """
        The date and time the Autonomous Database was most recently undeleted.
        """
        return pulumi.get(self, "time_undeleted")

    @_builtins.property
    @pulumi.getter(name="timeUntilReconnectCloneEnabled")
    def time_until_reconnect_clone_enabled(self) -> _builtins.str:
        """
        The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        """
        return pulumi.get(self, "time_until_reconnect_clone_enabled")

    @_builtins.property
    @pulumi.getter(name="totalBackupStorageSizeInGbs")
    def total_backup_storage_size_in_gbs(self) -> _builtins.float:
        """
        The backup storage to the database.
        """
        return pulumi.get(self, "total_backup_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="usedDataStorageSizeInGbs")
    def used_data_storage_size_in_gbs(self) -> _builtins.int:
        """
        The storage space consumed by Autonomous Database in GBs.
        """
        return pulumi.get(self, "used_data_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="usedDataStorageSizeInTbs")
    def used_data_storage_size_in_tbs(self) -> _builtins.int:
        """
        The amount of storage that has been used for Autonomous Databases in dedicated infrastructure, in terabytes.
        """
        return pulumi.get(self, "used_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="whitelistedIps")
    def whitelisted_ips(self) -> Sequence[_builtins.str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance. If `arePrimaryWhitelistedIpsUsed` is 'TRUE' then Autonomous Database uses this primary's IP access control list (ACL) for the disaster recovery peer called `standbywhitelistedips`.
        """
        return pulumi.get(self, "whitelisted_ips")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult(dict):
    def __init__(__self__, *,
                 apex_version: _builtins.str,
                 ords_version: _builtins.str):
        """
        :param _builtins.str apex_version: The Oracle APEX Application Development version.
        :param _builtins.str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        pulumi.set(__self__, "apex_version", apex_version)
        pulumi.set(__self__, "ords_version", ords_version)

    @_builtins.property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> _builtins.str:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @_builtins.property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 manual_backup_bucket_name: _builtins.str,
                 manual_backup_type: _builtins.str):
        """
        :param _builtins.str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param _builtins.str manual_backup_type: The manual backup destination type.
        """
        pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @_builtins.property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> _builtins.str:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @_builtins.property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> _builtins.str:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 dedicated: _builtins.str,
                 high: _builtins.str,
                 low: _builtins.str,
                 medium: _builtins.str,
                 profiles: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult']):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param _builtins.str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param _builtins.str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param _builtins.str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "dedicated", dedicated)
        pulumi.set(__self__, "high", high)
        pulumi.set(__self__, "low", low)
        pulumi.set(__self__, "medium", medium)
        pulumi.set(__self__, "profiles", profiles)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter
    def dedicated(self) -> _builtins.str:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @_builtins.property
    @pulumi.getter
    def high(self) -> _builtins.str:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @_builtins.property
    @pulumi.getter
    def low(self) -> _builtins.str:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @_builtins.property
    @pulumi.getter
    def medium(self) -> _builtins.str:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @_builtins.property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult']:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult(dict):
    def __init__(__self__, *,
                 consumer_group: _builtins.str,
                 display_name: _builtins.str,
                 host_format: _builtins.str,
                 is_regional: _builtins.bool,
                 protocol: _builtins.str,
                 session_mode: _builtins.str,
                 syntax_format: _builtins.str,
                 tls_authentication: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str consumer_group: Consumer group used by the connection.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str host_format: Host format used in connection string.
        :param _builtins.bool is_regional: True for a regional connection string, applicable to cross-region DG only.
        :param _builtins.str protocol: Protocol used by the connection.
        :param _builtins.str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param _builtins.str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        :param _builtins.str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param _builtins.str value: Connection string value.
        """
        pulumi.set(__self__, "consumer_group", consumer_group)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "host_format", host_format)
        pulumi.set(__self__, "is_regional", is_regional)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "session_mode", session_mode)
        pulumi.set(__self__, "syntax_format", syntax_format)
        pulumi.set(__self__, "tls_authentication", tls_authentication)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> _builtins.str:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> _builtins.str:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @_builtins.property
    @pulumi.getter(name="isRegional")
    def is_regional(self) -> _builtins.bool:
        """
        True for a regional connection string, applicable to cross-region DG only.
        """
        return pulumi.get(self, "is_regional")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> _builtins.str:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @_builtins.property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> _builtins.str:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @_builtins.property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> _builtins.str:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: _builtins.str,
                 database_transforms_url: _builtins.str,
                 graph_studio_url: _builtins.str,
                 machine_learning_notebook_url: _builtins.str,
                 machine_learning_user_management_url: _builtins.str,
                 mongo_db_url: _builtins.str,
                 ords_url: _builtins.str,
                 sql_dev_web_url: _builtins.str):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        pulumi.set(__self__, "apex_url", apex_url)
        pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        pulumi.set(__self__, "ords_url", ords_url)
        pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> _builtins.str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> _builtins.str:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> _builtins.str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> _builtins.str:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> _builtins.str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> _builtins.str:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> _builtins.str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseDbToolsDetailResult(dict):
    def __init__(__self__, *,
                 compute_count: _builtins.float,
                 is_enabled: _builtins.bool,
                 max_idle_time_in_minutes: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.float compute_count: Compute used by database tools.
        :param _builtins.bool is_enabled: Indicates whether tool is enabled.
        :param _builtins.int max_idle_time_in_minutes: The max idle time, in minutes, after which the VM used by database tools will be terminated.
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "max_idle_time_in_minutes", max_idle_time_in_minutes)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.float:
        """
        Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Indicates whether tool is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="maxIdleTimeInMinutes")
    def max_idle_time_in_minutes(self) -> _builtins.int:
        """
        The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        return pulumi.get(self, "max_idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 arn_role: _builtins.str,
                 autonomous_databases_clone_provider: _builtins.str,
                 certificate_directory_name: _builtins.str,
                 certificate_id: _builtins.str,
                 directory_name: _builtins.str,
                 external_id: _builtins.str,
                 key_arn: _builtins.str,
                 key_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 okv_kms_key: _builtins.str,
                 okv_uri: _builtins.str,
                 service_endpoint_uri: _builtins.str,
                 vault_id: _builtins.str,
                 vault_uri: _builtins.str):
        """
        :param _builtins.str arn_role: AWS ARN role
        :param _builtins.str autonomous_databases_clone_provider: The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: OKV certificate directory name
        :param _builtins.str certificate_id: OKV certificate id
        :param _builtins.str directory_name: OKV wallet directory name
        :param _builtins.str external_id: AWS external ID
        :param _builtins.str key_arn: AWS key ARN
        :param _builtins.str key_name: Azure key name
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: UUID of OKV KMS Key
        :param _builtins.str okv_uri: URI of OKV server
        :param _builtins.str service_endpoint_uri: AWS key service endpoint URI
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vault_uri: Azure vault URI
        """
        pulumi.set(__self__, "arn_role", arn_role)
        pulumi.set(__self__, "autonomous_databases_clone_provider", autonomous_databases_clone_provider)
        pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        pulumi.set(__self__, "okv_uri", okv_uri)
        pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> _builtins.str:
        """
        AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabasesCloneProvider")
    def autonomous_databases_clone_provider(self) -> _builtins.str:
        """
        The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_databases_clone_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> _builtins.str:
        """
        OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> _builtins.str:
        """
        OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> _builtins.str:
        """
        UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> _builtins.str:
        """
        URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> _builtins.str:
        """
        AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 encryption_keys: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult'],
                 time_activated: _builtins.str):
        """
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs'] encryption_keys: Details of the Autonomous Database encryption key.
        :param _builtins.str time_activated: The date and time the kms key activated.
        """
        pulumi.set(__self__, "encryption_keys", encryption_keys)
        pulumi.set(__self__, "time_activated", time_activated)

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult']:
        """
        Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 arn_role: _builtins.str,
                 autonomous_databases_clone_provider: _builtins.str,
                 certificate_directory_name: _builtins.str,
                 certificate_id: _builtins.str,
                 directory_name: _builtins.str,
                 external_id: _builtins.str,
                 key_arn: _builtins.str,
                 key_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 okv_kms_key: _builtins.str,
                 okv_uri: _builtins.str,
                 service_endpoint_uri: _builtins.str,
                 vault_id: _builtins.str,
                 vault_uri: _builtins.str):
        """
        :param _builtins.str arn_role: AWS ARN role
        :param _builtins.str autonomous_databases_clone_provider: The provider for the Autonomous Database encryption key.
        :param _builtins.str certificate_directory_name: OKV certificate directory name
        :param _builtins.str certificate_id: OKV certificate id
        :param _builtins.str directory_name: OKV wallet directory name
        :param _builtins.str external_id: AWS external ID
        :param _builtins.str key_arn: AWS key ARN
        :param _builtins.str key_name: Azure key name
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str okv_kms_key: UUID of OKV KMS Key
        :param _builtins.str okv_uri: URI of OKV server
        :param _builtins.str service_endpoint_uri: AWS key service endpoint URI
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vault_uri: Azure vault URI
        """
        pulumi.set(__self__, "arn_role", arn_role)
        pulumi.set(__self__, "autonomous_databases_clone_provider", autonomous_databases_clone_provider)
        pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        pulumi.set(__self__, "okv_uri", okv_uri)
        pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> _builtins.str:
        """
        AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @_builtins.property
    @pulumi.getter(name="autonomousDatabasesCloneProvider")
    def autonomous_databases_clone_provider(self) -> _builtins.str:
        """
        The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_databases_clone_provider")

    @_builtins.property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> _builtins.str:
        """
        OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> _builtins.str:
        """
        OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS external ID
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        Azure key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> _builtins.str:
        """
        UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @_builtins.property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> _builtins.str:
        """
        URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> _builtins.str:
        """
        AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        Azure vault URI
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 time_activated: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str time_activated: The date and time the kms key activated.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> _builtins.str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 lag_time_in_seconds: _builtins.int,
                 lifecycle_details: _builtins.str,
                 maintenance_target_component: _builtins.str,
                 state: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> _builtins.int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult(dict):
    def __init__(__self__, *,
                 is_disabled: _builtins.bool,
                 repeat_cadence: _builtins.str,
                 retention_period_in_days: _builtins.int,
                 time_of_backup: _builtins.str):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.str repeat_cadence: The frequency of the long-term backup schedule
        :param _builtins.int retention_period_in_days: Retention period, in days, for long-term backups
        :param _builtins.str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "repeat_cadence", repeat_cadence)
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "time_of_backup", time_of_backup)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> _builtins.bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> _builtins.str:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> _builtins.int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> _builtins.str:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabasePublicConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: _builtins.str,
                 database_transforms_url: _builtins.str,
                 graph_studio_url: _builtins.str,
                 machine_learning_notebook_url: _builtins.str,
                 machine_learning_user_management_url: _builtins.str,
                 mongo_db_url: _builtins.str,
                 ords_url: _builtins.str,
                 sql_dev_web_url: _builtins.str):
        """
        :param _builtins.str apex_url: Oracle Application Express (APEX) URL.
        :param _builtins.str database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param _builtins.str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param _builtins.str machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param _builtins.str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param _builtins.str mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param _builtins.str ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param _builtins.str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        pulumi.set(__self__, "apex_url", apex_url)
        pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        pulumi.set(__self__, "ords_url", ords_url)
        pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @_builtins.property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> _builtins.str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @_builtins.property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> _builtins.str:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @_builtins.property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> _builtins.str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> _builtins.str:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @_builtins.property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> _builtins.str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @_builtins.property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> _builtins.str:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @_builtins.property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> _builtins.str:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @_builtins.property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> _builtins.str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult(dict):
    def __init__(__self__, *,
                 disaster_recovery_type: _builtins.str,
                 is_replicate_automatic_backups: _builtins.bool,
                 is_snapshot_standby: _builtins.bool,
                 time_snapshot_standby_enabled_till: _builtins.str):
        """
        :param _builtins.str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param _builtins.bool is_replicate_automatic_backups: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        :param _builtins.bool is_snapshot_standby: Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        :param _builtins.str time_snapshot_standby_enabled_till: Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)
        pulumi.set(__self__, "is_replicate_automatic_backups", is_replicate_automatic_backups)
        pulumi.set(__self__, "is_snapshot_standby", is_snapshot_standby)
        pulumi.set(__self__, "time_snapshot_standby_enabled_till", time_snapshot_standby_enabled_till)

    @_builtins.property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> _builtins.str:
        """
        Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @_builtins.property
    @pulumi.getter(name="isReplicateAutomaticBackups")
    def is_replicate_automatic_backups(self) -> _builtins.bool:
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        return pulumi.get(self, "is_replicate_automatic_backups")

    @_builtins.property
    @pulumi.getter(name="isSnapshotStandby")
    def is_snapshot_standby(self) -> _builtins.bool:
        """
        Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        """
        return pulumi.get(self, "is_snapshot_standby")

    @_builtins.property
    @pulumi.getter(name="timeSnapshotStandbyEnabledTill")
    def time_snapshot_standby_enabled_till(self) -> _builtins.str:
        """
        Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        return pulumi.get(self, "time_snapshot_standby_enabled_till")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult(dict):
    def __init__(__self__, *,
                 is_disabled: _builtins.bool,
                 pool_size: _builtins.int):
        """
        :param _builtins.bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param _builtins.int pool_size: Resource pool size.
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "pool_size", pool_size)

    @_builtins.property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> _builtins.bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @_builtins.property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> _builtins.int:
        """
        Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult'],
                 scheduled_start_time: _builtins.str,
                 scheduled_stop_time: _builtins.str):
        """
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_weeks: Day of the week.
        :param _builtins.str scheduled_start_time: auto start time. value must be of ISO-8601 format "HH:mm"
        :param _builtins.str scheduled_stop_time: auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "scheduled_start_time", scheduled_start_time)
        pulumi.set(__self__, "scheduled_stop_time", scheduled_stop_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult']:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @_builtins.property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> _builtins.str:
        """
        auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @_builtins.property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> _builtins.str:
        """
        auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 lag_time_in_seconds: _builtins.int,
                 lifecycle_details: _builtins.str,
                 maintenance_target_component: _builtins.str,
                 state: _builtins.str,
                 time_data_guard_role_changed: _builtins.str,
                 time_disaster_recovery_role_changed: _builtins.str,
                 time_maintenance_begin: _builtins.str,
                 time_maintenance_end: _builtins.str):
        """
        :param _builtins.str availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param _builtins.int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_target_component: The component chosen for maintenance.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param _builtins.str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param _builtins.str time_maintenance_begin: The date and time when maintenance will begin.
        :param _builtins.str time_maintenance_end: The date and time when maintenance will end.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_target_component", maintenance_target_component)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        pulumi.set(__self__, "time_maintenance_begin", time_maintenance_begin)
        pulumi.set(__self__, "time_maintenance_end", time_maintenance_end)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> _builtins.int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceTargetComponent")
    def maintenance_target_component(self) -> _builtins.str:
        """
        The component chosen for maintenance.
        """
        return pulumi.get(self, "maintenance_target_component")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> _builtins.str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> _builtins.str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> _builtins.str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> _builtins.str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")


@pulumi.output_type
class GetAutonomousDatabasesClonesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDbPreviewVersionsAutonomousDbPreviewVersionResult(dict):
    def __init__(__self__, *,
                 db_workload: _builtins.str,
                 details: _builtins.str,
                 time_preview_begin: _builtins.str,
                 time_preview_end: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str db_workload: The Autonomous Database workload type. The following values are valid:
               * OLTP - indicates an Autonomous Transaction Processing database
               * DW - indicates an Autonomous Data Warehouse database
               * AJD - indicates an Autonomous JSON Database
               * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        :param _builtins.str details: A URL that points to a detailed description of the preview version.
        :param _builtins.str time_preview_begin: The date and time when the preview version availability begins.
        :param _builtins.str time_preview_end: The date and time when the preview version availability ends.
        :param _builtins.str version: A valid Autonomous Database preview version.
        """
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "time_preview_begin", time_preview_begin)
        pulumi.set(__self__, "time_preview_end", time_preview_end)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        The Autonomous Database workload type. The following values are valid:
        * OLTP - indicates an Autonomous Transaction Processing database
        * DW - indicates an Autonomous Data Warehouse database
        * AJD - indicates an Autonomous JSON Database
        * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter
    def details(self) -> _builtins.str:
        """
        A URL that points to a detailed description of the preview version.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="timePreviewBegin")
    def time_preview_begin(self) -> _builtins.str:
        """
        The date and time when the preview version availability begins.
        """
        return pulumi.get(self, "time_preview_begin")

    @_builtins.property
    @pulumi.getter(name="timePreviewEnd")
    def time_preview_end(self) -> _builtins.str:
        """
        The date and time when the preview version availability ends.
        """
        return pulumi.get(self, "time_preview_end")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A valid Autonomous Database preview version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutonomousDbPreviewVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDbVersionsAutonomousDbVersionResult(dict):
    def __init__(__self__, *,
                 db_workload: _builtins.str,
                 details: _builtins.str,
                 is_dedicated: _builtins.bool,
                 is_default_for_free: _builtins.bool,
                 is_default_for_paid: _builtins.bool,
                 is_free_tier_enabled: _builtins.bool,
                 is_paid_enabled: _builtins.bool,
                 version: _builtins.str):
        """
        :param _builtins.str db_workload: A filter to return only autonomous database resources that match the specified workload type.
        :param _builtins.str details: A URL that points to a detailed description of the Autonomous Database version.
        :param _builtins.bool is_dedicated: True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        :param _builtins.bool is_default_for_free: True if this version of the Oracle Database software's default is free.
        :param _builtins.bool is_default_for_paid: True if this version of the Oracle Database software's default is paid.
        :param _builtins.bool is_free_tier_enabled: True if this version of the Oracle Database software can be used for Always-Free Autonomous Databases.
        :param _builtins.bool is_paid_enabled: True if this version of the Oracle Database software has payments enabled.
        :param _builtins.str version: A valid Oracle Database version for Autonomous Database.
        """
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "is_dedicated", is_dedicated)
        pulumi.set(__self__, "is_default_for_free", is_default_for_free)
        pulumi.set(__self__, "is_default_for_paid", is_default_for_paid)
        pulumi.set(__self__, "is_free_tier_enabled", is_free_tier_enabled)
        pulumi.set(__self__, "is_paid_enabled", is_paid_enabled)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        A filter to return only autonomous database resources that match the specified workload type.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter
    def details(self) -> _builtins.str:
        """
        A URL that points to a detailed description of the Autonomous Database version.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="isDedicated")
    def is_dedicated(self) -> _builtins.bool:
        """
        True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        """
        return pulumi.get(self, "is_dedicated")

    @_builtins.property
    @pulumi.getter(name="isDefaultForFree")
    def is_default_for_free(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software's default is free.
        """
        return pulumi.get(self, "is_default_for_free")

    @_builtins.property
    @pulumi.getter(name="isDefaultForPaid")
    def is_default_for_paid(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software's default is paid.
        """
        return pulumi.get(self, "is_default_for_paid")

    @_builtins.property
    @pulumi.getter(name="isFreeTierEnabled")
    def is_free_tier_enabled(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software can be used for Always-Free Autonomous Databases.
        """
        return pulumi.get(self, "is_free_tier_enabled")

    @_builtins.property
    @pulumi.getter(name="isPaidEnabled")
    def is_paid_enabled(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software has payments enabled.
        """
        return pulumi.get(self, "is_paid_enabled")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutonomousDbVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureOcpuByWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 adw: _builtins.float,
                 atp: _builtins.float):
        """
        :param _builtins.float adw: The total number of OCPU cores in use for Autonomous Data Warehouse databases in the infrastructure instance.
        :param _builtins.float atp: The total number of OCPU cores in use for Autonomous Transaction Processing databases in the infrastructure instance.
        """
        pulumi.set(__self__, "adw", adw)
        pulumi.set(__self__, "atp", atp)

    @_builtins.property
    @pulumi.getter
    def adw(self) -> _builtins.float:
        """
        The total number of OCPU cores in use for Autonomous Data Warehouse databases in the infrastructure instance.
        """
        return pulumi.get(self, "adw")

    @_builtins.property
    @pulumi.getter
    def atp(self) -> _builtins.float:
        """
        The total number of OCPU cores in use for Autonomous Transaction Processing databases in the infrastructure instance.
        """
        return pulumi.get(self, "atp")


@pulumi.output_type
class GetAutonomousExadataInfrastructureShapesAutonomousExadataInfrastructureShapeResult(dict):
    def __init__(__self__, *,
                 available_core_count: _builtins.int,
                 core_count_increment: _builtins.int,
                 maximum_node_count: _builtins.int,
                 minimum_core_count: _builtins.int,
                 minimum_node_count: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int available_core_count: The maximum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        :param _builtins.int core_count_increment: The increment in which core count can be increased or decreased.
        :param _builtins.int maximum_node_count: The maximum number of nodes available for the shape.
        :param _builtins.int minimum_core_count: The minimum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        :param _builtins.int minimum_node_count: The minimum number of nodes available for the shape.
        :param _builtins.str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        pulumi.set(__self__, "available_core_count", available_core_count)
        pulumi.set(__self__, "core_count_increment", core_count_increment)
        pulumi.set(__self__, "maximum_node_count", maximum_node_count)
        pulumi.set(__self__, "minimum_core_count", minimum_core_count)
        pulumi.set(__self__, "minimum_node_count", minimum_node_count)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> _builtins.int:
        """
        The maximum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "available_core_count")

    @_builtins.property
    @pulumi.getter(name="coreCountIncrement")
    def core_count_increment(self) -> _builtins.int:
        """
        The increment in which core count can be increased or decreased.
        """
        return pulumi.get(self, "core_count_increment")

    @_builtins.property
    @pulumi.getter(name="maximumNodeCount")
    def maximum_node_count(self) -> _builtins.int:
        """
        The maximum number of nodes available for the shape.
        """
        return pulumi.get(self, "maximum_node_count")

    @_builtins.property
    @pulumi.getter(name="minimumCoreCount")
    def minimum_core_count(self) -> _builtins.int:
        """
        The minimum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "minimum_core_count")

    @_builtins.property
    @pulumi.getter(name="minimumNodeCount")
    def minimum_node_count(self) -> _builtins.int:
        """
        The minimum number of nodes available for the shape.
        """
        return pulumi.get(self, "minimum_node_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureShapesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 compartment_id: _builtins.str,
                 create_async: _builtins.bool,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 domain: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 hostname: _builtins.str,
                 id: _builtins.str,
                 last_maintenance_run_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 maintenance_window_details: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult'],
                 next_maintenance_run_id: _builtins.str,
                 nsg_ids: Sequence[_builtins.str],
                 scan_dns_name: _builtins.str,
                 shape: _builtins.str,
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 time_created: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str domain: The domain name for the Autonomous Exadata Infrastructure.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str hostname: The host name for the Autonomous Exadata Infrastructure node.
        :param _builtins.str id: The OCID of the Autonomous Exadata Infrastructure.
        :param _builtins.str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param _builtins.str license_model: The Oracle license model that applies to all databases in the Autonomous Exadata Infrastructure. The default is BRING_YOUR_OWN_LICENSE.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state of the Autonomous Exadata Infrastructure.
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the Autonomous Exadata Infrastructure.
        :param _builtins.str shape: The shape of the Autonomous Exadata Infrastructure. The shape determines resources to allocate to the Autonomous Exadata Infrastructure (CPU cores, memory and storage).
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str subnet_id: The OCID of the subnet the Autonomous Exadata Infrastructure is associated with.
        :param _builtins.str time_created: The date and time the Autonomous Exadata Infrastructure was created.
        :param _builtins.str zone_id: The OCID of the zone the Autonomous Exadata Infrastructure is associated with.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "create_async", create_async)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_maintenance_run_id", last_maintenance_run_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_window_details", maintenance_window_details)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "next_maintenance_run_id", next_maintenance_run_id)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "scan_dns_name", scan_dns_name)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    @_utilities.deprecated("""Autonomous Exadata Infrastructure resource is now end-of-life.Please provision cloud autonomous vm cluster instead.""")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> _builtins.bool:
        return pulumi.get(self, "create_async")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host name for the Autonomous Exadata Infrastructure node.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to all databases in the Autonomous Exadata Infrastructure. The default is BRING_YOUR_OWN_LICENSE.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state of the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> _builtins.str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "scan_dns_name")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the Autonomous Exadata Infrastructure. The shape determines resources to allocate to the Autonomous Exadata Infrastructure (CPU cores, memory and storage).
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet the Autonomous Exadata Infrastructure is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Autonomous Exadata Infrastructure was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The OCID of the zone the Autonomous Exadata Infrastructure is associated with.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousVirtualMachinesAutonomousVirtualMachineResult(dict):
    def __init__(__self__, *,
                 autonomous_vm_cluster_id: _builtins.str,
                 client_ip_address: _builtins.str,
                 compartment_id: _builtins.str,
                 cpu_core_count: _builtins.int,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_server_display_name: _builtins.str,
                 db_server_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 memory_size_in_gbs: _builtins.int,
                 state: _builtins.str,
                 vm_name: _builtins.str):
        """
        :param _builtins.str autonomous_vm_cluster_id: The Autonomous Virtual machine [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str client_ip_address: Client IP Address.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int cpu_core_count: The number of CPU cores enabled on the Autonomous Virtual Machine.
        :param _builtins.int db_node_storage_size_in_gbs: The allocated local node storage in GBs on the Autonomous Virtual Machine.
        :param _builtins.str db_server_display_name: The display name of the dbServer associated with the Autonomous Virtual Machine.
        :param _builtins.str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db server associated with the Autonomous Virtual Machine.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machine.
        :param _builtins.int memory_size_in_gbs: The allocated memory in GBs on the Autonomous Virtual Machine.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str vm_name: The name of the Autonomous Virtual Machine.
        """
        pulumi.set(__self__, "autonomous_vm_cluster_id", autonomous_vm_cluster_id)
        pulumi.set(__self__, "client_ip_address", client_ip_address)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_server_display_name", db_server_display_name)
        pulumi.set(__self__, "db_server_id", db_server_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vm_name", vm_name)

    @_builtins.property
    @pulumi.getter(name="autonomousVmClusterId")
    def autonomous_vm_cluster_id(self) -> _builtins.str:
        """
        The Autonomous Virtual machine [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> _builtins.str:
        """
        Client IP Address.
        """
        return pulumi.get(self, "client_ip_address")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores enabled on the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The allocated local node storage in GBs on the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServerDisplayName")
    def db_server_display_name(self) -> _builtins.str:
        """
        The display name of the dbServer associated with the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "db_server_display_name")

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db server associated with the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "db_server_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The allocated memory in GBs on the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> _builtins.str:
        """
        The name of the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "vm_name")


@pulumi.output_type
class GetAutonomousVirtualMachinesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult(dict):
    def __init__(__self__, *,
                 autonomous_container_database_vm_usages: Sequence['outputs.GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult'],
                 available_cpus: _builtins.float,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 largest_provisionable_autonomous_database_in_cpus: _builtins.float,
                 provisionable_cpuses: Sequence[_builtins.float],
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param Sequence['GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageArgs'] autonomous_container_database_vm_usages: list of autonomous container database resource usage per autonomous virtual machine.
        :param _builtins.float available_cpus: CPUs available for provisioning or scaling an Autonomous Database in the Autonomous Container Database.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param _builtins.float largest_provisionable_autonomous_database_in_cpus: Largest provisionable ADB in the Autonomous Container Database.
        :param Sequence[_builtins.float] provisionable_cpuses: Valid list of provisionable CPUs for Autonomous Database.
        :param _builtins.float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param _builtins.float reclaimable_cpus: Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        :param _builtins.float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param _builtins.float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        pulumi.set(__self__, "autonomous_container_database_vm_usages", autonomous_container_database_vm_usages)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "largest_provisionable_autonomous_database_in_cpus", largest_provisionable_autonomous_database_in_cpus)
        pulumi.set(__self__, "provisionable_cpuses", provisionable_cpuses)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseVmUsages")
    def autonomous_container_database_vm_usages(self) -> Sequence['outputs.GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult']:
        """
        list of autonomous container database resource usage per autonomous virtual machine.
        """
        return pulumi.get(self, "autonomous_container_database_vm_usages")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        CPUs available for provisioning or scaling an Autonomous Database in the Autonomous Container Database.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="largestProvisionableAutonomousDatabaseInCpus")
    def largest_provisionable_autonomous_database_in_cpus(self) -> _builtins.float:
        """
        Largest provisionable ADB in the Autonomous Container Database.
        """
        return pulumi.get(self, "largest_provisionable_autonomous_database_in_cpus")

    @_builtins.property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[_builtins.float]:
        """
        Valid list of provisionable CPUs for Autonomous Database.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param _builtins.str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param _builtins.float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param _builtins.float reclaimable_cpus: Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        :param _builtins.float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param _builtins.float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetAutonomousVmClusterAcdResourceUsagesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult(dict):
    def __init__(__self__, *,
                 autonomous_container_database_usages: Sequence['outputs.GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult'],
                 available_cpus: _builtins.float,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param Sequence['GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageArgs'] autonomous_container_database_usages: associated autonomous container database usages
        :param _builtins.float available_cpus: The number of CPU cores available.
        :param _builtins.str display_name: The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param _builtins.float reclaimable_cpus: CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param _builtins.float used_cpus: The number of CPU cores alloted to the Autonomous Container Databases in an Autonomous VM cluster.
        """
        pulumi.set(__self__, "autonomous_container_database_usages", autonomous_container_database_usages)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseUsages")
    def autonomous_container_database_usages(self) -> Sequence['outputs.GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult']:
        """
        associated autonomous container database usages
        """
        return pulumi.get(self, "autonomous_container_database_usages")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        The number of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        The number of CPU cores alloted to the Autonomous Container Databases in an Autonomous VM cluster.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult(dict):
    def __init__(__self__, *,
                 available_cpus: _builtins.float,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param _builtins.float available_cpus: The number of CPU cores available.
        :param _builtins.str display_name: The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param _builtins.float reclaimable_cpus: CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param _builtins.float used_cpus: The number of CPU cores alloted to the Autonomous Container Databases in an Autonomous VM cluster.
        """
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        The number of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        The number of CPU cores alloted to the Autonomous Container Databases in an Autonomous VM cluster.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 autonomous_data_storage_percentage: _builtins.float,
                 autonomous_data_storage_size_in_tbs: _builtins.float,
                 available_autonomous_data_storage_size_in_tbs: _builtins.float,
                 available_container_databases: _builtins.int,
                 available_cpus: _builtins.int,
                 available_data_storage_size_in_tbs: _builtins.float,
                 compartment_id: _builtins.str,
                 compute_model: _builtins.str,
                 cpu_core_count_per_node: _builtins.int,
                 cpu_percentage: _builtins.float,
                 cpus_enabled: _builtins.int,
                 cpus_lowest_scaled_value: _builtins.int,
                 data_storage_size_in_gb: _builtins.float,
                 data_storage_size_in_tbs: _builtins.float,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_servers: Sequence[_builtins.str],
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 exadata_infrastructure_id: _builtins.str,
                 exadata_storage_in_tbs_lowest_scaled_value: _builtins.float,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_local_backup_enabled: _builtins.bool,
                 is_mtls_enabled: _builtins.bool,
                 last_maintenance_run_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 maintenance_window_details: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult'],
                 max_acds_lowest_scaled_value: _builtins.int,
                 memory_per_oracle_compute_unit_in_gbs: _builtins.int,
                 memory_size_in_gbs: _builtins.int,
                 next_maintenance_run_id: _builtins.str,
                 node_count: _builtins.int,
                 non_provisionable_autonomous_container_databases: _builtins.int,
                 ocpus_enabled: _builtins.float,
                 provisionable_autonomous_container_databases: _builtins.int,
                 provisioned_autonomous_container_databases: _builtins.int,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.int,
                 reserved_cpus: _builtins.float,
                 scan_listener_port_non_tls: _builtins.int,
                 scan_listener_port_tls: _builtins.int,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_database_ssl_certificate_expires: _builtins.str,
                 time_ords_certificate_expires: _builtins.str,
                 time_zone: _builtins.str,
                 total_autonomous_data_storage_in_tbs: _builtins.float,
                 total_container_databases: _builtins.int,
                 vm_cluster_network_id: _builtins.str):
        """
        :param _builtins.float autonomous_data_storage_size_in_tbs: The data disk group size allocated for Autonomous Databases, in TBs.
        :param _builtins.float available_autonomous_data_storage_size_in_tbs: The data disk group size available for Autonomous Databases, in TBs.
        :param _builtins.int available_container_databases: The number of Autonomous Container Databases that can be created with the currently available local storage.
        :param _builtins.int available_cpus: The numnber of CPU cores available.
        :param _builtins.float available_data_storage_size_in_tbs: **Deprecated.** Use `availableAutonomousDataStorageSizeInTBs` for Autonomous Databases' data storage availability in TBs.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compute_model: The compute model of the Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy. See [Compute Models in Autonomous Database on Dedicated Exadata #Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        :param _builtins.int cpu_core_count_per_node: The number of CPU cores enabled per VM cluster node.
        :param _builtins.int cpus_enabled: The number of enabled CPU cores.
        :param _builtins.int cpus_lowest_scaled_value: The lowest value to which cpus can be scaled down.
        :param _builtins.float data_storage_size_in_gb: The total data storage allocated in GBs.
        :param _builtins.float data_storage_size_in_tbs: The total data storage allocated in TBs
        :param _builtins.int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param Sequence[_builtins.str] db_servers: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str exadata_infrastructure_id: If provided, filters the results for the given Exadata Infrastructure.
        :param _builtins.float exadata_storage_in_tbs_lowest_scaled_value: The lowest value to which exadataStorage(in TBs) can be scaled down.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        :param _builtins.bool is_local_backup_enabled: If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
        :param _builtins.bool is_mtls_enabled: Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
        :param _builtins.str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param _builtins.str license_model: The Oracle license model that applies to the Autonomous VM cluster. The default is LICENSE_INCLUDED.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.int max_acds_lowest_scaled_value: The lowest value to which maximum number of ACDs can be scaled down.
        :param _builtins.int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) to be enabled per OCPU or ECPU.
        :param _builtins.int memory_size_in_gbs: The memory allocated in GBs.
        :param _builtins.str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param _builtins.int node_count: The number of nodes in the Autonomous VM Cluster.
        :param _builtins.float ocpus_enabled: The number of enabled OCPU cores.
        :param _builtins.int provisionable_autonomous_container_databases: **Deprecated.** Use field totalContainerDatabases.
        :param _builtins.int provisioned_autonomous_container_databases: The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param _builtins.int reclaimable_cpus: For Autonomous Databases on Dedicated Exadata Infrastructure:
               * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
               * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param _builtins.int scan_listener_port_non_tls: The SCAN Listener Non TLS port number. Default value is 1521.
        :param _builtins.int scan_listener_port_tls: The SCAN Listener TLS port number. Default value is 2484.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the Autonomous VM cluster was created.
        :param _builtins.str time_database_ssl_certificate_expires: The date and time of Database SSL certificate expiration.
        :param _builtins.str time_ords_certificate_expires: The date and time of ORDS certificate expiration.
        :param _builtins.str time_zone: The time zone to use for the Autonomous VM cluster. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param _builtins.int total_container_databases: The total number of Autonomous Container Databases that can be created.
        :param _builtins.str vm_cluster_network_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        pulumi.set(__self__, "autonomous_data_storage_percentage", autonomous_data_storage_percentage)
        pulumi.set(__self__, "autonomous_data_storage_size_in_tbs", autonomous_data_storage_size_in_tbs)
        pulumi.set(__self__, "available_autonomous_data_storage_size_in_tbs", available_autonomous_data_storage_size_in_tbs)
        pulumi.set(__self__, "available_container_databases", available_container_databases)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "available_data_storage_size_in_tbs", available_data_storage_size_in_tbs)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "cpu_core_count_per_node", cpu_core_count_per_node)
        pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        pulumi.set(__self__, "cpus_enabled", cpus_enabled)
        pulumi.set(__self__, "cpus_lowest_scaled_value", cpus_lowest_scaled_value)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_servers", db_servers)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "exadata_infrastructure_id", exadata_infrastructure_id)
        pulumi.set(__self__, "exadata_storage_in_tbs_lowest_scaled_value", exadata_storage_in_tbs_lowest_scaled_value)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_local_backup_enabled", is_local_backup_enabled)
        pulumi.set(__self__, "is_mtls_enabled", is_mtls_enabled)
        pulumi.set(__self__, "last_maintenance_run_id", last_maintenance_run_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_window_details", maintenance_window_details)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "max_acds_lowest_scaled_value", max_acds_lowest_scaled_value)
        pulumi.set(__self__, "memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "next_maintenance_run_id", next_maintenance_run_id)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "non_provisionable_autonomous_container_databases", non_provisionable_autonomous_container_databases)
        pulumi.set(__self__, "ocpus_enabled", ocpus_enabled)
        pulumi.set(__self__, "provisionable_autonomous_container_databases", provisionable_autonomous_container_databases)
        pulumi.set(__self__, "provisioned_autonomous_container_databases", provisioned_autonomous_container_databases)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "scan_listener_port_non_tls", scan_listener_port_non_tls)
        pulumi.set(__self__, "scan_listener_port_tls", scan_listener_port_tls)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_database_ssl_certificate_expires", time_database_ssl_certificate_expires)
        pulumi.set(__self__, "time_ords_certificate_expires", time_ords_certificate_expires)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "total_autonomous_data_storage_in_tbs", total_autonomous_data_storage_in_tbs)
        pulumi.set(__self__, "total_container_databases", total_container_databases)
        pulumi.set(__self__, "vm_cluster_network_id", vm_cluster_network_id)

    @_builtins.property
    @pulumi.getter(name="autonomousDataStoragePercentage")
    def autonomous_data_storage_percentage(self) -> _builtins.float:
        return pulumi.get(self, "autonomous_data_storage_percentage")

    @_builtins.property
    @pulumi.getter(name="autonomousDataStorageSizeInTbs")
    def autonomous_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The data disk group size allocated for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "autonomous_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="availableAutonomousDataStorageSizeInTbs")
    def available_autonomous_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The data disk group size available for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "available_autonomous_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="availableContainerDatabases")
    def available_container_databases(self) -> _builtins.int:
        """
        The number of Autonomous Container Databases that can be created with the currently available local storage.
        """
        return pulumi.get(self, "available_container_databases")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.int:
        """
        The numnber of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="availableDataStorageSizeInTbs")
    def available_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        **Deprecated.** Use `availableAutonomousDataStorageSizeInTBs` for Autonomous Databases' data storage availability in TBs.
        """
        return pulumi.get(self, "available_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy. See [Compute Models in Autonomous Database on Dedicated Exadata #Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCountPerNode")
    def cpu_core_count_per_node(self) -> _builtins.int:
        """
        The number of CPU cores enabled per VM cluster node.
        """
        return pulumi.get(self, "cpu_core_count_per_node")

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> _builtins.float:
        return pulumi.get(self, "cpu_percentage")

    @_builtins.property
    @pulumi.getter(name="cpusEnabled")
    def cpus_enabled(self) -> _builtins.int:
        """
        The number of enabled CPU cores.
        """
        return pulumi.get(self, "cpus_enabled")

    @_builtins.property
    @pulumi.getter(name="cpusLowestScaledValue")
    def cpus_lowest_scaled_value(self) -> _builtins.int:
        """
        The lowest value to which cpus can be scaled down.
        """
        return pulumi.get(self, "cpus_lowest_scaled_value")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> _builtins.float:
        """
        The total data storage allocated in GBs.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The total data storage allocated in TBs
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        """
        return pulumi.get(self, "db_servers")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> _builtins.str:
        """
        If provided, filters the results for the given Exadata Infrastructure.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="exadataStorageInTbsLowestScaledValue")
    def exadata_storage_in_tbs_lowest_scaled_value(self) -> _builtins.float:
        """
        The lowest value to which exadataStorage(in TBs) can be scaled down.
        """
        return pulumi.get(self, "exadata_storage_in_tbs_lowest_scaled_value")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isLocalBackupEnabled")
    def is_local_backup_enabled(self) -> _builtins.bool:
        """
        If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
        """
        return pulumi.get(self, "is_local_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="isMtlsEnabled")
    def is_mtls_enabled(self) -> _builtins.bool:
        """
        Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
        """
        return pulumi.get(self, "is_mtls_enabled")

    @_builtins.property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the Autonomous VM cluster. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="maxAcdsLowestScaledValue")
    def max_acds_lowest_scaled_value(self) -> _builtins.int:
        """
        The lowest value to which maximum number of ACDs can be scaled down.
        """
        return pulumi.get(self, "max_acds_lowest_scaled_value")

    @_builtins.property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> _builtins.int:
        """
        The amount of memory (in GBs) to be enabled per OCPU or ECPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes in the Autonomous VM Cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nonProvisionableAutonomousContainerDatabases")
    def non_provisionable_autonomous_container_databases(self) -> _builtins.int:
        return pulumi.get(self, "non_provisionable_autonomous_container_databases")

    @_builtins.property
    @pulumi.getter(name="ocpusEnabled")
    def ocpus_enabled(self) -> _builtins.float:
        """
        The number of enabled OCPU cores.
        """
        return pulumi.get(self, "ocpus_enabled")

    @_builtins.property
    @pulumi.getter(name="provisionableAutonomousContainerDatabases")
    def provisionable_autonomous_container_databases(self) -> _builtins.int:
        """
        **Deprecated.** Use field totalContainerDatabases.
        """
        return pulumi.get(self, "provisionable_autonomous_container_databases")

    @_builtins.property
    @pulumi.getter(name="provisionedAutonomousContainerDatabases")
    def provisioned_autonomous_container_databases(self) -> _builtins.int:
        """
        The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_autonomous_container_databases")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.int:
        """
        For Autonomous Databases on Dedicated Exadata Infrastructure:
        * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortNonTls")
    def scan_listener_port_non_tls(self) -> _builtins.int:
        """
        The SCAN Listener Non TLS port number. Default value is 1521.
        """
        return pulumi.get(self, "scan_listener_port_non_tls")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTls")
    def scan_listener_port_tls(self) -> _builtins.int:
        """
        The SCAN Listener TLS port number. Default value is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tls")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the Autonomous VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeDatabaseSslCertificateExpires")
    def time_database_ssl_certificate_expires(self) -> _builtins.str:
        """
        The date and time of Database SSL certificate expiration.
        """
        return pulumi.get(self, "time_database_ssl_certificate_expires")

    @_builtins.property
    @pulumi.getter(name="timeOrdsCertificateExpires")
    def time_ords_certificate_expires(self) -> _builtins.str:
        """
        The date and time of ORDS certificate expiration.
        """
        return pulumi.get(self, "time_ords_certificate_expires")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone to use for the Autonomous VM cluster. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="totalAutonomousDataStorageInTbs")
    def total_autonomous_data_storage_in_tbs(self) -> _builtins.float:
        return pulumi.get(self, "total_autonomous_data_storage_in_tbs")

    @_builtins.property
    @pulumi.getter(name="totalContainerDatabases")
    def total_container_databases(self) -> _builtins.int:
        """
        The total number of Autonomous Container Databases that can be created.
        """
        return pulumi.get(self, "total_container_databases")

    @_builtins.property
    @pulumi.getter(name="vmClusterNetworkId")
    def vm_cluster_network_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        return pulumi.get(self, "vm_cluster_network_id")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBackupDestinationAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str db_name: The display name of the database that is associated with the backup destination.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBackupDestinationMountTypeDetailResult(dict):
    def __init__(__self__, *,
                 local_mount_point_path: _builtins.str,
                 mount_type: _builtins.str,
                 nfs_server_export: _builtins.str,
                 nfs_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param _builtins.str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[_builtins.str] nfs_servers: Host names or IP addresses for NFS Auto mount.
        """
        pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        pulumi.set(__self__, "mount_type", mount_type)
        pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        pulumi.set(__self__, "nfs_servers", nfs_servers)

    @_builtins.property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> _builtins.str:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @_builtins.property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> _builtins.str:
        return pulumi.get(self, "mount_type")

    @_builtins.property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> _builtins.str:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @_builtins.property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Sequence[_builtins.str]:
        """
        Host names or IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")


@pulumi.output_type
class GetBackupDestinationsBackupDestinationResult(dict):
    def __init__(__self__, *,
                 associated_databases: Sequence['outputs.GetBackupDestinationsBackupDestinationAssociatedDatabaseResult'],
                 compartment_id: _builtins.str,
                 connection_string: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 local_mount_point_path: _builtins.str,
                 mount_type_details: Sequence['outputs.GetBackupDestinationsBackupDestinationMountTypeDetailResult'],
                 nfs_mount_type: _builtins.str,
                 nfs_server_export: _builtins.str,
                 nfs_servers: Sequence[_builtins.str],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_at_which_storage_details_are_updated: _builtins.str,
                 time_created: _builtins.str,
                 total_storage_size_in_gbs: _builtins.int,
                 type: _builtins.str,
                 utilized_storage_size_in_gbs: _builtins.int,
                 vpc_users: Sequence[_builtins.str]):
        """
        :param Sequence['GetBackupDestinationsBackupDestinationAssociatedDatabaseArgs'] associated_databases: List of databases associated with the backup destination.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str connection_string: For a RECOVERY_APPLIANCE backup destination, the connection string for connecting to the Recovery Appliance.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: The user-provided name of the backup destination.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text
        :param _builtins.str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param _builtins.str nfs_mount_type: NFS Mount type for backup destination.
        :param _builtins.str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[_builtins.str] nfs_servers: Host names or IP addresses for NFS Auto mount.
        :param _builtins.str state: The current lifecycle state of the backup destination.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_at_which_storage_details_are_updated: The time when the total storage size and the utilized storage size of the backup destination are updated.
        :param _builtins.str time_created: The date and time the backup destination was created.
        :param _builtins.int total_storage_size_in_gbs: The total storage size of the backup destination in GBs, rounded to the nearest integer.
        :param _builtins.str type: A filter to return only resources that match the given type of the Backup Destination.
        :param _builtins.int utilized_storage_size_in_gbs: The total amount of space utilized on the backup destination (in GBs), rounded to the nearest integer.
        :param Sequence[_builtins.str] vpc_users: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) users that are used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "associated_databases", associated_databases)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        pulumi.set(__self__, "mount_type_details", mount_type_details)
        pulumi.set(__self__, "nfs_mount_type", nfs_mount_type)
        pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        pulumi.set(__self__, "nfs_servers", nfs_servers)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_at_which_storage_details_are_updated", time_at_which_storage_details_are_updated)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "total_storage_size_in_gbs", total_storage_size_in_gbs)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "utilized_storage_size_in_gbs", utilized_storage_size_in_gbs)
        pulumi.set(__self__, "vpc_users", vpc_users)

    @_builtins.property
    @pulumi.getter(name="associatedDatabases")
    def associated_databases(self) -> Sequence['outputs.GetBackupDestinationsBackupDestinationAssociatedDatabaseResult']:
        """
        List of databases associated with the backup destination.
        """
        return pulumi.get(self, "associated_databases")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the connection string for connecting to the Recovery Appliance.
        """
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-provided name of the backup destination.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="localMountPointPath")
    @_utilities.deprecated("""The 'local_mount_point_path' field has been deprecated. Please use 'local_mount_point_path under mount_type_details' instead.""")
    def local_mount_point_path(self) -> _builtins.str:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @_builtins.property
    @pulumi.getter(name="mountTypeDetails")
    def mount_type_details(self) -> Sequence['outputs.GetBackupDestinationsBackupDestinationMountTypeDetailResult']:
        return pulumi.get(self, "mount_type_details")

    @_builtins.property
    @pulumi.getter(name="nfsMountType")
    def nfs_mount_type(self) -> _builtins.str:
        """
        NFS Mount type for backup destination.
        """
        return pulumi.get(self, "nfs_mount_type")

    @_builtins.property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> _builtins.str:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @_builtins.property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Sequence[_builtins.str]:
        """
        Host names or IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current lifecycle state of the backup destination.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeAtWhichStorageDetailsAreUpdated")
    def time_at_which_storage_details_are_updated(self) -> _builtins.str:
        """
        The time when the total storage size and the utilized storage size of the backup destination are updated.
        """
        return pulumi.get(self, "time_at_which_storage_details_are_updated")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the backup destination was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="totalStorageSizeInGbs")
    def total_storage_size_in_gbs(self) -> _builtins.int:
        """
        The total storage size of the backup destination in GBs, rounded to the nearest integer.
        """
        return pulumi.get(self, "total_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given type of the Backup Destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="utilizedStorageSizeInGbs")
    def utilized_storage_size_in_gbs(self) -> _builtins.int:
        """
        The total amount of space utilized on the backup destination (in GBs), rounded to the nearest integer.
        """
        return pulumi.get(self, "utilized_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="vpcUsers")
    def vpc_users(self) -> Sequence[_builtins.str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) users that are used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_users")


@pulumi.output_type
class GetBackupDestinationsBackupDestinationAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str db_name: The display name of the database that is associated with the backup destination.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBackupDestinationsBackupDestinationMountTypeDetailResult(dict):
    def __init__(__self__, *,
                 local_mount_point_path: _builtins.str,
                 mount_type: _builtins.str,
                 nfs_server_export: _builtins.str,
                 nfs_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param _builtins.str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[_builtins.str] nfs_servers: Host names or IP addresses for NFS Auto mount.
        """
        pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        pulumi.set(__self__, "mount_type", mount_type)
        pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        pulumi.set(__self__, "nfs_servers", nfs_servers)

    @_builtins.property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> _builtins.str:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @_builtins.property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> _builtins.str:
        return pulumi.get(self, "mount_type")

    @_builtins.property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> _builtins.str:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @_builtins.property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Sequence[_builtins.str]:
        """
        Host names or IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")


@pulumi.output_type
class GetBackupDestinationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBackupsBackupResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 backup_destination_type: _builtins.str,
                 compartment_id: _builtins.str,
                 database_edition: _builtins.str,
                 database_id: _builtins.str,
                 database_size_in_gbs: _builtins.float,
                 display_name: _builtins.str,
                 encryption_key_location_details: Sequence['outputs.GetBackupsBackupEncryptionKeyLocationDetailResult'],
                 id: _builtins.str,
                 is_using_oracle_managed_keys: _builtins.bool,
                 key_store_id: _builtins.str,
                 key_store_wallet_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 retention_period_in_days: _builtins.int,
                 retention_period_in_years: _builtins.int,
                 secondary_kms_key_ids: Sequence[_builtins.str],
                 shape: _builtins.str,
                 state: _builtins.str,
                 time_ended: _builtins.str,
                 time_expiry_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 type: _builtins.str,
                 vault_id: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str availability_domain: The name of the availability domain where the database backup is stored.
        :param _builtins.str backup_destination_type: A filter to return only resources that match the given backup destination type.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_edition: The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        :param _builtins.str database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.float database_size_in_gbs: The size of the database in gigabytes at the time the backup was taken.
        :param _builtins.str display_name: The user-friendly name for the backup. The name does not have to be unique.
        :param Sequence['GetBackupsBackupEncryptionKeyLocationDetailArgs'] encryption_key_location_details: Types of providers supported for managing database encryption keys
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup.
        :param _builtins.bool is_using_oracle_managed_keys: True if Oracle Managed Keys is required for restore of the backup.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int retention_period_in_days: The retention period of the long term backup in days.
        :param _builtins.int retention_period_in_years: The retention period of the long term backup in years.
        :param Sequence[_builtins.str] secondary_kms_key_ids: List of OCIDs of the key containers used as the secondary encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str shape: Shape of the backup's source database.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_ended: The date and time the backup was completed.
        :param _builtins.str time_expiry_scheduled: Expiration time of the long term database backup.
        :param _builtins.str time_started: The date and time the backup started.
        :param _builtins.str type: A filter to return only backups that matches with the given type of Backup.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str version: A filter to return only resources that match the given database version.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_destination_type", backup_destination_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_size_in_gbs", database_size_in_gbs)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_using_oracle_managed_keys", is_using_oracle_managed_keys)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "key_store_wallet_name", key_store_wallet_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "retention_period_in_years", retention_period_in_years)
        pulumi.set(__self__, "secondary_kms_key_ids", secondary_kms_key_ids)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_expiry_scheduled", time_expiry_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain where the database backup is stored.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="backupDestinationType")
    def backup_destination_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given backup destination type.
        """
        return pulumi.get(self, "backup_destination_type")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSizeInGbs")
    def database_size_in_gbs(self) -> _builtins.float:
        """
        The size of the database in gigabytes at the time the backup was taken.
        """
        return pulumi.get(self, "database_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the backup. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Sequence['outputs.GetBackupsBackupEncryptionKeyLocationDetailResult']:
        """
        Types of providers supported for managing database encryption keys
        """
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isUsingOracleManagedKeys")
    def is_using_oracle_managed_keys(self) -> _builtins.bool:
        """
        True if Oracle Managed Keys is required for restore of the backup.
        """
        return pulumi.get(self, "is_using_oracle_managed_keys")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> _builtins.str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> _builtins.int:
        """
        The retention period of the long term backup in days.
        """
        return pulumi.get(self, "retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInYears")
    def retention_period_in_years(self) -> _builtins.int:
        """
        The retention period of the long term backup in years.
        """
        return pulumi.get(self, "retention_period_in_years")

    @_builtins.property
    @pulumi.getter(name="secondaryKmsKeyIds")
    def secondary_kms_key_ids(self) -> Sequence[_builtins.str]:
        """
        List of OCIDs of the key containers used as the secondary encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "secondary_kms_key_ids")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the backup's source database.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the backup was completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeExpiryScheduled")
    def time_expiry_scheduled(self) -> _builtins.str:
        """
        Expiration time of the long term database backup.
        """
        return pulumi.get(self, "time_expiry_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the backup started.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        A filter to return only backups that matches with the given type of Backup.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A filter to return only resources that match the given database version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBackupsBackupEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 azure_encryption_key_id: _builtins.str,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        """
        :param _builtins.str azure_encryption_key_id: Provide the key OCID of a registered Azure key.
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> _builtins.str:
        """
        Provide the key OCID of a registered Azure key.
        """
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult(dict):
    def __init__(__self__, *,
                 autonomous_container_database_vm_usages: Sequence['outputs.GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult'],
                 available_cpus: _builtins.float,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 largest_provisionable_autonomous_database_in_cpus: _builtins.float,
                 provisionable_cpuses: Sequence[_builtins.float],
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param Sequence['GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageArgs'] autonomous_container_database_vm_usages: List of autonomous container database resource usage per autonomous virtual machine.
        :param _builtins.float available_cpus: CPUs available for provisioning or scaling an Autonomous Database in the Autonomous Container Database.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param _builtins.float largest_provisionable_autonomous_database_in_cpus: Largest provisionable ADB in the Autonomous Container Database.
        :param Sequence[_builtins.float] provisionable_cpuses: Valid list of provisionable CPUs for Autonomous Database.
        :param _builtins.float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param _builtins.float reclaimable_cpus: Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        :param _builtins.float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param _builtins.float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        pulumi.set(__self__, "autonomous_container_database_vm_usages", autonomous_container_database_vm_usages)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "largest_provisionable_autonomous_database_in_cpus", largest_provisionable_autonomous_database_in_cpus)
        pulumi.set(__self__, "provisionable_cpuses", provisionable_cpuses)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseVmUsages")
    def autonomous_container_database_vm_usages(self) -> Sequence['outputs.GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult']:
        """
        List of autonomous container database resource usage per autonomous virtual machine.
        """
        return pulumi.get(self, "autonomous_container_database_vm_usages")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        CPUs available for provisioning or scaling an Autonomous Database in the Autonomous Container Database.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="largestProvisionableAutonomousDatabaseInCpus")
    def largest_provisionable_autonomous_database_in_cpus(self) -> _builtins.float:
        """
        Largest provisionable ADB in the Autonomous Container Database.
        """
        return pulumi.get(self, "largest_provisionable_autonomous_database_in_cpus")

    @_builtins.property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[_builtins.float]:
        """
        Valid list of provisionable CPUs for Autonomous Database.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param _builtins.str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param _builtins.float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param _builtins.float reclaimable_cpus: Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        :param _builtins.float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param _builtins.float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        Number of CPUs that are reclaimable or released to the AVMC on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClusterAcdResourceUsagesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult(dict):
    def __init__(__self__, *,
                 autonomous_container_database_usages: Sequence['outputs.GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult'],
                 available_cpus: _builtins.float,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param Sequence['GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageArgs'] autonomous_container_database_usages: Associated Autonomous Container Database Usages.
        :param _builtins.float available_cpus: The number of CPU cores available.
        :param _builtins.str display_name: The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param _builtins.float reclaimable_cpus: CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param _builtins.float used_cpus: The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        pulumi.set(__self__, "autonomous_container_database_usages", autonomous_container_database_usages)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="autonomousContainerDatabaseUsages")
    def autonomous_container_database_usages(self) -> Sequence['outputs.GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult']:
        """
        Associated Autonomous Container Database Usages.
        """
        return pulumi.get(self, "autonomous_container_database_usages")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        The number of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult(dict):
    def __init__(__self__, *,
                 available_cpus: _builtins.float,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 used_cpus: _builtins.float):
        """
        :param _builtins.float available_cpus: The number of CPU cores available.
        :param _builtins.str display_name: The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param _builtins.float reclaimable_cpus: CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param _builtins.float used_cpus: The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "used_cpus", used_cpus)

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        The number of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> _builtins.float:
        """
        The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 autonomous_data_storage_percentage: _builtins.float,
                 autonomous_data_storage_size_in_tbs: _builtins.float,
                 availability_domain: _builtins.str,
                 available_autonomous_data_storage_size_in_tbs: _builtins.float,
                 available_container_databases: _builtins.int,
                 available_cpus: _builtins.float,
                 cloud_exadata_infrastructure_id: _builtins.str,
                 cluster_time_zone: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_model: _builtins.str,
                 cpu_core_count: _builtins.int,
                 cpu_core_count_per_node: _builtins.int,
                 cpu_percentage: _builtins.float,
                 data_storage_size_in_gb: _builtins.float,
                 data_storage_size_in_tbs: _builtins.float,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_servers: Sequence[_builtins.str],
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 domain: _builtins.str,
                 exadata_storage_in_tbs_lowest_scaled_value: _builtins.float,
                 freeform_tags: Mapping[str, _builtins.str],
                 hostname: _builtins.str,
                 id: _builtins.str,
                 is_mtls_enabled_vm_cluster: _builtins.bool,
                 last_maintenance_run_id: _builtins.str,
                 last_update_history_entry_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 maintenance_window_details: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult'],
                 max_acds_lowest_scaled_value: _builtins.int,
                 memory_per_oracle_compute_unit_in_gbs: _builtins.int,
                 memory_size_in_gbs: _builtins.int,
                 next_maintenance_run_id: _builtins.str,
                 node_count: _builtins.int,
                 non_provisionable_autonomous_container_databases: _builtins.int,
                 nsg_ids: Sequence[_builtins.str],
                 ocpu_count: _builtins.float,
                 ocpus_lowest_scaled_value: _builtins.int,
                 opc_dry_run: _builtins.bool,
                 provisionable_autonomous_container_databases: _builtins.int,
                 provisioned_autonomous_container_databases: _builtins.int,
                 provisioned_cpus: _builtins.float,
                 reclaimable_cpus: _builtins.float,
                 reserved_cpus: _builtins.float,
                 scan_listener_port_non_tls: _builtins.int,
                 scan_listener_port_tls: _builtins.int,
                 security_attributes: Mapping[str, _builtins.str],
                 shape: _builtins.str,
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 subscription_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_database_ssl_certificate_expires: _builtins.str,
                 time_ords_certificate_expires: _builtins.str,
                 time_updated: _builtins.str,
                 total_autonomous_data_storage_in_tbs: _builtins.float,
                 total_container_databases: _builtins.int,
                 total_cpus: _builtins.float):
        """
        :param _builtins.float autonomous_data_storage_percentage: The percentage of the data storage used for the Autonomous Databases in an Autonomous VM Cluster.
        :param _builtins.float autonomous_data_storage_size_in_tbs: The data disk group size allocated for Autonomous Databases, in TBs.
        :param _builtins.str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param _builtins.float available_autonomous_data_storage_size_in_tbs: The data disk group size available for Autonomous Databases, in TBs.
        :param _builtins.int available_container_databases: The number of Autonomous Container Databases that can be created with the currently available local storage.
        :param _builtins.float available_cpus: CPU cores available for allocation to Autonomous Databases.
        :param _builtins.str cloud_exadata_infrastructure_id: If provided, filters the results for the specified cloud Exadata infrastructure.
        :param _builtins.str cluster_time_zone: The time zone of the Cloud Autonomous VM Cluster.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compute_model: The compute model of the Cloud Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy. See [Compute Models in Autonomous Database on Dedicated Exadata #Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        :param _builtins.int cpu_core_count: The number of CPU cores on the cloud Autonomous VM cluster.
        :param _builtins.int cpu_core_count_per_node: The number of CPU cores enabled per VM cluster node.
        :param _builtins.float cpu_percentage: The percentage of total number of CPUs used in an Autonomous VM Cluster.
        :param _builtins.float data_storage_size_in_gb: The total data storage allocated, in gigabytes (GB).
        :param _builtins.float data_storage_size_in_tbs: The total data storage allocated, in terabytes (TB).
        :param _builtins.int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param Sequence[_builtins.str] db_servers: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: User defined description of the cloud Autonomous VM cluster.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str domain: The domain name for the cloud Autonomous VM cluster.
        :param _builtins.float exadata_storage_in_tbs_lowest_scaled_value: The lowest value to which exadataStorage (in TBs) can be scaled down.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str hostname: The hostname for the cloud Autonomous VM cluster.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        :param _builtins.bool is_mtls_enabled_vm_cluster: Enable mutual TLS(mTLS) authentication for database at time of provisioning a VMCluster. This is applicable to database TLS Certificates only. Default is TLS
        :param _builtins.str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param _builtins.str last_update_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history. This value is updated when a maintenance update starts.
        :param _builtins.str license_model: The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Oracle Database service. Note that when provisioning an [Autonomous Database on dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null. It is already set at the Autonomous Exadata Infrastructure level. When provisioning an [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) database, if a value is not specified, the system defaults the value to `BRING_YOUR_OWN_LICENSE`. Bring your own license (BYOL) also allows you to select the DB edition using the optional parameter.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.int max_acds_lowest_scaled_value: The lowest value to which maximum number of ACDs can be scaled down.
        :param _builtins.int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per OCPU or ECPU.
        :param _builtins.int memory_size_in_gbs: The memory allocated in GBs.
        :param _builtins.str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param _builtins.int node_count: The number of database servers in the cloud VM cluster.
        :param _builtins.int non_provisionable_autonomous_container_databases: The number of non-provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.float ocpu_count: The number of CPU cores on the cloud Autonomous VM cluster. Only 1 decimal place is allowed for the fractional part.
        :param _builtins.int ocpus_lowest_scaled_value: The lowest value to which ocpus can be scaled down.
        :param _builtins.int provisionable_autonomous_container_databases: The number of provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        :param _builtins.int provisioned_autonomous_container_databases: The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
        :param _builtins.float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param _builtins.float reclaimable_cpus: For Autonomous Databases on Dedicated Exadata Infrastructure:
               * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
               * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param _builtins.float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param _builtins.int scan_listener_port_non_tls: The SCAN Listener Non TLS port. Default is 1521.
        :param _builtins.int scan_listener_port_tls: The SCAN Listenenr TLS port. Default is 2484.
        :param Mapping[str, _builtins.str] security_attributes: Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        :param _builtins.str shape: The model name of the Exadata hardware running the cloud Autonomous VM cluster.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the cloud Autonomous VM Cluster is associated with.
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the cloud Autonomous VM cluster was created.
        :param _builtins.str time_database_ssl_certificate_expires: The date and time of Database SSL certificate expiration.
        :param _builtins.str time_ords_certificate_expires: The date and time of ORDS certificate expiration.
        :param _builtins.str time_updated: The last date and time that the cloud Autonomous VM cluster was updated.
        :param _builtins.float total_autonomous_data_storage_in_tbs: The total data disk group size for Autonomous Databases, in TBs.
        :param _builtins.int total_container_databases: The total number of Autonomous Container Databases that can be created with the allocated local storage.
        :param _builtins.float total_cpus: The total number of CPUs in an Autonomous VM Cluster.
        """
        pulumi.set(__self__, "autonomous_data_storage_percentage", autonomous_data_storage_percentage)
        pulumi.set(__self__, "autonomous_data_storage_size_in_tbs", autonomous_data_storage_size_in_tbs)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "available_autonomous_data_storage_size_in_tbs", available_autonomous_data_storage_size_in_tbs)
        pulumi.set(__self__, "available_container_databases", available_container_databases)
        pulumi.set(__self__, "available_cpus", available_cpus)
        pulumi.set(__self__, "cloud_exadata_infrastructure_id", cloud_exadata_infrastructure_id)
        pulumi.set(__self__, "cluster_time_zone", cluster_time_zone)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "cpu_core_count_per_node", cpu_core_count_per_node)
        pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_servers", db_servers)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "exadata_storage_in_tbs_lowest_scaled_value", exadata_storage_in_tbs_lowest_scaled_value)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_mtls_enabled_vm_cluster", is_mtls_enabled_vm_cluster)
        pulumi.set(__self__, "last_maintenance_run_id", last_maintenance_run_id)
        pulumi.set(__self__, "last_update_history_entry_id", last_update_history_entry_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_window_details", maintenance_window_details)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "max_acds_lowest_scaled_value", max_acds_lowest_scaled_value)
        pulumi.set(__self__, "memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "next_maintenance_run_id", next_maintenance_run_id)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "non_provisionable_autonomous_container_databases", non_provisionable_autonomous_container_databases)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        pulumi.set(__self__, "ocpus_lowest_scaled_value", ocpus_lowest_scaled_value)
        pulumi.set(__self__, "opc_dry_run", opc_dry_run)
        pulumi.set(__self__, "provisionable_autonomous_container_databases", provisionable_autonomous_container_databases)
        pulumi.set(__self__, "provisioned_autonomous_container_databases", provisioned_autonomous_container_databases)
        pulumi.set(__self__, "provisioned_cpus", provisioned_cpus)
        pulumi.set(__self__, "reclaimable_cpus", reclaimable_cpus)
        pulumi.set(__self__, "reserved_cpus", reserved_cpus)
        pulumi.set(__self__, "scan_listener_port_non_tls", scan_listener_port_non_tls)
        pulumi.set(__self__, "scan_listener_port_tls", scan_listener_port_tls)
        pulumi.set(__self__, "security_attributes", security_attributes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_database_ssl_certificate_expires", time_database_ssl_certificate_expires)
        pulumi.set(__self__, "time_ords_certificate_expires", time_ords_certificate_expires)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_autonomous_data_storage_in_tbs", total_autonomous_data_storage_in_tbs)
        pulumi.set(__self__, "total_container_databases", total_container_databases)
        pulumi.set(__self__, "total_cpus", total_cpus)

    @_builtins.property
    @pulumi.getter(name="autonomousDataStoragePercentage")
    def autonomous_data_storage_percentage(self) -> _builtins.float:
        """
        The percentage of the data storage used for the Autonomous Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "autonomous_data_storage_percentage")

    @_builtins.property
    @pulumi.getter(name="autonomousDataStorageSizeInTbs")
    def autonomous_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The data disk group size allocated for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "autonomous_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="availableAutonomousDataStorageSizeInTbs")
    def available_autonomous_data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The data disk group size available for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "available_autonomous_data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="availableContainerDatabases")
    def available_container_databases(self) -> _builtins.int:
        """
        The number of Autonomous Container Databases that can be created with the currently available local storage.
        """
        return pulumi.get(self, "available_container_databases")

    @_builtins.property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> _builtins.float:
        """
        CPU cores available for allocation to Autonomous Databases.
        """
        return pulumi.get(self, "available_cpus")

    @_builtins.property
    @pulumi.getter(name="cloudExadataInfrastructureId")
    def cloud_exadata_infrastructure_id(self) -> _builtins.str:
        """
        If provided, filters the results for the specified cloud Exadata infrastructure.
        """
        return pulumi.get(self, "cloud_exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="clusterTimeZone")
    def cluster_time_zone(self) -> _builtins.str:
        """
        The time zone of the Cloud Autonomous VM Cluster.
        """
        return pulumi.get(self, "cluster_time_zone")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Cloud Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy. See [Compute Models in Autonomous Database on Dedicated Exadata #Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores on the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCountPerNode")
    def cpu_core_count_per_node(self) -> _builtins.int:
        """
        The number of CPU cores enabled per VM cluster node.
        """
        return pulumi.get(self, "cpu_core_count_per_node")

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> _builtins.float:
        """
        The percentage of total number of CPUs used in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "cpu_percentage")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> _builtins.float:
        """
        The total data storage allocated, in gigabytes (GB).
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The total data storage allocated, in terabytes (TB).
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        """
        return pulumi.get(self, "db_servers")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        User defined description of the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name for the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="exadataStorageInTbsLowestScaledValue")
    def exadata_storage_in_tbs_lowest_scaled_value(self) -> _builtins.float:
        """
        The lowest value to which exadataStorage (in TBs) can be scaled down.
        """
        return pulumi.get(self, "exadata_storage_in_tbs_lowest_scaled_value")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname for the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isMtlsEnabledVmCluster")
    def is_mtls_enabled_vm_cluster(self) -> _builtins.bool:
        """
        Enable mutual TLS(mTLS) authentication for database at time of provisioning a VMCluster. This is applicable to database TLS Certificates only. Default is TLS
        """
        return pulumi.get(self, "is_mtls_enabled_vm_cluster")

    @_builtins.property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="lastUpdateHistoryEntryId")
    def last_update_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history. This value is updated when a maintenance update starts.
        """
        return pulumi.get(self, "last_update_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Oracle Database service. Note that when provisioning an [Autonomous Database on dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null. It is already set at the Autonomous Exadata Infrastructure level. When provisioning an [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) database, if a value is not specified, the system defaults the value to `BRING_YOUR_OWN_LICENSE`. Bring your own license (BYOL) also allows you to select the DB edition using the optional parameter.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="maxAcdsLowestScaledValue")
    def max_acds_lowest_scaled_value(self) -> _builtins.int:
        """
        The lowest value to which maximum number of ACDs can be scaled down.
        """
        return pulumi.get(self, "max_acds_lowest_scaled_value")

    @_builtins.property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> _builtins.int:
        """
        The amount of memory (in GBs) enabled per OCPU or ECPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of database servers in the cloud VM cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nonProvisionableAutonomousContainerDatabases")
    def non_provisionable_autonomous_container_databases(self) -> _builtins.int:
        """
        The number of non-provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "non_provisionable_autonomous_container_databases")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> _builtins.float:
        """
        The number of CPU cores on the cloud Autonomous VM cluster. Only 1 decimal place is allowed for the fractional part.
        """
        return pulumi.get(self, "ocpu_count")

    @_builtins.property
    @pulumi.getter(name="ocpusLowestScaledValue")
    def ocpus_lowest_scaled_value(self) -> _builtins.int:
        """
        The lowest value to which ocpus can be scaled down.
        """
        return pulumi.get(self, "ocpus_lowest_scaled_value")

    @_builtins.property
    @pulumi.getter(name="opcDryRun")
    def opc_dry_run(self) -> _builtins.bool:
        return pulumi.get(self, "opc_dry_run")

    @_builtins.property
    @pulumi.getter(name="provisionableAutonomousContainerDatabases")
    def provisionable_autonomous_container_databases(self) -> _builtins.int:
        """
        The number of provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisionable_autonomous_container_databases")

    @_builtins.property
    @pulumi.getter(name="provisionedAutonomousContainerDatabases")
    def provisioned_autonomous_container_databases(self) -> _builtins.int:
        """
        The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_autonomous_container_databases")

    @_builtins.property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> _builtins.float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @_builtins.property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> _builtins.float:
        """
        For Autonomous Databases on Dedicated Exadata Infrastructure:
        * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @_builtins.property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> _builtins.float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortNonTls")
    def scan_listener_port_non_tls(self) -> _builtins.int:
        """
        The SCAN Listener Non TLS port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_non_tls")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTls")
    def scan_listener_port_tls(self) -> _builtins.int:
        """
        The SCAN Listenenr TLS port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tls")

    @_builtins.property
    @pulumi.getter(name="securityAttributes")
    def security_attributes(self) -> Mapping[str, _builtins.str]:
        """
        Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        """
        return pulumi.get(self, "security_attributes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The model name of the Exadata hardware running the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the cloud Autonomous VM Cluster is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the cloud Autonomous VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeDatabaseSslCertificateExpires")
    def time_database_ssl_certificate_expires(self) -> _builtins.str:
        """
        The date and time of Database SSL certificate expiration.
        """
        return pulumi.get(self, "time_database_ssl_certificate_expires")

    @_builtins.property
    @pulumi.getter(name="timeOrdsCertificateExpires")
    def time_ords_certificate_expires(self) -> _builtins.str:
        """
        The date and time of ORDS certificate expiration.
        """
        return pulumi.get(self, "time_ords_certificate_expires")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the cloud Autonomous VM cluster was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalAutonomousDataStorageInTbs")
    def total_autonomous_data_storage_in_tbs(self) -> _builtins.float:
        """
        The total data disk group size for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "total_autonomous_data_storage_in_tbs")

    @_builtins.property
    @pulumi.getter(name="totalContainerDatabases")
    def total_container_databases(self) -> _builtins.int:
        """
        The total number of Autonomous Container Databases that can be created with the allocated local storage.
        """
        return pulumi.get(self, "total_container_databases")

    @_builtins.property
    @pulumi.getter(name="totalCpus")
    def total_cpus(self) -> _builtins.float:
        """
        The total number of CPUs in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "total_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.bool] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudExadataInfrastructureCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetCloudExadataInfrastructureDefinedFileSystemConfigurationResult(dict):
    def __init__(__self__, *,
                 is_backup_partition: _builtins.bool,
                 is_resizable: _builtins.bool,
                 min_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        pulumi.set(__self__, "is_resizable", is_resizable)
        pulumi.set(__self__, "min_size_gb", min_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> _builtins.bool:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> _builtins.bool:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> _builtins.int:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetCloudExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructureUnAllocatedResourceCloudAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 un_allocated_adb_storage_in_tbs: _builtins.float):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Exadata infrastructure.
        :param _builtins.float un_allocated_adb_storage_in_tbs: Total unallocated autonomous data storage in the Cloud Autonomous VM Cluster in TBs.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "un_allocated_adb_storage_in_tbs", un_allocated_adb_storage_in_tbs)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Exadata infrastructure.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="unAllocatedAdbStorageInTbs")
    def un_allocated_adb_storage_in_tbs(self) -> _builtins.float:
        """
        Total unallocated autonomous data storage in the Cloud Autonomous VM Cluster in TBs.
        """
        return pulumi.get(self, "un_allocated_adb_storage_in_tbs")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureResult(dict):
    def __init__(__self__, *,
                 activated_storage_count: _builtins.int,
                 additional_storage_count: _builtins.int,
                 availability_domain: _builtins.str,
                 available_storage_size_in_gbs: _builtins.int,
                 cluster_placement_group_id: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_count: _builtins.int,
                 compute_model: _builtins.str,
                 cpu_count: _builtins.int,
                 customer_contacts: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult'],
                 data_storage_size_in_tbs: _builtins.float,
                 database_server_type: _builtins.str,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_server_version: _builtins.str,
                 defined_file_system_configurations: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureDefinedFileSystemConfigurationResult'],
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_scheduling_policy_associated: _builtins.bool,
                 last_maintenance_run_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 maintenance_windows: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult'],
                 max_cpu_count: _builtins.int,
                 max_data_storage_in_tbs: _builtins.float,
                 max_db_node_storage_in_gbs: _builtins.int,
                 max_memory_in_gbs: _builtins.int,
                 memory_size_in_gbs: _builtins.int,
                 monthly_db_server_version: _builtins.str,
                 monthly_storage_server_version: _builtins.str,
                 next_maintenance_run_id: _builtins.str,
                 shape: _builtins.str,
                 state: _builtins.str,
                 storage_count: _builtins.int,
                 storage_server_type: _builtins.str,
                 storage_server_version: _builtins.str,
                 subscription_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 total_storage_size_in_gbs: _builtins.int):
        """
        :param _builtins.int activated_storage_count: The requested number of additional storage servers activated for the Exadata infrastructure.
        :param _builtins.int additional_storage_count: The requested number of additional storage servers for the Exadata infrastructure.
        :param _builtins.str availability_domain: The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        :param _builtins.int available_storage_size_in_gbs: The available storage can be allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        :param _builtins.str cluster_placement_group_id: A filter to return only resources that match the given cluster placement group ID exactly.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int compute_count: The number of compute servers for the cloud Exadata infrastructure.
        :param _builtins.str compute_model: The compute model of the Exadata infrastructure.
        :param _builtins.int cpu_count: The total number of CPU cores allocated.
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactArgs'] customer_contacts: The list of customer email addresses that receive information from Oracle about the specified Oracle Cloud Infrastructure Database service resource. Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators. Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance.
        :param _builtins.float data_storage_size_in_tbs: Size, in terabytes, of the DATA disk group.
        :param _builtins.str database_server_type: The database server type of the Exadata infrastructure.
        :param _builtins.int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param _builtins.str db_server_version: The software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureDefinedFileSystemConfigurationArgs'] defined_file_system_configurations: Details of the file system configuration of the Exadata infrastructure.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Exadata infrastructure resource.
        :param _builtins.bool is_scheduling_policy_associated: If true, the infrastructure is using granular maintenance scheduling preference.
        :param _builtins.str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.int max_cpu_count: The total number of CPU cores available.
        :param _builtins.float max_data_storage_in_tbs: The total available DATA disk group size.
        :param _builtins.int max_db_node_storage_in_gbs: The total local node storage available in GBs.
        :param _builtins.int max_memory_in_gbs: The total memory available in GBs.
        :param _builtins.int memory_size_in_gbs: The memory allocated in GBs.
        :param _builtins.str monthly_db_server_version: The monthly software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        :param _builtins.str monthly_storage_server_version: The monthly software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        :param _builtins.str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param _builtins.str shape: The model name of the cloud Exadata infrastructure resource.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.int storage_count: The number of storage servers for the cloud Exadata infrastructure.
        :param _builtins.str storage_server_type: The storage server type of the Exadata infrastructure.
        :param _builtins.str storage_server_version: The software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the cloud Exadata infrastructure resource was created.
        :param _builtins.int total_storage_size_in_gbs: The total storage allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        """
        pulumi.set(__self__, "activated_storage_count", activated_storage_count)
        pulumi.set(__self__, "additional_storage_count", additional_storage_count)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "available_storage_size_in_gbs", available_storage_size_in_gbs)
        pulumi.set(__self__, "cluster_placement_group_id", cluster_placement_group_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "cpu_count", cpu_count)
        pulumi.set(__self__, "customer_contacts", customer_contacts)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "database_server_type", database_server_type)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_server_version", db_server_version)
        pulumi.set(__self__, "defined_file_system_configurations", defined_file_system_configurations)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_scheduling_policy_associated", is_scheduling_policy_associated)
        pulumi.set(__self__, "last_maintenance_run_id", last_maintenance_run_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "max_cpu_count", max_cpu_count)
        pulumi.set(__self__, "max_data_storage_in_tbs", max_data_storage_in_tbs)
        pulumi.set(__self__, "max_db_node_storage_in_gbs", max_db_node_storage_in_gbs)
        pulumi.set(__self__, "max_memory_in_gbs", max_memory_in_gbs)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "monthly_db_server_version", monthly_db_server_version)
        pulumi.set(__self__, "monthly_storage_server_version", monthly_storage_server_version)
        pulumi.set(__self__, "next_maintenance_run_id", next_maintenance_run_id)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_count", storage_count)
        pulumi.set(__self__, "storage_server_type", storage_server_type)
        pulumi.set(__self__, "storage_server_version", storage_server_version)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "total_storage_size_in_gbs", total_storage_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="activatedStorageCount")
    def activated_storage_count(self) -> _builtins.int:
        """
        The requested number of additional storage servers activated for the Exadata infrastructure.
        """
        return pulumi.get(self, "activated_storage_count")

    @_builtins.property
    @pulumi.getter(name="additionalStorageCount")
    def additional_storage_count(self) -> _builtins.int:
        """
        The requested number of additional storage servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "additional_storage_count")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="availableStorageSizeInGbs")
    def available_storage_size_in_gbs(self) -> _builtins.int:
        """
        The available storage can be allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        """
        return pulumi.get(self, "available_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="clusterPlacementGroupId")
    def cluster_placement_group_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given cluster placement group ID exactly.
        """
        return pulumi.get(self, "cluster_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.int:
        """
        The number of compute servers for the cloud Exadata infrastructure.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Exadata infrastructure.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> _builtins.int:
        """
        The total number of CPU cores allocated.
        """
        return pulumi.get(self, "cpu_count")

    @_builtins.property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult']:
        """
        The list of customer email addresses that receive information from Oracle about the specified Oracle Cloud Infrastructure Database service resource. Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators. Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance.
        """
        return pulumi.get(self, "customer_contacts")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.float:
        """
        Size, in terabytes, of the DATA disk group.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="databaseServerType")
    def database_server_type(self) -> _builtins.str:
        """
        The database server type of the Exadata infrastructure.
        """
        return pulumi.get(self, "database_server_type")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServerVersion")
    def db_server_version(self) -> _builtins.str:
        """
        The software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "db_server_version")

    @_builtins.property
    @pulumi.getter(name="definedFileSystemConfigurations")
    def defined_file_system_configurations(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureDefinedFileSystemConfigurationResult']:
        """
        Details of the file system configuration of the Exadata infrastructure.
        """
        return pulumi.get(self, "defined_file_system_configurations")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Exadata infrastructure resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isSchedulingPolicyAssociated")
    def is_scheduling_policy_associated(self) -> _builtins.bool:
        """
        If true, the infrastructure is using granular maintenance scheduling preference.
        """
        return pulumi.get(self, "is_scheduling_policy_associated")

    @_builtins.property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="maxCpuCount")
    def max_cpu_count(self) -> _builtins.int:
        """
        The total number of CPU cores available.
        """
        return pulumi.get(self, "max_cpu_count")

    @_builtins.property
    @pulumi.getter(name="maxDataStorageInTbs")
    def max_data_storage_in_tbs(self) -> _builtins.float:
        """
        The total available DATA disk group size.
        """
        return pulumi.get(self, "max_data_storage_in_tbs")

    @_builtins.property
    @pulumi.getter(name="maxDbNodeStorageInGbs")
    def max_db_node_storage_in_gbs(self) -> _builtins.int:
        """
        The total local node storage available in GBs.
        """
        return pulumi.get(self, "max_db_node_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="maxMemoryInGbs")
    def max_memory_in_gbs(self) -> _builtins.int:
        """
        The total memory available in GBs.
        """
        return pulumi.get(self, "max_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="monthlyDbServerVersion")
    def monthly_db_server_version(self) -> _builtins.str:
        """
        The monthly software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "monthly_db_server_version")

    @_builtins.property
    @pulumi.getter(name="monthlyStorageServerVersion")
    def monthly_storage_server_version(self) -> _builtins.str:
        """
        The monthly software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "monthly_storage_server_version")

    @_builtins.property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The model name of the cloud Exadata infrastructure resource.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageCount")
    def storage_count(self) -> _builtins.int:
        """
        The number of storage servers for the cloud Exadata infrastructure.
        """
        return pulumi.get(self, "storage_count")

    @_builtins.property
    @pulumi.getter(name="storageServerType")
    def storage_server_type(self) -> _builtins.str:
        """
        The storage server type of the Exadata infrastructure.
        """
        return pulumi.get(self, "storage_server_type")

    @_builtins.property
    @pulumi.getter(name="storageServerVersion")
    def storage_server_version(self) -> _builtins.str:
        """
        The software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "storage_server_version")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the cloud Exadata infrastructure resource was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="totalStorageSizeInGbs")
    def total_storage_size_in_gbs(self) -> _builtins.int:
        """
        The total storage allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        """
        return pulumi.get(self, "total_storage_size_in_gbs")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str):
        """
        :param _builtins.str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureDefinedFileSystemConfigurationResult(dict):
    def __init__(__self__, *,
                 is_backup_partition: _builtins.bool,
                 is_resizable: _builtins.bool,
                 min_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        pulumi.set(__self__, "is_resizable", is_resizable)
        pulumi.set(__self__, "min_size_gb", min_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> _builtins.bool:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> _builtins.bool:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> _builtins.int:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructuresFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudVmClusterCloudAutomationUpdateDetailResult(dict):
    def __init__(__self__, *,
                 apply_update_time_preferences: Sequence['outputs.GetCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult'],
                 freeze_periods: Sequence['outputs.GetCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult'],
                 is_early_adoption_enabled: _builtins.bool,
                 is_freeze_period_enabled: _builtins.bool):
        """
        :param Sequence['GetCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs'] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param Sequence['GetCloudVmClusterCloudAutomationUpdateDetailFreezePeriodArgs'] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        pulumi.set(__self__, "freeze_periods", freeze_periods)
        pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Sequence['outputs.GetCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult']:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @_builtins.property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Sequence['outputs.GetCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult']:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> _builtins.bool:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> _builtins.bool:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class GetCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult(dict):
    def __init__(__self__, *,
                 apply_update_preferred_end_time: _builtins.str,
                 apply_update_preferred_start_time: _builtins.str):
        """
        :param _builtins.str apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> _builtins.str:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> _builtins.str:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class GetCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult(dict):
    def __init__(__self__, *,
                 freeze_period_end_time: _builtins.str,
                 freeze_period_start_time: _builtins.str):
        """
        :param _builtins.str freeze_period_end_time: End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: Start time of the freeze period cycle.
        """
        pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> _builtins.str:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> _builtins.str:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class GetCloudVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetCloudVmClusterFileSystemConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 file_system_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.int file_system_size_gb: The file system size to be allocated in GBs.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> _builtins.int:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetCloudVmClusterIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetCloudVmClusterIormConfigCachDbPlanResult'],
                 lifecycle_details: _builtins.str,
                 objective: _builtins.str,
                 state: _builtins.str):
        """
        :param Sequence['GetCloudVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: The current state of the cloud VM cluster.
        """
        pulumi.set(__self__, "db_plans", db_plans)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "objective", objective)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetCloudVmClusterIormConfigCachDbPlanResult']:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> _builtins.str:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudVmClusterIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetCloudVmClusterIormConfigDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetCloudVmClusterMultiCloudIdentityConnectorConfigResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str cloud_provider: Cloud provider
        :param _builtins.str id: The OCID of the identity connector
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Cloud provider
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the identity connector
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 backup_network_nsg_ids: Sequence[_builtins.str],
                 backup_subnet_id: _builtins.str,
                 cloud_automation_update_details: Sequence['outputs.GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailResult'],
                 cloud_exadata_infrastructure_id: _builtins.str,
                 cluster_name: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_model: _builtins.str,
                 cpu_core_count: _builtins.int,
                 create_async: _builtins.bool,
                 data_collection_options: Sequence['outputs.GetCloudVmClustersCloudVmClusterDataCollectionOptionResult'],
                 data_storage_percentage: _builtins.int,
                 data_storage_size_in_tbs: _builtins.float,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_servers: Sequence[_builtins.str],
                 defined_tags: Mapping[str, _builtins.str],
                 disk_redundancy: _builtins.str,
                 display_name: _builtins.str,
                 domain: _builtins.str,
                 file_system_configuration_details: Sequence['outputs.GetCloudVmClustersCloudVmClusterFileSystemConfigurationDetailResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 gi_version: _builtins.str,
                 hostname: _builtins.str,
                 id: _builtins.str,
                 iorm_config_caches: Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachResult'],
                 is_local_backup_enabled: _builtins.bool,
                 is_sparse_diskgroup_enabled: _builtins.bool,
                 last_update_history_entry_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 listener_port: _builtins.str,
                 memory_size_in_gbs: _builtins.int,
                 multi_cloud_identity_connector_configs: Sequence['outputs.GetCloudVmClustersCloudVmClusterMultiCloudIdentityConnectorConfigResult'],
                 node_count: _builtins.int,
                 nsg_ids: Sequence[_builtins.str],
                 ocpu_count: _builtins.float,
                 private_zone_id: _builtins.str,
                 scan_dns_name: _builtins.str,
                 scan_dns_record_id: _builtins.str,
                 scan_ip_ids: Sequence[_builtins.str],
                 scan_ipv6ids: Sequence[_builtins.str],
                 scan_listener_port_tcp: _builtins.int,
                 scan_listener_port_tcp_ssl: _builtins.int,
                 security_attributes: Mapping[str, _builtins.str],
                 shape: _builtins.str,
                 ssh_public_keys: Sequence[_builtins.str],
                 state: _builtins.str,
                 storage_size_in_gbs: _builtins.int,
                 subnet_id: _builtins.str,
                 subscription_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 system_version: _builtins.str,
                 tde_key_store_type: _builtins.str,
                 time_created: _builtins.str,
                 time_zone: _builtins.str,
                 vip_ids: Sequence[_builtins.str],
                 vipv6ids: Sequence[_builtins.str],
                 vm_cluster_type: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.str availability_domain: The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        :param Sequence[_builtins.str] backup_network_nsg_ids: A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        :param _builtins.str backup_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet associated with the cloud VM cluster.
        :param Sequence['GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailArgs'] cloud_automation_update_details: Specifies the properties necessary for cloud automation updates. This includes modifying the apply update time preference, enabling or disabling early adoption, and enabling, modifying, or disabling the update freeze period.
        :param _builtins.str cloud_exadata_infrastructure_id: If provided, filters the results for the specified cloud Exadata infrastructure.
        :param _builtins.str cluster_name: The cluster name for cloud VM cluster. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compute_model: The compute model of the cloud VM cluster.
        :param _builtins.int cpu_core_count: The number of CPU cores enabled on the cloud VM cluster.
        :param Sequence['GetCloudVmClustersCloudVmClusterDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param _builtins.int data_storage_percentage: The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 35, 40, 60 and 80. The default is 80 percent assigned to DATA storage. See [Storage Configuration](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/exaoverview.htm#Exadata) in the Exadata documentation for details on the impact of the configuration settings on storage.
        :param _builtins.float data_storage_size_in_tbs: The data disk group size to be allocated in TBs.
        :param _builtins.int db_node_storage_size_in_gbs: The local node storage to be allocated in GBs.
        :param Sequence[_builtins.str] db_servers: The list of DB servers.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str disk_redundancy: The type of redundancy configured for the cloud Vm cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str domain: The domain name for the cloud VM cluster.
        :param Sequence['GetCloudVmClustersCloudVmClusterFileSystemConfigurationDetailArgs'] file_system_configuration_details: Details of the file system configuration of the VM cluster.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param _builtins.str hostname: The hostname for the cloud VM cluster.
        :param _builtins.str id: The OCID of the identity connector
        :param _builtins.bool is_local_backup_enabled: If true, database backup on local Exadata storage is configured for the cloud VM cluster. If false, database backup on local Exadata storage is not available in the cloud VM cluster.
        :param _builtins.bool is_sparse_diskgroup_enabled: If true, sparse disk group is configured for the cloud VM cluster. If false, sparse disk group is not created.
        :param _builtins.str last_update_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history entry. This value is updated when a maintenance update starts.
        :param _builtins.str license_model: The Oracle license model that applies to the cloud VM cluster. The default is LICENSE_INCLUDED.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str listener_port: The port number configured for the listener on the cloud VM cluster.
        :param _builtins.int memory_size_in_gbs: The memory to be allocated in GBs.
        :param Sequence['GetCloudVmClustersCloudVmClusterMultiCloudIdentityConnectorConfigArgs'] multi_cloud_identity_connector_configs: Details of the multi cloud identity connectors of the VM cluster.
        :param _builtins.int node_count: The number of nodes in the cloud VM cluster.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.float ocpu_count: The number of OCPU cores to enable on the cloud VM cluster. Only 1 decimal place is allowed for the fractional part.
        :param _builtins.str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        :param _builtins.str scan_dns_record_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        :param Sequence[_builtins.str] scan_ip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv4 addresses associated with the cloud VM cluster. SCAN IPv4 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param Sequence[_builtins.str] scan_ipv6ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv6 addresses associated with the cloud VM cluster. SCAN IPv6 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param _builtins.int scan_listener_port_tcp: The TCP Single Client Access Name (SCAN) port. The default port is 1521.
        :param _builtins.int scan_listener_port_tcp_ssl: The TCPS Single Client Access Name (SCAN) port. The default port is 2484.
        :param Mapping[str, _builtins.str] security_attributes: Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        :param _builtins.str shape: The model name of the Exadata hardware running the cloud VM cluster.
        :param Sequence[_builtins.str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the cloud VM cluster.
        :param _builtins.str state: A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        :param _builtins.int storage_size_in_gbs: The storage allocation for the disk group, in gigabytes (GB).
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the cloud VM cluster.
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str system_version: Operating system version of the image.
        :param _builtins.str tde_key_store_type: TDE keystore type
        :param _builtins.str time_created: The date and time that the cloud VM cluster was created.
        :param _builtins.str time_zone: The time zone of the cloud VM cluster. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param Sequence[_builtins.str] vip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) IPv4 addresses associated with the cloud VM cluster. The Cluster Ready Services (CRS) creates and maintains one VIP IPv4 address for each node in the Exadata Cloud Service instance to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        :param Sequence[_builtins.str] vipv6ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) IPv6 addresses associated with the cloud VM cluster. The Cluster Ready Services (CRS) creates and maintains one VIP IPv6 address for each node in the Exadata Cloud Service instance to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        :param _builtins.str vm_cluster_type: A filter to return only cloud vmclusters that match the given cloud vmcluster type exactly.
        :param _builtins.str zone_id: The OCID of the zone the cloud VM cluster is associated with.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_network_nsg_ids", backup_network_nsg_ids)
        pulumi.set(__self__, "backup_subnet_id", backup_subnet_id)
        pulumi.set(__self__, "cloud_automation_update_details", cloud_automation_update_details)
        pulumi.set(__self__, "cloud_exadata_infrastructure_id", cloud_exadata_infrastructure_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "create_async", create_async)
        pulumi.set(__self__, "data_collection_options", data_collection_options)
        pulumi.set(__self__, "data_storage_percentage", data_storage_percentage)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_servers", db_servers)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "disk_redundancy", disk_redundancy)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "file_system_configuration_details", file_system_configuration_details)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "gi_version", gi_version)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "iorm_config_caches", iorm_config_caches)
        pulumi.set(__self__, "is_local_backup_enabled", is_local_backup_enabled)
        pulumi.set(__self__, "is_sparse_diskgroup_enabled", is_sparse_diskgroup_enabled)
        pulumi.set(__self__, "last_update_history_entry_id", last_update_history_entry_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "listener_port", listener_port)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "multi_cloud_identity_connector_configs", multi_cloud_identity_connector_configs)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        pulumi.set(__self__, "private_zone_id", private_zone_id)
        pulumi.set(__self__, "scan_dns_name", scan_dns_name)
        pulumi.set(__self__, "scan_dns_record_id", scan_dns_record_id)
        pulumi.set(__self__, "scan_ip_ids", scan_ip_ids)
        pulumi.set(__self__, "scan_ipv6ids", scan_ipv6ids)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)
        pulumi.set(__self__, "security_attributes", security_attributes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_size_in_gbs", storage_size_in_gbs)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "system_version", system_version)
        pulumi.set(__self__, "tde_key_store_type", tde_key_store_type)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "vip_ids", vip_ids)
        pulumi.set(__self__, "vipv6ids", vipv6ids)
        pulumi.set(__self__, "vm_cluster_type", vm_cluster_type)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[_builtins.str]:
        """
        A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        """
        return pulumi.get(self, "backup_network_nsg_ids")

    @_builtins.property
    @pulumi.getter(name="backupSubnetId")
    def backup_subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet associated with the cloud VM cluster.
        """
        return pulumi.get(self, "backup_subnet_id")

    @_builtins.property
    @pulumi.getter(name="cloudAutomationUpdateDetails")
    def cloud_automation_update_details(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailResult']:
        """
        Specifies the properties necessary for cloud automation updates. This includes modifying the apply update time preference, enabling or disabling early adoption, and enabling, modifying, or disabling the update freeze period.
        """
        return pulumi.get(self, "cloud_automation_update_details")

    @_builtins.property
    @pulumi.getter(name="cloudExadataInfrastructureId")
    def cloud_exadata_infrastructure_id(self) -> _builtins.str:
        """
        If provided, filters the results for the specified cloud Exadata infrastructure.
        """
        return pulumi.get(self, "cloud_exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The cluster name for cloud VM cluster. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the cloud VM cluster.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores enabled on the cloud VM cluster.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> _builtins.bool:
        return pulumi.get(self, "create_async")

    @_builtins.property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @_builtins.property
    @pulumi.getter(name="dataStoragePercentage")
    def data_storage_percentage(self) -> _builtins.int:
        """
        The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 35, 40, 60 and 80. The default is 80 percent assigned to DATA storage. See [Storage Configuration](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/exaoverview.htm#Exadata) in the Exadata documentation for details on the impact of the configuration settings on storage.
        """
        return pulumi.get(self, "data_storage_percentage")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.float:
        """
        The data disk group size to be allocated in TBs.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The local node storage to be allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[_builtins.str]:
        """
        The list of DB servers.
        """
        return pulumi.get(self, "db_servers")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="diskRedundancy")
    def disk_redundancy(self) -> _builtins.str:
        """
        The type of redundancy configured for the cloud Vm cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        """
        return pulumi.get(self, "disk_redundancy")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name for the cloud VM cluster.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="fileSystemConfigurationDetails")
    def file_system_configuration_details(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterFileSystemConfigurationDetailResult']:
        """
        Details of the file system configuration of the VM cluster.
        """
        return pulumi.get(self, "file_system_configuration_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="giVersion")
    def gi_version(self) -> _builtins.str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "gi_version")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname for the cloud VM cluster.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the identity connector
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="iormConfigCaches")
    def iorm_config_caches(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachResult']:
        return pulumi.get(self, "iorm_config_caches")

    @_builtins.property
    @pulumi.getter(name="isLocalBackupEnabled")
    def is_local_backup_enabled(self) -> _builtins.bool:
        """
        If true, database backup on local Exadata storage is configured for the cloud VM cluster. If false, database backup on local Exadata storage is not available in the cloud VM cluster.
        """
        return pulumi.get(self, "is_local_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="isSparseDiskgroupEnabled")
    def is_sparse_diskgroup_enabled(self) -> _builtins.bool:
        """
        If true, sparse disk group is configured for the cloud VM cluster. If false, sparse disk group is not created.
        """
        return pulumi.get(self, "is_sparse_diskgroup_enabled")

    @_builtins.property
    @pulumi.getter(name="lastUpdateHistoryEntryId")
    def last_update_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history entry. This value is updated when a maintenance update starts.
        """
        return pulumi.get(self, "last_update_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the cloud VM cluster. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> _builtins.str:
        """
        The port number configured for the listener on the cloud VM cluster.
        """
        return pulumi.get(self, "listener_port")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The memory to be allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="multiCloudIdentityConnectorConfigs")
    def multi_cloud_identity_connector_configs(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterMultiCloudIdentityConnectorConfigResult']:
        """
        Details of the multi cloud identity connectors of the VM cluster.
        """
        return pulumi.get(self, "multi_cloud_identity_connector_configs")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes in the cloud VM cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> _builtins.float:
        """
        The number of OCPU cores to enable on the cloud VM cluster. Only 1 decimal place is allowed for the fractional part.
        """
        return pulumi.get(self, "ocpu_count")

    @_builtins.property
    @pulumi.getter(name="privateZoneId")
    def private_zone_id(self) -> _builtins.str:
        return pulumi.get(self, "private_zone_id")

    @_builtins.property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> _builtins.str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        """
        return pulumi.get(self, "scan_dns_name")

    @_builtins.property
    @pulumi.getter(name="scanDnsRecordId")
    def scan_dns_record_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        """
        return pulumi.get(self, "scan_dns_record_id")

    @_builtins.property
    @pulumi.getter(name="scanIpIds")
    def scan_ip_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv4 addresses associated with the cloud VM cluster. SCAN IPv4 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ip_ids")

    @_builtins.property
    @pulumi.getter(name="scanIpv6ids")
    def scan_ipv6ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv6 addresses associated with the cloud VM cluster. SCAN IPv6 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ipv6ids")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The TCP Single Client Access Name (SCAN) port. The default port is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> _builtins.int:
        """
        The TCPS Single Client Access Name (SCAN) port. The default port is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")

    @_builtins.property
    @pulumi.getter(name="securityAttributes")
    def security_attributes(self) -> Mapping[str, _builtins.str]:
        """
        Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        """
        return pulumi.get(self, "security_attributes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The model name of the Exadata hardware running the cloud VM cluster.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[_builtins.str]:
        """
        The public key portion of one or more key pairs used for SSH access to the cloud VM cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageSizeInGbs")
    def storage_size_in_gbs(self) -> _builtins.int:
        """
        The storage allocation for the disk group, in gigabytes (GB).
        """
        return pulumi.get(self, "storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the cloud VM cluster.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="systemVersion")
    def system_version(self) -> _builtins.str:
        """
        Operating system version of the image.
        """
        return pulumi.get(self, "system_version")

    @_builtins.property
    @pulumi.getter(name="tdeKeyStoreType")
    def tde_key_store_type(self) -> _builtins.str:
        """
        TDE keystore type
        """
        return pulumi.get(self, "tde_key_store_type")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the cloud VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the cloud VM cluster. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="vipIds")
    def vip_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) IPv4 addresses associated with the cloud VM cluster. The Cluster Ready Services (CRS) creates and maintains one VIP IPv4 address for each node in the Exadata Cloud Service instance to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vip_ids")

    @_builtins.property
    @pulumi.getter
    def vipv6ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) IPv6 addresses associated with the cloud VM cluster. The Cluster Ready Services (CRS) creates and maintains one VIP IPv6 address for each node in the Exadata Cloud Service instance to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vipv6ids")

    @_builtins.property
    @pulumi.getter(name="vmClusterType")
    def vm_cluster_type(self) -> _builtins.str:
        """
        A filter to return only cloud vmclusters that match the given cloud vmcluster type exactly.
        """
        return pulumi.get(self, "vm_cluster_type")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The OCID of the zone the cloud VM cluster is associated with.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailResult(dict):
    def __init__(__self__, *,
                 apply_update_time_preferences: Sequence['outputs.GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult'],
                 freeze_periods: Sequence['outputs.GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult'],
                 is_early_adoption_enabled: _builtins.bool,
                 is_freeze_period_enabled: _builtins.bool):
        """
        :param Sequence['GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs'] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param Sequence['GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailFreezePeriodArgs'] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        pulumi.set(__self__, "freeze_periods", freeze_periods)
        pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult']:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @_builtins.property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult']:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> _builtins.bool:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> _builtins.bool:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult(dict):
    def __init__(__self__, *,
                 apply_update_preferred_end_time: _builtins.str,
                 apply_update_preferred_start_time: _builtins.str):
        """
        :param _builtins.str apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> _builtins.str:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> _builtins.str:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterCloudAutomationUpdateDetailFreezePeriodResult(dict):
    def __init__(__self__, *,
                 freeze_period_end_time: _builtins.str,
                 freeze_period_start_time: _builtins.str):
        """
        :param _builtins.str freeze_period_end_time: End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: Start time of the freeze period cycle.
        """
        pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> _builtins.str:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> _builtins.str:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterFileSystemConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 file_system_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.int file_system_size_gb: The file system size to be allocated in GBs.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> _builtins.int:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult'],
                 lifecycle_details: _builtins.str,
                 objective: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        """
        pulumi.set(__self__, "db_plans", db_plans)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "objective", objective)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult']:
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> _builtins.str:
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        return pulumi.get(self, "share")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterMultiCloudIdentityConnectorConfigResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str cloud_provider: Cloud provider
        :param _builtins.str id: The OCID of the identity connector
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Cloud provider
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the identity connector
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetCloudVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDataGuardAssociationDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetDataGuardAssociationsDataGuardAssociationResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 availability_domain: _builtins.str,
                 backup_network_nsg_ids: Sequence[_builtins.str],
                 cpu_core_count: _builtins.int,
                 create_async: _builtins.bool,
                 creation_type: _builtins.str,
                 data_collection_options: Sequence['outputs.GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult'],
                 database_admin_password: _builtins.str,
                 database_defined_tags: Mapping[str, _builtins.str],
                 database_freeform_tags: Mapping[str, _builtins.str],
                 database_id: _builtins.str,
                 database_software_image_id: _builtins.str,
                 db_system_defined_tags: Mapping[str, _builtins.str],
                 db_system_freeform_tags: Mapping[str, _builtins.str],
                 db_system_security_attributes: Mapping[str, _builtins.str],
                 delete_standby_db_home_on_delete: _builtins.str,
                 display_name: _builtins.str,
                 domain: _builtins.str,
                 fault_domains: Sequence[_builtins.str],
                 hostname: _builtins.str,
                 id: _builtins.str,
                 is_active_data_guard_enabled: _builtins.bool,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 migrate_trigger: _builtins.int,
                 node_count: _builtins.int,
                 nsg_ids: Sequence[_builtins.str],
                 peer_data_guard_association_id: _builtins.str,
                 peer_database_id: _builtins.str,
                 peer_db_home_id: _builtins.str,
                 peer_db_system_id: _builtins.str,
                 peer_db_unique_name: _builtins.str,
                 peer_role: _builtins.str,
                 peer_sid_prefix: _builtins.str,
                 peer_vm_cluster_id: _builtins.str,
                 private_ip: _builtins.str,
                 private_ip_v6: _builtins.str,
                 protection_mode: _builtins.str,
                 role: _builtins.str,
                 shape: _builtins.str,
                 state: _builtins.str,
                 storage_volume_performance_mode: _builtins.str,
                 subnet_id: _builtins.str,
                 time_created: _builtins.str,
                 time_zone: _builtins.str,
                 transport_type: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        :param _builtins.str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        :param _builtins.str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Data Guard association.
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycleState, if available.
        :param _builtins.str peer_data_guard_association_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer database's Data Guard association.
        :param _builtins.str peer_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated peer database.
        :param _builtins.str peer_db_home_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home containing the associated peer database.
        :param _builtins.str peer_db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system containing the associated peer database.
        :param _builtins.str peer_role: The role of the peer database in this Data Guard association.
        :param _builtins.str protection_mode: The protection mode of this Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str role: The role of the reporting database in this Data Guard association.
        :param _builtins.str state: The current state of the Data Guard association.
        :param _builtins.str time_created: The date and time the Data Guard association was created.
        :param _builtins.str transport_type: The redo transport type used by this Data Guard association.  For more information, see [Redo Transport Services](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-redo-transport-services.htm#SBYDB00400) in the Oracle Data Guard documentation.
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_network_nsg_ids", backup_network_nsg_ids)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "create_async", create_async)
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "data_collection_options", data_collection_options)
        pulumi.set(__self__, "database_admin_password", database_admin_password)
        pulumi.set(__self__, "database_defined_tags", database_defined_tags)
        pulumi.set(__self__, "database_freeform_tags", database_freeform_tags)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "db_system_defined_tags", db_system_defined_tags)
        pulumi.set(__self__, "db_system_freeform_tags", db_system_freeform_tags)
        pulumi.set(__self__, "db_system_security_attributes", db_system_security_attributes)
        pulumi.set(__self__, "delete_standby_db_home_on_delete", delete_standby_db_home_on_delete)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "fault_domains", fault_domains)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "migrate_trigger", migrate_trigger)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "peer_data_guard_association_id", peer_data_guard_association_id)
        pulumi.set(__self__, "peer_database_id", peer_database_id)
        pulumi.set(__self__, "peer_db_home_id", peer_db_home_id)
        pulumi.set(__self__, "peer_db_system_id", peer_db_system_id)
        pulumi.set(__self__, "peer_db_unique_name", peer_db_unique_name)
        pulumi.set(__self__, "peer_role", peer_role)
        pulumi.set(__self__, "peer_sid_prefix", peer_sid_prefix)
        pulumi.set(__self__, "peer_vm_cluster_id", peer_vm_cluster_id)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "private_ip_v6", private_ip_v6)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_volume_performance_mode", storage_volume_performance_mode)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "transport_type", transport_type)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "backup_network_nsg_ids")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> _builtins.bool:
        return pulumi.get(self, "create_async")

    @_builtins.property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> _builtins.str:
        return pulumi.get(self, "creation_type")

    @_builtins.property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult']:
        return pulumi.get(self, "data_collection_options")

    @_builtins.property
    @pulumi.getter(name="databaseAdminPassword")
    def database_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "database_admin_password")

    @_builtins.property
    @pulumi.getter(name="databaseDefinedTags")
    def database_defined_tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "database_defined_tags")

    @_builtins.property
    @pulumi.getter(name="databaseFreeformTags")
    def database_freeform_tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "database_freeform_tags")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbSystemDefinedTags")
    def db_system_defined_tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "db_system_defined_tags")

    @_builtins.property
    @pulumi.getter(name="dbSystemFreeformTags")
    def db_system_freeform_tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "db_system_freeform_tags")

    @_builtins.property
    @pulumi.getter(name="dbSystemSecurityAttributes")
    def db_system_security_attributes(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "db_system_security_attributes")

    @_builtins.property
    @pulumi.getter(name="deleteStandbyDbHomeOnDelete")
    def delete_standby_db_home_on_delete(self) -> _builtins.str:
        return pulumi.get(self, "delete_standby_db_home_on_delete")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "fault_domains")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Data Guard association.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> _builtins.bool:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycleState, if available.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="migrateTrigger")
    def migrate_trigger(self) -> _builtins.int:
        return pulumi.get(self, "migrate_trigger")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="peerDataGuardAssociationId")
    def peer_data_guard_association_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer database's Data Guard association.
        """
        return pulumi.get(self, "peer_data_guard_association_id")

    @_builtins.property
    @pulumi.getter(name="peerDatabaseId")
    def peer_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated peer database.
        """
        return pulumi.get(self, "peer_database_id")

    @_builtins.property
    @pulumi.getter(name="peerDbHomeId")
    def peer_db_home_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home containing the associated peer database.
        """
        return pulumi.get(self, "peer_db_home_id")

    @_builtins.property
    @pulumi.getter(name="peerDbSystemId")
    def peer_db_system_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system containing the associated peer database.
        """
        return pulumi.get(self, "peer_db_system_id")

    @_builtins.property
    @pulumi.getter(name="peerDbUniqueName")
    def peer_db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_db_unique_name")

    @_builtins.property
    @pulumi.getter(name="peerRole")
    def peer_role(self) -> _builtins.str:
        """
        The role of the peer database in this Data Guard association.
        """
        return pulumi.get(self, "peer_role")

    @_builtins.property
    @pulumi.getter(name="peerSidPrefix")
    def peer_sid_prefix(self) -> _builtins.str:
        return pulumi.get(self, "peer_sid_prefix")

    @_builtins.property
    @pulumi.getter(name="peerVmClusterId")
    def peer_vm_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="privateIpV6")
    def private_ip_v6(self) -> _builtins.str:
        return pulumi.get(self, "private_ip_v6")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the reporting database in this Data Guard association.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Data Guard association.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageVolumePerformanceMode")
    def storage_volume_performance_mode(self) -> _builtins.str:
        return pulumi.get(self, "storage_volume_performance_mode")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Data Guard association was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> _builtins.str:
        """
        The redo transport type used by this Data Guard association.  For more information, see [Redo Transport Services](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-redo-transport-services.htm#SBYDB00400) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "transport_type")


@pulumi.output_type
class GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetDataGuardAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 cdb_default: _builtins.str,
                 cdb_ip_default: _builtins.str):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the Database.
        :param _builtins.str cdb_default: Host name based CDB Connection String.
        :param _builtins.str cdb_ip_default: IP based CDB Connection String.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "cdb_default", cdb_default)
        pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> _builtins.str:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> _builtins.str:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDatabaseDataGuardGroupResult(dict):
    def __init__(__self__, *,
                 members: Sequence['outputs.GetDatabaseDataGuardGroupMemberResult'],
                 protection_mode: _builtins.str):
        """
        :param Sequence['GetDatabaseDataGuardGroupMemberArgs'] members: List of Data Guard members, representing each database that is part of Data Guard.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "protection_mode", protection_mode)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetDatabaseDataGuardGroupMemberResult']:
        """
        List of Data Guard members, representing each database that is part of Data Guard.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")


@pulumi.output_type
class GetDatabaseDataGuardGroupMemberResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 database_id: _builtins.str,
                 db_system_id: _builtins.str,
                 is_active_data_guard_enabled: _builtins.bool,
                 role: _builtins.str,
                 transport_lag: _builtins.str,
                 transport_lag_refresh: _builtins.str,
                 transport_type: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        :param _builtins.str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        :param _builtins.str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str role: The role of the reporting database in this Data Guard association.
        :param _builtins.str transport_lag: The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        :param _builtins.str transport_lag_refresh: The date and time when last redo transport has been done.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "transport_lag", transport_lag)
        pulumi.set(__self__, "transport_lag_refresh", transport_lag_refresh)
        pulumi.set(__self__, "transport_type", transport_type)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> _builtins.bool:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the reporting database in this Data Guard association.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        """
        return pulumi.get(self, "transport_lag")

    @_builtins.property
    @pulumi.getter(name="transportLagRefresh")
    def transport_lag_refresh(self) -> _builtins.str:
        """
        The date and time when last redo transport has been done.
        """
        return pulumi.get(self, "transport_lag_refresh")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> _builtins.str:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC
        """
        return pulumi.get(self, "transport_type")


@pulumi.output_type
class GetDatabaseDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: _builtins.str,
                 backup_tde_password: _builtins.str,
                 character_set: _builtins.str,
                 database_admin_password: _builtins.str,
                 database_software_image_id: _builtins.str,
                 db_backup_configs: Sequence['outputs.GetDatabaseDatabaseDbBackupConfigResult'],
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 encryption_key_location_details: Sequence['outputs.GetDatabaseDatabaseEncryptionKeyLocationDetailResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 is_active_data_guard_enabled: _builtins.bool,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 ncharacter_set: _builtins.str,
                 pdb_name: _builtins.str,
                 pluggable_databases: Sequence[_builtins.str],
                 protection_mode: _builtins.str,
                 sid_prefix: _builtins.str,
                 source_database_id: _builtins.str,
                 source_encryption_key_location_details: Sequence['outputs.GetDatabaseDatabaseSourceEncryptionKeyLocationDetailResult'],
                 source_tde_wallet_password: _builtins.str,
                 tde_wallet_password: _builtins.str,
                 transport_type: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str character_set: The character set for the database.
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Sequence['GetDatabaseDatabaseDbBackupConfigArgs'] db_backup_configs: Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param _builtins.str db_name: The database name.
        :param _builtins.str db_unique_name: A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        :param _builtins.str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Sequence['GetDatabaseDatabaseEncryptionKeyLocationDetailArgs'] encryption_key_location_details: Types of providers supported for managing database encryption keys
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str ncharacter_set: The national character set for the database.
        :param _builtins.str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "database_admin_password", database_admin_password)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "db_backup_configs", db_backup_configs)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "sid_prefix", sid_prefix)
        pulumi.set(__self__, "source_database_id", source_database_id)
        pulumi.set(__self__, "source_encryption_key_location_details", source_encryption_key_location_details)
        pulumi.set(__self__, "source_tde_wallet_password", source_tde_wallet_password)
        pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        pulumi.set(__self__, "transport_type", transport_type)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> _builtins.str:
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set for the database.
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="databaseAdminPassword")
    def database_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "database_admin_password")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDatabaseDatabaseDbBackupConfigResult']:
        """
        Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_configs")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Sequence['outputs.GetDatabaseDatabaseEncryptionKeyLocationDetailResult']:
        """
        Types of providers supported for managing database encryption keys
        """
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> _builtins.bool:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character set for the database.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> _builtins.str:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> _builtins.str:
        return pulumi.get(self, "source_database_id")

    @_builtins.property
    @pulumi.getter(name="sourceEncryptionKeyLocationDetails")
    def source_encryption_key_location_details(self) -> Sequence['outputs.GetDatabaseDatabaseSourceEncryptionKeyLocationDetailResult']:
        return pulumi.get(self, "source_encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="sourceTdeWalletPassword")
    def source_tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "source_tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> _builtins.str:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC
        """
        return pulumi.get(self, "transport_type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDatabaseDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        """
        :param _builtins.bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabaseDatabaseEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 azure_encryption_key_id: _builtins.str,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        """
        :param _builtins.str azure_encryption_key_id: Provide the key OCID of a registered Azure key.
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> _builtins.str:
        """
        Provide the key OCID of a registered Azure key.
        """
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: _builtins.str,
                 management_type: _builtins.str):
        """
        :param _builtins.str management_status: The status of the Database Management service.
        :param _builtins.str management_type: The Database Management type.
        """
        pulumi.set(__self__, "management_status", management_status)
        pulumi.set(__self__, "management_type", management_type)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @_builtins.property
    @pulumi.getter(name="managementType")
    def management_type(self) -> _builtins.str:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")


@pulumi.output_type
class GetDatabaseDatabaseSourceEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        """
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        """
        :param _builtins.bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        :param _builtins.str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param _builtins.str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryResult(dict):
    def __init__(__self__, *,
                 current_execution_window: _builtins.str,
                 db_servers_history_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult'],
                 granular_maintenance_histories: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryResult'],
                 id: _builtins.str,
                 maintenance_run_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult']):
        """
        :param _builtins.str current_execution_window: The OCID of the current execution window.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailArgs'] db_servers_history_details: List of database server history details.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryArgs'] granular_maintenance_histories: The list of granular maintenance history details.
        :param _builtins.str id: The OCID of the maintenance run.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailArgs'] maintenance_run_details: Details of a maintenance run.
        """
        pulumi.set(__self__, "current_execution_window", current_execution_window)
        pulumi.set(__self__, "db_servers_history_details", db_servers_history_details)
        pulumi.set(__self__, "granular_maintenance_histories", granular_maintenance_histories)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "maintenance_run_details", maintenance_run_details)

    @_builtins.property
    @pulumi.getter(name="currentExecutionWindow")
    def current_execution_window(self) -> _builtins.str:
        """
        The OCID of the current execution window.
        """
        return pulumi.get(self, "current_execution_window")

    @_builtins.property
    @pulumi.getter(name="dbServersHistoryDetails")
    def db_servers_history_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult']:
        """
        List of database server history details.
        """
        return pulumi.get(self, "db_servers_history_details")

    @_builtins.property
    @pulumi.getter(name="granularMaintenanceHistories")
    def granular_maintenance_histories(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryResult']:
        """
        The list of granular maintenance history details.
        """
        return pulumi.get(self, "granular_maintenance_histories")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maintenanceRunDetails")
    def maintenance_run_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult']:
        """
        Details of a maintenance run.
        """
        return pulumi.get(self, "maintenance_run_details")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult(dict):
    def __init__(__self__, *,
                 db_server_patching_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult'],
                 display_name: _builtins.str,
                 id: _builtins.str):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailArgs'] db_server_patching_details: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.str id: The OCID of the maintenance run.
        """
        pulumi.set(__self__, "db_server_patching_details", db_server_patching_details)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbServerPatchingDetails")
    def db_server_patching_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "db_server_patching_details")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: _builtins.int,
                 patching_status: _builtins.str,
                 time_patching_ended: _builtins.str,
                 time_patching_started: _builtins.str):
        """
        :param _builtins.int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str time_patching_ended: The time when the patching operation ended.
        :param _builtins.str time_patching_started: The time when the patching operation started.
        """
        pulumi.set(__self__, "estimated_patch_duration", estimated_patch_duration)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "time_patching_ended", time_patching_ended)
        pulumi.set(__self__, "time_patching_started", time_patching_started)

    @_builtins.property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> _builtins.int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @_builtins.property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryResult(dict):
    def __init__(__self__, *,
                 execution_actions: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult'],
                 execution_windows: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult']):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionArgs'] execution_actions: The list of execution actions for this granular maintenance history.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowArgs'] execution_windows: Details of an execution window.
        """
        pulumi.set(__self__, "execution_actions", execution_actions)
        pulumi.set(__self__, "execution_windows", execution_windows)

    @_builtins.property
    @pulumi.getter(name="executionActions")
    def execution_actions(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult']:
        """
        The list of execution actions for this granular maintenance history.
        """
        return pulumi.get(self, "execution_actions")

    @_builtins.property
    @pulumi.getter(name="executionWindows")
    def execution_windows(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult']:
        """
        Details of an execution window.
        """
        return pulumi.get(self, "execution_windows")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult(dict):
    def __init__(__self__, *,
                 action_members: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult'],
                 action_params: Mapping[str, _builtins.str],
                 action_type: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 execution_action_order: _builtins.int,
                 execution_window_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 lifecycle_substate: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberArgs'] action_members: List of action members of this execution action.
        :param Mapping[str, _builtins.str] action_params: Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        :param _builtins.str action_type: The action type of the execution action being performed
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.int execution_action_order: The priority order of the execution action.
        :param _builtins.str execution_window_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution window resource the execution action belongs to.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str lifecycle_substate: The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        :param _builtins.str state: The state of the maintenance run history.
        :param _builtins.str time_created: The date and time the execution window was created.
        :param _builtins.str time_updated: The last date and time that the execution window was updated.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "action_members", action_members)
        pulumi.set(__self__, "action_params", action_params)
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "execution_action_order", execution_action_order)
        pulumi.set(__self__, "execution_window_id", execution_window_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_substate", lifecycle_substate)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="actionMembers")
    def action_members(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult']:
        """
        List of action members of this execution action.
        """
        return pulumi.get(self, "action_members")

    @_builtins.property
    @pulumi.getter(name="actionParams")
    def action_params(self) -> Mapping[str, _builtins.str]:
        """
        Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        """
        return pulumi.get(self, "action_params")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The action type of the execution action being performed
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="executionActionOrder")
    def execution_action_order(self) -> _builtins.int:
        """
        The priority order of the execution action.
        """
        return pulumi.get(self, "execution_action_order")

    @_builtins.property
    @pulumi.getter(name="executionWindowId")
    def execution_window_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution window resource the execution action belongs to.
        """
        return pulumi.get(self, "execution_window_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lifecycleSubstate")
    def lifecycle_substate(self) -> _builtins.str:
        """
        The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        """
        return pulumi.get(self, "lifecycle_substate")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the maintenance run history.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the execution window was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the execution window was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int,
                 status: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.str member_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        :param _builtins.int member_order: The priority order of the execution action member.
        :param _builtins.str status: The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
               * SCHEDULED
               * IN_PROGRESS
               * FAILED
               * CANCELED
               * DURATION_EXCEEDED
               * RESCHEDULED
               * SUCCEEDED
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The priority order of the execution action member.
        """
        return pulumi.get(self, "member_order")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
        * SCHEDULED
        * IN_PROGRESS
        * FAILED
        * CANCELED
        * DURATION_EXCEEDED
        * RESCHEDULED
        * SUCCEEDED
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 execution_resource_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enforced_duration: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 lifecycle_substate: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_ended: _builtins.str,
                 time_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 time_updated: _builtins.str,
                 total_time_taken_in_mins: _builtins.int,
                 window_duration_in_mins: _builtins.int,
                 window_type: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.str execution_resource_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution resource the execution window belongs to.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.bool is_enforced_duration: Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str lifecycle_substate: The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        :param _builtins.str state: The state of the maintenance run history.
        :param _builtins.str time_created: The date and time the execution window was created.
        :param _builtins.str time_ended: The date and time the maintenance run was completed.
        :param _builtins.str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param _builtins.str time_started: The date and time the maintenance run starts.
        :param _builtins.str time_updated: The last date and time that the execution window was updated.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        :param _builtins.int window_duration_in_mins: Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        :param _builtins.str window_type: The execution window is of PLANNED or UNPLANNED type.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "execution_resource_id", execution_resource_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enforced_duration", is_enforced_duration)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_substate", lifecycle_substate)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_scheduled", time_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)
        pulumi.set(__self__, "window_duration_in_mins", window_duration_in_mins)
        pulumi.set(__self__, "window_type", window_type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="executionResourceId")
    def execution_resource_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution resource the execution window belongs to.
        """
        return pulumi.get(self, "execution_resource_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnforcedDuration")
    def is_enforced_duration(self) -> _builtins.bool:
        """
        Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_enforced_duration")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lifecycleSubstate")
    def lifecycle_substate(self) -> _builtins.str:
        """
        The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        """
        return pulumi.get(self, "lifecycle_substate")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the maintenance run history.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the execution window was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> _builtins.str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the execution window was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")

    @_builtins.property
    @pulumi.getter(name="windowDurationInMins")
    def window_duration_in_mins(self) -> _builtins.int:
        """
        Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        """
        return pulumi.get(self, "window_duration_in_mins")

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> _builtins.str:
        """
        The execution window is of PLANNED or UNPLANNED type.
        """
        return pulumi.get(self, "window_type")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 current_custom_action_timeout_in_mins: _builtins.int,
                 current_patching_component: _builtins.str,
                 custom_action_timeout_in_mins: _builtins.int,
                 database_software_image_id: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_component_patching_start_time: _builtins.str,
                 estimated_patching_times: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult'],
                 id: _builtins.str,
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_dst_file_update_enabled: _builtins.bool,
                 is_maintenance_run_granular: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 maintenance_subtype: _builtins.str,
                 maintenance_type: _builtins.str,
                 patch_failure_count: _builtins.int,
                 patch_id: _builtins.str,
                 patching_end_time: _builtins.str,
                 patching_mode: _builtins.str,
                 patching_start_time: _builtins.str,
                 patching_status: _builtins.str,
                 peer_maintenance_run_id: _builtins.str,
                 peer_maintenance_run_ids: Sequence[_builtins.str],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 target_db_server_version: _builtins.str,
                 target_resource_id: _builtins.str,
                 target_resource_type: _builtins.str,
                 target_storage_server_version: _builtins.str,
                 time_ended: _builtins.str,
                 time_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int current_custom_action_timeout_in_mins: Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        :param _builtins.str current_patching_component: The name of the current infrastruture component that is getting patched.
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        :param _builtins.str database_software_image_id: The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.str estimated_component_patching_start_time: The estimated start time of the next infrastruture component patching operation.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeArgs'] estimated_patching_times: The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        :param _builtins.bool is_dst_file_update_enabled: Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        :param _builtins.bool is_maintenance_run_granular: If `FALSE`, the maintenance run doesn't support granular maintenance.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_subtype: Maintenance sub-type.
        :param _builtins.str maintenance_type: The maintenance type.
        :param _builtins.int patch_failure_count: Contain the patch failure count.
        :param _builtins.str patch_id: The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        :param _builtins.str patching_end_time: The time when the patching operation ended.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str patching_start_time: The time when the patching operation started.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str peer_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        :param Sequence[_builtins.str] peer_maintenance_run_ids: The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
        :param _builtins.str state: The state of the maintenance run history.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str target_db_server_version: The target software version for the database server patching operation.
        :param _builtins.str target_resource_id: The target resource ID.
        :param _builtins.str target_resource_type: The type of the target resource.
        :param _builtins.str target_storage_server_version: The target Cell version that is to be patched to.
        :param _builtins.str time_ended: The date and time the maintenance run was completed.
        :param _builtins.str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param _builtins.str time_started: The date and time the maintenance run starts.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "current_custom_action_timeout_in_mins", current_custom_action_timeout_in_mins)
        pulumi.set(__self__, "current_patching_component", current_patching_component)
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_component_patching_start_time", estimated_component_patching_start_time)
        pulumi.set(__self__, "estimated_patching_times", estimated_patching_times)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_dst_file_update_enabled", is_dst_file_update_enabled)
        pulumi.set(__self__, "is_maintenance_run_granular", is_maintenance_run_granular)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_subtype", maintenance_subtype)
        pulumi.set(__self__, "maintenance_type", maintenance_type)
        pulumi.set(__self__, "patch_failure_count", patch_failure_count)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "patching_end_time", patching_end_time)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "patching_start_time", patching_start_time)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "peer_maintenance_run_id", peer_maintenance_run_id)
        pulumi.set(__self__, "peer_maintenance_run_ids", peer_maintenance_run_ids)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "target_db_server_version", target_db_server_version)
        pulumi.set(__self__, "target_resource_id", target_resource_id)
        pulumi.set(__self__, "target_resource_type", target_resource_type)
        pulumi.set(__self__, "target_storage_server_version", target_storage_server_version)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_scheduled", time_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="currentCustomActionTimeoutInMins")
    def current_custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        """
        return pulumi.get(self, "current_custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="currentPatchingComponent")
    def current_patching_component(self) -> _builtins.str:
        """
        The name of the current infrastruture component that is getting patched.
        """
        return pulumi.get(self, "current_patching_component")

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedComponentPatchingStartTime")
    def estimated_component_patching_start_time(self) -> _builtins.str:
        """
        The estimated start time of the next infrastruture component patching operation.
        """
        return pulumi.get(self, "estimated_component_patching_start_time")

    @_builtins.property
    @pulumi.getter(name="estimatedPatchingTimes")
    def estimated_patching_times(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult']:
        """
        The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        """
        return pulumi.get(self, "estimated_patching_times")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isDstFileUpdateEnabled")
    def is_dst_file_update_enabled(self) -> _builtins.bool:
        """
        Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        """
        return pulumi.get(self, "is_dst_file_update_enabled")

    @_builtins.property
    @pulumi.getter(name="isMaintenanceRunGranular")
    def is_maintenance_run_granular(self) -> _builtins.bool:
        """
        If `FALSE`, the maintenance run doesn't support granular maintenance.
        """
        return pulumi.get(self, "is_maintenance_run_granular")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceSubtype")
    def maintenance_subtype(self) -> _builtins.str:
        """
        Maintenance sub-type.
        """
        return pulumi.get(self, "maintenance_subtype")

    @_builtins.property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> _builtins.str:
        """
        The maintenance type.
        """
        return pulumi.get(self, "maintenance_type")

    @_builtins.property
    @pulumi.getter(name="patchFailureCount")
    def patch_failure_count(self) -> _builtins.int:
        """
        Contain the patch failure count.
        """
        return pulumi.get(self, "patch_failure_count")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter(name="patchingEndTime")
    def patching_end_time(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "patching_end_time")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter(name="patchingStartTime")
    def patching_start_time(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "patching_start_time")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="peerMaintenanceRunId")
    def peer_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        """
        return pulumi.get(self, "peer_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="peerMaintenanceRunIds")
    def peer_maintenance_run_ids(self) -> Sequence[_builtins.str]:
        """
        The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
        """
        return pulumi.get(self, "peer_maintenance_run_ids")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the maintenance run history.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="targetDbServerVersion")
    def target_db_server_version(self) -> _builtins.str:
        """
        The target software version for the database server patching operation.
        """
        return pulumi.get(self, "target_db_server_version")

    @_builtins.property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> _builtins.str:
        """
        The target resource ID.
        """
        return pulumi.get(self, "target_resource_id")

    @_builtins.property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> _builtins.str:
        """
        The type of the target resource.
        """
        return pulumi.get(self, "target_resource_type")

    @_builtins.property
    @pulumi.getter(name="targetStorageServerVersion")
    def target_storage_server_version(self) -> _builtins.str:
        """
        The target Cell version that is to be patched to.
        """
        return pulumi.get(self, "target_storage_server_version")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> _builtins.str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: _builtins.int,
                 estimated_network_switches_patching_time: _builtins.int,
                 estimated_storage_server_patching_time: _builtins.int,
                 total_estimated_patching_time: _builtins.int):
        """
        :param _builtins.int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param _builtins.int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param _builtins.int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param _builtins.int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @_builtins.property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> _builtins.int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailResult(dict):
    def __init__(__self__, *,
                 db_server_patching_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult'],
                 display_name: _builtins.str,
                 id: _builtins.str):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailArgs'] db_server_patching_details: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.str id: The OCID of the maintenance run.
        """
        pulumi.set(__self__, "db_server_patching_details", db_server_patching_details)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbServerPatchingDetails")
    def db_server_patching_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "db_server_patching_details")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: _builtins.int,
                 patching_status: _builtins.str,
                 time_patching_ended: _builtins.str,
                 time_patching_started: _builtins.str):
        """
        :param _builtins.int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str time_patching_ended: The time when the patching operation ended.
        :param _builtins.str time_patching_started: The time when the patching operation started.
        """
        pulumi.set(__self__, "estimated_patch_duration", estimated_patch_duration)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "time_patching_ended", time_patching_ended)
        pulumi.set(__self__, "time_patching_started", time_patching_started)

    @_builtins.property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> _builtins.int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @_builtins.property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryResult(dict):
    def __init__(__self__, *,
                 execution_actions: Sequence['outputs.GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult'],
                 execution_windows: Sequence['outputs.GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult']):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionArgs'] execution_actions: The list of execution actions for this granular maintenance history.
        :param Sequence['GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowArgs'] execution_windows: Details of an execution window.
        """
        pulumi.set(__self__, "execution_actions", execution_actions)
        pulumi.set(__self__, "execution_windows", execution_windows)

    @_builtins.property
    @pulumi.getter(name="executionActions")
    def execution_actions(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult']:
        """
        The list of execution actions for this granular maintenance history.
        """
        return pulumi.get(self, "execution_actions")

    @_builtins.property
    @pulumi.getter(name="executionWindows")
    def execution_windows(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult']:
        """
        Details of an execution window.
        """
        return pulumi.get(self, "execution_windows")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionResult(dict):
    def __init__(__self__, *,
                 action_members: Sequence['outputs.GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult'],
                 action_params: Mapping[str, _builtins.str],
                 action_type: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 execution_action_order: _builtins.int,
                 execution_window_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 lifecycle_substate: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberArgs'] action_members: List of action members of this execution action.
        :param Mapping[str, _builtins.str] action_params: Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        :param _builtins.str action_type: The action type of the execution action being performed
        :param _builtins.str compartment_id: The OCID of the compartment.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.int execution_action_order: The priority order of the execution action.
        :param _builtins.str execution_window_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution window resource the execution action belongs to.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str lifecycle_substate: The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        :param _builtins.str state: The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        :param _builtins.str time_created: The date and time the execution window was created.
        :param _builtins.str time_updated: The last date and time that the execution window was updated.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "action_members", action_members)
        pulumi.set(__self__, "action_params", action_params)
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "execution_action_order", execution_action_order)
        pulumi.set(__self__, "execution_window_id", execution_window_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_substate", lifecycle_substate)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="actionMembers")
    def action_members(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult']:
        """
        List of action members of this execution action.
        """
        return pulumi.get(self, "action_members")

    @_builtins.property
    @pulumi.getter(name="actionParams")
    def action_params(self) -> Mapping[str, _builtins.str]:
        """
        Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        """
        return pulumi.get(self, "action_params")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The action type of the execution action being performed
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="executionActionOrder")
    def execution_action_order(self) -> _builtins.int:
        """
        The priority order of the execution action.
        """
        return pulumi.get(self, "execution_action_order")

    @_builtins.property
    @pulumi.getter(name="executionWindowId")
    def execution_window_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution window resource the execution action belongs to.
        """
        return pulumi.get(self, "execution_window_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lifecycleSubstate")
    def lifecycle_substate(self) -> _builtins.str:
        """
        The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        """
        return pulumi.get(self, "lifecycle_substate")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the execution window was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the execution window was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionActionActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int,
                 status: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.str member_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        :param _builtins.int member_order: The priority order of the execution action member.
        :param _builtins.str status: The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
               * SCHEDULED
               * IN_PROGRESS
               * FAILED
               * CANCELED
               * DURATION_EXCEEDED
               * RESCHEDULED
               * SUCCEEDED
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The priority order of the execution action member.
        """
        return pulumi.get(self, "member_order")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
        * SCHEDULED
        * IN_PROGRESS
        * FAILED
        * CANCELED
        * DURATION_EXCEEDED
        * RESCHEDULED
        * SUCCEEDED
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryGranularMaintenanceHistoryExecutionWindowResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 execution_resource_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enforced_duration: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 lifecycle_substate: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_ended: _builtins.str,
                 time_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 time_updated: _builtins.str,
                 total_time_taken_in_mins: _builtins.int,
                 window_duration_in_mins: _builtins.int,
                 window_type: _builtins.str):
        """
        :param _builtins.str compartment_id: The OCID of the compartment.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.str execution_resource_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution resource the execution window belongs to.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.bool is_enforced_duration: Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str lifecycle_substate: The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        :param _builtins.str state: The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        :param _builtins.str time_created: The date and time the execution window was created.
        :param _builtins.str time_ended: The date and time the maintenance run was completed.
        :param _builtins.str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param _builtins.str time_started: The date and time the maintenance run starts.
        :param _builtins.str time_updated: The last date and time that the execution window was updated.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        :param _builtins.int window_duration_in_mins: Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        :param _builtins.str window_type: The execution window is of PLANNED or UNPLANNED type.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "execution_resource_id", execution_resource_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enforced_duration", is_enforced_duration)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_substate", lifecycle_substate)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_scheduled", time_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)
        pulumi.set(__self__, "window_duration_in_mins", window_duration_in_mins)
        pulumi.set(__self__, "window_type", window_type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="executionResourceId")
    def execution_resource_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution resource the execution window belongs to.
        """
        return pulumi.get(self, "execution_resource_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnforcedDuration")
    def is_enforced_duration(self) -> _builtins.bool:
        """
        Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_enforced_duration")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lifecycleSubstate")
    def lifecycle_substate(self) -> _builtins.str:
        """
        The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        """
        return pulumi.get(self, "lifecycle_substate")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the execution window was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> _builtins.str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the execution window was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")

    @_builtins.property
    @pulumi.getter(name="windowDurationInMins")
    def window_duration_in_mins(self) -> _builtins.int:
        """
        Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        """
        return pulumi.get(self, "window_duration_in_mins")

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> _builtins.str:
        """
        The execution window is of PLANNED or UNPLANNED type.
        """
        return pulumi.get(self, "window_type")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 current_custom_action_timeout_in_mins: _builtins.int,
                 current_patching_component: _builtins.str,
                 custom_action_timeout_in_mins: _builtins.int,
                 database_software_image_id: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_component_patching_start_time: _builtins.str,
                 estimated_patching_times: Sequence['outputs.GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult'],
                 id: _builtins.str,
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_dst_file_update_enabled: _builtins.bool,
                 is_maintenance_run_granular: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 maintenance_subtype: _builtins.str,
                 maintenance_type: _builtins.str,
                 patch_failure_count: _builtins.int,
                 patch_id: _builtins.str,
                 patching_end_time: _builtins.str,
                 patching_mode: _builtins.str,
                 patching_start_time: _builtins.str,
                 patching_status: _builtins.str,
                 peer_maintenance_run_id: _builtins.str,
                 peer_maintenance_run_ids: Sequence[_builtins.str],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 target_db_server_version: _builtins.str,
                 target_resource_id: _builtins.str,
                 target_resource_type: _builtins.str,
                 target_storage_server_version: _builtins.str,
                 time_ended: _builtins.str,
                 time_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.str compartment_id: The OCID of the compartment.
        :param _builtins.int current_custom_action_timeout_in_mins: Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        :param _builtins.str current_patching_component: The name of the current infrastruture component that is getting patched.
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        :param _builtins.str database_software_image_id: The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.str estimated_component_patching_start_time: The estimated start time of the next infrastruture component patching operation.
        :param Sequence['GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeArgs'] estimated_patching_times: The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        :param _builtins.bool is_dst_file_update_enabled: Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        :param _builtins.bool is_maintenance_run_granular: If `FALSE`, the maintenance run doesn't support granular maintenance.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_subtype: Maintenance sub-type.
        :param _builtins.str maintenance_type: Maintenance type.
        :param _builtins.int patch_failure_count: Contain the patch failure count.
        :param _builtins.str patch_id: The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        :param _builtins.str patching_end_time: The time when the patching operation ended.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str patching_start_time: The time when the patching operation started.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str peer_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        :param Sequence[_builtins.str] peer_maintenance_run_ids: The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
        :param _builtins.str state: The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str target_db_server_version: The target software version for the database server patching operation.
        :param _builtins.str target_resource_id: The ID of the target resource on which the maintenance run occurs.
        :param _builtins.str target_resource_type: The type of the target resource on which the maintenance run occurs.
        :param _builtins.str target_storage_server_version: The target Cell version that is to be patched to.
        :param _builtins.str time_ended: The date and time the maintenance run was completed.
        :param _builtins.str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param _builtins.str time_started: The date and time the maintenance run starts.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "current_custom_action_timeout_in_mins", current_custom_action_timeout_in_mins)
        pulumi.set(__self__, "current_patching_component", current_patching_component)
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_component_patching_start_time", estimated_component_patching_start_time)
        pulumi.set(__self__, "estimated_patching_times", estimated_patching_times)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_dst_file_update_enabled", is_dst_file_update_enabled)
        pulumi.set(__self__, "is_maintenance_run_granular", is_maintenance_run_granular)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_subtype", maintenance_subtype)
        pulumi.set(__self__, "maintenance_type", maintenance_type)
        pulumi.set(__self__, "patch_failure_count", patch_failure_count)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "patching_end_time", patching_end_time)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "patching_start_time", patching_start_time)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "peer_maintenance_run_id", peer_maintenance_run_id)
        pulumi.set(__self__, "peer_maintenance_run_ids", peer_maintenance_run_ids)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "target_db_server_version", target_db_server_version)
        pulumi.set(__self__, "target_resource_id", target_resource_id)
        pulumi.set(__self__, "target_resource_type", target_resource_type)
        pulumi.set(__self__, "target_storage_server_version", target_storage_server_version)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_scheduled", time_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="currentCustomActionTimeoutInMins")
    def current_custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        """
        return pulumi.get(self, "current_custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="currentPatchingComponent")
    def current_patching_component(self) -> _builtins.str:
        """
        The name of the current infrastruture component that is getting patched.
        """
        return pulumi.get(self, "current_patching_component")

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedComponentPatchingStartTime")
    def estimated_component_patching_start_time(self) -> _builtins.str:
        """
        The estimated start time of the next infrastruture component patching operation.
        """
        return pulumi.get(self, "estimated_component_patching_start_time")

    @_builtins.property
    @pulumi.getter(name="estimatedPatchingTimes")
    def estimated_patching_times(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult']:
        """
        The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        """
        return pulumi.get(self, "estimated_patching_times")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isDstFileUpdateEnabled")
    def is_dst_file_update_enabled(self) -> _builtins.bool:
        """
        Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        """
        return pulumi.get(self, "is_dst_file_update_enabled")

    @_builtins.property
    @pulumi.getter(name="isMaintenanceRunGranular")
    def is_maintenance_run_granular(self) -> _builtins.bool:
        """
        If `FALSE`, the maintenance run doesn't support granular maintenance.
        """
        return pulumi.get(self, "is_maintenance_run_granular")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceSubtype")
    def maintenance_subtype(self) -> _builtins.str:
        """
        Maintenance sub-type.
        """
        return pulumi.get(self, "maintenance_subtype")

    @_builtins.property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> _builtins.str:
        """
        Maintenance type.
        """
        return pulumi.get(self, "maintenance_type")

    @_builtins.property
    @pulumi.getter(name="patchFailureCount")
    def patch_failure_count(self) -> _builtins.int:
        """
        Contain the patch failure count.
        """
        return pulumi.get(self, "patch_failure_count")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter(name="patchingEndTime")
    def patching_end_time(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "patching_end_time")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter(name="patchingStartTime")
    def patching_start_time(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "patching_start_time")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="peerMaintenanceRunId")
    def peer_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        """
        return pulumi.get(self, "peer_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="peerMaintenanceRunIds")
    def peer_maintenance_run_ids(self) -> Sequence[_builtins.str]:
        """
        The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
        """
        return pulumi.get(self, "peer_maintenance_run_ids")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="targetDbServerVersion")
    def target_db_server_version(self) -> _builtins.str:
        """
        The target software version for the database server patching operation.
        """
        return pulumi.get(self, "target_db_server_version")

    @_builtins.property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> _builtins.str:
        """
        The ID of the target resource on which the maintenance run occurs.
        """
        return pulumi.get(self, "target_resource_id")

    @_builtins.property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> _builtins.str:
        """
        The type of the target resource on which the maintenance run occurs.
        """
        return pulumi.get(self, "target_resource_type")

    @_builtins.property
    @pulumi.getter(name="targetStorageServerVersion")
    def target_storage_server_version(self) -> _builtins.str:
        """
        The target Cell version that is to be patched to.
        """
        return pulumi.get(self, "target_storage_server_version")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> _builtins.str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: _builtins.int,
                 estimated_network_switches_patching_time: _builtins.int,
                 estimated_storage_server_patching_time: _builtins.int,
                 total_estimated_patching_time: _builtins.int):
        """
        :param _builtins.int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param _builtins.int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param _builtins.int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param _builtins.int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @_builtins.property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> _builtins.int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetDatabasePdbConversionHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabasePdbConversionHistoryEntriesPdbConversionHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 additional_cdb_params: _builtins.str,
                 cdb_name: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 source_database_id: _builtins.str,
                 state: _builtins.str,
                 target: _builtins.str,
                 target_database_id: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str action: The operations used to convert a non-container database to a pluggable database.
               * Use `PRECHECK` to run a pre-check operation on non-container database prior to converting it into a pluggable database.
               * Use `CONVERT` to convert a non-container database into a pluggable database.
               * Use `SYNC` if the non-container database was manually converted into a pluggable database using the dbcli command-line utility. Databases may need to be converted manually if the CONVERT action fails when converting a non-container database using the API.
               * Use `SYNC_ROLLBACK` if the conversion of a non-container database into a pluggable database was manually rolled back using the dbcli command line utility. Conversions may need to be manually rolled back if the CONVERT action fails when converting a non-container database using the API.
        :param _builtins.str additional_cdb_params: Additional container database parameter.
        :param _builtins.str cdb_name: The database name. The name must begin with an alphabetic character and can contain a maximum of 8 alphanumeric characters. Special characters are not permitted. The database name must be unique in the tenancy.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database conversion history.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state for the conversion operation.
        :param _builtins.str source_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.str state: A filter to return only the pluggable database conversion history entries that match the specified lifecycle state. For example, you can use this filter to return only entries in the "failed" lifecycle state.
        :param _builtins.str target: The target container database of the pluggable database created by the database conversion operation. Currently, the database conversion operation only supports creating the pluggable database in a new container database.
               * Use `NEW_DATABASE` to specify that the pluggable database be created within a new container database in the same database home.
        :param _builtins.str target_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.str time_ended: The date and time when the database conversion operation ended.
        :param _builtins.str time_started: The date and time when the database conversion operation started.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "additional_cdb_params", additional_cdb_params)
        pulumi.set(__self__, "cdb_name", cdb_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "source_database_id", source_database_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_database_id", target_database_id)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The operations used to convert a non-container database to a pluggable database.
        * Use `PRECHECK` to run a pre-check operation on non-container database prior to converting it into a pluggable database.
        * Use `CONVERT` to convert a non-container database into a pluggable database.
        * Use `SYNC` if the non-container database was manually converted into a pluggable database using the dbcli command-line utility. Databases may need to be converted manually if the CONVERT action fails when converting a non-container database using the API.
        * Use `SYNC_ROLLBACK` if the conversion of a non-container database into a pluggable database was manually rolled back using the dbcli command line utility. Conversions may need to be manually rolled back if the CONVERT action fails when converting a non-container database using the API.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="additionalCdbParams")
    def additional_cdb_params(self) -> _builtins.str:
        """
        Additional container database parameter.
        """
        return pulumi.get(self, "additional_cdb_params")

    @_builtins.property
    @pulumi.getter(name="cdbName")
    def cdb_name(self) -> _builtins.str:
        """
        The database name. The name must begin with an alphabetic character and can contain a maximum of 8 alphanumeric characters. Special characters are not permitted. The database name must be unique in the tenancy.
        """
        return pulumi.get(self, "cdb_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database conversion history.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state for the conversion operation.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "source_database_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only the pluggable database conversion history entries that match the specified lifecycle state. For example, you can use this filter to return only entries in the "failed" lifecycle state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The target container database of the pluggable database created by the database conversion operation. Currently, the database conversion operation only supports creating the pluggable database in a new container database.
        * Use `NEW_DATABASE` to specify that the pluggable database be created within a new container database in the same database home.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="targetDatabaseId")
    def target_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "target_database_id")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time when the database conversion operation ended.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the database conversion operation started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDatabaseSoftwareImagesDatabaseSoftwareImageResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 database_software_image_included_patches: Sequence[_builtins.str],
                 database_software_image_one_off_patches: Sequence[_builtins.str],
                 database_version: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 image_shape_family: _builtins.str,
                 image_type: _builtins.str,
                 included_patches_summary: _builtins.str,
                 is_upgrade_supported: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 ls_inventory: _builtins.str,
                 patch_set: _builtins.str,
                 source_db_home_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence[_builtins.str] database_software_image_included_patches: List of one-off patches for Database Homes.
        :param Sequence[_builtins.str] database_software_image_one_off_patches: List of one-off patches for Database Homes.
        :param _builtins.str database_version: The database version with which the database software image is to be built.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database software image.
        :param _builtins.str image_shape_family: A filter to return only resources that match the given image shape family exactly.
        :param _builtins.str image_type: A filter to return only resources that match the given image type exactly.
        :param _builtins.str included_patches_summary: The patches included in the image and the version of the image.
        :param _builtins.bool is_upgrade_supported: If provided, filters the results to the set of database versions which are supported for Upgrade.
        :param _builtins.str lifecycle_details: Detailed message for the lifecycle state.
        :param _builtins.str ls_inventory: The output from the OPatch lsInventory command, which is passed as a string.
        :param _builtins.str patch_set: The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the database software image was created.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_software_image_included_patches", database_software_image_included_patches)
        pulumi.set(__self__, "database_software_image_one_off_patches", database_software_image_one_off_patches)
        pulumi.set(__self__, "database_version", database_version)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_shape_family", image_shape_family)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "included_patches_summary", included_patches_summary)
        pulumi.set(__self__, "is_upgrade_supported", is_upgrade_supported)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ls_inventory", ls_inventory)
        pulumi.set(__self__, "patch_set", patch_set)
        pulumi.set(__self__, "source_db_home_id", source_db_home_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageIncludedPatches")
    def database_software_image_included_patches(self) -> Sequence[_builtins.str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "database_software_image_included_patches")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageOneOffPatches")
    def database_software_image_one_off_patches(self) -> Sequence[_builtins.str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "database_software_image_one_off_patches")

    @_builtins.property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> _builtins.str:
        """
        The database version with which the database software image is to be built.
        """
        return pulumi.get(self, "database_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database software image.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="imageShapeFamily")
    def image_shape_family(self) -> _builtins.str:
        """
        A filter to return only resources that match the given image shape family exactly.
        """
        return pulumi.get(self, "image_shape_family")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given image type exactly.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter(name="includedPatchesSummary")
    def included_patches_summary(self) -> _builtins.str:
        """
        The patches included in the image and the version of the image.
        """
        return pulumi.get(self, "included_patches_summary")

    @_builtins.property
    @pulumi.getter(name="isUpgradeSupported")
    def is_upgrade_supported(self) -> _builtins.bool:
        """
        If provided, filters the results to the set of database versions which are supported for Upgrade.
        """
        return pulumi.get(self, "is_upgrade_supported")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lsInventory")
    def ls_inventory(self) -> _builtins.str:
        """
        The output from the OPatch lsInventory command, which is passed as a string.
        """
        return pulumi.get(self, "ls_inventory")

    @_builtins.property
    @pulumi.getter(name="patchSet")
    def patch_set(self) -> _builtins.str:
        """
        The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "patch_set")

    @_builtins.property
    @pulumi.getter(name="sourceDbHomeId")
    def source_db_home_id(self) -> _builtins.str:
        return pulumi.get(self, "source_db_home_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the database software image was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDatabaseSoftwareImagesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabaseUpgradeHistoryEntriesDatabaseUpgradeHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 options: _builtins.str,
                 source: _builtins.str,
                 source_db_home_id: _builtins.str,
                 state: _builtins.str,
                 target_database_software_image_id: _builtins.str,
                 target_db_home_id: _builtins.str,
                 target_db_version: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str action: The database upgrade action.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database upgrade history.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param _builtins.str source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
        :param _builtins.str source_db_home_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param _builtins.str state: A filter to return only upgradeHistoryEntries that match the given lifecycle state exactly.
        :param _builtins.str target_database_software_image_id: the database software image used for upgrading database.
        :param _builtins.str target_db_home_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param _builtins.str target_db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
        :param _builtins.str time_ended: The date and time when the database upgrade ended.
        :param _builtins.str time_started: The date and time when the database upgrade started.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_db_home_id", source_db_home_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target_database_software_image_id", target_database_software_image_id)
        pulumi.set(__self__, "target_db_home_id", target_db_home_id)
        pulumi.set(__self__, "target_db_version", target_db_version)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The database upgrade action.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database upgrade history.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def options(self) -> _builtins.str:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceDbHomeId")
    def source_db_home_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "source_db_home_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only upgradeHistoryEntries that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="targetDatabaseSoftwareImageId")
    def target_database_software_image_id(self) -> _builtins.str:
        """
        the database software image used for upgrading database.
        """
        return pulumi.get(self, "target_database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="targetDbHomeId")
    def target_db_home_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "target_db_home_id")

    @_builtins.property
    @pulumi.getter(name="targetDbVersion")
    def target_db_version(self) -> _builtins.str:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
        """
        return pulumi.get(self, "target_db_version")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time when the database upgrade ended.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the database upgrade started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDatabaseUpgradeHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabasesDatabaseResult(dict):
    def __init__(__self__, *,
                 action_trigger: _builtins.int,
                 character_set: _builtins.str,
                 compartment_id: _builtins.str,
                 connection_strings: Sequence['outputs.GetDatabasesDatabaseConnectionStringResult'],
                 data_guard_action: _builtins.str,
                 data_guard_groups: Sequence['outputs.GetDatabasesDatabaseDataGuardGroupResult'],
                 database_management_configs: Sequence['outputs.GetDatabasesDatabaseDatabaseManagementConfigResult'],
                 database_software_image_id: _builtins.str,
                 databases: Sequence['outputs.GetDatabasesDatabaseDatabaseResult'],
                 db_backup_configs: Sequence['outputs.GetDatabasesDatabaseDbBackupConfigResult'],
                 db_home_id: _builtins.str,
                 db_name: _builtins.str,
                 db_system_id: _builtins.str,
                 db_unique_name: _builtins.str,
                 db_version: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_cdb: _builtins.bool,
                 key_store_id: _builtins.str,
                 key_store_wallet_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_migration: _builtins.bool,
                 kms_key_rotation: _builtins.int,
                 kms_key_version_id: _builtins.str,
                 last_backup_duration_in_seconds: _builtins.int,
                 last_backup_timestamp: _builtins.str,
                 last_failed_backup_timestamp: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 pdb_name: _builtins.str,
                 sid_prefix: _builtins.str,
                 source: _builtins.str,
                 source_database_point_in_time_recovery_timestamp: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 vault_id: _builtins.str,
                 vm_cluster_id: _builtins.str):
        """
        :param _builtins.str character_set: The character set for the database.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetDatabasesDatabaseConnectionStringArgs'] connection_strings: The Connection strings used to connect to the Oracle Database.
        :param Sequence['GetDatabasesDatabaseDataGuardGroupArgs'] data_guard_groups: Details of Data Guard setup that the given database is part of.  Also includes information about databases part of this Data Guard group and properties for their Data Guard configuration.
        :param Sequence['GetDatabasesDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Sequence['GetDatabasesDatabaseDbBackupConfigArgs'] db_backup_configs: Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param _builtins.str db_home_id: A Database Home [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). *Note: Either `db_home_id` or `system_id` is required to make the LIST API call.
        :param _builtins.str db_name: A filter to return only resources that match the entire database name given. The match is not case sensitive.
        :param _builtins.str db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.str db_unique_name: A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        :param _builtins.str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.bool is_cdb: True if the database is a container database.
        :param _builtins.str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param _builtins.str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.int last_backup_duration_in_seconds: The duration when the latest database backup created.
        :param _builtins.str last_backup_timestamp: The date and time when the latest database backup was created.
        :param _builtins.str last_failed_backup_timestamp: The date and time when the latest database backup failed.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str ncharacter_set: The national character set for the database.
        :param _builtins.str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param _builtins.str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param _builtins.str source_database_point_in_time_recovery_timestamp: Point in time recovery timeStamp of the source database at which cloned database system is cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339)
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the database was created.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param _builtins.str vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        pulumi.set(__self__, "action_trigger", action_trigger)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "data_guard_action", data_guard_action)
        pulumi.set(__self__, "data_guard_groups", data_guard_groups)
        pulumi.set(__self__, "database_management_configs", database_management_configs)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "db_backup_configs", db_backup_configs)
        pulumi.set(__self__, "db_home_id", db_home_id)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_cdb", is_cdb)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "key_store_wallet_name", key_store_wallet_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_migration", kms_key_migration)
        pulumi.set(__self__, "kms_key_rotation", kms_key_rotation)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "last_backup_duration_in_seconds", last_backup_duration_in_seconds)
        pulumi.set(__self__, "last_backup_timestamp", last_backup_timestamp)
        pulumi.set(__self__, "last_failed_backup_timestamp", last_failed_backup_timestamp)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "sid_prefix", sid_prefix)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_database_point_in_time_recovery_timestamp", source_database_point_in_time_recovery_timestamp)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "vault_id", vault_id)
        pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @_builtins.property
    @pulumi.getter(name="actionTrigger")
    def action_trigger(self) -> _builtins.int:
        return pulumi.get(self, "action_trigger")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set for the database.
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDatabasesDatabaseConnectionStringResult']:
        """
        The Connection strings used to connect to the Oracle Database.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="dataGuardAction")
    def data_guard_action(self) -> _builtins.str:
        return pulumi.get(self, "data_guard_action")

    @_builtins.property
    @pulumi.getter(name="dataGuardGroups")
    def data_guard_groups(self) -> Sequence['outputs.GetDatabasesDatabaseDataGuardGroupResult']:
        """
        Details of Data Guard setup that the given database is part of.  Also includes information about databases part of this Data Guard group and properties for their Data Guard configuration.
        """
        return pulumi.get(self, "data_guard_groups")

    @_builtins.property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseResult']:
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDatabasesDatabaseDbBackupConfigResult']:
        """
        Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_configs")

    @_builtins.property
    @pulumi.getter(name="dbHomeId")
    def db_home_id(self) -> _builtins.str:
        """
        A Database Home [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). *Note: Either `db_home_id` or `system_id` is required to make the LIST API call.
        """
        return pulumi.get(self, "db_home_id")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire database name given. The match is not case sensitive.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isCdb")
    def is_cdb(self) -> _builtins.bool:
        """
        True if the database is a container database.
        """
        return pulumi.get(self, "is_cdb")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> _builtins.str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyMigration")
    def kms_key_migration(self) -> _builtins.bool:
        return pulumi.get(self, "kms_key_migration")

    @_builtins.property
    @pulumi.getter(name="kmsKeyRotation")
    def kms_key_rotation(self) -> _builtins.int:
        return pulumi.get(self, "kms_key_rotation")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lastBackupDurationInSeconds")
    def last_backup_duration_in_seconds(self) -> _builtins.int:
        """
        The duration when the latest database backup created.
        """
        return pulumi.get(self, "last_backup_duration_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lastBackupTimestamp")
    def last_backup_timestamp(self) -> _builtins.str:
        """
        The date and time when the latest database backup was created.
        """
        return pulumi.get(self, "last_backup_timestamp")

    @_builtins.property
    @pulumi.getter(name="lastFailedBackupTimestamp")
    def last_failed_backup_timestamp(self) -> _builtins.str:
        """
        The date and time when the latest database backup failed.
        """
        return pulumi.get(self, "last_failed_backup_timestamp")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character set for the database.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> _builtins.str:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceDatabasePointInTimeRecoveryTimestamp")
    def source_database_point_in_time_recovery_timestamp(self) -> _builtins.str:
        """
        Point in time recovery timeStamp of the source database at which cloned database system is cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339)
        """
        return pulumi.get(self, "source_database_point_in_time_recovery_timestamp")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class GetDatabasesDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 cdb_default: _builtins.str,
                 cdb_ip_default: _builtins.str):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the Database.
        :param _builtins.str cdb_default: Host name based CDB Connection String.
        :param _builtins.str cdb_ip_default: IP based CDB Connection String.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "cdb_default", cdb_default)
        pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> _builtins.str:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> _builtins.str:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDatabasesDatabaseDataGuardGroupResult(dict):
    def __init__(__self__, *,
                 members: Sequence['outputs.GetDatabasesDatabaseDataGuardGroupMemberResult'],
                 protection_mode: _builtins.str):
        """
        :param Sequence['GetDatabasesDatabaseDataGuardGroupMemberArgs'] members: List of Data Guard members, representing each database that is part of Data Guard.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "protection_mode", protection_mode)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetDatabasesDatabaseDataGuardGroupMemberResult']:
        """
        List of Data Guard members, representing each database that is part of Data Guard.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")


@pulumi.output_type
class GetDatabasesDatabaseDataGuardGroupMemberResult(dict):
    def __init__(__self__, *,
                 apply_lag: _builtins.str,
                 apply_rate: _builtins.str,
                 database_id: _builtins.str,
                 db_system_id: _builtins.str,
                 is_active_data_guard_enabled: _builtins.bool,
                 role: _builtins.str,
                 transport_lag: _builtins.str,
                 transport_lag_refresh: _builtins.str,
                 transport_type: _builtins.str):
        """
        :param _builtins.str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        :param _builtins.str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        :param _builtins.str database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database.
        :param _builtins.str db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str role: The role of the reporting database in this Data Guard association.
        :param _builtins.str transport_lag: The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        :param _builtins.str transport_lag_refresh: The date and time when last redo transport has been done.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
        """
        pulumi.set(__self__, "apply_lag", apply_lag)
        pulumi.set(__self__, "apply_rate", apply_rate)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "transport_lag", transport_lag)
        pulumi.set(__self__, "transport_lag_refresh", transport_lag_refresh)
        pulumi.set(__self__, "transport_type", transport_type)

    @_builtins.property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> _builtins.str:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `1 second`
        """
        return pulumi.get(self, "apply_lag")

    @_builtins.property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> _builtins.str:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `102.96 MByte/s`
        """
        return pulumi.get(self, "apply_rate")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database.
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> _builtins.bool:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the reporting database in this Data Guard association.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> _builtins.str:
        """
        The rate at which redo logs are transported between the associated databases.  Example: `1 second`
        """
        return pulumi.get(self, "transport_lag")

    @_builtins.property
    @pulumi.getter(name="transportLagRefresh")
    def transport_lag_refresh(self) -> _builtins.str:
        """
        The date and time when last redo transport has been done.
        """
        return pulumi.get(self, "transport_lag_refresh")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> _builtins.str:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC
        """
        return pulumi.get(self, "transport_type")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: _builtins.str,
                 backup_tde_password: _builtins.str,
                 character_set: _builtins.str,
                 database_admin_password: _builtins.str,
                 database_software_image_id: _builtins.str,
                 db_backup_configs: Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigResult'],
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 encryption_key_location_details: Sequence['outputs.GetDatabasesDatabaseDatabaseEncryptionKeyLocationDetailResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 is_active_data_guard_enabled: _builtins.bool,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 ncharacter_set: _builtins.str,
                 pdb_name: _builtins.str,
                 pluggable_databases: Sequence[_builtins.str],
                 protection_mode: _builtins.str,
                 sid_prefix: _builtins.str,
                 source_database_id: _builtins.str,
                 source_encryption_key_location_details: Sequence['outputs.GetDatabasesDatabaseDatabaseSourceEncryptionKeyLocationDetailResult'],
                 source_tde_wallet_password: _builtins.str,
                 tde_wallet_password: _builtins.str,
                 transport_type: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str character_set: The character set for the database.
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Sequence['GetDatabasesDatabaseDatabaseDbBackupConfigArgs'] db_backup_configs: Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param _builtins.str db_name: A filter to return only resources that match the entire database name given. The match is not case sensitive.
        :param _builtins.str db_unique_name: A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        :param _builtins.str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Sequence['GetDatabasesDatabaseDatabaseEncryptionKeyLocationDetailArgs'] encryption_key_location_details: Types of providers supported for managing database encryption keys
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param _builtins.str ncharacter_set: The national character set for the database.
        :param _builtins.str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param _builtins.str protection_mode: The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param _builtins.str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param _builtins.str transport_type: The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
               * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
               * MAXIMUM_PERFORMANCE - ASYNC
               * MAXIMUM_PROTECTION - SYNC
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "database_admin_password", database_admin_password)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "db_backup_configs", db_backup_configs)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "is_active_data_guard_enabled", is_active_data_guard_enabled)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "sid_prefix", sid_prefix)
        pulumi.set(__self__, "source_database_id", source_database_id)
        pulumi.set(__self__, "source_encryption_key_location_details", source_encryption_key_location_details)
        pulumi.set(__self__, "source_tde_wallet_password", source_tde_wallet_password)
        pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        pulumi.set(__self__, "transport_type", transport_type)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> _builtins.str:
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set for the database.
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="databaseAdminPassword")
    def database_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "database_admin_password")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigResult']:
        """
        Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_configs")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire database name given. The match is not case sensitive.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        """
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseEncryptionKeyLocationDetailResult']:
        """
        Types of providers supported for managing database encryption keys
        """
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> _builtins.bool:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character set for the database.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protection mode of this Data Guard. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> _builtins.str:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> _builtins.str:
        return pulumi.get(self, "source_database_id")

    @_builtins.property
    @pulumi.getter(name="sourceEncryptionKeyLocationDetails")
    def source_encryption_key_location_details(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseSourceEncryptionKeyLocationDetailResult']:
        return pulumi.get(self, "source_encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="sourceTdeWalletPassword")
    def source_tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "source_tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> _builtins.str:
        """
        The redo transport type to use for this Data Guard association.  Valid values depend on the specified `protectionMode`:
        * MAXIMUM_AVAILABILITY - SYNC or FASTSYNC
        * MAXIMUM_PERFORMANCE - ASYNC
        * MAXIMUM_PROTECTION - SYNC
        """
        return pulumi.get(self, "transport_type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        """
        :param _builtins.bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 azure_encryption_key_id: _builtins.str,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        """
        :param _builtins.str azure_encryption_key_id: Provide the key OCID of a registered Azure key.
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> _builtins.str:
        """
        Provide the key OCID of a registered Azure key.
        """
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: _builtins.str,
                 management_type: _builtins.str):
        """
        :param _builtins.str management_status: The status of the Database Management service.
        :param _builtins.str management_type: The Database Management type.
        """
        pulumi.set(__self__, "management_status", management_status)
        pulumi.set(__self__, "management_type", management_type)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @_builtins.property
    @pulumi.getter(name="managementType")
    def management_type(self) -> _builtins.str:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseSourceEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        """
        :param _builtins.str hsm_password: Provide the HSM password as you would in RDBMS for External HSM.
        :param _builtins.str provider_type: Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        """
        Provide the HSM password as you would in RDBMS for External HSM.
        """
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        """
        Use 'EXTERNAL' for creating a new database or migrating a database key to an External HSM. Use 'AZURE' for creating a new database or migrating a database key to Azure.
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetDatabasesDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        """
        :param _builtins.bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param _builtins.str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param _builtins.str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param _builtins.str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param _builtins.int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param _builtins.bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param _builtins.bool is_remote: Indicates whether the backup destination is cross-region or local region.
        :param _builtins.str remote_region: The name of the remote region where the remote automatic incremental backups will be stored.
        :param _builtins.str type: Type of the database backup destination.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        """
        Indicates whether the backup destination is cross-region or local region.
        """
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        """
        The name of the remote region where the remote automatic incremental backups will be stored.
        """
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbHomeDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: _builtins.str,
                 backup_tde_password: _builtins.str,
                 character_set: _builtins.str,
                 connection_strings: Sequence['outputs.GetDbHomeDatabaseConnectionStringResult'],
                 database_id: _builtins.str,
                 database_software_image_id: _builtins.str,
                 db_backup_configs: Sequence['outputs.GetDbHomeDatabaseDbBackupConfigResult'],
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 encryption_key_location_details: Sequence['outputs.GetDbHomeDatabaseEncryptionKeyLocationDetailResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 key_store_id: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 one_off_patches: Sequence[_builtins.str],
                 pdb_name: _builtins.str,
                 pluggable_databases: Sequence[_builtins.str],
                 sid_prefix: _builtins.str,
                 state: _builtins.str,
                 tde_wallet_password: _builtins.str,
                 time_created: _builtins.str,
                 time_stamp_for_point_in_time_recovery: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[_builtins.str] one_off_patches: List of one-off patches for Database Homes.
        :param _builtins.str state: The current state of the Database Home.
        :param _builtins.str time_created: The date and time the Database Home was created.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "db_backup_configs", db_backup_configs)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "one_off_patches", one_off_patches)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        pulumi.set(__self__, "sid_prefix", sid_prefix)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> _builtins.str:
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDbHomeDatabaseConnectionStringResult']:
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDbHomeDatabaseDbBackupConfigResult']:
        return pulumi.get(self, "db_backup_configs")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Sequence['outputs.GetDbHomeDatabaseEncryptionKeyLocationDetailResult']:
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Sequence[_builtins.str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> _builtins.str:
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> _builtins.str:
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDbHomeDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 cdb_default: _builtins.str,
                 cdb_ip_default: _builtins.str):
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "cdb_default", cdb_default)
        pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> _builtins.str:
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> _builtins.str:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDbHomeDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDbHomeDatabaseEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 azure_encryption_key_id: _builtins.str,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> _builtins.str:
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetDbHomePatchHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbHomePatchHistoryEntriesPatchHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 patch_id: _builtins.str,
                 patch_type: _builtins.str,
                 state: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str action: The action being performed or was completed.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param _builtins.str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str patch_type: The type of Patch operation.
        :param _builtins.str state: The current state of the action.
        :param _builtins.str time_ended: The date and time when the patch action completed
        :param _builtins.str time_started: The date and time when the patch action started.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "patch_type", patch_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action being performed or was completed.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> _builtins.str:
        """
        The type of Patch operation.
        """
        return pulumi.get(self, "patch_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the action.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time when the patch action completed
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the patch action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDbHomePatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbHomePatchesPatchResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[_builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 last_action: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_released: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence[_builtins.str] available_actions: Actions that can possibly be performed using this patch.
        :param _builtins.str description: The text describing this patch package.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str last_action: Action that is currently being performed or was completed last.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param _builtins.str state: The current state of the patch as a result of lastAction.
        :param _builtins.str time_released: The date and time that the patch was released.
        :param _builtins.str version: The version of this patch package.
        """
        pulumi.set(__self__, "available_actions", available_actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_action", last_action)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[_builtins.str]:
        """
        Actions that can possibly be performed using this patch.
        """
        return pulumi.get(self, "available_actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> _builtins.str:
        """
        Action that is currently being performed or was completed last.
        """
        return pulumi.get(self, "last_action")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDbHomesDbHomeResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 database_software_image_id: _builtins.str,
                 databases: Sequence['outputs.GetDbHomesDbHomeDatabaseResult'],
                 db_home_id: _builtins.str,
                 db_home_location: _builtins.str,
                 db_system_id: _builtins.str,
                 db_version: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 enable_database_delete: _builtins.bool,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_desupported_version: _builtins.bool,
                 is_unified_auditing_enabled: _builtins.bool,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 last_patch_history_entry_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 source: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 vm_cluster_id: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param _builtins.str db_home_location: The location of the Oracle Database Home.
        :param _builtins.str db_system_id: The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        :param _builtins.str db_version: A filter to return only DB Homes that match the specified dbVersion.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param _builtins.bool is_unified_auditing_enabled: Indicates whether unified autiding is enabled or not.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation is started.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Database Home was created.
        :param _builtins.str vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "db_home_id", db_home_id)
        pulumi.set(__self__, "db_home_location", db_home_location)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "enable_database_delete", enable_database_delete)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_desupported_version", is_desupported_version)
        pulumi.set(__self__, "is_unified_auditing_enabled", is_unified_auditing_enabled)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseResult']:
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="dbHomeId")
    def db_home_id(self) -> _builtins.str:
        return pulumi.get(self, "db_home_id")

    @_builtins.property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> _builtins.str:
        """
        The location of the Oracle Database Home.
        """
        return pulumi.get(self, "db_home_location")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> _builtins.str:
        """
        The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        A filter to return only DB Homes that match the specified dbVersion.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="enableDatabaseDelete")
    def enable_database_delete(self) -> _builtins.bool:
        return pulumi.get(self, "enable_database_delete")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDesupportedVersion")
    def is_desupported_version(self) -> _builtins.bool:
        return pulumi.get(self, "is_desupported_version")

    @_builtins.property
    @pulumi.getter(name="isUnifiedAuditingEnabled")
    def is_unified_auditing_enabled(self) -> _builtins.bool:
        """
        Indicates whether unified autiding is enabled or not.
        """
        return pulumi.get(self, "is_unified_auditing_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation is started.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: _builtins.str,
                 backup_tde_password: _builtins.str,
                 character_set: _builtins.str,
                 connection_strings: Sequence['outputs.GetDbHomesDbHomeDatabaseConnectionStringResult'],
                 database_id: _builtins.str,
                 database_software_image_id: _builtins.str,
                 db_backup_configs: Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigResult'],
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 encryption_key_location_details: Sequence['outputs.GetDbHomesDbHomeDatabaseEncryptionKeyLocationDetailResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 key_store_id: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 one_off_patches: Sequence[_builtins.str],
                 pdb_name: _builtins.str,
                 pluggable_databases: Sequence[_builtins.str],
                 sid_prefix: _builtins.str,
                 state: _builtins.str,
                 tde_wallet_password: _builtins.str,
                 time_created: _builtins.str,
                 time_stamp_for_point_in_time_recovery: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str backup_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        :param _builtins.str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[_builtins.str] one_off_patches: List of one-off patches for Database Homes.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the Database Home was created.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "db_backup_configs", db_backup_configs)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "encryption_key_location_details", encryption_key_location_details)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key_store_id", key_store_id)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "one_off_patches", one_off_patches)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        pulumi.set(__self__, "sid_prefix", sid_prefix)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> _builtins.str:
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseConnectionStringResult']:
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigResult']:
        return pulumi.get(self, "db_backup_configs")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyLocationDetails")
    def encryption_key_location_details(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseEncryptionKeyLocationDetailResult']:
        return pulumi.get(self, "encryption_key_location_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> _builtins.str:
        return pulumi.get(self, "key_store_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Sequence[_builtins.str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> _builtins.str:
        return pulumi.get(self, "sid_prefix")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> _builtins.str:
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 cdb_default: _builtins.str,
                 cdb_ip_default: _builtins.str):
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "cdb_default", cdb_default)
        pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> _builtins.str:
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> _builtins.str:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str,
                 vpc_password: _builtins.str,
                 vpc_user: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_password", vpc_password)
        pulumi.set(__self__, "vpc_user", vpc_user)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> _builtins.str:
        return pulumi.get(self, "vpc_password")

    @_builtins.property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> _builtins.str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseEncryptionKeyLocationDetailResult(dict):
    def __init__(__self__, *,
                 azure_encryption_key_id: _builtins.str,
                 hsm_password: _builtins.str,
                 provider_type: _builtins.str):
        pulumi.set(__self__, "azure_encryption_key_id", azure_encryption_key_id)
        pulumi.set(__self__, "hsm_password", hsm_password)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="azureEncryptionKeyId")
    def azure_encryption_key_id(self) -> _builtins.str:
        return pulumi.get(self, "azure_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="hsmPassword")
    def hsm_password(self) -> _builtins.str:
        return pulumi.get(self, "hsm_password")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetDbHomesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbNodeConsoleConnectionsConsoleConnectionResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 connection_string: _builtins.str,
                 db_node_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 fingerprint: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 public_key: _builtins.str,
                 service_host_key_fingerprint: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str compartment_id: The OCID of the compartment to contain the console connection.
        :param _builtins.str connection_string: The SSH connection string for the console connection.
        :param _builtins.str db_node_id: The database node [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str fingerprint: The SSH public key fingerprint for the console connection.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The OCID of the console connection.
        :param _builtins.str lifecycle_details: Information about the current lifecycle state.
        :param _builtins.str service_host_key_fingerprint: The SSH public key's fingerprint for the console connection service host.
        :param _builtins.str state: The current state of the console connection.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "db_node_id", db_node_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "service_host_key_fingerprint", service_host_key_fingerprint)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment to contain the console connection.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        """
        The SSH connection string for the console connection.
        """
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> _builtins.str:
        """
        The database node [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_node_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> _builtins.str:
        """
        The SSH public key fingerprint for the console connection.
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the console connection.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="serviceHostKeyFingerprint")
    def service_host_key_fingerprint(self) -> _builtins.str:
        """
        The SSH public key's fingerprint for the console connection service host.
        """
        return pulumi.get(self, "service_host_key_fingerprint")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the console connection.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetDbNodeConsoleConnectionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbNodeConsoleHistoriesConsoleHistoryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDbNodeConsoleHistoriesConsoleHistoryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDbNodeConsoleHistoriesConsoleHistoryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDbNodeConsoleHistoriesConsoleHistoryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 db_node_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str):
        """
        :param _builtins.str compartment_id: The OCID of the compartment containing the console history.
        :param _builtins.str db_node_id: The database node [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The OCID of the console history.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the console history was created.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "db_node_id", db_node_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment containing the console history.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> _builtins.str:
        """
        The database node [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_node_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the console history.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the console history was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDbNodeConsoleHistoriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbNodesDbNodeResult(dict):
    def __init__(__self__, *,
                 additional_details: _builtins.str,
                 backup_ip_id: _builtins.str,
                 backup_ipv6id: _builtins.str,
                 backup_vnic2id: _builtins.str,
                 backup_vnic_id: _builtins.str,
                 cpu_core_count: _builtins.int,
                 db_node_id: _builtins.str,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_server_id: _builtins.str,
                 db_system_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 fault_domain: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 host_ip_id: _builtins.str,
                 host_ipv6id: _builtins.str,
                 hostname: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 maintenance_type: _builtins.str,
                 memory_size_in_gbs: _builtins.int,
                 software_storage_size_in_gb: _builtins.int,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_maintenance_window_end: _builtins.str,
                 time_maintenance_window_start: _builtins.str,
                 total_cpu_core_count: _builtins.int,
                 vnic2id: _builtins.str,
                 vnic_id: _builtins.str):
        """
        :param _builtins.str additional_details: Additional information about the planned maintenance.
        :param _builtins.str backup_ip_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup IPv4 address associated with the database node. Use this OCID with either the [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IPv4 address needed to make a database connection.
        :param _builtins.str backup_ipv6id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup IPv6 address associated with the database node. Use this OCID with the [GetIpv6](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/Ipv6/GetIpv6) API to get the IPv6 address needed to make a database connection.
        :param _builtins.str backup_vnic2id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second backup VNIC.
        :param _builtins.str backup_vnic_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup VNIC.
        :param _builtins.int cpu_core_count: The number of CPU cores enabled on the Db node.
        :param _builtins.int db_node_storage_size_in_gbs: The allocated local node storage in GBs on the Db node.
        :param _builtins.str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        :param _builtins.str db_system_id: The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str fault_domain: The name of the Fault Domain the instance is contained in.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str host_ip_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the host IPv4 address associated with the database node. Use this OCID with either the [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IPv4 address needed to make a database connection.
        :param _builtins.str host_ipv6id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the host IPv6 address associated with the database node. Use this OCID with the [GetIpv6](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/Ipv6/GetIpv6) API to get the IPv6 address needed to make a database connection.
        :param _builtins.str hostname: The host name for the database node.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database node.
        :param _builtins.str lifecycle_details: Information about the current lifecycle state.
        :param _builtins.str maintenance_type: The type of database node maintenance.
        :param _builtins.int memory_size_in_gbs: The allocated memory in GBs on the Db node.
        :param _builtins.int software_storage_size_in_gb: The size (in GB) of the block storage volume allocation for the DB system. This attribute applies only for virtual machine DB systems.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the database node was created.
        :param _builtins.str time_maintenance_window_end: End date and time of maintenance window.
        :param _builtins.str time_maintenance_window_start: Start date and time of maintenance window.
        :param _builtins.int total_cpu_core_count: The total number of CPU cores reserved on the Db node.
        :param _builtins.str vnic2id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second VNIC.
        :param _builtins.str vnic_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VNIC.
        """
        pulumi.set(__self__, "additional_details", additional_details)
        pulumi.set(__self__, "backup_ip_id", backup_ip_id)
        pulumi.set(__self__, "backup_ipv6id", backup_ipv6id)
        pulumi.set(__self__, "backup_vnic2id", backup_vnic2id)
        pulumi.set(__self__, "backup_vnic_id", backup_vnic_id)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "db_node_id", db_node_id)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_server_id", db_server_id)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "fault_domain", fault_domain)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "host_ip_id", host_ip_id)
        pulumi.set(__self__, "host_ipv6id", host_ipv6id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_type", maintenance_type)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "software_storage_size_in_gb", software_storage_size_in_gb)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_maintenance_window_end", time_maintenance_window_end)
        pulumi.set(__self__, "time_maintenance_window_start", time_maintenance_window_start)
        pulumi.set(__self__, "total_cpu_core_count", total_cpu_core_count)
        pulumi.set(__self__, "vnic2id", vnic2id)
        pulumi.set(__self__, "vnic_id", vnic_id)

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> _builtins.str:
        """
        Additional information about the planned maintenance.
        """
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="backupIpId")
    def backup_ip_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup IPv4 address associated with the database node. Use this OCID with either the [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IPv4 address needed to make a database connection.
        """
        return pulumi.get(self, "backup_ip_id")

    @_builtins.property
    @pulumi.getter(name="backupIpv6id")
    def backup_ipv6id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup IPv6 address associated with the database node. Use this OCID with the [GetIpv6](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/Ipv6/GetIpv6) API to get the IPv6 address needed to make a database connection.
        """
        return pulumi.get(self, "backup_ipv6id")

    @_builtins.property
    @pulumi.getter(name="backupVnic2id")
    def backup_vnic2id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second backup VNIC.
        """
        return pulumi.get(self, "backup_vnic2id")

    @_builtins.property
    @pulumi.getter(name="backupVnicId")
    def backup_vnic_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup VNIC.
        """
        return pulumi.get(self, "backup_vnic_id")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores enabled on the Db node.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> _builtins.str:
        return pulumi.get(self, "db_node_id")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The allocated local node storage in GBs on the Db node.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> _builtins.str:
        """
        The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> _builtins.str:
        """
        The name of the Fault Domain the instance is contained in.
        """
        return pulumi.get(self, "fault_domain")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="hostIpId")
    def host_ip_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the host IPv4 address associated with the database node. Use this OCID with either the [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IPv4 address needed to make a database connection.
        """
        return pulumi.get(self, "host_ip_id")

    @_builtins.property
    @pulumi.getter(name="hostIpv6id")
    def host_ipv6id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the host IPv6 address associated with the database node. Use this OCID with the [GetIpv6](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/Ipv6/GetIpv6) API to get the IPv6 address needed to make a database connection.
        """
        return pulumi.get(self, "host_ipv6id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host name for the database node.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> _builtins.str:
        """
        The type of database node maintenance.
        """
        return pulumi.get(self, "maintenance_type")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The allocated memory in GBs on the Db node.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="softwareStorageSizeInGb")
    def software_storage_size_in_gb(self) -> _builtins.int:
        """
        The size (in GB) of the block storage volume allocation for the DB system. This attribute applies only for virtual machine DB systems.
        """
        return pulumi.get(self, "software_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the database node was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceWindowEnd")
    def time_maintenance_window_end(self) -> _builtins.str:
        """
        End date and time of maintenance window.
        """
        return pulumi.get(self, "time_maintenance_window_end")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceWindowStart")
    def time_maintenance_window_start(self) -> _builtins.str:
        """
        Start date and time of maintenance window.
        """
        return pulumi.get(self, "time_maintenance_window_start")

    @_builtins.property
    @pulumi.getter(name="totalCpuCoreCount")
    def total_cpu_core_count(self) -> _builtins.int:
        """
        The total number of CPU cores reserved on the Db node.
        """
        return pulumi.get(self, "total_cpu_core_count")

    @_builtins.property
    @pulumi.getter
    def vnic2id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second VNIC.
        """
        return pulumi.get(self, "vnic2id")

    @_builtins.property
    @pulumi.getter(name="vnicId")
    def vnic_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VNIC.
        """
        return pulumi.get(self, "vnic_id")


@pulumi.output_type
class GetDbNodesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbServerDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: _builtins.int,
                 patching_status: _builtins.str,
                 time_patching_ended: _builtins.str,
                 time_patching_started: _builtins.str):
        """
        :param _builtins.int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str time_patching_ended: The time when the patching operation ended.
        :param _builtins.str time_patching_started: The time when the patching operation started.
        """
        pulumi.set(__self__, "estimated_patch_duration", estimated_patch_duration)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "time_patching_ended", time_patching_ended)
        pulumi.set(__self__, "time_patching_started", time_patching_started)

    @_builtins.property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> _builtins.int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @_builtins.property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDbServersDbServerResult(dict):
    def __init__(__self__, *,
                 autonomous_virtual_machine_ids: Sequence[_builtins.str],
                 autonomous_vm_cluster_ids: Sequence[_builtins.str],
                 compartment_id: _builtins.str,
                 compute_model: _builtins.str,
                 cpu_core_count: _builtins.int,
                 db_node_ids: Sequence[_builtins.str],
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_server_patching_details: Sequence['outputs.GetDbServersDbServerDbServerPatchingDetailResult'],
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 exadata_infrastructure_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 max_cpu_count: _builtins.int,
                 max_db_node_storage_in_gbs: _builtins.int,
                 max_memory_in_gbs: _builtins.int,
                 memory_size_in_gbs: _builtins.int,
                 shape: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 vm_cluster_ids: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] autonomous_virtual_machine_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machines associated with the Db server.
        :param Sequence[_builtins.str] autonomous_vm_cluster_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM Clusters associated with the Db server.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        :param _builtins.int cpu_core_count: The number of CPU cores enabled on the Db server.
        :param Sequence[_builtins.str] db_node_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db nodes associated with the Db server.
        :param _builtins.int db_node_storage_size_in_gbs: The allocated local node storage in GBs on the Db server.
        :param Sequence['GetDbServersDbServerDbServerPatchingDetailArgs'] db_server_patching_details: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str exadata_infrastructure_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the ExadataInfrastructure.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int max_cpu_count: The total number of CPU cores available.
        :param _builtins.int max_db_node_storage_in_gbs: The total local node storage available in GBs.
        :param _builtins.int max_memory_in_gbs: The total memory available in GBs.
        :param _builtins.int memory_size_in_gbs: The allocated memory in GBs on the Db server.
        :param _builtins.str shape: The shape of the Db server. The shape determines the amount of CPU, storage, and memory resources available.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the Db Server was created.
        :param Sequence[_builtins.str] vm_cluster_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM Clusters associated with the Db server.
        """
        pulumi.set(__self__, "autonomous_virtual_machine_ids", autonomous_virtual_machine_ids)
        pulumi.set(__self__, "autonomous_vm_cluster_ids", autonomous_vm_cluster_ids)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "db_node_ids", db_node_ids)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_server_patching_details", db_server_patching_details)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "exadata_infrastructure_id", exadata_infrastructure_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "max_cpu_count", max_cpu_count)
        pulumi.set(__self__, "max_db_node_storage_in_gbs", max_db_node_storage_in_gbs)
        pulumi.set(__self__, "max_memory_in_gbs", max_memory_in_gbs)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "vm_cluster_ids", vm_cluster_ids)

    @_builtins.property
    @pulumi.getter(name="autonomousVirtualMachineIds")
    def autonomous_virtual_machine_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machines associated with the Db server.
        """
        return pulumi.get(self, "autonomous_virtual_machine_ids")

    @_builtins.property
    @pulumi.getter(name="autonomousVmClusterIds")
    def autonomous_vm_cluster_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM Clusters associated with the Db server.
        """
        return pulumi.get(self, "autonomous_vm_cluster_ids")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores enabled on the Db server.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="dbNodeIds")
    def db_node_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db nodes associated with the Db server.
        """
        return pulumi.get(self, "db_node_ids")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The allocated local node storage in GBs on the Db server.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServerPatchingDetails")
    def db_server_patching_details(self) -> Sequence['outputs.GetDbServersDbServerDbServerPatchingDetailResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "db_server_patching_details")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the ExadataInfrastructure.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maxCpuCount")
    def max_cpu_count(self) -> _builtins.int:
        """
        The total number of CPU cores available.
        """
        return pulumi.get(self, "max_cpu_count")

    @_builtins.property
    @pulumi.getter(name="maxDbNodeStorageInGbs")
    def max_db_node_storage_in_gbs(self) -> _builtins.int:
        """
        The total local node storage available in GBs.
        """
        return pulumi.get(self, "max_db_node_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="maxMemoryInGbs")
    def max_memory_in_gbs(self) -> _builtins.int:
        """
        The total memory available in GBs.
        """
        return pulumi.get(self, "max_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The allocated memory in GBs on the Db server.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the Db server. The shape determines the amount of CPU, storage, and memory resources available.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the Db Server was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="vmClusterIds")
    def vm_cluster_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM Clusters associated with the Db server.
        """
        return pulumi.get(self, "vm_cluster_ids")


@pulumi.output_type
class GetDbServersDbServerDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: _builtins.int,
                 patching_status: _builtins.str,
                 time_patching_ended: _builtins.str,
                 time_patching_started: _builtins.str):
        """
        :param _builtins.int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str time_patching_ended: The time when the patching operation ended.
        :param _builtins.str time_patching_started: The time when the patching operation started.
        """
        pulumi.set(__self__, "estimated_patch_duration", estimated_patch_duration)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "time_patching_ended", time_patching_ended)
        pulumi.set(__self__, "time_patching_started", time_patching_started)

    @_builtins.property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> _builtins.int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @_builtins.property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDbServersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemComputePerformancesDbSystemComputePerformanceResult(dict):
    def __init__(__self__, *,
                 compute_performance_lists: Sequence['outputs.GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult'],
                 shape: _builtins.str):
        """
        :param Sequence['GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListArgs'] compute_performance_lists: List of Compute performance details for the specified DB system shape.
        :param _builtins.str shape: The shape of the DB system.
        """
        pulumi.set(__self__, "compute_performance_lists", compute_performance_lists)
        pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="computePerformanceLists")
    def compute_performance_lists(self) -> Sequence['outputs.GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult']:
        """
        List of Compute performance details for the specified DB system shape.
        """
        return pulumi.get(self, "compute_performance_lists")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the DB system.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult(dict):
    def __init__(__self__, *,
                 cpu_core_count: _builtins.int,
                 memory_in_gbs: _builtins.float,
                 network_bandwidth_in_gbps: _builtins.float,
                 network_iops: _builtins.float,
                 network_throughput_in_mbps: _builtins.float):
        """
        :param _builtins.int cpu_core_count: The number of OCPU cores available.
        :param _builtins.float memory_in_gbs: The amount of memory allocated for the VMDB System.
        :param _builtins.float network_bandwidth_in_gbps: The network bandwidth of the VMDB system in gbps.
        :param _builtins.float network_iops: IOPS for the VMDB System.
        :param _builtins.float network_throughput_in_mbps: Network throughput for the VMDB System.
        """
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "network_bandwidth_in_gbps", network_bandwidth_in_gbps)
        pulumi.set(__self__, "network_iops", network_iops)
        pulumi.set(__self__, "network_throughput_in_mbps", network_throughput_in_mbps)

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of OCPU cores available.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.float:
        """
        The amount of memory allocated for the VMDB System.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthInGbps")
    def network_bandwidth_in_gbps(self) -> _builtins.float:
        """
        The network bandwidth of the VMDB system in gbps.
        """
        return pulumi.get(self, "network_bandwidth_in_gbps")

    @_builtins.property
    @pulumi.getter(name="networkIops")
    def network_iops(self) -> _builtins.float:
        """
        IOPS for the VMDB System.
        """
        return pulumi.get(self, "network_iops")

    @_builtins.property
    @pulumi.getter(name="networkThroughputInMbps")
    def network_throughput_in_mbps(self) -> _builtins.float:
        """
        Network throughput for the VMDB System.
        """
        return pulumi.get(self, "network_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemComputePerformancesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemHistoryEntriesPatchHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 patch_id: _builtins.str,
                 patch_type: _builtins.str,
                 state: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str action: The action being performed or was completed.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param _builtins.str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str patch_type: The type of Patch operation.
        :param _builtins.str state: The current state of the action.
        :param _builtins.str time_ended: The date and time when the patch action completed
        :param _builtins.str time_started: The date and time when the patch action started.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "patch_type", patch_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action being performed or was completed.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> _builtins.str:
        """
        The type of Patch operation.
        """
        return pulumi.get(self, "patch_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the action.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time when the patch action completed
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the patch action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDbSystemPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemPatchesPatchResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[_builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 last_action: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_released: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence[_builtins.str] available_actions: Actions that can possibly be performed using this patch.
        :param _builtins.str description: The text describing this patch package.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str last_action: Action that is currently being performed or was completed last.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param _builtins.str state: The current state of the patch as a result of lastAction.
        :param _builtins.str time_released: The date and time that the patch was released.
        :param _builtins.str version: The version of this patch package.
        """
        pulumi.set(__self__, "available_actions", available_actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_action", last_action)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[_builtins.str]:
        """
        Actions that can possibly be performed using this patch.
        """
        return pulumi.get(self, "available_actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> _builtins.str:
        """
        Action that is currently being performed or was completed last.
        """
        return pulumi.get(self, "last_action")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDbSystemShapesDbSystemShapeResult(dict):
    def __init__(__self__, *,
                 are_server_types_supported: _builtins.bool,
                 available_core_count: _builtins.int,
                 available_core_count_per_node: _builtins.int,
                 available_data_storage_in_tbs: _builtins.int,
                 available_data_storage_per_server_in_tbs: _builtins.float,
                 available_db_node_per_node_in_gbs: _builtins.int,
                 available_db_node_storage_in_gbs: _builtins.int,
                 available_memory_in_gbs: _builtins.int,
                 available_memory_per_node_in_gbs: _builtins.int,
                 compute_model: _builtins.str,
                 core_count_increment: _builtins.int,
                 display_name: _builtins.str,
                 max_storage_count: _builtins.int,
                 maximum_node_count: _builtins.int,
                 min_core_count_per_node: _builtins.int,
                 min_data_storage_in_tbs: _builtins.int,
                 min_db_node_storage_per_node_in_gbs: _builtins.int,
                 min_memory_per_node_in_gbs: _builtins.int,
                 min_storage_count: _builtins.int,
                 minimum_core_count: _builtins.int,
                 minimum_node_count: _builtins.int,
                 name: _builtins.str,
                 shape: _builtins.str,
                 shape_family: _builtins.str,
                 shape_type: _builtins.str):
        """
        :param _builtins.bool are_server_types_supported: If true, the shape supports configurable DB and Storage Server types.
        :param _builtins.int available_core_count: The maximum number of CPU cores that can be enabled on the DB system for this shape.
        :param _builtins.int available_core_count_per_node: The maximum number of CPU cores per database node that can be enabled for this shape. Only applicable to the flex Exadata shape, ExaCC Elastic shapes and VM Flex shapes.
        :param _builtins.int available_data_storage_in_tbs: The maximum DATA storage that can be enabled for this shape.
        :param _builtins.float available_data_storage_per_server_in_tbs: The maximum data storage available per storage server for this shape. Only applicable to ExaCC Elastic shapes.
        :param _builtins.int available_db_node_per_node_in_gbs: The maximum Db Node storage available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        :param _builtins.int available_db_node_storage_in_gbs: The maximum Db Node storage that can be enabled for this shape.
        :param _builtins.int available_memory_in_gbs: The maximum memory that can be enabled for this shape.
        :param _builtins.int available_memory_per_node_in_gbs: The maximum memory available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        :param _builtins.str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        :param _builtins.int core_count_increment: The discrete number by which the CPU core count for this shape can be increased or decreased.
        :param _builtins.str display_name: The display name of the shape used for the DB system.
        :param _builtins.int max_storage_count: The maximum number of Exadata storage servers available for the Exadata infrastructure.
        :param _builtins.int maximum_node_count: The maximum number of compute servers available for this shape.
        :param _builtins.int min_core_count_per_node: The minimum number of CPU cores that can be enabled per node for this shape.
        :param _builtins.int min_data_storage_in_tbs: The minimum data storage that need be allocated for this shape.
        :param _builtins.int min_db_node_storage_per_node_in_gbs: The minimum Db Node storage that need be allocated per node for this shape.
        :param _builtins.int min_memory_per_node_in_gbs: The minimum memory that need be allocated per node for this shape.
        :param _builtins.int min_storage_count: The minimum number of Exadata storage servers available for the Exadata infrastructure.
        :param _builtins.int minimum_core_count: The minimum number of CPU cores that can be enabled on the DB system for this shape.
        :param _builtins.int minimum_node_count: The minimum number of compute servers available for this shape.
        :param _builtins.str name: The name of the shape used for the DB system.
        :param _builtins.str shape: Deprecated. Use `name` instead of `shape`.
        :param _builtins.str shape_family: The family of the shape used for the DB system.
        :param _builtins.str shape_type: The shape type for the virtual machine DB system. Shape type is determined by CPU hardware. Valid values are `AMD` , `INTEL` or `INTEL_FLEX_X9`.
        """
        pulumi.set(__self__, "are_server_types_supported", are_server_types_supported)
        pulumi.set(__self__, "available_core_count", available_core_count)
        pulumi.set(__self__, "available_core_count_per_node", available_core_count_per_node)
        pulumi.set(__self__, "available_data_storage_in_tbs", available_data_storage_in_tbs)
        pulumi.set(__self__, "available_data_storage_per_server_in_tbs", available_data_storage_per_server_in_tbs)
        pulumi.set(__self__, "available_db_node_per_node_in_gbs", available_db_node_per_node_in_gbs)
        pulumi.set(__self__, "available_db_node_storage_in_gbs", available_db_node_storage_in_gbs)
        pulumi.set(__self__, "available_memory_in_gbs", available_memory_in_gbs)
        pulumi.set(__self__, "available_memory_per_node_in_gbs", available_memory_per_node_in_gbs)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "core_count_increment", core_count_increment)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "max_storage_count", max_storage_count)
        pulumi.set(__self__, "maximum_node_count", maximum_node_count)
        pulumi.set(__self__, "min_core_count_per_node", min_core_count_per_node)
        pulumi.set(__self__, "min_data_storage_in_tbs", min_data_storage_in_tbs)
        pulumi.set(__self__, "min_db_node_storage_per_node_in_gbs", min_db_node_storage_per_node_in_gbs)
        pulumi.set(__self__, "min_memory_per_node_in_gbs", min_memory_per_node_in_gbs)
        pulumi.set(__self__, "min_storage_count", min_storage_count)
        pulumi.set(__self__, "minimum_core_count", minimum_core_count)
        pulumi.set(__self__, "minimum_node_count", minimum_node_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_family", shape_family)
        pulumi.set(__self__, "shape_type", shape_type)

    @_builtins.property
    @pulumi.getter(name="areServerTypesSupported")
    def are_server_types_supported(self) -> _builtins.bool:
        """
        If true, the shape supports configurable DB and Storage Server types.
        """
        return pulumi.get(self, "are_server_types_supported")

    @_builtins.property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> _builtins.int:
        """
        The maximum number of CPU cores that can be enabled on the DB system for this shape.
        """
        return pulumi.get(self, "available_core_count")

    @_builtins.property
    @pulumi.getter(name="availableCoreCountPerNode")
    def available_core_count_per_node(self) -> _builtins.int:
        """
        The maximum number of CPU cores per database node that can be enabled for this shape. Only applicable to the flex Exadata shape, ExaCC Elastic shapes and VM Flex shapes.
        """
        return pulumi.get(self, "available_core_count_per_node")

    @_builtins.property
    @pulumi.getter(name="availableDataStorageInTbs")
    def available_data_storage_in_tbs(self) -> _builtins.int:
        """
        The maximum DATA storage that can be enabled for this shape.
        """
        return pulumi.get(self, "available_data_storage_in_tbs")

    @_builtins.property
    @pulumi.getter(name="availableDataStoragePerServerInTbs")
    def available_data_storage_per_server_in_tbs(self) -> _builtins.float:
        """
        The maximum data storage available per storage server for this shape. Only applicable to ExaCC Elastic shapes.
        """
        return pulumi.get(self, "available_data_storage_per_server_in_tbs")

    @_builtins.property
    @pulumi.getter(name="availableDbNodePerNodeInGbs")
    def available_db_node_per_node_in_gbs(self) -> _builtins.int:
        """
        The maximum Db Node storage available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        """
        return pulumi.get(self, "available_db_node_per_node_in_gbs")

    @_builtins.property
    @pulumi.getter(name="availableDbNodeStorageInGbs")
    def available_db_node_storage_in_gbs(self) -> _builtins.int:
        """
        The maximum Db Node storage that can be enabled for this shape.
        """
        return pulumi.get(self, "available_db_node_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="availableMemoryInGbs")
    def available_memory_in_gbs(self) -> _builtins.int:
        """
        The maximum memory that can be enabled for this shape.
        """
        return pulumi.get(self, "available_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="availableMemoryPerNodeInGbs")
    def available_memory_per_node_in_gbs(self) -> _builtins.int:
        """
        The maximum memory available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        """
        return pulumi.get(self, "available_memory_per_node_in_gbs")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="coreCountIncrement")
    def core_count_increment(self) -> _builtins.int:
        """
        The discrete number by which the CPU core count for this shape can be increased or decreased.
        """
        return pulumi.get(self, "core_count_increment")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name of the shape used for the DB system.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="maxStorageCount")
    def max_storage_count(self) -> _builtins.int:
        """
        The maximum number of Exadata storage servers available for the Exadata infrastructure.
        """
        return pulumi.get(self, "max_storage_count")

    @_builtins.property
    @pulumi.getter(name="maximumNodeCount")
    def maximum_node_count(self) -> _builtins.int:
        """
        The maximum number of compute servers available for this shape.
        """
        return pulumi.get(self, "maximum_node_count")

    @_builtins.property
    @pulumi.getter(name="minCoreCountPerNode")
    def min_core_count_per_node(self) -> _builtins.int:
        """
        The minimum number of CPU cores that can be enabled per node for this shape.
        """
        return pulumi.get(self, "min_core_count_per_node")

    @_builtins.property
    @pulumi.getter(name="minDataStorageInTbs")
    def min_data_storage_in_tbs(self) -> _builtins.int:
        """
        The minimum data storage that need be allocated for this shape.
        """
        return pulumi.get(self, "min_data_storage_in_tbs")

    @_builtins.property
    @pulumi.getter(name="minDbNodeStoragePerNodeInGbs")
    def min_db_node_storage_per_node_in_gbs(self) -> _builtins.int:
        """
        The minimum Db Node storage that need be allocated per node for this shape.
        """
        return pulumi.get(self, "min_db_node_storage_per_node_in_gbs")

    @_builtins.property
    @pulumi.getter(name="minMemoryPerNodeInGbs")
    def min_memory_per_node_in_gbs(self) -> _builtins.int:
        """
        The minimum memory that need be allocated per node for this shape.
        """
        return pulumi.get(self, "min_memory_per_node_in_gbs")

    @_builtins.property
    @pulumi.getter(name="minStorageCount")
    def min_storage_count(self) -> _builtins.int:
        """
        The minimum number of Exadata storage servers available for the Exadata infrastructure.
        """
        return pulumi.get(self, "min_storage_count")

    @_builtins.property
    @pulumi.getter(name="minimumCoreCount")
    def minimum_core_count(self) -> _builtins.int:
        """
        The minimum number of CPU cores that can be enabled on the DB system for this shape.
        """
        return pulumi.get(self, "minimum_core_count")

    @_builtins.property
    @pulumi.getter(name="minimumNodeCount")
    def minimum_node_count(self) -> _builtins.int:
        """
        The minimum number of compute servers available for this shape.
        """
        return pulumi.get(self, "minimum_node_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'shape' field has been deprecated. Please use 'name' instead.""")
    def shape(self) -> _builtins.str:
        """
        Deprecated. Use `name` instead of `shape`.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeFamily")
    def shape_family(self) -> _builtins.str:
        """
        The family of the shape used for the DB system.
        """
        return pulumi.get(self, "shape_family")

    @_builtins.property
    @pulumi.getter(name="shapeType")
    def shape_type(self) -> _builtins.str:
        """
        The shape type for the virtual machine DB system. Shape type is determined by CPU hardware. Valid values are `AMD` , `INTEL` or `INTEL_FLEX_X9`.
        """
        return pulumi.get(self, "shape_type")


@pulumi.output_type
class GetDbSystemShapesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the shape used for the DB system.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceResult(dict):
    def __init__(__self__, *,
                 data_storage_performance_lists: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult'],
                 reco_storage_performance_lists: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult'],
                 shape_type: _builtins.str):
        """
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListArgs'] data_storage_performance_lists: List of storage performance for the DATA disks
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListArgs'] reco_storage_performance_lists: List of storage performance for the RECO disks
        :param _builtins.str shape_type: Optional. Filters the performance results by shape type.
        """
        pulumi.set(__self__, "data_storage_performance_lists", data_storage_performance_lists)
        pulumi.set(__self__, "reco_storage_performance_lists", reco_storage_performance_lists)
        pulumi.set(__self__, "shape_type", shape_type)

    @_builtins.property
    @pulumi.getter(name="dataStoragePerformanceLists")
    def data_storage_performance_lists(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult']:
        """
        List of storage performance for the DATA disks
        """
        return pulumi.get(self, "data_storage_performance_lists")

    @_builtins.property
    @pulumi.getter(name="recoStoragePerformanceLists")
    def reco_storage_performance_lists(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult']:
        """
        List of storage performance for the RECO disks
        """
        return pulumi.get(self, "reco_storage_performance_lists")

    @_builtins.property
    @pulumi.getter(name="shapeType")
    def shape_type(self) -> _builtins.str:
        """
        Optional. Filters the performance results by shape type.
        """
        return pulumi.get(self, "shape_type")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult(dict):
    def __init__(__self__, *,
                 balanced_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult'],
                 high_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult'],
                 size_in_gbs: _builtins.int):
        """
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceArgs'] balanced_disk_performances: Representation of disk performance detail parameters.
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceArgs'] high_disk_performances: Representation of disk performance detail parameters.
        :param _builtins.int size_in_gbs: Size in GBs.
        """
        pulumi.set(__self__, "balanced_disk_performances", balanced_disk_performances)
        pulumi.set(__self__, "high_disk_performances", high_disk_performances)
        pulumi.set(__self__, "size_in_gbs", size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="balancedDiskPerformances")
    def balanced_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "balanced_disk_performances")

    @_builtins.property
    @pulumi.getter(name="highDiskPerformances")
    def high_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "high_disk_performances")

    @_builtins.property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> _builtins.int:
        """
        Size in GBs.
        """
        return pulumi.get(self, "size_in_gbs")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.float,
                 disk_throughput_in_mbps: _builtins.float):
        """
        :param _builtins.float disk_iops: Disk IOPS in thousands.
        :param _builtins.float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_throughput_in_mbps", disk_throughput_in_mbps)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> _builtins.float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.float,
                 disk_throughput_in_mbps: _builtins.float):
        """
        :param _builtins.float disk_iops: Disk IOPS in thousands.
        :param _builtins.float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_throughput_in_mbps", disk_throughput_in_mbps)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> _builtins.float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult(dict):
    def __init__(__self__, *,
                 balanced_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult'],
                 high_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult'],
                 size_in_gbs: _builtins.int):
        """
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceArgs'] balanced_disk_performances: Representation of disk performance detail parameters.
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceArgs'] high_disk_performances: Representation of disk performance detail parameters.
        :param _builtins.int size_in_gbs: Size in GBs.
        """
        pulumi.set(__self__, "balanced_disk_performances", balanced_disk_performances)
        pulumi.set(__self__, "high_disk_performances", high_disk_performances)
        pulumi.set(__self__, "size_in_gbs", size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="balancedDiskPerformances")
    def balanced_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "balanced_disk_performances")

    @_builtins.property
    @pulumi.getter(name="highDiskPerformances")
    def high_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "high_disk_performances")

    @_builtins.property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> _builtins.int:
        """
        Size in GBs.
        """
        return pulumi.get(self, "size_in_gbs")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.float,
                 disk_throughput_in_mbps: _builtins.float):
        """
        :param _builtins.float disk_iops: Disk IOPS in thousands.
        :param _builtins.float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_throughput_in_mbps", disk_throughput_in_mbps)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> _builtins.float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.float,
                 disk_throughput_in_mbps: _builtins.float):
        """
        :param _builtins.float disk_iops: Disk IOPS in thousands.
        :param _builtins.float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_throughput_in_mbps", disk_throughput_in_mbps)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> _builtins.float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemsDbSystemResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 backup_network_nsg_ids: Sequence[_builtins.str],
                 backup_subnet_id: _builtins.str,
                 cluster_name: _builtins.str,
                 compartment_id: _builtins.str,
                 cpu_core_count: _builtins.int,
                 data_collection_options: Sequence['outputs.GetDbSystemsDbSystemDataCollectionOptionResult'],
                 data_storage_percentage: _builtins.int,
                 data_storage_size_in_gb: _builtins.int,
                 database_edition: _builtins.str,
                 db_homes: Sequence['outputs.GetDbSystemsDbSystemDbHomeResult'],
                 db_system_options: Sequence['outputs.GetDbSystemsDbSystemDbSystemOptionResult'],
                 defined_tags: Mapping[str, _builtins.str],
                 disk_redundancy: _builtins.str,
                 display_name: _builtins.str,
                 domain: _builtins.str,
                 fault_domains: Sequence[_builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 hostname: _builtins.str,
                 id: _builtins.str,
                 iorm_config_caches: Sequence['outputs.GetDbSystemsDbSystemIormConfigCachResult'],
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 last_maintenance_run_id: _builtins.str,
                 last_patch_history_entry_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 listener_port: _builtins.int,
                 maintenance_window_details: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowResult'],
                 memory_size_in_gbs: _builtins.int,
                 next_maintenance_run_id: _builtins.str,
                 node_count: _builtins.int,
                 nsg_ids: Sequence[_builtins.str],
                 os_version: _builtins.str,
                 point_in_time_data_disk_clone_timestamp: _builtins.str,
                 private_ip: _builtins.str,
                 private_ip_v6: _builtins.str,
                 reco_storage_size_in_gb: _builtins.int,
                 scan_dns_name: _builtins.str,
                 scan_dns_record_id: _builtins.str,
                 scan_ip_ids: Sequence[_builtins.str],
                 scan_ipv6ids: Sequence[_builtins.str],
                 security_attributes: Mapping[str, _builtins.str],
                 shape: _builtins.str,
                 source: _builtins.str,
                 source_db_system_id: _builtins.str,
                 sparse_diskgroup: _builtins.bool,
                 ssh_public_keys: Sequence[_builtins.str],
                 state: _builtins.str,
                 storage_volume_performance_mode: _builtins.str,
                 subnet_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_zone: _builtins.str,
                 version: _builtins.str,
                 vip_ids: Sequence[_builtins.str],
                 vipv6ids: Sequence[_builtins.str],
                 zone_id: _builtins.str):
        """
        :param _builtins.str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param Sequence[_builtins.str] backup_network_nsg_ids: A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        :param _builtins.str backup_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet the DB system is associated with. Applicable only to Exadata DB systems.
        :param _builtins.str cluster_name: The cluster name for Exadata and 2-node RAC virtual machine DB systems. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int cpu_core_count: The number of CPU cores enabled on the DB system.
        :param Sequence['GetDbSystemsDbSystemDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param _builtins.int data_storage_percentage: The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 40 and 80. The default is 80 percent assigned to DATA storage. Not applicable for virtual machine DB systems. Required for BMDBs.
        :param _builtins.int data_storage_size_in_gb: The data storage size, in gigabytes, that is currently available to the DB system. Applies only for virtual machine DB systems. Required for VMDBs.
        :param _builtins.str database_edition: The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        :param Sequence['GetDbSystemsDbSystemDbSystemOptionArgs'] db_system_options: The DB system options.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str disk_redundancy: The type of redundancy configured for the DB system. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str domain: The domain name for the DB system.
        :param Sequence[_builtins.str] fault_domains: List of the Fault Domains in which this DB system is provisioned.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str hostname: The hostname for the DB system.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param _builtins.str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param _builtins.str license_model: The Oracle license model that applies to all the databases on the DB system. The default is LICENSE_INCLUDED.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int listener_port: The port number configured for the listener on the DB system.
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.int memory_size_in_gbs: Memory allocated to the DB system, in gigabytes.
        :param _builtins.str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param _builtins.int node_count: The number of nodes in the DB system. For RAC DB systems, the value is greater than 1.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.str os_version: The most recent OS Patch Version applied on the DB system.
        :param _builtins.str point_in_time_data_disk_clone_timestamp: The point in time for a cloned database system when the data disks were cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param _builtins.int reco_storage_size_in_gb: The RECO/REDO storage size, in gigabytes, that is currently allocated to the DB system. Applies only for virtual machine DB systems.
        :param _builtins.str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the DB system.
        :param _builtins.str scan_dns_record_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the DB system.
        :param Sequence[_builtins.str] scan_ip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv4 addresses associated with the DB system. SCAN IPv4 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param Sequence[_builtins.str] scan_ipv6ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv6 addresses associated with the DB system. SCAN IPv6 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param Mapping[str, _builtins.str] security_attributes: Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        :param _builtins.str shape: The shape of the DB system. The shape determines resources to allocate to the DB system.
               * For virtual machine shapes, the number of CPU cores and memory
               * For bare metal and Exadata shapes, the number of CPU cores, storage, and memory
        :param _builtins.str source_db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.bool sparse_diskgroup: True, if Sparse Diskgroup is configured for Exadata dbsystem, False, if Sparse diskgroup was not configured. Only applied for Exadata shape.
        :param Sequence[_builtins.str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the DB system.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str storage_volume_performance_mode: The block storage volume performance level. Valid values are `BALANCED` and `HIGH_PERFORMANCE`. See [Block Volume Performance](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm) for more information.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the DB system is associated with.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the DB system was created.
        :param _builtins.str time_zone: The time zone of the DB system. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param _builtins.str version: The Oracle Database version of the DB system.
        :param Sequence[_builtins.str] vip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IPv4 (VIP) addresses associated with the DB system. The Cluster Ready Services (CRS) creates and maintains one VIPv4 address for each node in the DB system to enable failover. If one node fails, the VIPv4 is reassigned to another active node in the cluster.
        :param Sequence[_builtins.str] vipv6ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IPv6 (VIP) addresses associated with the DB system. The Cluster Ready Services (CRS) creates and maintains one VIP IpV6 address for each node in the DB system to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        :param _builtins.str zone_id: The OCID of the zone the DB system is associated with.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_network_nsg_ids", backup_network_nsg_ids)
        pulumi.set(__self__, "backup_subnet_id", backup_subnet_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "data_collection_options", data_collection_options)
        pulumi.set(__self__, "data_storage_percentage", data_storage_percentage)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "db_homes", db_homes)
        pulumi.set(__self__, "db_system_options", db_system_options)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "disk_redundancy", disk_redundancy)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "fault_domains", fault_domains)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "iorm_config_caches", iorm_config_caches)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "last_maintenance_run_id", last_maintenance_run_id)
        pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "listener_port", listener_port)
        pulumi.set(__self__, "maintenance_window_details", maintenance_window_details)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "next_maintenance_run_id", next_maintenance_run_id)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "os_version", os_version)
        pulumi.set(__self__, "point_in_time_data_disk_clone_timestamp", point_in_time_data_disk_clone_timestamp)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "private_ip_v6", private_ip_v6)
        pulumi.set(__self__, "reco_storage_size_in_gb", reco_storage_size_in_gb)
        pulumi.set(__self__, "scan_dns_name", scan_dns_name)
        pulumi.set(__self__, "scan_dns_record_id", scan_dns_record_id)
        pulumi.set(__self__, "scan_ip_ids", scan_ip_ids)
        pulumi.set(__self__, "scan_ipv6ids", scan_ipv6ids)
        pulumi.set(__self__, "security_attributes", security_attributes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_db_system_id", source_db_system_id)
        pulumi.set(__self__, "sparse_diskgroup", sparse_diskgroup)
        pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_volume_performance_mode", storage_volume_performance_mode)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "vip_ids", vip_ids)
        pulumi.set(__self__, "vipv6ids", vipv6ids)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[_builtins.str]:
        """
        A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        """
        return pulumi.get(self, "backup_network_nsg_ids")

    @_builtins.property
    @pulumi.getter(name="backupSubnetId")
    def backup_subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet the DB system is associated with. Applicable only to Exadata DB systems.
        """
        return pulumi.get(self, "backup_subnet_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The cluster name for Exadata and 2-node RAC virtual machine DB systems. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        """
        The number of CPU cores enabled on the DB system.
        """
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetDbSystemsDbSystemDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @_builtins.property
    @pulumi.getter(name="dataStoragePercentage")
    def data_storage_percentage(self) -> _builtins.int:
        """
        The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 40 and 80. The default is 80 percent assigned to DATA storage. Not applicable for virtual machine DB systems. Required for BMDBs.
        """
        return pulumi.get(self, "data_storage_percentage")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> _builtins.int:
        """
        The data storage size, in gigabytes, that is currently available to the DB system. Applies only for virtual machine DB systems. Required for VMDBs.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="dbHomes")
    def db_homes(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeResult']:
        return pulumi.get(self, "db_homes")

    @_builtins.property
    @pulumi.getter(name="dbSystemOptions")
    def db_system_options(self) -> Sequence['outputs.GetDbSystemsDbSystemDbSystemOptionResult']:
        """
        The DB system options.
        """
        return pulumi.get(self, "db_system_options")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="diskRedundancy")
    def disk_redundancy(self) -> _builtins.str:
        """
        The type of redundancy configured for the DB system. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        """
        return pulumi.get(self, "disk_redundancy")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name for the DB system.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Sequence[_builtins.str]:
        """
        List of the Fault Domains in which this DB system is provisioned.
        """
        return pulumi.get(self, "fault_domains")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname for the DB system.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="iormConfigCaches")
    def iorm_config_caches(self) -> Sequence['outputs.GetDbSystemsDbSystemIormConfigCachResult']:
        return pulumi.get(self, "iorm_config_caches")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to all the databases on the DB system. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> _builtins.int:
        """
        The port number configured for the listener on the DB system.
        """
        return pulumi.get(self, "listener_port")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        Memory allocated to the DB system, in gigabytes.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes in the DB system. For RAC DB systems, the value is greater than 1.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> _builtins.str:
        """
        The most recent OS Patch Version applied on the DB system.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter(name="pointInTimeDataDiskCloneTimestamp")
    def point_in_time_data_disk_clone_timestamp(self) -> _builtins.str:
        """
        The point in time for a cloned database system when the data disks were cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "point_in_time_data_disk_clone_timestamp")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="privateIpV6")
    def private_ip_v6(self) -> _builtins.str:
        return pulumi.get(self, "private_ip_v6")

    @_builtins.property
    @pulumi.getter(name="recoStorageSizeInGb")
    def reco_storage_size_in_gb(self) -> _builtins.int:
        """
        The RECO/REDO storage size, in gigabytes, that is currently allocated to the DB system. Applies only for virtual machine DB systems.
        """
        return pulumi.get(self, "reco_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> _builtins.str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the DB system.
        """
        return pulumi.get(self, "scan_dns_name")

    @_builtins.property
    @pulumi.getter(name="scanDnsRecordId")
    def scan_dns_record_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the DB system.
        """
        return pulumi.get(self, "scan_dns_record_id")

    @_builtins.property
    @pulumi.getter(name="scanIpIds")
    def scan_ip_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv4 addresses associated with the DB system. SCAN IPv4 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ip_ids")

    @_builtins.property
    @pulumi.getter(name="scanIpv6ids")
    def scan_ipv6ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IPv6 addresses associated with the DB system. SCAN IPv6 addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ipv6ids")

    @_builtins.property
    @pulumi.getter(name="securityAttributes")
    def security_attributes(self) -> Mapping[str, _builtins.str]:
        """
        Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        """
        return pulumi.get(self, "security_attributes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the DB system. The shape determines resources to allocate to the DB system.
        * For virtual machine shapes, the number of CPU cores and memory
        * For bare metal and Exadata shapes, the number of CPU cores, storage, and memory
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceDbSystemId")
    def source_db_system_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "source_db_system_id")

    @_builtins.property
    @pulumi.getter(name="sparseDiskgroup")
    def sparse_diskgroup(self) -> _builtins.bool:
        """
        True, if Sparse Diskgroup is configured for Exadata dbsystem, False, if Sparse diskgroup was not configured. Only applied for Exadata shape.
        """
        return pulumi.get(self, "sparse_diskgroup")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[_builtins.str]:
        """
        The public key portion of one or more key pairs used for SSH access to the DB system.
        """
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageVolumePerformanceMode")
    def storage_volume_performance_mode(self) -> _builtins.str:
        """
        The block storage volume performance level. Valid values are `BALANCED` and `HIGH_PERFORMANCE`. See [Block Volume Performance](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm) for more information.
        """
        return pulumi.get(self, "storage_volume_performance_mode")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the DB system is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the DB system. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The Oracle Database version of the DB system.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="vipIds")
    def vip_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IPv4 (VIP) addresses associated with the DB system. The Cluster Ready Services (CRS) creates and maintains one VIPv4 address for each node in the DB system to enable failover. If one node fails, the VIPv4 is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vip_ids")

    @_builtins.property
    @pulumi.getter
    def vipv6ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IPv6 (VIP) addresses associated with the DB system. The Cluster Ready Services (CRS) creates and maintains one VIP IpV6 address for each node in the DB system to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vipv6ids")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The OCID of the zone the DB system is associated with.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetDbSystemsDbSystemDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeResult(dict):
    def __init__(__self__, *,
                 create_async: _builtins.bool,
                 database_software_image_id: _builtins.str,
                 databases: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseResult'],
                 db_home_location: _builtins.str,
                 db_version: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_unified_auditing_enabled: _builtins.bool,
                 last_patch_history_entry_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str):
        """
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the DB system was created.
        """
        pulumi.set(__self__, "create_async", create_async)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "db_home_location", db_home_location)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_unified_auditing_enabled", is_unified_auditing_enabled)
        pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> _builtins.bool:
        return pulumi.get(self, "create_async")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseResult']:
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> _builtins.str:
        return pulumi.get(self, "db_home_location")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isUnifiedAuditingEnabled")
    def is_unified_auditing_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_unified_auditing_enabled")

    @_builtins.property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 backup_id: _builtins.str,
                 backup_tde_password: _builtins.str,
                 character_set: _builtins.str,
                 connection_strings: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult'],
                 database_id: _builtins.str,
                 database_software_image_id: _builtins.str,
                 db_backup_configs: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult'],
                 db_domain: _builtins.str,
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 db_workload: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 kms_key_id: _builtins.str,
                 kms_key_version_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 pdb_name: _builtins.str,
                 pluggable_databases: Sequence[_builtins.str],
                 state: _builtins.str,
                 tde_wallet_password: _builtins.str,
                 time_created: _builtins.str,
                 time_stamp_for_point_in_time_recovery: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str backup_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param _builtins.str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the DB system was created.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "db_backup_configs", db_backup_configs)
        pulumi.set(__self__, "db_domain", db_domain)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> _builtins.str:
        return pulumi.get(self, "backup_tde_password")

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult']:
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult']:
        return pulumi.get(self, "db_backup_configs")

    @_builtins.property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> _builtins.str:
        return pulumi.get(self, "db_domain")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> _builtins.str:
        return pulumi.get(self, "db_workload")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "pluggable_databases")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> _builtins.str:
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 cdb_default: _builtins.str,
                 cdb_ip_default: _builtins.str):
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "cdb_default", cdb_default)
        pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> _builtins.str:
        return pulumi.get(self, "cdb_default")

    @_builtins.property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> _builtins.str:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: _builtins.bool,
                 auto_backup_window: _builtins.str,
                 auto_full_backup_day: _builtins.str,
                 auto_full_backup_window: _builtins.str,
                 backup_deletion_policy: _builtins.str,
                 backup_destination_details: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: _builtins.int,
                 run_immediate_full_backup: _builtins.bool):
        pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @_builtins.property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "auto_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> _builtins.str:
        return pulumi.get(self, "auto_backup_window")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> _builtins.str:
        return pulumi.get(self, "auto_full_backup_day")

    @_builtins.property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> _builtins.str:
        return pulumi.get(self, "auto_full_backup_window")

    @_builtins.property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> _builtins.str:
        return pulumi.get(self, "backup_deletion_policy")

    @_builtins.property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @_builtins.property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> _builtins.int:
        return pulumi.get(self, "recovery_window_in_days")

    @_builtins.property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> _builtins.bool:
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: _builtins.str,
                 id: _builtins.str,
                 is_remote: _builtins.bool,
                 remote_region: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_remote", is_remote)
        pulumi.set(__self__, "remote_region", remote_region)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "dbrs_policy_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRemote")
    def is_remote(self) -> _builtins.bool:
        return pulumi.get(self, "is_remote")

    @_builtins.property
    @pulumi.getter(name="remoteRegion")
    def remote_region(self) -> _builtins.str:
        return pulumi.get(self, "remote_region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDbSystemsDbSystemDbSystemOptionResult(dict):
    def __init__(__self__, *,
                 storage_management: _builtins.str):
        """
        :param _builtins.str storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        pulumi.set(__self__, "storage_management", storage_management)

    @_builtins.property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> _builtins.str:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")


@pulumi.output_type
class GetDbSystemsDbSystemIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetDbSystemsDbSystemIormConfigCachDbPlanResult'],
                 db_system_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 objective: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        """
        pulumi.set(__self__, "db_plans", db_plans)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "objective", objective)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetDbSystemsDbSystemIormConfigCachDbPlanResult']:
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> _builtins.str:
        return pulumi.get(self, "db_system_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> _builtins.str:
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetDbSystemsDbSystemIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        return pulumi.get(self, "share")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemsUpgradeHistoryEntriesDbSystemUpgradeHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 new_gi_version: _builtins.str,
                 new_os_version: _builtins.str,
                 old_gi_version: _builtins.str,
                 old_os_version: _builtins.str,
                 snapshot_retention_period_in_days: _builtins.int,
                 state: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str action: The operating system upgrade action.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the upgrade history entry.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param _builtins.str new_gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param _builtins.str new_os_version: A valid Oracle Software (OS) version eg. Oracle Linux Server release 8
        :param _builtins.str old_gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param _builtins.str old_os_version: A valid Oracle Software (OS) version eg. Oracle Linux Server release 8
        :param _builtins.int snapshot_retention_period_in_days: The retention period, in days, for the snapshot that allows you to perform a rollback of the upgrade operation. After this number of days passes, you cannot roll back the upgrade.
        :param _builtins.str state: A filter to return only upgrade history entries that match the given lifecycle state exactly.
        :param _builtins.str time_ended: The date and time when the upgrade action completed
        :param _builtins.str time_started: The date and time when the upgrade action started.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "new_gi_version", new_gi_version)
        pulumi.set(__self__, "new_os_version", new_os_version)
        pulumi.set(__self__, "old_gi_version", old_gi_version)
        pulumi.set(__self__, "old_os_version", old_os_version)
        pulumi.set(__self__, "snapshot_retention_period_in_days", snapshot_retention_period_in_days)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The operating system upgrade action.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the upgrade history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="newGiVersion")
    def new_gi_version(self) -> _builtins.str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "new_gi_version")

    @_builtins.property
    @pulumi.getter(name="newOsVersion")
    def new_os_version(self) -> _builtins.str:
        """
        A valid Oracle Software (OS) version eg. Oracle Linux Server release 8
        """
        return pulumi.get(self, "new_os_version")

    @_builtins.property
    @pulumi.getter(name="oldGiVersion")
    def old_gi_version(self) -> _builtins.str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "old_gi_version")

    @_builtins.property
    @pulumi.getter(name="oldOsVersion")
    def old_os_version(self) -> _builtins.str:
        """
        A valid Oracle Software (OS) version eg. Oracle Linux Server release 8
        """
        return pulumi.get(self, "old_os_version")

    @_builtins.property
    @pulumi.getter(name="snapshotRetentionPeriodInDays")
    def snapshot_retention_period_in_days(self) -> _builtins.int:
        """
        The retention period, in days, for the snapshot that allows you to perform a rollback of the upgrade operation. After this number of days passes, you cannot roll back the upgrade.
        """
        return pulumi.get(self, "snapshot_retention_period_in_days")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only upgrade history entries that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time when the upgrade action completed
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the upgrade action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDbSystemsUpgradeHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbVersionsDbVersionResult(dict):
    def __init__(__self__, *,
                 is_latest_for_major_version: _builtins.bool,
                 is_preview_db_version: _builtins.bool,
                 is_upgrade_supported: _builtins.bool,
                 supports_pdb: _builtins.bool,
                 version: _builtins.str):
        """
        :param _builtins.bool is_latest_for_major_version: True if this version of the Oracle Database software is the latest version for a release.
        :param _builtins.bool is_preview_db_version: True if this version of the Oracle Database software is the preview version.
        :param _builtins.bool is_upgrade_supported: If provided, filters the results to the set of database versions which are supported for Upgrade.
        :param _builtins.bool supports_pdb: True if this version of the Oracle Database software supports pluggable databases.
        :param _builtins.str version: A valid Oracle Database version.
        """
        pulumi.set(__self__, "is_latest_for_major_version", is_latest_for_major_version)
        pulumi.set(__self__, "is_preview_db_version", is_preview_db_version)
        pulumi.set(__self__, "is_upgrade_supported", is_upgrade_supported)
        pulumi.set(__self__, "supports_pdb", supports_pdb)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="isLatestForMajorVersion")
    def is_latest_for_major_version(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software is the latest version for a release.
        """
        return pulumi.get(self, "is_latest_for_major_version")

    @_builtins.property
    @pulumi.getter(name="isPreviewDbVersion")
    def is_preview_db_version(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software is the preview version.
        """
        return pulumi.get(self, "is_preview_db_version")

    @_builtins.property
    @pulumi.getter(name="isUpgradeSupported")
    def is_upgrade_supported(self) -> _builtins.bool:
        """
        If provided, filters the results to the set of database versions which are supported for Upgrade.
        """
        return pulumi.get(self, "is_upgrade_supported")

    @_builtins.property
    @pulumi.getter(name="supportsPdb")
    def supports_pdb(self) -> _builtins.bool:
        """
        True if this version of the Oracle Database software supports pluggable databases.
        """
        return pulumi.get(self, "supports_pdb")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A valid Oracle Database version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDbVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExadataInfrastructureContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 is_contact_mos_validated: _builtins.bool,
                 is_primary: _builtins.bool,
                 name: _builtins.str,
                 phone_number: _builtins.str):
        """
        :param _builtins.str email: The email for the Exadata Infrastructure contact.
        :param _builtins.bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param _builtins.bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param _builtins.str name: Name of the month of the year.
        :param _builtins.str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> _builtins.bool:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> _builtins.bool:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> _builtins.str:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetExadataInfrastructureDefinedFileSystemConfigurationResult(dict):
    def __init__(__self__, *,
                 is_backup_partition: _builtins.bool,
                 is_resizable: _builtins.bool,
                 min_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        pulumi.set(__self__, "is_resizable", is_resizable)
        pulumi.set(__self__, "min_size_gb", min_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> _builtins.bool:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> _builtins.bool:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> _builtins.int:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetExadataInfrastructureExascaleConfigResult(dict):
    def __init__(__self__, *,
                 available_storage_in_gbs: _builtins.int,
                 total_storage_in_gbs: _builtins.int):
        """
        :param _builtins.int available_storage_in_gbs: Available storage size for Exascale in GBs.
        :param _builtins.int total_storage_in_gbs: Storage size needed for Exascale in GBs.
        """
        pulumi.set(__self__, "available_storage_in_gbs", available_storage_in_gbs)
        pulumi.set(__self__, "total_storage_in_gbs", total_storage_in_gbs)

    @_builtins.property
    @pulumi.getter(name="availableStorageInGbs")
    def available_storage_in_gbs(self) -> _builtins.int:
        """
        Available storage size for Exascale in GBs.
        """
        return pulumi.get(self, "available_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="totalStorageInGbs")
    def total_storage_in_gbs(self) -> _builtins.int:
        """
        Storage size needed for Exascale in GBs.
        """
        return pulumi.get(self, "total_storage_in_gbs")


@pulumi.output_type
class GetExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructureNetworkBondingModeDetailResult(dict):
    def __init__(__self__, *,
                 backup_network_bonding_mode: _builtins.str,
                 client_network_bonding_mode: _builtins.str,
                 dr_network_bonding_mode: _builtins.str):
        """
        :param _builtins.str backup_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param _builtins.str client_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param _builtins.str dr_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        """
        pulumi.set(__self__, "backup_network_bonding_mode", backup_network_bonding_mode)
        pulumi.set(__self__, "client_network_bonding_mode", client_network_bonding_mode)
        pulumi.set(__self__, "dr_network_bonding_mode", dr_network_bonding_mode)

    @_builtins.property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> _builtins.str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> _builtins.str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> _builtins.str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class GetExadataInfrastructureUnAllocatedResourceAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 un_allocated_adb_storage_in_tbs: _builtins.float):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        :param _builtins.float un_allocated_adb_storage_in_tbs: Total unallocated autonomous data storage in the AVM in TBs.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "un_allocated_adb_storage_in_tbs", un_allocated_adb_storage_in_tbs)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="unAllocatedAdbStorageInTbs")
    def un_allocated_adb_storage_in_tbs(self) -> _builtins.float:
        """
        Total unallocated autonomous data storage in the AVM in TBs.
        """
        return pulumi.get(self, "un_allocated_adb_storage_in_tbs")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureResult(dict):
    def __init__(__self__, *,
                 activated_storage_count: _builtins.int,
                 activation_file: _builtins.str,
                 additional_compute_count: _builtins.int,
                 additional_compute_system_model: _builtins.str,
                 additional_storage_count: _builtins.int,
                 admin_network_cidr: _builtins.str,
                 availability_domain: _builtins.str,
                 cloud_control_plane_server1: _builtins.str,
                 cloud_control_plane_server2: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_count: _builtins.int,
                 compute_model: _builtins.str,
                 contacts: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureContactResult'],
                 corporate_proxy: _builtins.str,
                 cpus_enabled: _builtins.int,
                 create_async: _builtins.bool,
                 csi_number: _builtins.str,
                 data_storage_size_in_tbs: _builtins.float,
                 database_server_type: _builtins.str,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_server_version: _builtins.str,
                 defined_file_system_configurations: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureDefinedFileSystemConfigurationResult'],
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 dns_servers: Sequence[_builtins.str],
                 exascale_configs: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureExascaleConfigResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 gateway: _builtins.str,
                 id: _builtins.str,
                 infini_band_network_cidr: _builtins.str,
                 is_cps_offline_report_enabled: _builtins.bool,
                 is_multi_rack_deployment: _builtins.bool,
                 is_scheduling_policy_associated: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 maintenance_slo_status: _builtins.str,
                 maintenance_windows: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult'],
                 max_cpu_count: _builtins.int,
                 max_data_storage_in_tbs: _builtins.float,
                 max_db_node_storage_in_gbs: _builtins.int,
                 max_memory_in_gbs: _builtins.int,
                 memory_size_in_gbs: _builtins.int,
                 monthly_db_server_version: _builtins.str,
                 multi_rack_configuration_file: _builtins.str,
                 netmask: _builtins.str,
                 network_bonding_mode_details: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult'],
                 ntp_servers: Sequence[_builtins.str],
                 rack_serial_number: _builtins.str,
                 shape: _builtins.str,
                 state: _builtins.str,
                 storage_count: _builtins.int,
                 storage_server_type: _builtins.str,
                 storage_server_version: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_zone: _builtins.str):
        """
        :param _builtins.int activated_storage_count: The requested number of additional storage servers activated for the Exadata infrastructure.
        :param _builtins.int additional_compute_count: The requested number of additional compute servers for the Exadata infrastructure.
        :param _builtins.str additional_compute_system_model: Oracle Exadata System Model specification. The system model determines the amount of compute or storage server resources available for use. For more information, please see [System and Shape Configuration Options] (https://docs.oracle.com/en/engineered-systems/exadata-cloud-at-customer/ecccm/ecc-system-config-options.html#GUID-9E090174-5C57-4EB1-9243-B470F9F10D6B)
        :param _builtins.int additional_storage_count: The requested number of additional storage servers for the Exadata infrastructure.
        :param _builtins.str admin_network_cidr: The CIDR block for the Exadata administration network.
        :param _builtins.str availability_domain: The name of the availability domain that the Exadata infrastructure is located in.
        :param _builtins.str cloud_control_plane_server1: The IP address for the first control plane server.
        :param _builtins.str cloud_control_plane_server2: The IP address for the second control plane server.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int compute_count: The number of compute servers for the Exadata infrastructure.
        :param _builtins.str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureContactArgs'] contacts: The list of contacts for the Exadata infrastructure.
        :param _builtins.str corporate_proxy: The corporate network proxy for access to the control plane network.
        :param _builtins.int cpus_enabled: The number of enabled CPU cores.
        :param _builtins.str csi_number: The CSI Number of the Exadata infrastructure.
        :param _builtins.float data_storage_size_in_tbs: Size, in terabytes, of the DATA disk group.
        :param _builtins.str database_server_type: The database server type of the Exadata infrastructure.
        :param _builtins.int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param _builtins.str db_server_version: The software version of the database servers (dom0) in the Exadata infrastructure.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureDefinedFileSystemConfigurationArgs'] defined_file_system_configurations: Details of the file system configuration of the Exadata infrastructure.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Sequence[_builtins.str] dns_servers: The list of DNS server IP addresses. Maximum of 3 allowed.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureExascaleConfigArgs'] exascale_configs: The exascale config response details for the Exadata Cloud@Customer infrastructure or cloud Exadata infrastructure . Applies to both Exadata Cloud@Customer instances and Exadata Cloud Service instances.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str gateway: The gateway for the control plane network.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        :param _builtins.str infini_band_network_cidr: The CIDR block for the Exadata InfiniBand interconnect.
        :param _builtins.bool is_cps_offline_report_enabled: Indicates whether cps offline diagnostic report is enabled for this Exadata infrastructure. This will allow a customer to quickly check status themselves and fix problems on their end, saving time and frustration for both Oracle and the customer when they find the CPS in a disconnected state.You can enable offline diagnostic report during Exadata infrastructure provisioning. You can also disable or enable it at any time using the UpdateExadatainfrastructure API.
        :param _builtins.bool is_multi_rack_deployment: Indicates if deployment is Multi-Rack or not.
        :param _builtins.bool is_scheduling_policy_associated: If true, the infrastructure is using granular maintenance scheduling preference.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_slo_status: A field to capture Maintenance SLO Status for the Exadata infrastructure with values OK, DEGRADED. Default is OK when the infrastructure is provisioned.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param _builtins.int max_cpu_count: The total number of CPU cores available.
        :param _builtins.float max_data_storage_in_tbs: The total available DATA disk group size.
        :param _builtins.int max_db_node_storage_in_gbs: The total local node storage available in GBs.
        :param _builtins.int max_memory_in_gbs: The total memory available in GBs.
        :param _builtins.int memory_size_in_gbs: The memory allocated in GBs.
        :param _builtins.str monthly_db_server_version: The monthly software version of the database servers (dom0) in the Exadata infrastructure.
        :param _builtins.str multi_rack_configuration_file: The base64 encoded Multi-Rack configuration json file.
        :param _builtins.str netmask: The netmask for the control plane network.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailArgs'] network_bonding_mode_details: Details of bonding mode for Client and Backup and DR networks of an Exadata infrastructure.
        :param Sequence[_builtins.str] ntp_servers: The list of NTP server IP addresses. Maximum of 3 allowed.
        :param _builtins.str rack_serial_number: The serial number for the Exadata infrastructure.
        :param _builtins.str shape: The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.int storage_count: The number of Exadata storage servers for the Exadata infrastructure.
        :param _builtins.str storage_server_type: The storage server type of the Exadata infrastructure.
        :param _builtins.str storage_server_version: The software version of the storage servers (cells) in the Exadata infrastructure.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Exadata infrastructure was created.
        :param _builtins.str time_zone: The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        pulumi.set(__self__, "activated_storage_count", activated_storage_count)
        pulumi.set(__self__, "activation_file", activation_file)
        pulumi.set(__self__, "additional_compute_count", additional_compute_count)
        pulumi.set(__self__, "additional_compute_system_model", additional_compute_system_model)
        pulumi.set(__self__, "additional_storage_count", additional_storage_count)
        pulumi.set(__self__, "admin_network_cidr", admin_network_cidr)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "cloud_control_plane_server1", cloud_control_plane_server1)
        pulumi.set(__self__, "cloud_control_plane_server2", cloud_control_plane_server2)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_count", compute_count)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "contacts", contacts)
        pulumi.set(__self__, "corporate_proxy", corporate_proxy)
        pulumi.set(__self__, "cpus_enabled", cpus_enabled)
        pulumi.set(__self__, "create_async", create_async)
        pulumi.set(__self__, "csi_number", csi_number)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "database_server_type", database_server_type)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_server_version", db_server_version)
        pulumi.set(__self__, "defined_file_system_configurations", defined_file_system_configurations)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "exascale_configs", exascale_configs)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infini_band_network_cidr", infini_band_network_cidr)
        pulumi.set(__self__, "is_cps_offline_report_enabled", is_cps_offline_report_enabled)
        pulumi.set(__self__, "is_multi_rack_deployment", is_multi_rack_deployment)
        pulumi.set(__self__, "is_scheduling_policy_associated", is_scheduling_policy_associated)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_slo_status", maintenance_slo_status)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "max_cpu_count", max_cpu_count)
        pulumi.set(__self__, "max_data_storage_in_tbs", max_data_storage_in_tbs)
        pulumi.set(__self__, "max_db_node_storage_in_gbs", max_db_node_storage_in_gbs)
        pulumi.set(__self__, "max_memory_in_gbs", max_memory_in_gbs)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "monthly_db_server_version", monthly_db_server_version)
        pulumi.set(__self__, "multi_rack_configuration_file", multi_rack_configuration_file)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_bonding_mode_details", network_bonding_mode_details)
        pulumi.set(__self__, "ntp_servers", ntp_servers)
        pulumi.set(__self__, "rack_serial_number", rack_serial_number)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_count", storage_count)
        pulumi.set(__self__, "storage_server_type", storage_server_type)
        pulumi.set(__self__, "storage_server_version", storage_server_version)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="activatedStorageCount")
    def activated_storage_count(self) -> _builtins.int:
        """
        The requested number of additional storage servers activated for the Exadata infrastructure.
        """
        return pulumi.get(self, "activated_storage_count")

    @_builtins.property
    @pulumi.getter(name="activationFile")
    def activation_file(self) -> _builtins.str:
        return pulumi.get(self, "activation_file")

    @_builtins.property
    @pulumi.getter(name="additionalComputeCount")
    def additional_compute_count(self) -> _builtins.int:
        """
        The requested number of additional compute servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "additional_compute_count")

    @_builtins.property
    @pulumi.getter(name="additionalComputeSystemModel")
    def additional_compute_system_model(self) -> _builtins.str:
        """
        Oracle Exadata System Model specification. The system model determines the amount of compute or storage server resources available for use. For more information, please see [System and Shape Configuration Options] (https://docs.oracle.com/en/engineered-systems/exadata-cloud-at-customer/ecccm/ecc-system-config-options.html#GUID-9E090174-5C57-4EB1-9243-B470F9F10D6B)
        """
        return pulumi.get(self, "additional_compute_system_model")

    @_builtins.property
    @pulumi.getter(name="additionalStorageCount")
    def additional_storage_count(self) -> _builtins.int:
        """
        The requested number of additional storage servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "additional_storage_count")

    @_builtins.property
    @pulumi.getter(name="adminNetworkCidr")
    def admin_network_cidr(self) -> _builtins.str:
        """
        The CIDR block for the Exadata administration network.
        """
        return pulumi.get(self, "admin_network_cidr")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain that the Exadata infrastructure is located in.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="cloudControlPlaneServer1")
    def cloud_control_plane_server1(self) -> _builtins.str:
        """
        The IP address for the first control plane server.
        """
        return pulumi.get(self, "cloud_control_plane_server1")

    @_builtins.property
    @pulumi.getter(name="cloudControlPlaneServer2")
    def cloud_control_plane_server2(self) -> _builtins.str:
        """
        The IP address for the second control plane server.
        """
        return pulumi.get(self, "cloud_control_plane_server2")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> _builtins.int:
        """
        The number of compute servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "compute_count")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter
    def contacts(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureContactResult']:
        """
        The list of contacts for the Exadata infrastructure.
        """
        return pulumi.get(self, "contacts")

    @_builtins.property
    @pulumi.getter(name="corporateProxy")
    def corporate_proxy(self) -> _builtins.str:
        """
        The corporate network proxy for access to the control plane network.
        """
        return pulumi.get(self, "corporate_proxy")

    @_builtins.property
    @pulumi.getter(name="cpusEnabled")
    def cpus_enabled(self) -> _builtins.int:
        """
        The number of enabled CPU cores.
        """
        return pulumi.get(self, "cpus_enabled")

    @_builtins.property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> _builtins.bool:
        return pulumi.get(self, "create_async")

    @_builtins.property
    @pulumi.getter(name="csiNumber")
    def csi_number(self) -> _builtins.str:
        """
        The CSI Number of the Exadata infrastructure.
        """
        return pulumi.get(self, "csi_number")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.float:
        """
        Size, in terabytes, of the DATA disk group.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="databaseServerType")
    def database_server_type(self) -> _builtins.str:
        """
        The database server type of the Exadata infrastructure.
        """
        return pulumi.get(self, "database_server_type")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServerVersion")
    def db_server_version(self) -> _builtins.str:
        """
        The software version of the database servers (dom0) in the Exadata infrastructure.
        """
        return pulumi.get(self, "db_server_version")

    @_builtins.property
    @pulumi.getter(name="definedFileSystemConfigurations")
    def defined_file_system_configurations(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureDefinedFileSystemConfigurationResult']:
        """
        Details of the file system configuration of the Exadata infrastructure.
        """
        return pulumi.get(self, "defined_file_system_configurations")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[_builtins.str]:
        """
        The list of DNS server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "dns_servers")

    @_builtins.property
    @pulumi.getter(name="exascaleConfigs")
    def exascale_configs(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureExascaleConfigResult']:
        """
        The exascale config response details for the Exadata Cloud@Customer infrastructure or cloud Exadata infrastructure . Applies to both Exadata Cloud@Customer instances and Exadata Cloud Service instances.
        """
        return pulumi.get(self, "exascale_configs")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The gateway for the control plane network.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="infiniBandNetworkCidr")
    def infini_band_network_cidr(self) -> _builtins.str:
        """
        The CIDR block for the Exadata InfiniBand interconnect.
        """
        return pulumi.get(self, "infini_band_network_cidr")

    @_builtins.property
    @pulumi.getter(name="isCpsOfflineReportEnabled")
    def is_cps_offline_report_enabled(self) -> _builtins.bool:
        """
        Indicates whether cps offline diagnostic report is enabled for this Exadata infrastructure. This will allow a customer to quickly check status themselves and fix problems on their end, saving time and frustration for both Oracle and the customer when they find the CPS in a disconnected state.You can enable offline diagnostic report during Exadata infrastructure provisioning. You can also disable or enable it at any time using the UpdateExadatainfrastructure API.
        """
        return pulumi.get(self, "is_cps_offline_report_enabled")

    @_builtins.property
    @pulumi.getter(name="isMultiRackDeployment")
    def is_multi_rack_deployment(self) -> _builtins.bool:
        """
        Indicates if deployment is Multi-Rack or not.
        """
        return pulumi.get(self, "is_multi_rack_deployment")

    @_builtins.property
    @pulumi.getter(name="isSchedulingPolicyAssociated")
    def is_scheduling_policy_associated(self) -> _builtins.bool:
        """
        If true, the infrastructure is using granular maintenance scheduling preference.
        """
        return pulumi.get(self, "is_scheduling_policy_associated")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceSloStatus")
    def maintenance_slo_status(self) -> _builtins.str:
        """
        A field to capture Maintenance SLO Status for the Exadata infrastructure with values OK, DEGRADED. Default is OK when the infrastructure is provisioned.
        """
        return pulumi.get(self, "maintenance_slo_status")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter(name="maxCpuCount")
    def max_cpu_count(self) -> _builtins.int:
        """
        The total number of CPU cores available.
        """
        return pulumi.get(self, "max_cpu_count")

    @_builtins.property
    @pulumi.getter(name="maxDataStorageInTbs")
    def max_data_storage_in_tbs(self) -> _builtins.float:
        """
        The total available DATA disk group size.
        """
        return pulumi.get(self, "max_data_storage_in_tbs")

    @_builtins.property
    @pulumi.getter(name="maxDbNodeStorageInGbs")
    def max_db_node_storage_in_gbs(self) -> _builtins.int:
        """
        The total local node storage available in GBs.
        """
        return pulumi.get(self, "max_db_node_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="maxMemoryInGbs")
    def max_memory_in_gbs(self) -> _builtins.int:
        """
        The total memory available in GBs.
        """
        return pulumi.get(self, "max_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="monthlyDbServerVersion")
    def monthly_db_server_version(self) -> _builtins.str:
        """
        The monthly software version of the database servers (dom0) in the Exadata infrastructure.
        """
        return pulumi.get(self, "monthly_db_server_version")

    @_builtins.property
    @pulumi.getter(name="multiRackConfigurationFile")
    def multi_rack_configuration_file(self) -> _builtins.str:
        """
        The base64 encoded Multi-Rack configuration json file.
        """
        return pulumi.get(self, "multi_rack_configuration_file")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        """
        The netmask for the control plane network.
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter(name="networkBondingModeDetails")
    def network_bonding_mode_details(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult']:
        """
        Details of bonding mode for Client and Backup and DR networks of an Exadata infrastructure.
        """
        return pulumi.get(self, "network_bonding_mode_details")

    @_builtins.property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Sequence[_builtins.str]:
        """
        The list of NTP server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "ntp_servers")

    @_builtins.property
    @pulumi.getter(name="rackSerialNumber")
    def rack_serial_number(self) -> _builtins.str:
        """
        The serial number for the Exadata infrastructure.
        """
        return pulumi.get(self, "rack_serial_number")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageCount")
    def storage_count(self) -> _builtins.int:
        """
        The number of Exadata storage servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "storage_count")

    @_builtins.property
    @pulumi.getter(name="storageServerType")
    def storage_server_type(self) -> _builtins.str:
        """
        The storage server type of the Exadata infrastructure.
        """
        return pulumi.get(self, "storage_server_type")

    @_builtins.property
    @pulumi.getter(name="storageServerVersion")
    def storage_server_version(self) -> _builtins.str:
        """
        The software version of the storage servers (cells) in the Exadata infrastructure.
        """
        return pulumi.get(self, "storage_server_version")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Exadata infrastructure was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 is_contact_mos_validated: _builtins.bool,
                 is_primary: _builtins.bool,
                 name: _builtins.str,
                 phone_number: _builtins.str):
        """
        :param _builtins.str email: The email for the Exadata Infrastructure contact.
        :param _builtins.bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param _builtins.bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param _builtins.str name: Name of the month of the year.
        :param _builtins.str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> _builtins.bool:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> _builtins.bool:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> _builtins.str:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureDefinedFileSystemConfigurationResult(dict):
    def __init__(__self__, *,
                 is_backup_partition: _builtins.bool,
                 is_resizable: _builtins.bool,
                 min_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.bool is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param _builtins.bool is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param _builtins.int min_size_gb: The minimum size of file system.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        pulumi.set(__self__, "is_resizable", is_resizable)
        pulumi.set(__self__, "min_size_gb", min_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> _builtins.bool:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @_builtins.property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> _builtins.bool:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @_builtins.property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> _builtins.int:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureExascaleConfigResult(dict):
    def __init__(__self__, *,
                 available_storage_in_gbs: _builtins.int,
                 total_storage_in_gbs: _builtins.int):
        """
        :param _builtins.int available_storage_in_gbs: Available storage size for Exascale in GBs.
        :param _builtins.int total_storage_in_gbs: Storage size needed for Exascale in GBs.
        """
        pulumi.set(__self__, "available_storage_in_gbs", available_storage_in_gbs)
        pulumi.set(__self__, "total_storage_in_gbs", total_storage_in_gbs)

    @_builtins.property
    @pulumi.getter(name="availableStorageInGbs")
    def available_storage_in_gbs(self) -> _builtins.int:
        """
        Available storage size for Exascale in GBs.
        """
        return pulumi.get(self, "available_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="totalStorageInGbs")
    def total_storage_in_gbs(self) -> _builtins.int:
        """
        Storage size needed for Exascale in GBs.
        """
        return pulumi.get(self, "total_storage_in_gbs")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: _builtins.int,
                 days_of_weeks: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[_builtins.int],
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_monthly_patching_enabled: _builtins.bool,
                 lead_time_in_weeks: _builtins.int,
                 months: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: _builtins.str,
                 preference: _builtins.str,
                 skip_rus: Sequence[_builtins.bool],
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[_builtins.int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param _builtins.bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param _builtins.int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str preference: The maintenance window scheduling preference.
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours_of_days", hours_of_days)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "skip_rus", skip_rus)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[_builtins.int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> _builtins.bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> _builtins.int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Sequence[_builtins.bool]:
        return pulumi.get(self, "skip_rus")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult(dict):
    def __init__(__self__, *,
                 backup_network_bonding_mode: _builtins.str,
                 client_network_bonding_mode: _builtins.str,
                 dr_network_bonding_mode: _builtins.str):
        """
        :param _builtins.str backup_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param _builtins.str client_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param _builtins.str dr_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        """
        pulumi.set(__self__, "backup_network_bonding_mode", backup_network_bonding_mode)
        pulumi.set(__self__, "client_network_bonding_mode", client_network_bonding_mode)
        pulumi.set(__self__, "dr_network_bonding_mode", dr_network_bonding_mode)

    @_builtins.property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> _builtins.str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> _builtins.str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @_builtins.property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> _builtins.str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class GetExadataInfrastructuresFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExadataIormConfigDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetExadbVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetExadbVmClusterIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetExadbVmClusterIormConfigCachDbPlanResult'],
                 lifecycle_details: _builtins.str,
                 objective: _builtins.str,
                 state: _builtins.str):
        """
        :param Sequence['GetExadbVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        pulumi.set(__self__, "db_plans", db_plans)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "objective", objective)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetExadbVmClusterIormConfigCachDbPlanResult']:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> _builtins.str:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetExadbVmClusterIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetExadbVmClusterNodeConfigResult(dict):
    def __init__(__self__, *,
                 enabled_ecpu_count_per_node: _builtins.int,
                 memory_size_in_gbs_per_node: _builtins.int,
                 snapshot_file_system_storage_size_gbs_per_node: _builtins.int,
                 total_ecpu_count_per_node: _builtins.int,
                 total_file_system_storage_size_gbs_per_node: _builtins.int,
                 vm_file_system_storage_size_gbs_per_node: _builtins.int):
        """
        :param _builtins.int enabled_ecpu_count_per_node: The number of ECPUs to enable for each node.
        :param _builtins.int memory_size_in_gbs_per_node: The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        :param _builtins.int snapshot_file_system_storage_size_gbs_per_node: The file system storage in GBs for snapshot for each node.
        :param _builtins.int total_ecpu_count_per_node: The number of Total ECPUs for each node.
        :param _builtins.int total_file_system_storage_size_gbs_per_node: Total file system storage in GBs for each node.
        :param _builtins.int vm_file_system_storage_size_gbs_per_node: The file system storage in GBs for each node.
        """
        pulumi.set(__self__, "enabled_ecpu_count_per_node", enabled_ecpu_count_per_node)
        pulumi.set(__self__, "memory_size_in_gbs_per_node", memory_size_in_gbs_per_node)
        pulumi.set(__self__, "snapshot_file_system_storage_size_gbs_per_node", snapshot_file_system_storage_size_gbs_per_node)
        pulumi.set(__self__, "total_ecpu_count_per_node", total_ecpu_count_per_node)
        pulumi.set(__self__, "total_file_system_storage_size_gbs_per_node", total_file_system_storage_size_gbs_per_node)
        pulumi.set(__self__, "vm_file_system_storage_size_gbs_per_node", vm_file_system_storage_size_gbs_per_node)

    @_builtins.property
    @pulumi.getter(name="enabledEcpuCountPerNode")
    def enabled_ecpu_count_per_node(self) -> _builtins.int:
        """
        The number of ECPUs to enable for each node.
        """
        return pulumi.get(self, "enabled_ecpu_count_per_node")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbsPerNode")
    def memory_size_in_gbs_per_node(self) -> _builtins.int:
        """
        The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        """
        return pulumi.get(self, "memory_size_in_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="snapshotFileSystemStorageSizeGbsPerNode")
    def snapshot_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        The file system storage in GBs for snapshot for each node.
        """
        return pulumi.get(self, "snapshot_file_system_storage_size_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="totalEcpuCountPerNode")
    def total_ecpu_count_per_node(self) -> _builtins.int:
        """
        The number of Total ECPUs for each node.
        """
        return pulumi.get(self, "total_ecpu_count_per_node")

    @_builtins.property
    @pulumi.getter(name="totalFileSystemStorageSizeGbsPerNode")
    def total_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        Total file system storage in GBs for each node.
        """
        return pulumi.get(self, "total_file_system_storage_size_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="vmFileSystemStorageSizeGbsPerNode")
    def vm_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        The file system storage in GBs for each node.
        """
        return pulumi.get(self, "vm_file_system_storage_size_gbs_per_node")


@pulumi.output_type
class GetExadbVmClusterNodeResourceResult(dict):
    def __init__(__self__, *,
                 node_hostname: _builtins.str,
                 node_id: _builtins.str,
                 node_name: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str node_hostname: The host name for the node.
        :param _builtins.str node_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        :param _builtins.str state: The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        pulumi.set(__self__, "node_hostname", node_hostname)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="nodeHostname")
    def node_hostname(self) -> _builtins.str:
        """
        The host name for the node.
        """
        return pulumi.get(self, "node_hostname")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetExadbVmClusterUpdateHistoryEntriesExadbVmClusterUpdateHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_completed: _builtins.str,
                 time_started: _builtins.str,
                 update_action: _builtins.str,
                 update_id: _builtins.str,
                 update_type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update history entry.
        :param _builtins.str lifecycle_details: Descriptive text providing additional details about the lifecycle state.
        :param _builtins.str state: The current lifecycle state of the maintenance update operation.
        :param _builtins.str time_completed: The date and time when the maintenance update action completed.
        :param _builtins.str time_started: The date and time when the maintenance update action started.
        :param _builtins.str update_action: The update action.
        :param _builtins.str update_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        :param _builtins.str update_type: A filter to return only resources that match the given update type exactly.
        :param _builtins.str version: The version of the maintenance update package.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_completed", time_completed)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "update_action", update_action)
        pulumi.set(__self__, "update_id", update_id)
        pulumi.set(__self__, "update_type", update_type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Descriptive text providing additional details about the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current lifecycle state of the maintenance update operation.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCompleted")
    def time_completed(self) -> _builtins.str:
        """
        The date and time when the maintenance update action completed.
        """
        return pulumi.get(self, "time_completed")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the maintenance update action started.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="updateAction")
    def update_action(self) -> _builtins.str:
        """
        The update action.
        """
        return pulumi.get(self, "update_action")

    @_builtins.property
    @pulumi.getter(name="updateId")
    def update_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        """
        return pulumi.get(self, "update_id")

    @_builtins.property
    @pulumi.getter(name="updateType")
    def update_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given update type exactly.
        """
        return pulumi.get(self, "update_type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the maintenance update package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetExadbVmClusterUpdateHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExadbVmClusterUpdatesExadbVmClusterUpdateResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[_builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 last_action: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_released: _builtins.str,
                 update_type: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence[_builtins.str] available_actions: The possible actions performed by the update operation on the infrastructure components.
        :param _builtins.str description: Details of the maintenance update package.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        :param _builtins.str last_action: The previous update action performed.
        :param _builtins.str lifecycle_details: Descriptive text providing additional details about the lifecycle state.
        :param _builtins.str state: The current state of the maintenance update. Dependent on value of `lastAction`.
        :param _builtins.str time_released: The date and time the maintenance update was released.
        :param _builtins.str update_type: A filter to return only resources that match the given update type exactly.
        :param _builtins.str version: A filter to return only resources that match the given update version exactly.
        """
        pulumi.set(__self__, "available_actions", available_actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_action", last_action)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "update_type", update_type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[_builtins.str]:
        """
        The possible actions performed by the update operation on the infrastructure components.
        """
        return pulumi.get(self, "available_actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Details of the maintenance update package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> _builtins.str:
        """
        The previous update action performed.
        """
        return pulumi.get(self, "last_action")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Descriptive text providing additional details about the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the maintenance update. Dependent on value of `lastAction`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The date and time the maintenance update was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter(name="updateType")
    def update_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given update type exactly.
        """
        return pulumi.get(self, "update_type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A filter to return only resources that match the given update version exactly.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetExadbVmClusterUpdatesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExadbVmClustersExadbVmClusterResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 backup_network_nsg_ids: Sequence[_builtins.str],
                 backup_subnet_id: _builtins.str,
                 cluster_name: _builtins.str,
                 cluster_placement_group_id: _builtins.str,
                 compartment_id: _builtins.str,
                 data_collection_options: Sequence['outputs.GetExadbVmClustersExadbVmClusterDataCollectionOptionResult'],
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 domain: _builtins.str,
                 exascale_db_storage_vault_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 gi_version: _builtins.str,
                 grid_image_id: _builtins.str,
                 grid_image_type: _builtins.str,
                 hostname: _builtins.str,
                 id: _builtins.str,
                 iorm_config_caches: Sequence['outputs.GetExadbVmClustersExadbVmClusterIormConfigCachResult'],
                 last_update_history_entry_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 listener_port: _builtins.str,
                 node_configs: Sequence['outputs.GetExadbVmClustersExadbVmClusterNodeConfigResult'],
                 node_resources: Sequence['outputs.GetExadbVmClustersExadbVmClusterNodeResourceResult'],
                 nsg_ids: Sequence[_builtins.str],
                 private_zone_id: _builtins.str,
                 scan_dns_name: _builtins.str,
                 scan_dns_record_id: _builtins.str,
                 scan_ip_ids: Sequence[_builtins.str],
                 scan_listener_port_tcp: _builtins.int,
                 scan_listener_port_tcp_ssl: _builtins.int,
                 security_attributes: Mapping[str, _builtins.str],
                 shape: _builtins.str,
                 ssh_public_keys: Sequence[_builtins.str],
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 subscription_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 system_version: _builtins.str,
                 time_created: _builtins.str,
                 time_zone: _builtins.str,
                 vip_ids: Sequence[_builtins.str],
                 zone_id: _builtins.str):
        """
        :param _builtins.str availability_domain: The name of the availability domain in which the Exadata VM cluster on Exascale Infrastructure is located.
        :param Sequence[_builtins.str] backup_network_nsg_ids: A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        :param _builtins.str backup_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet associated with the Exadata VM cluster on Exascale Infrastructure.
        :param _builtins.str cluster_name: The cluster name for Exadata VM cluster on Exascale Infrastructure. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        :param _builtins.str cluster_placement_group_id: A filter to return only resources that match the given cluster placement group ID exactly.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetExadbVmClustersExadbVmClusterDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str domain: A domain name used for the Exadata VM cluster on Exascale Infrastructure. If the Oracle-provided internet and VCN resolver is enabled for the specified subnet, then the domain name for the subnet is used (do not provide one). Otherwise, provide a valid DNS domain name. Hyphens (-) are not permitted.  Applies to Exadata Database Service on Exascale Infrastructure only.
        :param _builtins.str exascale_db_storage_vault_id: A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given Exascale Database Storage Vault ID.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param _builtins.str grid_image_id: Grid Setup will be done using this grid image id.
        :param _builtins.str grid_image_type: The type of Grid Image
        :param _builtins.str hostname: The hostname for the Exadata VM cluster on Exascale Infrastructure. The hostname must begin with an alphabetic character, and  can contain alphanumeric characters and hyphens (-). For Exadata systems, the maximum length of the hostname is 12 characters.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata VM cluster on Exascale Infrastructure.
        :param Sequence['GetExadbVmClustersExadbVmClusterIormConfigCachArgs'] iorm_config_caches: The IORM settings of the Exadata DB system.
        :param _builtins.str last_update_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history entry. This value is updated when a maintenance update starts.
        :param _builtins.str license_model: The Oracle license model that applies to the Exadata VM cluster on Exascale Infrastructure. The default is BRING_YOUR_OWN_LICENSE.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str listener_port: The port number configured for the listener on the Exadata VM cluster on Exascale Infrastructure.
        :param Sequence['GetExadbVmClustersExadbVmClusterNodeConfigArgs'] node_configs: The configuration of each node in the Exadata VM cluster on Exascale Infrastructure.
        :param Sequence['GetExadbVmClustersExadbVmClusterNodeResourceArgs'] node_resources: The list of node in the Exadata VM cluster on Exascale Infrastructure.
        :param Sequence[_builtins.str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param _builtins.str private_zone_id: The private zone ID in which you want DNS records to be created.
        :param _builtins.str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the Exadata VM cluster on Exascale Infrastructure.
        :param _builtins.str scan_dns_record_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the Exadata VM cluster on Exascale Infrastructure.
        :param Sequence[_builtins.str] scan_ip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IP addresses associated with the Exadata VM cluster on Exascale Infrastructure. SCAN IP addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param _builtins.int scan_listener_port_tcp: The TCP Single Client Access Name (SCAN) port. The default port is 1521.
        :param _builtins.int scan_listener_port_tcp_ssl: The Secured Communication (TCPS) protocol Single Client Access Name (SCAN) port. The default port is 2484.
        :param Mapping[str, _builtins.str] security_attributes: Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        :param _builtins.str shape: The shape of the Exadata VM cluster on Exascale Infrastructure resource
        :param Sequence[_builtins.str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the Exadata VM cluster on Exascale Infrastructure.
        :param _builtins.str state: A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given lifecycle state exactly.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the Exadata VM cluster on Exascale Infrastructure.
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str system_version: Operating system version of the image.
        :param _builtins.str time_created: The date and time that the Exadata VM cluster on Exascale Infrastructure was created.
        :param _builtins.str time_zone: The time zone to use for the Exadata VM cluster on Exascale Infrastructure. For details, see [Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param Sequence[_builtins.str] vip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) addresses associated with the Exadata VM cluster on Exascale Infrastructure.  The Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the Exadata Cloud Service instance to  enable failover. If one node fails, then the VIP is reassigned to another active node in the cluster.
        :param _builtins.str zone_id: The OCID of the zone with which the Exadata VM cluster on Exascale Infrastructure is associated.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_network_nsg_ids", backup_network_nsg_ids)
        pulumi.set(__self__, "backup_subnet_id", backup_subnet_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_placement_group_id", cluster_placement_group_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "data_collection_options", data_collection_options)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "exascale_db_storage_vault_id", exascale_db_storage_vault_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "gi_version", gi_version)
        pulumi.set(__self__, "grid_image_id", grid_image_id)
        pulumi.set(__self__, "grid_image_type", grid_image_type)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "iorm_config_caches", iorm_config_caches)
        pulumi.set(__self__, "last_update_history_entry_id", last_update_history_entry_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "listener_port", listener_port)
        pulumi.set(__self__, "node_configs", node_configs)
        pulumi.set(__self__, "node_resources", node_resources)
        pulumi.set(__self__, "nsg_ids", nsg_ids)
        pulumi.set(__self__, "private_zone_id", private_zone_id)
        pulumi.set(__self__, "scan_dns_name", scan_dns_name)
        pulumi.set(__self__, "scan_dns_record_id", scan_dns_record_id)
        pulumi.set(__self__, "scan_ip_ids", scan_ip_ids)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)
        pulumi.set(__self__, "security_attributes", security_attributes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "system_version", system_version)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "vip_ids", vip_ids)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain in which the Exadata VM cluster on Exascale Infrastructure is located.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[_builtins.str]:
        """
        A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        """
        return pulumi.get(self, "backup_network_nsg_ids")

    @_builtins.property
    @pulumi.getter(name="backupSubnetId")
    def backup_subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet associated with the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "backup_subnet_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The cluster name for Exadata VM cluster on Exascale Infrastructure. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterPlacementGroupId")
    def cluster_placement_group_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given cluster placement group ID exactly.
        """
        return pulumi.get(self, "cluster_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetExadbVmClustersExadbVmClusterDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        A domain name used for the Exadata VM cluster on Exascale Infrastructure. If the Oracle-provided internet and VCN resolver is enabled for the specified subnet, then the domain name for the subnet is used (do not provide one). Otherwise, provide a valid DNS domain name. Hyphens (-) are not permitted.  Applies to Exadata Database Service on Exascale Infrastructure only.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="exascaleDbStorageVaultId")
    def exascale_db_storage_vault_id(self) -> _builtins.str:
        """
        A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given Exascale Database Storage Vault ID.
        """
        return pulumi.get(self, "exascale_db_storage_vault_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="giVersion")
    def gi_version(self) -> _builtins.str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "gi_version")

    @_builtins.property
    @pulumi.getter(name="gridImageId")
    def grid_image_id(self) -> _builtins.str:
        """
        Grid Setup will be done using this grid image id.
        """
        return pulumi.get(self, "grid_image_id")

    @_builtins.property
    @pulumi.getter(name="gridImageType")
    def grid_image_type(self) -> _builtins.str:
        """
        The type of Grid Image
        """
        return pulumi.get(self, "grid_image_type")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname for the Exadata VM cluster on Exascale Infrastructure. The hostname must begin with an alphabetic character, and  can contain alphanumeric characters and hyphens (-). For Exadata systems, the maximum length of the hostname is 12 characters.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="iormConfigCaches")
    def iorm_config_caches(self) -> Sequence['outputs.GetExadbVmClustersExadbVmClusterIormConfigCachResult']:
        """
        The IORM settings of the Exadata DB system.
        """
        return pulumi.get(self, "iorm_config_caches")

    @_builtins.property
    @pulumi.getter(name="lastUpdateHistoryEntryId")
    def last_update_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history entry. This value is updated when a maintenance update starts.
        """
        return pulumi.get(self, "last_update_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the Exadata VM cluster on Exascale Infrastructure. The default is BRING_YOUR_OWN_LICENSE.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> _builtins.str:
        """
        The port number configured for the listener on the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "listener_port")

    @_builtins.property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Sequence['outputs.GetExadbVmClustersExadbVmClusterNodeConfigResult']:
        """
        The configuration of each node in the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "node_configs")

    @_builtins.property
    @pulumi.getter(name="nodeResources")
    def node_resources(self) -> Sequence['outputs.GetExadbVmClustersExadbVmClusterNodeResourceResult']:
        """
        The list of node in the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "node_resources")

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[_builtins.str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @_builtins.property
    @pulumi.getter(name="privateZoneId")
    def private_zone_id(self) -> _builtins.str:
        """
        The private zone ID in which you want DNS records to be created.
        """
        return pulumi.get(self, "private_zone_id")

    @_builtins.property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> _builtins.str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "scan_dns_name")

    @_builtins.property
    @pulumi.getter(name="scanDnsRecordId")
    def scan_dns_record_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "scan_dns_record_id")

    @_builtins.property
    @pulumi.getter(name="scanIpIds")
    def scan_ip_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IP addresses associated with the Exadata VM cluster on Exascale Infrastructure. SCAN IP addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ip_ids")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The TCP Single Client Access Name (SCAN) port. The default port is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> _builtins.int:
        """
        The Secured Communication (TCPS) protocol Single Client Access Name (SCAN) port. The default port is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")

    @_builtins.property
    @pulumi.getter(name="securityAttributes")
    def security_attributes(self) -> Mapping[str, _builtins.str]:
        """
        Security Attributes for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Oracle-ZPR": {"MaxEgressCount": {"value": "42", "mode": "audit"}}}`
        """
        return pulumi.get(self, "security_attributes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the Exadata VM cluster on Exascale Infrastructure resource
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[_builtins.str]:
        """
        The public key portion of one or more key pairs used for SSH access to the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="systemVersion")
    def system_version(self) -> _builtins.str:
        """
        Operating system version of the image.
        """
        return pulumi.get(self, "system_version")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the Exadata VM cluster on Exascale Infrastructure was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone to use for the Exadata VM cluster on Exascale Infrastructure. For details, see [Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="vipIds")
    def vip_ids(self) -> Sequence[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) addresses associated with the Exadata VM cluster on Exascale Infrastructure.  The Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the Exadata Cloud Service instance to  enable failover. If one node fails, then the VIP is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vip_ids")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The OCID of the zone with which the Exadata VM cluster on Exascale Infrastructure is associated.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetExadbVmClustersExadbVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetExadbVmClustersExadbVmClusterIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetExadbVmClustersExadbVmClusterIormConfigCachDbPlanResult'],
                 lifecycle_details: _builtins.str,
                 objective: _builtins.str,
                 state: _builtins.str):
        """
        :param Sequence['GetExadbVmClustersExadbVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str objective: The current value for the IORM objective. The default is `AUTO`.
        :param _builtins.str state: A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given lifecycle state exactly.
        """
        pulumi.set(__self__, "db_plans", db_plans)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "objective", objective)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetExadbVmClustersExadbVmClusterIormConfigCachDbPlanResult']:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def objective(self) -> _builtins.str:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetExadbVmClustersExadbVmClusterIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 flash_cache_limit: _builtins.str,
                 share: _builtins.int):
        """
        :param _builtins.str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param _builtins.str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param _builtins.int share: The relative priority of this database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> _builtins.str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @_builtins.property
    @pulumi.getter
    def share(self) -> _builtins.int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetExadbVmClustersExadbVmClusterNodeConfigResult(dict):
    def __init__(__self__, *,
                 enabled_ecpu_count_per_node: _builtins.int,
                 memory_size_in_gbs_per_node: _builtins.int,
                 snapshot_file_system_storage_size_gbs_per_node: _builtins.int,
                 total_ecpu_count_per_node: _builtins.int,
                 total_file_system_storage_size_gbs_per_node: _builtins.int,
                 vm_file_system_storage_size_gbs_per_node: _builtins.int):
        """
        :param _builtins.int memory_size_in_gbs_per_node: The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        :param _builtins.int snapshot_file_system_storage_size_gbs_per_node: The file system storage in GBs for snapshot for each node.
        :param _builtins.int total_file_system_storage_size_gbs_per_node: Total file system storage in GBs for each node.
        :param _builtins.int vm_file_system_storage_size_gbs_per_node: The file system storage in GBs for each node.
        """
        pulumi.set(__self__, "enabled_ecpu_count_per_node", enabled_ecpu_count_per_node)
        pulumi.set(__self__, "memory_size_in_gbs_per_node", memory_size_in_gbs_per_node)
        pulumi.set(__self__, "snapshot_file_system_storage_size_gbs_per_node", snapshot_file_system_storage_size_gbs_per_node)
        pulumi.set(__self__, "total_ecpu_count_per_node", total_ecpu_count_per_node)
        pulumi.set(__self__, "total_file_system_storage_size_gbs_per_node", total_file_system_storage_size_gbs_per_node)
        pulumi.set(__self__, "vm_file_system_storage_size_gbs_per_node", vm_file_system_storage_size_gbs_per_node)

    @_builtins.property
    @pulumi.getter(name="enabledEcpuCountPerNode")
    def enabled_ecpu_count_per_node(self) -> _builtins.int:
        return pulumi.get(self, "enabled_ecpu_count_per_node")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbsPerNode")
    def memory_size_in_gbs_per_node(self) -> _builtins.int:
        """
        The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        """
        return pulumi.get(self, "memory_size_in_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="snapshotFileSystemStorageSizeGbsPerNode")
    def snapshot_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        The file system storage in GBs for snapshot for each node.
        """
        return pulumi.get(self, "snapshot_file_system_storage_size_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="totalEcpuCountPerNode")
    def total_ecpu_count_per_node(self) -> _builtins.int:
        return pulumi.get(self, "total_ecpu_count_per_node")

    @_builtins.property
    @pulumi.getter(name="totalFileSystemStorageSizeGbsPerNode")
    def total_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        Total file system storage in GBs for each node.
        """
        return pulumi.get(self, "total_file_system_storage_size_gbs_per_node")

    @_builtins.property
    @pulumi.getter(name="vmFileSystemStorageSizeGbsPerNode")
    def vm_file_system_storage_size_gbs_per_node(self) -> _builtins.int:
        """
        The file system storage in GBs for each node.
        """
        return pulumi.get(self, "vm_file_system_storage_size_gbs_per_node")


@pulumi.output_type
class GetExadbVmClustersExadbVmClusterNodeResourceResult(dict):
    def __init__(__self__, *,
                 node_hostname: _builtins.str,
                 node_id: _builtins.str,
                 node_name: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str node_hostname: The host name for the node.
        :param _builtins.str node_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        :param _builtins.str state: A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given lifecycle state exactly.
        """
        pulumi.set(__self__, "node_hostname", node_hostname)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="nodeHostname")
    def node_hostname(self) -> _builtins.str:
        """
        The host name for the node.
        """
        return pulumi.get(self, "node_hostname")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only Exadata VM clusters on Exascale Infrastructure that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetExadbVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExascaleDbStorageVaultHighCapacityDatabaseStorageResult(dict):
    def __init__(__self__, *,
                 available_size_in_gbs: _builtins.int,
                 total_size_in_gbs: _builtins.int):
        """
        :param _builtins.int available_size_in_gbs: Available Capacity
        :param _builtins.int total_size_in_gbs: Total Capacity
        """
        pulumi.set(__self__, "available_size_in_gbs", available_size_in_gbs)
        pulumi.set(__self__, "total_size_in_gbs", total_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="availableSizeInGbs")
    def available_size_in_gbs(self) -> _builtins.int:
        """
        Available Capacity
        """
        return pulumi.get(self, "available_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="totalSizeInGbs")
    def total_size_in_gbs(self) -> _builtins.int:
        """
        Total Capacity
        """
        return pulumi.get(self, "total_size_in_gbs")


@pulumi.output_type
class GetExascaleDbStorageVaultsExascaleDbStorageVaultResult(dict):
    def __init__(__self__, *,
                 additional_flash_cache_in_percent: _builtins.int,
                 availability_domain: _builtins.str,
                 cluster_placement_group_id: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 exadata_infrastructure_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 high_capacity_database_storages: Sequence['outputs.GetExascaleDbStorageVaultsExascaleDbStorageVaultHighCapacityDatabaseStorageResult'],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 subscription_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_zone: _builtins.str,
                 vm_cluster_count: _builtins.int,
                 vm_cluster_ids: Sequence[_builtins.str]):
        """
        :param _builtins.int additional_flash_cache_in_percent: The size of additional Flash Cache in percentage of High Capacity database storage.
        :param _builtins.str availability_domain: The name of the availability domain in which the Exadata Database Storage Vault is located.
        :param _builtins.str cluster_placement_group_id: A filter to return only resources that match the given cluster placement group ID exactly.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Exadata Database Storage Vault description.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str exadata_infrastructure_id: A filter to return only list of Vaults that are linked to the exadata infrastructure Id.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param Sequence['GetExascaleDbStorageVaultsExascaleDbStorageVaultHighCapacityDatabaseStorageArgs'] high_capacity_database_storages: Exadata Database Storage Details
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata Database Storage Vault.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only Exadata Database Storage Vaults that match the given lifecycle state exactly.
        :param _builtins.str subscription_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the Exadata Database Storage Vault was created.
        :param _builtins.str time_zone: The time zone that you want to use for the Exadata Database Storage Vault. For details, see [Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param _builtins.int vm_cluster_count: The number of Exadata VM clusters used the Exadata Database Storage Vault.
        :param Sequence[_builtins.str] vm_cluster_ids: The List of Exadata VM cluster on Exascale Infrastructure [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) **Note:** If Exadata Database Storage Vault is not used for any Exadata VM cluster on Exascale Infrastructure, this list is empty.
        """
        pulumi.set(__self__, "additional_flash_cache_in_percent", additional_flash_cache_in_percent)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "cluster_placement_group_id", cluster_placement_group_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "exadata_infrastructure_id", exadata_infrastructure_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "high_capacity_database_storages", high_capacity_database_storages)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "vm_cluster_count", vm_cluster_count)
        pulumi.set(__self__, "vm_cluster_ids", vm_cluster_ids)

    @_builtins.property
    @pulumi.getter(name="additionalFlashCacheInPercent")
    def additional_flash_cache_in_percent(self) -> _builtins.int:
        """
        The size of additional Flash Cache in percentage of High Capacity database storage.
        """
        return pulumi.get(self, "additional_flash_cache_in_percent")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain in which the Exadata Database Storage Vault is located.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="clusterPlacementGroupId")
    def cluster_placement_group_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given cluster placement group ID exactly.
        """
        return pulumi.get(self, "cluster_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Exadata Database Storage Vault description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> _builtins.str:
        """
        A filter to return only list of Vaults that are linked to the exadata infrastructure Id.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="highCapacityDatabaseStorages")
    def high_capacity_database_storages(self) -> Sequence['outputs.GetExascaleDbStorageVaultsExascaleDbStorageVaultHighCapacityDatabaseStorageResult']:
        """
        Exadata Database Storage Details
        """
        return pulumi.get(self, "high_capacity_database_storages")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata Database Storage Vault.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only Exadata Database Storage Vaults that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subscription with which resource needs to be associated with.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the Exadata Database Storage Vault was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone that you want to use for the Exadata Database Storage Vault. For details, see [Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="vmClusterCount")
    def vm_cluster_count(self) -> _builtins.int:
        """
        The number of Exadata VM clusters used the Exadata Database Storage Vault.
        """
        return pulumi.get(self, "vm_cluster_count")

    @_builtins.property
    @pulumi.getter(name="vmClusterIds")
    def vm_cluster_ids(self) -> Sequence[_builtins.str]:
        """
        The List of Exadata VM cluster on Exascale Infrastructure [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) **Note:** If Exadata Database Storage Vault is not used for any Exadata VM cluster on Exascale Infrastructure, this list is empty.
        """
        return pulumi.get(self, "vm_cluster_ids")


@pulumi.output_type
class GetExascaleDbStorageVaultsExascaleDbStorageVaultHighCapacityDatabaseStorageResult(dict):
    def __init__(__self__, *,
                 available_size_in_gbs: _builtins.int,
                 total_size_in_gbs: _builtins.int):
        """
        :param _builtins.int available_size_in_gbs: Available Capacity
        :param _builtins.int total_size_in_gbs: Total Capacity
        """
        pulumi.set(__self__, "available_size_in_gbs", available_size_in_gbs)
        pulumi.set(__self__, "total_size_in_gbs", total_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="availableSizeInGbs")
    def available_size_in_gbs(self) -> _builtins.int:
        """
        Available Capacity
        """
        return pulumi.get(self, "available_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="totalSizeInGbs")
    def total_size_in_gbs(self) -> _builtins.int:
        """
        Total Capacity
        """
        return pulumi.get(self, "total_size_in_gbs")


@pulumi.output_type
class GetExascaleDbStorageVaultsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExecutionActionActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int,
                 status: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution action in minutes.
        :param _builtins.str member_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        :param _builtins.int member_order: The priority order of the execution action member.
        :param _builtins.str status: The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
               * SCHEDULED
               * IN_PROGRESS
               * FAILED
               * CANCELED
               * DURATION_EXCEEDED
               * RESCHEDULED
               * SUCCEEDED
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution action in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The priority order of the execution action member.
        """
        return pulumi.get(self, "member_order")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
        * SCHEDULED
        * IN_PROGRESS
        * FAILED
        * CANCELED
        * DURATION_EXCEEDED
        * RESCHEDULED
        * SUCCEEDED
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetExecutionActionsExecutionActionResult(dict):
    def __init__(__self__, *,
                 action_members: Sequence['outputs.GetExecutionActionsExecutionActionActionMemberResult'],
                 action_params: Mapping[str, _builtins.str],
                 action_type: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 execution_action_order: _builtins.int,
                 execution_window_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 lifecycle_substate: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param Sequence['GetExecutionActionsExecutionActionActionMemberArgs'] action_members: List of action members of this execution action.
        :param Mapping[str, _builtins.str] action_params: Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        :param _builtins.str action_type: The action type of the execution action being performed
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Description of the execution action.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution action in minutes.
        :param _builtins.int execution_action_order: The priority order of the execution action.
        :param _builtins.str execution_window_id: A filter to return only resources that match the given execution wondow id.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution action.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str lifecycle_substate: The current sub-state of the execution action. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the execution action was created.
        :param _builtins.str time_updated: The last date and time that the execution action was updated.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "action_members", action_members)
        pulumi.set(__self__, "action_params", action_params)
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "execution_action_order", execution_action_order)
        pulumi.set(__self__, "execution_window_id", execution_window_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_substate", lifecycle_substate)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="actionMembers")
    def action_members(self) -> Sequence['outputs.GetExecutionActionsExecutionActionActionMemberResult']:
        """
        List of action members of this execution action.
        """
        return pulumi.get(self, "action_members")

    @_builtins.property
    @pulumi.getter(name="actionParams")
    def action_params(self) -> Mapping[str, _builtins.str]:
        """
        Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        """
        return pulumi.get(self, "action_params")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The action type of the execution action being performed
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the execution action.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution action in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="executionActionOrder")
    def execution_action_order(self) -> _builtins.int:
        """
        The priority order of the execution action.
        """
        return pulumi.get(self, "execution_action_order")

    @_builtins.property
    @pulumi.getter(name="executionWindowId")
    def execution_window_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given execution wondow id.
        """
        return pulumi.get(self, "execution_window_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution action.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lifecycleSubstate")
    def lifecycle_substate(self) -> _builtins.str:
        """
        The current sub-state of the execution action. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        """
        return pulumi.get(self, "lifecycle_substate")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the execution action was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the execution action was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetExecutionActionsExecutionActionActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int,
                 status: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution action in minutes.
        :param _builtins.str member_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        :param _builtins.int member_order: The priority order of the execution action member.
        :param _builtins.str status: The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
               * SCHEDULED
               * IN_PROGRESS
               * FAILED
               * CANCELED
               * DURATION_EXCEEDED
               * RESCHEDULED
               * SUCCEEDED
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution action in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the parent resource the execution action belongs to.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The priority order of the execution action member.
        """
        return pulumi.get(self, "member_order")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the execution action member. Valid states are SCHEDULED, IN_PROGRESS, FAILED, CANCELED, DURATION_EXCEEDED, RESCHEDULED and COMPLETED. enum:
        * SCHEDULED
        * IN_PROGRESS
        * FAILED
        * CANCELED
        * DURATION_EXCEEDED
        * RESCHEDULED
        * SUCCEEDED
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetExecutionActionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExecutionWindowsExecutionWindowResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 execution_resource_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enforced_duration: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 lifecycle_substate: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_ended: _builtins.str,
                 time_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 time_updated: _builtins.str,
                 total_time_taken_in_mins: _builtins.int,
                 window_duration_in_mins: _builtins.int,
                 window_type: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str description: Description of the execution window.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.int estimated_time_in_mins: The estimated time of the execution window in minutes.
        :param _builtins.str execution_resource_id: A filter to return only resources that match the given resource id exactly.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution window.
        :param _builtins.bool is_enforced_duration: Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str lifecycle_substate: The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the execution window was created.
        :param _builtins.str time_ended: The date and time that the execution window ended.
        :param _builtins.str time_scheduled: The scheduled start date and time of the execution window.
        :param _builtins.str time_started: The date and time that the execution window was started.
        :param _builtins.str time_updated: The last date and time that the execution window was updated.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        :param _builtins.int window_duration_in_mins: Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        :param _builtins.str window_type: The execution window is of PLANNED or UNPLANNED type.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "execution_resource_id", execution_resource_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enforced_duration", is_enforced_duration)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_substate", lifecycle_substate)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_scheduled", time_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)
        pulumi.set(__self__, "window_duration_in_mins", window_duration_in_mins)
        pulumi.set(__self__, "window_type", window_type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the execution window.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time of the execution window in minutes.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="executionResourceId")
    def execution_resource_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given resource id exactly.
        """
        return pulumi.get(self, "execution_resource_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the execution window.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnforcedDuration")
    def is_enforced_duration(self) -> _builtins.bool:
        """
        Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_enforced_duration")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="lifecycleSubstate")
    def lifecycle_substate(self) -> _builtins.str:
        """
        The current sub-state of the execution window. Valid states are DURATION_EXCEEDED, MAINTENANCE_IN_PROGRESS and WAITING.
        """
        return pulumi.get(self, "lifecycle_substate")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the execution window was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time that the execution window ended.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> _builtins.str:
        """
        The scheduled start date and time of the execution window.
        """
        return pulumi.get(self, "time_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time that the execution window was started.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the execution window was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")

    @_builtins.property
    @pulumi.getter(name="windowDurationInMins")
    def window_duration_in_mins(self) -> _builtins.int:
        """
        Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        """
        return pulumi.get(self, "window_duration_in_mins")

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> _builtins.str:
        """
        The execution window is of PLANNED or UNPLANNED type.
        """
        return pulumi.get(self, "window_type")


@pulumi.output_type
class GetExecutionWindowsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: _builtins.str,
                 database_management_status: _builtins.str,
                 license_model: _builtins.str):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: _builtins.str,
                 stack_monitoring_status: _builtins.str):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> _builtins.str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalContainerDatabasesExternalContainerDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: _builtins.str,
                 compartment_id: _builtins.str,
                 database_configuration: _builtins.str,
                 database_edition: _builtins.str,
                 database_management_configs: Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult'],
                 database_version: _builtins.str,
                 db_id: _builtins.str,
                 db_packs: _builtins.str,
                 db_unique_name: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 stack_monitoring_configs: Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult'],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_zone: _builtins.str):
        """
        :param _builtins.str character_set: The character set of the external database.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_configuration: The Oracle Database configuration
        :param _builtins.str database_edition: The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        :param Sequence['GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param _builtins.str database_version: The Oracle Database version.
        :param _builtins.str db_id: The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        :param _builtins.str db_packs: The database packs licensed for the external Oracle Database.
        :param _builtins.str db_unique_name: The `DB_UNIQUE_NAME` of the external database.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str ncharacter_set: The national character of the external database.
        :param Sequence['GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigArgs'] stack_monitoring_configs: The configuration of Stack Monitoring for the external database.
        :param _builtins.str state: A filter to return only resources that match the specified lifecycle state.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the database was created.
        :param _builtins.str time_zone: The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_configuration", database_configuration)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "database_management_configs", database_management_configs)
        pulumi.set(__self__, "database_version", database_version)
        pulumi.set(__self__, "db_id", db_id)
        pulumi.set(__self__, "db_packs", db_packs)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "stack_monitoring_configs", stack_monitoring_configs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set of the external database.
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> _builtins.str:
        """
        The Oracle Database configuration
        """
        return pulumi.get(self, "database_configuration")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @_builtins.property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> _builtins.str:
        """
        The Oracle Database version.
        """
        return pulumi.get(self, "database_version")

    @_builtins.property
    @pulumi.getter(name="dbId")
    def db_id(self) -> _builtins.str:
        """
        The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        """
        return pulumi.get(self, "db_id")

    @_builtins.property
    @pulumi.getter(name="dbPacks")
    def db_packs(self) -> _builtins.str:
        """
        The database packs licensed for the external Oracle Database.
        """
        return pulumi.get(self, "db_packs")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        The `DB_UNIQUE_NAME` of the external database.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character of the external database.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConfigs")
    def stack_monitoring_configs(self) -> Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult']:
        """
        The configuration of Stack Monitoring for the external database.
        """
        return pulumi.get(self, "stack_monitoring_configs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: _builtins.str,
                 database_management_status: _builtins.str,
                 license_model: _builtins.str):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: _builtins.str,
                 stack_monitoring_status: _builtins.str):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> _builtins.str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalContainerDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalDatabaseConnectorConnectionCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: _builtins.str,
                 credential_type: _builtins.str,
                 password: _builtins.str,
                 role: _builtins.str,
                 ssl_secret_id: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str credential_name: The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        :param _builtins.str credential_type: The type of credential used to connect to the database.
        :param _builtins.str password: The password that will be used to connect to the database.
        :param _builtins.str role: The role of the user that will be connecting to the database.
        :param _builtins.str ssl_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str username: The username that will be used to connect to the database.
        """
        pulumi.set(__self__, "credential_name", credential_name)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "ssl_secret_id", ssl_secret_id)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> _builtins.str:
        """
        The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        """
        return pulumi.get(self, "credential_name")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetExternalDatabaseConnectorConnectionStringResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 service: _builtins.str):
        """
        :param _builtins.str hostname: The host name of the database.
        :param _builtins.int port: The port used to connect to the database.
        :param _builtins.str protocol: The protocol used to connect to the database.
        :param _builtins.str service: The name of the service alias used to connect to the database.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetExternalDatabaseConnectorsExternalDatabaseConnectorResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 connection_credentials: Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult'],
                 connection_status: _builtins.str,
                 connection_strings: Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult'],
                 connector_agent_id: _builtins.str,
                 connector_type: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 external_database_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_connection_status_last_updated: _builtins.str,
                 time_created: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialArgs'] connection_credentials: Credentials used to connect to the database. Currently only the `DETAILS` type is supported for creating MACS connector crendentials.
        :param _builtins.str connection_status: The status of connectivity to the external database.
        :param Sequence['GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringArgs'] connection_strings: The Oracle Database connection string.
        :param _builtins.str connector_agent_id: The ID of the agent used for the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str connector_type: The type of connector used by the external database resource.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str external_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the external database whose connectors will be listed.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the specified lifecycle state.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_connection_status_last_updated: The date and time the `connectionStatus` of this external connector was last updated.
        :param _builtins.str time_created: The date and time the external connector was created.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "connection_credentials", connection_credentials)
        pulumi.set(__self__, "connection_status", connection_status)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "connector_agent_id", connector_agent_id)
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "external_database_id", external_database_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_connection_status_last_updated", time_connection_status_last_updated)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="connectionCredentials")
    def connection_credentials(self) -> Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult']:
        """
        Credentials used to connect to the database. Currently only the `DETAILS` type is supported for creating MACS connector crendentials.
        """
        return pulumi.get(self, "connection_credentials")

    @_builtins.property
    @pulumi.getter(name="connectionStatus")
    def connection_status(self) -> _builtins.str:
        """
        The status of connectivity to the external database.
        """
        return pulumi.get(self, "connection_status")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult']:
        """
        The Oracle Database connection string.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="connectorAgentId")
    def connector_agent_id(self) -> _builtins.str:
        """
        The ID of the agent used for the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "connector_agent_id")

    @_builtins.property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> _builtins.str:
        """
        The type of connector used by the external database resource.
        """
        return pulumi.get(self, "connector_type")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="externalDatabaseId")
    def external_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the external database whose connectors will be listed.
        """
        return pulumi.get(self, "external_database_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeConnectionStatusLastUpdated")
    def time_connection_status_last_updated(self) -> _builtins.str:
        """
        The date and time the `connectionStatus` of this external connector was last updated.
        """
        return pulumi.get(self, "time_connection_status_last_updated")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the external connector was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: _builtins.str,
                 credential_type: _builtins.str,
                 password: _builtins.str,
                 role: _builtins.str,
                 ssl_secret_id: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str credential_name: The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        :param _builtins.str credential_type: The type of credential used to connect to the database.
        :param _builtins.str password: The password that will be used to connect to the database.
        :param _builtins.str role: The role of the user that will be connecting to the database.
        :param _builtins.str ssl_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str username: The username that will be used to connect to the database.
        """
        pulumi.set(__self__, "credential_name", credential_name)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "ssl_secret_id", ssl_secret_id)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> _builtins.str:
        """
        The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        """
        return pulumi.get(self, "credential_name")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 service: _builtins.str):
        """
        :param _builtins.str hostname: The host name of the database.
        :param _builtins.int port: The port used to connect to the database.
        :param _builtins.str protocol: The protocol used to connect to the database.
        :param _builtins.str service: The name of the service alias used to connect to the database.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetExternalDatabaseConnectorsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalNonContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: _builtins.str,
                 database_management_status: _builtins.str,
                 license_model: _builtins.str):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalNonContainerDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: _builtins.str,
                 operations_insights_status: _builtins.str):
        """
        :param _builtins.str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str operations_insights_status: The status of Operations Insights
        """
        pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> _builtins.str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalNonContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: _builtins.str,
                 stack_monitoring_status: _builtins.str):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> _builtins.str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: _builtins.str,
                 compartment_id: _builtins.str,
                 database_configuration: _builtins.str,
                 database_edition: _builtins.str,
                 database_management_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult'],
                 database_version: _builtins.str,
                 db_id: _builtins.str,
                 db_packs: _builtins.str,
                 db_unique_name: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 operations_insights_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult'],
                 stack_monitoring_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult'],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_zone: _builtins.str):
        """
        :param _builtins.str character_set: The character set of the external database.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_configuration: The Oracle Database configuration
        :param _builtins.str database_edition: The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        :param Sequence['GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param _builtins.str database_version: The Oracle Database version.
        :param _builtins.str db_id: The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        :param _builtins.str db_packs: The database packs licensed for the external Oracle Database.
        :param _builtins.str db_unique_name: The `DB_UNIQUE_NAME` of the external database.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str ncharacter_set: The national character of the external database.
        :param Sequence['GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigArgs'] operations_insights_configs: The configuration of Operations Insights for the external database
        :param Sequence['GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigArgs'] stack_monitoring_configs: The configuration of Stack Monitoring for the external database.
        :param _builtins.str state: A filter to return only resources that match the specified lifecycle state.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the database was created.
        :param _builtins.str time_zone: The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_configuration", database_configuration)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "database_management_configs", database_management_configs)
        pulumi.set(__self__, "database_version", database_version)
        pulumi.set(__self__, "db_id", db_id)
        pulumi.set(__self__, "db_packs", db_packs)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "operations_insights_configs", operations_insights_configs)
        pulumi.set(__self__, "stack_monitoring_configs", stack_monitoring_configs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set of the external database.
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> _builtins.str:
        """
        The Oracle Database configuration
        """
        return pulumi.get(self, "database_configuration")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @_builtins.property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> _builtins.str:
        """
        The Oracle Database version.
        """
        return pulumi.get(self, "database_version")

    @_builtins.property
    @pulumi.getter(name="dbId")
    def db_id(self) -> _builtins.str:
        """
        The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        """
        return pulumi.get(self, "db_id")

    @_builtins.property
    @pulumi.getter(name="dbPacks")
    def db_packs(self) -> _builtins.str:
        """
        The database packs licensed for the external Oracle Database.
        """
        return pulumi.get(self, "db_packs")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        The `DB_UNIQUE_NAME` of the external database.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character of the external database.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConfigs")
    def operations_insights_configs(self) -> Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult']:
        """
        The configuration of Operations Insights for the external database
        """
        return pulumi.get(self, "operations_insights_configs")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConfigs")
    def stack_monitoring_configs(self) -> Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult']:
        """
        The configuration of Stack Monitoring for the external database.
        """
        return pulumi.get(self, "stack_monitoring_configs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: _builtins.str,
                 database_management_status: _builtins.str,
                 license_model: _builtins.str):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: _builtins.str,
                 operations_insights_status: _builtins.str):
        """
        :param _builtins.str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str operations_insights_status: The status of Operations Insights
        """
        pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> _builtins.str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: _builtins.str,
                 stack_monitoring_status: _builtins.str):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> _builtins.str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalNonContainerDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalPluggableDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: _builtins.str,
                 database_management_status: _builtins.str,
                 license_model: _builtins.str):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalPluggableDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: _builtins.str,
                 operations_insights_status: _builtins.str):
        """
        :param _builtins.str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str operations_insights_status: The status of Operations Insights
        """
        pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> _builtins.str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalPluggableDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: _builtins.str,
                 stack_monitoring_status: _builtins.str):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> _builtins.str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: _builtins.str,
                 compartment_id: _builtins.str,
                 database_configuration: _builtins.str,
                 database_edition: _builtins.str,
                 database_management_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult'],
                 database_version: _builtins.str,
                 db_id: _builtins.str,
                 db_packs: _builtins.str,
                 db_unique_name: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 external_container_database_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ncharacter_set: _builtins.str,
                 operations_insights_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult'],
                 source_id: _builtins.str,
                 stack_monitoring_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult'],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_zone: _builtins.str):
        """
        :param _builtins.str character_set: The character set of the external database.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str database_configuration: The Oracle Database configuration
        :param _builtins.str database_edition: The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        :param Sequence['GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param _builtins.str database_version: The Oracle Database version.
        :param _builtins.str db_id: The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        :param _builtins.str db_packs: The database packs licensed for the external Oracle Database.
        :param _builtins.str db_unique_name: The `DB_UNIQUE_NAME` of the external database.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str external_container_database_id: The ExternalContainerDatabase [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str ncharacter_set: The national character of the external database.
        :param Sequence['GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigArgs'] operations_insights_configs: The configuration of Operations Insights for the external database
        :param _builtins.str source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the the non-container database that was converted to a pluggable database to create this resource.
        :param Sequence['GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigArgs'] stack_monitoring_configs: The configuration of Stack Monitoring for the external database.
        :param _builtins.str state: A filter to return only resources that match the specified lifecycle state.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the database was created.
        :param _builtins.str time_zone: The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        pulumi.set(__self__, "character_set", character_set)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "database_configuration", database_configuration)
        pulumi.set(__self__, "database_edition", database_edition)
        pulumi.set(__self__, "database_management_configs", database_management_configs)
        pulumi.set(__self__, "database_version", database_version)
        pulumi.set(__self__, "db_id", db_id)
        pulumi.set(__self__, "db_packs", db_packs)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "external_container_database_id", external_container_database_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        pulumi.set(__self__, "operations_insights_configs", operations_insights_configs)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "stack_monitoring_configs", stack_monitoring_configs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> _builtins.str:
        """
        The character set of the external database.
        """
        return pulumi.get(self, "character_set")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> _builtins.str:
        """
        The Oracle Database configuration
        """
        return pulumi.get(self, "database_configuration")

    @_builtins.property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> _builtins.str:
        """
        The Oracle Database Edition that applies to all the databases on the DB system. Exadata DB systems and 2-node RAC DB systems require ENTERPRISE_EDITION_EXTREME_PERFORMANCE.
        """
        return pulumi.get(self, "database_edition")

    @_builtins.property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @_builtins.property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> _builtins.str:
        """
        The Oracle Database version.
        """
        return pulumi.get(self, "database_version")

    @_builtins.property
    @pulumi.getter(name="dbId")
    def db_id(self) -> _builtins.str:
        """
        The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        """
        return pulumi.get(self, "db_id")

    @_builtins.property
    @pulumi.getter(name="dbPacks")
    def db_packs(self) -> _builtins.str:
        """
        The database packs licensed for the external Oracle Database.
        """
        return pulumi.get(self, "db_packs")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        The `DB_UNIQUE_NAME` of the external database.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="externalContainerDatabaseId")
    def external_container_database_id(self) -> _builtins.str:
        """
        The ExternalContainerDatabase [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "external_container_database_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> _builtins.str:
        """
        The national character of the external database.
        """
        return pulumi.get(self, "ncharacter_set")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConfigs")
    def operations_insights_configs(self) -> Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult']:
        """
        The configuration of Operations Insights for the external database
        """
        return pulumi.get(self, "operations_insights_configs")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the the non-container database that was converted to a pluggable database to create this resource.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConfigs")
    def stack_monitoring_configs(self) -> Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult']:
        """
        The configuration of Stack Monitoring for the external database.
        """
        return pulumi.get(self, "stack_monitoring_configs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: _builtins.str,
                 database_management_status: _builtins.str,
                 license_model: _builtins.str):
        """
        :param _builtins.str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str database_management_status: The status of the Database Management service.
        :param _builtins.str license_model: The Oracle license model that applies to the external database.
        """
        pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        pulumi.set(__self__, "database_management_status", database_management_status)
        pulumi.set(__self__, "license_model", license_model)

    @_builtins.property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @_builtins.property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> _builtins.str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: _builtins.str,
                 operations_insights_status: _builtins.str):
        """
        :param _builtins.str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str operations_insights_status: The status of Operations Insights
        """
        pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @_builtins.property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @_builtins.property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> _builtins.str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: _builtins.str,
                 stack_monitoring_status: _builtins.str):
        """
        :param _builtins.str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param _builtins.str stack_monitoring_status: The status of Stack Monitoring.
        """
        pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @_builtins.property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @_builtins.property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> _builtins.str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalPluggableDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetFlexComponentsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetFlexComponentsFlexComponentCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetFlexComponentsFlexComponentCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetFlexComponentsFlexComponentCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetFlexComponentsFlexComponentCollectionItemResult(dict):
    def __init__(__self__, *,
                 available_core_count: _builtins.int,
                 available_db_storage_in_gbs: _builtins.int,
                 available_local_storage_in_gbs: _builtins.int,
                 available_memory_in_gbs: _builtins.int,
                 compute_model: _builtins.str,
                 description_summary: _builtins.str,
                 hardware_type: _builtins.str,
                 minimum_core_count: _builtins.int,
                 name: _builtins.str,
                 runtime_minimum_core_count: _builtins.int,
                 shape: _builtins.str):
        """
        :param _builtins.int available_core_count: The maximum number of CPU cores that can ben enabled on the DB Server for this Flex Component.
        :param _builtins.int available_db_storage_in_gbs: The maximum  storage that can be enabled on the Storage Server for this Flex Component.
        :param _builtins.int available_local_storage_in_gbs: The maximum local storage that can be enabled on the DB Server for this Flex Component.
        :param _builtins.int available_memory_in_gbs: The maximum memory size that can be enabled on the DB Server for this Flex Component.
        :param _builtins.str compute_model: The compute model of the DB Server for this Flex Component.
        :param _builtins.str description_summary: The description summary for this Flex Component.
        :param _builtins.str hardware_type: The hardware type of the DB (Compute) or Storage (Cell) Server for this Flex Component.
        :param _builtins.int minimum_core_count: The minimum number of CPU cores that can be enabled on the DB Server for this Flex Component.
        :param _builtins.str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        :param _builtins.int runtime_minimum_core_count: The runtime minimum number of CPU cores that can be enabled for this Flex Component.
        :param _builtins.str shape: A filter to return only resources that belong to the entire shape name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "available_core_count", available_core_count)
        pulumi.set(__self__, "available_db_storage_in_gbs", available_db_storage_in_gbs)
        pulumi.set(__self__, "available_local_storage_in_gbs", available_local_storage_in_gbs)
        pulumi.set(__self__, "available_memory_in_gbs", available_memory_in_gbs)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "description_summary", description_summary)
        pulumi.set(__self__, "hardware_type", hardware_type)
        pulumi.set(__self__, "minimum_core_count", minimum_core_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "runtime_minimum_core_count", runtime_minimum_core_count)
        pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> _builtins.int:
        """
        The maximum number of CPU cores that can ben enabled on the DB Server for this Flex Component.
        """
        return pulumi.get(self, "available_core_count")

    @_builtins.property
    @pulumi.getter(name="availableDbStorageInGbs")
    def available_db_storage_in_gbs(self) -> _builtins.int:
        """
        The maximum  storage that can be enabled on the Storage Server for this Flex Component.
        """
        return pulumi.get(self, "available_db_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="availableLocalStorageInGbs")
    def available_local_storage_in_gbs(self) -> _builtins.int:
        """
        The maximum local storage that can be enabled on the DB Server for this Flex Component.
        """
        return pulumi.get(self, "available_local_storage_in_gbs")

    @_builtins.property
    @pulumi.getter(name="availableMemoryInGbs")
    def available_memory_in_gbs(self) -> _builtins.int:
        """
        The maximum memory size that can be enabled on the DB Server for this Flex Component.
        """
        return pulumi.get(self, "available_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the DB Server for this Flex Component.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="descriptionSummary")
    def description_summary(self) -> _builtins.str:
        """
        The description summary for this Flex Component.
        """
        return pulumi.get(self, "description_summary")

    @_builtins.property
    @pulumi.getter(name="hardwareType")
    def hardware_type(self) -> _builtins.str:
        """
        The hardware type of the DB (Compute) or Storage (Cell) Server for this Flex Component.
        """
        return pulumi.get(self, "hardware_type")

    @_builtins.property
    @pulumi.getter(name="minimumCoreCount")
    def minimum_core_count(self) -> _builtins.int:
        """
        The minimum number of CPU cores that can be enabled on the DB Server for this Flex Component.
        """
        return pulumi.get(self, "minimum_core_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="runtimeMinimumCoreCount")
    def runtime_minimum_core_count(self) -> _builtins.int:
        """
        The runtime minimum number of CPU cores that can be enabled for this Flex Component.
        """
        return pulumi.get(self, "runtime_minimum_core_count")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        A filter to return only resources that belong to the entire shape name given. The match is not case sensitive.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetGiVersionMinorVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGiVersionMinorVersionsGiMinorVersionResult(dict):
    def __init__(__self__, *,
                 grid_image_id: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str grid_image_id: Grid Infrastructure Image Id
        :param _builtins.str version: The Oracle Grid Infrastructure major version.
        """
        pulumi.set(__self__, "grid_image_id", grid_image_id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="gridImageId")
    def grid_image_id(self) -> _builtins.str:
        """
        Grid Infrastructure Image Id
        """
        return pulumi.get(self, "grid_image_id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The Oracle Grid Infrastructure major version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGiVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGiVersionsGiVersionResult(dict):
    def __init__(__self__, *,
                 version: _builtins.str):
        """
        :param _builtins.str version: A valid Oracle Grid Infrastructure (GI) software version.
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetKeyStoreAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str db_name: The name of the database that is associated with the key store.
        :param _builtins.str db_unique_name: The unique name of the database that is associated with the key store.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        The unique name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKeyStoreTypeDetailResult(dict):
    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 connection_ips: Sequence[_builtins.str],
                 secret_id: _builtins.str,
                 type: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str admin_username: The administrator username to connect to Oracle Key Vault
        :param Sequence[_builtins.str] connection_ips: The list of Oracle Key Vault connection IP addresses.
        :param _builtins.str secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str type: The type of key store.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "connection_ips", connection_ips)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> Sequence[_builtins.str]:
        """
        The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of key store.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetKeyStoresFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetKeyStoresKeyStoreResult(dict):
    def __init__(__self__, *,
                 associated_databases: Sequence['outputs.GetKeyStoresKeyStoreAssociatedDatabaseResult'],
                 compartment_id: _builtins.str,
                 confirm_details_trigger: _builtins.int,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 type_details: Sequence['outputs.GetKeyStoresKeyStoreTypeDetailResult']):
        """
        :param Sequence['GetKeyStoresKeyStoreAssociatedDatabaseArgs'] associated_databases: List of databases associated with the key store.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: The user-friendly name for the key store. The name does not need to be unique.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: The current state of the key store.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the key store was created.
        :param Sequence['GetKeyStoresKeyStoreTypeDetailArgs'] type_details: Key store type details.
        """
        pulumi.set(__self__, "associated_databases", associated_databases)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "confirm_details_trigger", confirm_details_trigger)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "type_details", type_details)

    @_builtins.property
    @pulumi.getter(name="associatedDatabases")
    def associated_databases(self) -> Sequence['outputs.GetKeyStoresKeyStoreAssociatedDatabaseResult']:
        """
        List of databases associated with the key store.
        """
        return pulumi.get(self, "associated_databases")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="confirmDetailsTrigger")
    def confirm_details_trigger(self) -> _builtins.int:
        return pulumi.get(self, "confirm_details_trigger")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the key store. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the key store.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the key store was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="typeDetails")
    def type_details(self) -> Sequence['outputs.GetKeyStoresKeyStoreTypeDetailResult']:
        """
        Key store type details.
        """
        return pulumi.get(self, "type_details")


@pulumi.output_type
class GetKeyStoresKeyStoreAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: _builtins.str,
                 db_unique_name: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str db_name: The name of the database that is associated with the key store.
        :param _builtins.str db_unique_name: The unique name of the database that is associated with the key store.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_unique_name", db_unique_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> _builtins.str:
        """
        The unique name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_unique_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKeyStoresKeyStoreTypeDetailResult(dict):
    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 connection_ips: Sequence[_builtins.str],
                 secret_id: _builtins.str,
                 type: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str admin_username: The administrator username to connect to Oracle Key Vault
        :param Sequence[_builtins.str] connection_ips: The list of Oracle Key Vault connection IP addresses.
        :param _builtins.str secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param _builtins.str type: The type of key store.
        :param _builtins.str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "connection_ips", connection_ips)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> Sequence[_builtins.str]:
        """
        The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of key store.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetMaintenanceRunEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: _builtins.int,
                 estimated_network_switches_patching_time: _builtins.int,
                 estimated_storage_server_patching_time: _builtins.int,
                 total_estimated_patching_time: _builtins.int):
        """
        :param _builtins.int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param _builtins.int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param _builtins.int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param _builtins.int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @_builtins.property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> _builtins.int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetMaintenanceRunsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaintenanceRunsMaintenanceRunResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 current_custom_action_timeout_in_mins: _builtins.int,
                 current_patching_component: _builtins.str,
                 custom_action_timeout_in_mins: _builtins.int,
                 database_software_image_id: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 estimated_component_patching_start_time: _builtins.str,
                 estimated_patching_times: Sequence['outputs.GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult'],
                 id: _builtins.str,
                 is_custom_action_timeout_enabled: _builtins.bool,
                 is_dst_file_update_enabled: _builtins.bool,
                 is_maintenance_run_granular: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 maintenance_subtype: _builtins.str,
                 maintenance_type: _builtins.str,
                 patch_failure_count: _builtins.int,
                 patch_id: _builtins.str,
                 patch_type: _builtins.str,
                 patching_end_time: _builtins.str,
                 patching_mode: _builtins.str,
                 patching_start_time: _builtins.str,
                 patching_status: _builtins.str,
                 peer_maintenance_run_id: _builtins.str,
                 peer_maintenance_run_ids: Sequence[_builtins.str],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 target_db_server_version: _builtins.str,
                 target_resource_id: _builtins.str,
                 target_resource_type: _builtins.str,
                 target_storage_server_version: _builtins.str,
                 time_ended: _builtins.str,
                 time_scheduled: _builtins.str,
                 time_started: _builtins.str,
                 total_time_taken_in_mins: _builtins.int):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.int current_custom_action_timeout_in_mins: Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        :param _builtins.str current_patching_component: The name of the current infrastruture component that is getting patched.
        :param _builtins.int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        :param _builtins.str database_software_image_id: The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param _builtins.str description: Description of the maintenance run.
        :param _builtins.str display_name: The user-friendly name for the maintenance run.
        :param _builtins.str estimated_component_patching_start_time: The estimated start time of the next infrastruture component patching operation.
        :param Sequence['GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeArgs'] estimated_patching_times: The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        :param _builtins.str id: The OCID of the maintenance run.
        :param _builtins.bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        :param _builtins.bool is_dst_file_update_enabled: Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        :param _builtins.bool is_maintenance_run_granular: If `FALSE`, the maintenance run doesn't support granular maintenance.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str maintenance_subtype: The sub-type of the maintenance run.
        :param _builtins.str maintenance_type: The maintenance type.
        :param _builtins.int patch_failure_count: Contain the patch failure count.
        :param _builtins.str patch_id: The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        :param _builtins.str patching_end_time: The time when the patching operation ended.
        :param _builtins.str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param _builtins.str patching_start_time: The time when the patching operation started.
        :param _builtins.str patching_status: The status of the patching operation.
        :param _builtins.str peer_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        :param Sequence[_builtins.str] peer_maintenance_run_ids: The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str target_db_server_version: The target software version for the database server patching operation.
        :param _builtins.str target_resource_id: The target resource ID.
        :param _builtins.str target_resource_type: The type of the target resource. Accepted values are: AUTONOMOUS_CONTAINER_DATABASE, AUTONOMOUS_EXADATA_INFRASTRUCTURE, EXADATA_DB_SYSTEM
        :param _builtins.str target_storage_server_version: The target Cell version that is to be patched to.
        :param _builtins.str time_ended: The date and time the maintenance run was completed.
        :param _builtins.str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param _builtins.str time_started: The date and time the maintenance run starts.
        :param _builtins.int total_time_taken_in_mins: The total time taken by corresponding resource activity in minutes.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "current_custom_action_timeout_in_mins", current_custom_action_timeout_in_mins)
        pulumi.set(__self__, "current_patching_component", current_patching_component)
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_component_patching_start_time", estimated_component_patching_start_time)
        pulumi.set(__self__, "estimated_patching_times", estimated_patching_times)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "is_dst_file_update_enabled", is_dst_file_update_enabled)
        pulumi.set(__self__, "is_maintenance_run_granular", is_maintenance_run_granular)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenance_subtype", maintenance_subtype)
        pulumi.set(__self__, "maintenance_type", maintenance_type)
        pulumi.set(__self__, "patch_failure_count", patch_failure_count)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "patch_type", patch_type)
        pulumi.set(__self__, "patching_end_time", patching_end_time)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "patching_start_time", patching_start_time)
        pulumi.set(__self__, "patching_status", patching_status)
        pulumi.set(__self__, "peer_maintenance_run_id", peer_maintenance_run_id)
        pulumi.set(__self__, "peer_maintenance_run_ids", peer_maintenance_run_ids)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "target_db_server_version", target_db_server_version)
        pulumi.set(__self__, "target_resource_id", target_resource_id)
        pulumi.set(__self__, "target_resource_type", target_resource_type)
        pulumi.set(__self__, "target_storage_server_version", target_storage_server_version)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_scheduled", time_scheduled)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "total_time_taken_in_mins", total_time_taken_in_mins)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="currentCustomActionTimeoutInMins")
    def current_custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        """
        return pulumi.get(self, "current_custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="currentPatchingComponent")
    def current_patching_component(self) -> _builtins.str:
        """
        The name of the current infrastruture component that is getting patched.
        """
        return pulumi.get(self, "current_patching_component")

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> _builtins.int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @_builtins.property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> _builtins.str:
        """
        The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedComponentPatchingStartTime")
    def estimated_component_patching_start_time(self) -> _builtins.str:
        """
        The estimated start time of the next infrastruture component patching operation.
        """
        return pulumi.get(self, "estimated_component_patching_start_time")

    @_builtins.property
    @pulumi.getter(name="estimatedPatchingTimes")
    def estimated_patching_times(self) -> Sequence['outputs.GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult']:
        """
        The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        """
        return pulumi.get(self, "estimated_patching_times")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> _builtins.bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @_builtins.property
    @pulumi.getter(name="isDstFileUpdateEnabled")
    def is_dst_file_update_enabled(self) -> _builtins.bool:
        """
        Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
        """
        return pulumi.get(self, "is_dst_file_update_enabled")

    @_builtins.property
    @pulumi.getter(name="isMaintenanceRunGranular")
    def is_maintenance_run_granular(self) -> _builtins.bool:
        """
        If `FALSE`, the maintenance run doesn't support granular maintenance.
        """
        return pulumi.get(self, "is_maintenance_run_granular")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceSubtype")
    def maintenance_subtype(self) -> _builtins.str:
        """
        The sub-type of the maintenance run.
        """
        return pulumi.get(self, "maintenance_subtype")

    @_builtins.property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> _builtins.str:
        """
        The maintenance type.
        """
        return pulumi.get(self, "maintenance_type")

    @_builtins.property
    @pulumi.getter(name="patchFailureCount")
    def patch_failure_count(self) -> _builtins.int:
        """
        Contain the patch failure count.
        """
        return pulumi.get(self, "patch_failure_count")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> _builtins.str:
        return pulumi.get(self, "patch_type")

    @_builtins.property
    @pulumi.getter(name="patchingEndTime")
    def patching_end_time(self) -> _builtins.str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "patching_end_time")

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> _builtins.str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @_builtins.property
    @pulumi.getter(name="patchingStartTime")
    def patching_start_time(self) -> _builtins.str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "patching_start_time")

    @_builtins.property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> _builtins.str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @_builtins.property
    @pulumi.getter(name="peerMaintenanceRunId")
    def peer_maintenance_run_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        """
        return pulumi.get(self, "peer_maintenance_run_id")

    @_builtins.property
    @pulumi.getter(name="peerMaintenanceRunIds")
    def peer_maintenance_run_ids(self) -> Sequence[_builtins.str]:
        """
        The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
        """
        return pulumi.get(self, "peer_maintenance_run_ids")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="targetDbServerVersion")
    def target_db_server_version(self) -> _builtins.str:
        """
        The target software version for the database server patching operation.
        """
        return pulumi.get(self, "target_db_server_version")

    @_builtins.property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> _builtins.str:
        """
        The target resource ID.
        """
        return pulumi.get(self, "target_resource_id")

    @_builtins.property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> _builtins.str:
        """
        The type of the target resource. Accepted values are: AUTONOMOUS_CONTAINER_DATABASE, AUTONOMOUS_EXADATA_INFRASTRUCTURE, EXADATA_DB_SYSTEM
        """
        return pulumi.get(self, "target_resource_type")

    @_builtins.property
    @pulumi.getter(name="targetStorageServerVersion")
    def target_storage_server_version(self) -> _builtins.str:
        """
        The target Cell version that is to be patched to.
        """
        return pulumi.get(self, "target_storage_server_version")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> _builtins.str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="totalTimeTakenInMins")
    def total_time_taken_in_mins(self) -> _builtins.int:
        """
        The total time taken by corresponding resource activity in minutes.
        """
        return pulumi.get(self, "total_time_taken_in_mins")


@pulumi.output_type
class GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: _builtins.int,
                 estimated_network_switches_patching_time: _builtins.int,
                 estimated_storage_server_patching_time: _builtins.int,
                 total_estimated_patching_time: _builtins.int):
        """
        :param _builtins.int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param _builtins.int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param _builtins.int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param _builtins.int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @_builtins.property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @_builtins.property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> _builtins.int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @_builtins.property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> _builtins.int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetManagedPreferredCredentialsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedPreferredCredentialsPreferredCredentialCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult(dict):
    def __init__(__self__, *,
                 credential_name: _builtins.str,
                 is_accessible: _builtins.bool,
                 named_credential_id: _builtins.str,
                 password_secret_id: _builtins.str,
                 role: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str credential_name: The name of the preferred credential.
        :param _builtins.bool is_accessible: Indicates whether the preferred credential is accessible.
        :param _builtins.str named_credential_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Named Credential that contains the database user password metadata.
        :param _builtins.str password_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Vault service secret that contains the database user password.
        :param _builtins.str role: The role of the database user.
        :param _builtins.str status: The status of the preferred credential.
        :param _builtins.str type: The type of preferred credential. Only 'BASIC' is supported currently.
        :param _builtins.str user_name: The user name used to connect to the database.
        """
        pulumi.set(__self__, "credential_name", credential_name)
        pulumi.set(__self__, "is_accessible", is_accessible)
        pulumi.set(__self__, "named_credential_id", named_credential_id)
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> _builtins.str:
        """
        The name of the preferred credential.
        """
        return pulumi.get(self, "credential_name")

    @_builtins.property
    @pulumi.getter(name="isAccessible")
    def is_accessible(self) -> _builtins.bool:
        """
        Indicates whether the preferred credential is accessible.
        """
        return pulumi.get(self, "is_accessible")

    @_builtins.property
    @pulumi.getter(name="namedCredentialId")
    def named_credential_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Named Credential that contains the database user password metadata.
        """
        return pulumi.get(self, "named_credential_id")

    @_builtins.property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Vault service secret that contains the database user password.
        """
        return pulumi.get(self, "password_secret_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the database user.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the preferred credential.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of preferred credential. Only 'BASIC' is supported currently.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The user name used to connect to the database.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetOneoffPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetOneoffPatchesOneoffPatchResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 db_version: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 download_oneoff_patch_trigger: _builtins.int,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 one_off_patches: Sequence[_builtins.str],
                 release_update: _builtins.str,
                 sha256sum: _builtins.str,
                 size_in_kbs: _builtins.float,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_of_expiration: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str compartment_id: (Updatable) The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str db_version: A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the one-off patch.
        :param _builtins.str lifecycle_details: Detailed message for the lifecycle state.
        :param Sequence[_builtins.str] one_off_patches: List of one-off patches for Database Homes.
        :param _builtins.str release_update: The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param _builtins.str sha256sum: SHA-256 checksum of the one-off patch.
        :param _builtins.float size_in_kbs: The size of one-off patch in kilobytes.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time one-off patch was created.
        :param _builtins.str time_of_expiration: The date and time until which the one-off patch will be available for download.
        :param _builtins.str time_updated: The date and time one-off patch was updated.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "download_oneoff_patch_trigger", download_oneoff_patch_trigger)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "one_off_patches", one_off_patches)
        pulumi.set(__self__, "release_update", release_update)
        pulumi.set(__self__, "sha256sum", sha256sum)
        pulumi.set(__self__, "size_in_kbs", size_in_kbs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_of_expiration", time_of_expiration)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        (Updatable) The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="downloadOneoffPatchTrigger")
    def download_oneoff_patch_trigger(self) -> _builtins.int:
        return pulumi.get(self, "download_oneoff_patch_trigger")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the one-off patch.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Sequence[_builtins.str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @_builtins.property
    @pulumi.getter(name="releaseUpdate")
    def release_update(self) -> _builtins.str:
        """
        The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "release_update")

    @_builtins.property
    @pulumi.getter
    def sha256sum(self) -> _builtins.str:
        """
        SHA-256 checksum of the one-off patch.
        """
        return pulumi.get(self, "sha256sum")

    @_builtins.property
    @pulumi.getter(name="sizeInKbs")
    def size_in_kbs(self) -> _builtins.float:
        """
        The size of one-off patch in kilobytes.
        """
        return pulumi.get(self, "size_in_kbs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time one-off patch was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeOfExpiration")
    def time_of_expiration(self) -> _builtins.str:
        """
        The date and time until which the one-off patch will be available for download.
        """
        return pulumi.get(self, "time_of_expiration")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time one-off patch was updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetPluggableDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 pdb_default: _builtins.str,
                 pdb_ip_default: _builtins.str):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param _builtins.str pdb_default: A host name-based PDB connection string.
        :param _builtins.str pdb_ip_default: An IP-based PDB connection string.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "pdb_default", pdb_default)
        pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> _builtins.str:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @_builtins.property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> _builtins.str:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class GetPluggableDatabasePdbCreationTypeDetailResult(dict):
    def __init__(__self__, *,
                 creation_type: _builtins.str,
                 dblink_user_password: _builtins.str,
                 dblink_username: _builtins.str,
                 is_thin_clone: _builtins.bool,
                 refreshable_clone_details: Sequence['outputs.GetPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult'],
                 source_container_database_admin_password: _builtins.str,
                 source_pluggable_database_id: _builtins.str,
                 source_pluggable_database_snapshot_id: _builtins.str):
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "dblink_user_password", dblink_user_password)
        pulumi.set(__self__, "dblink_username", dblink_username)
        pulumi.set(__self__, "is_thin_clone", is_thin_clone)
        pulumi.set(__self__, "refreshable_clone_details", refreshable_clone_details)
        pulumi.set(__self__, "source_container_database_admin_password", source_container_database_admin_password)
        pulumi.set(__self__, "source_pluggable_database_id", source_pluggable_database_id)
        pulumi.set(__self__, "source_pluggable_database_snapshot_id", source_pluggable_database_snapshot_id)

    @_builtins.property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> _builtins.str:
        return pulumi.get(self, "creation_type")

    @_builtins.property
    @pulumi.getter(name="dblinkUserPassword")
    def dblink_user_password(self) -> _builtins.str:
        return pulumi.get(self, "dblink_user_password")

    @_builtins.property
    @pulumi.getter(name="dblinkUsername")
    def dblink_username(self) -> _builtins.str:
        return pulumi.get(self, "dblink_username")

    @_builtins.property
    @pulumi.getter(name="isThinClone")
    def is_thin_clone(self) -> _builtins.bool:
        return pulumi.get(self, "is_thin_clone")

    @_builtins.property
    @pulumi.getter(name="refreshableCloneDetails")
    def refreshable_clone_details(self) -> Sequence['outputs.GetPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult']:
        return pulumi.get(self, "refreshable_clone_details")

    @_builtins.property
    @pulumi.getter(name="sourceContainerDatabaseAdminPassword")
    def source_container_database_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "source_container_database_admin_password")

    @_builtins.property
    @pulumi.getter(name="sourcePluggableDatabaseId")
    def source_pluggable_database_id(self) -> _builtins.str:
        return pulumi.get(self, "source_pluggable_database_id")

    @_builtins.property
    @pulumi.getter(name="sourcePluggableDatabaseSnapshotId")
    def source_pluggable_database_snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "source_pluggable_database_snapshot_id")


@pulumi.output_type
class GetPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult(dict):
    def __init__(__self__, *,
                 is_refreshable_clone: _builtins.bool):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> _builtins.bool:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class GetPluggableDatabasePdbNodeLevelDetailResult(dict):
    def __init__(__self__, *,
                 node_name: _builtins.str,
                 open_mode: _builtins.str):
        """
        :param _builtins.str node_name: The Node name of the Database Instance.
        :param _builtins.str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "open_mode", open_mode)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> _builtins.str:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")


@pulumi.output_type
class GetPluggableDatabasePluggableDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: _builtins.str):
        """
        :param _builtins.str management_status: The status of the Pluggable Database Management service.
        """
        pulumi.set(__self__, "management_status", management_status)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> _builtins.str:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class GetPluggableDatabaseRefreshableCloneConfigResult(dict):
    def __init__(__self__, *,
                 is_refreshable_clone: _builtins.bool):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> _builtins.bool:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class GetPluggableDatabaseSnapshotsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetPluggableDatabaseSnapshotsPluggableDatabaseSnapshotResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 name: _builtins.str,
                 pluggable_database_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str):
        """
        :param _builtins.str cluster_id: A filter to return only Exadata Database Node Snapshots that match the given VM cluster.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata Pluggable Database Snapshot.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state of the Exadata Pluggable Database Snapshot.
        :param _builtins.str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        :param _builtins.str pluggable_database_id: A filter to return only Exadata Pluggable Database Snapshots that match the given database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str state: A filter to return only Exadata Pluggable Database Snapshots that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time that the Exadata Pluggable Database Snapshot was created, as expressed in RFC 3339 format. For example: 2023-06-27T21:10:29Z
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pluggable_database_id", pluggable_database_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        A filter to return only Exadata Database Node Snapshots that match the given VM cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata Pluggable Database Snapshot.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state of the Exadata Pluggable Database Snapshot.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabaseId")
    def pluggable_database_id(self) -> _builtins.str:
        """
        A filter to return only Exadata Pluggable Database Snapshots that match the given database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "pluggable_database_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only Exadata Pluggable Database Snapshots that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the Exadata Pluggable Database Snapshot was created, as expressed in RFC 3339 format. For example: 2023-06-27T21:10:29Z
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetPluggableDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabaseResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 connection_strings: Sequence['outputs.GetPluggableDatabasesPluggableDatabaseConnectionStringResult'],
                 container_database_admin_password: _builtins.str,
                 container_database_id: _builtins.str,
                 convert_to_regular_trigger: _builtins.int,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_restricted: _builtins.bool,
                 kms_key_version_id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 open_mode: _builtins.str,
                 pdb_admin_password: _builtins.str,
                 pdb_creation_type_details: Sequence['outputs.GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailResult'],
                 pdb_name: _builtins.str,
                 pdb_node_level_details: Sequence['outputs.GetPluggableDatabasesPluggableDatabasePdbNodeLevelDetailResult'],
                 pluggable_database_management_configs: Sequence['outputs.GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult'],
                 refresh_trigger: _builtins.int,
                 refreshable_clone_configs: Sequence['outputs.GetPluggableDatabasesPluggableDatabaseRefreshableCloneConfigResult'],
                 rotate_key_trigger: _builtins.int,
                 should_create_pdb_backup: _builtins.bool,
                 should_pdb_admin_account_be_locked: _builtins.bool,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 tde_wallet_password: _builtins.str,
                 time_created: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetPluggableDatabasesPluggableDatabaseConnectionStringArgs'] connection_strings: Connection strings to connect to an Oracle Pluggable Database.
        :param _builtins.str container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the CDB.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pluggable database.
        :param _builtins.bool is_restricted: The restricted mode of the pluggable database. If a pluggable database is opened in restricted mode, the user needs both create a session and have restricted session privileges to connect to it.
        :param _builtins.str lifecycle_details: Detailed message for the lifecycle state.
        :param _builtins.str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        :param _builtins.str pdb_name: A filter to return only pluggable databases that match the entire name given. The match is not case sensitive.
        :param Sequence['GetPluggableDatabasesPluggableDatabasePdbNodeLevelDetailArgs'] pdb_node_level_details: Pluggable Database Node Level Details. Example: [{"nodeName" : "node1", "openMode" : "READ_WRITE"}, {"nodeName" : "node2", "openMode" : "READ_ONLY"}]
        :param Sequence['GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigArgs'] pluggable_database_management_configs: The configuration of the Pluggable Database Management service.
        :param Sequence['GetPluggableDatabasesPluggableDatabaseRefreshableCloneConfigArgs'] refreshable_clone_configs: Pluggable Database Refreshable Clone Configuration.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the pluggable database was created.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "container_database_admin_password", container_database_admin_password)
        pulumi.set(__self__, "container_database_id", container_database_id)
        pulumi.set(__self__, "convert_to_regular_trigger", convert_to_regular_trigger)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_restricted", is_restricted)
        pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "open_mode", open_mode)
        pulumi.set(__self__, "pdb_admin_password", pdb_admin_password)
        pulumi.set(__self__, "pdb_creation_type_details", pdb_creation_type_details)
        pulumi.set(__self__, "pdb_name", pdb_name)
        pulumi.set(__self__, "pdb_node_level_details", pdb_node_level_details)
        pulumi.set(__self__, "pluggable_database_management_configs", pluggable_database_management_configs)
        pulumi.set(__self__, "refresh_trigger", refresh_trigger)
        pulumi.set(__self__, "refreshable_clone_configs", refreshable_clone_configs)
        pulumi.set(__self__, "rotate_key_trigger", rotate_key_trigger)
        pulumi.set(__self__, "should_create_pdb_backup", should_create_pdb_backup)
        pulumi.set(__self__, "should_pdb_admin_account_be_locked", should_pdb_admin_account_be_locked)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabaseConnectionStringResult']:
        """
        Connection strings to connect to an Oracle Pluggable Database.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="containerDatabaseAdminPassword")
    def container_database_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "container_database_admin_password")

    @_builtins.property
    @pulumi.getter(name="containerDatabaseId")
    def container_database_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the CDB.
        """
        return pulumi.get(self, "container_database_id")

    @_builtins.property
    @pulumi.getter(name="convertToRegularTrigger")
    def convert_to_regular_trigger(self) -> _builtins.int:
        return pulumi.get(self, "convert_to_regular_trigger")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pluggable database.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isRestricted")
    def is_restricted(self) -> _builtins.bool:
        """
        The restricted mode of the pluggable database. If a pluggable database is opened in restricted mode, the user needs both create a session and have restricted session privileges to connect to it.
        """
        return pulumi.get(self, "is_restricted")

    @_builtins.property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_version_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> _builtins.str:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @_builtins.property
    @pulumi.getter(name="pdbAdminPassword")
    def pdb_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "pdb_admin_password")

    @_builtins.property
    @pulumi.getter(name="pdbCreationTypeDetails")
    def pdb_creation_type_details(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailResult']:
        return pulumi.get(self, "pdb_creation_type_details")

    @_builtins.property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> _builtins.str:
        """
        A filter to return only pluggable databases that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "pdb_name")

    @_builtins.property
    @pulumi.getter(name="pdbNodeLevelDetails")
    def pdb_node_level_details(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabasePdbNodeLevelDetailResult']:
        """
        Pluggable Database Node Level Details. Example: [{"nodeName" : "node1", "openMode" : "READ_WRITE"}, {"nodeName" : "node2", "openMode" : "READ_ONLY"}]
        """
        return pulumi.get(self, "pdb_node_level_details")

    @_builtins.property
    @pulumi.getter(name="pluggableDatabaseManagementConfigs")
    def pluggable_database_management_configs(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult']:
        """
        The configuration of the Pluggable Database Management service.
        """
        return pulumi.get(self, "pluggable_database_management_configs")

    @_builtins.property
    @pulumi.getter(name="refreshTrigger")
    def refresh_trigger(self) -> _builtins.int:
        return pulumi.get(self, "refresh_trigger")

    @_builtins.property
    @pulumi.getter(name="refreshableCloneConfigs")
    def refreshable_clone_configs(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabaseRefreshableCloneConfigResult']:
        """
        Pluggable Database Refreshable Clone Configuration.
        """
        return pulumi.get(self, "refreshable_clone_configs")

    @_builtins.property
    @pulumi.getter(name="rotateKeyTrigger")
    def rotate_key_trigger(self) -> _builtins.int:
        return pulumi.get(self, "rotate_key_trigger")

    @_builtins.property
    @pulumi.getter(name="shouldCreatePdbBackup")
    def should_create_pdb_backup(self) -> _builtins.bool:
        return pulumi.get(self, "should_create_pdb_backup")

    @_builtins.property
    @pulumi.getter(name="shouldPdbAdminAccountBeLocked")
    def should_pdb_admin_account_be_locked(self) -> _builtins.bool:
        return pulumi.get(self, "should_pdb_admin_account_be_locked")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> _builtins.str:
        return pulumi.get(self, "tde_wallet_password")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the pluggable database was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, _builtins.str],
                 pdb_default: _builtins.str,
                 pdb_ip_default: _builtins.str):
        """
        :param Mapping[str, _builtins.str] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param _builtins.str pdb_default: A host name-based PDB connection string.
        :param _builtins.str pdb_ip_default: An IP-based PDB connection string.
        """
        pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        pulumi.set(__self__, "pdb_default", pdb_default)
        pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @_builtins.property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, _builtins.str]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @_builtins.property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> _builtins.str:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @_builtins.property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> _builtins.str:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailResult(dict):
    def __init__(__self__, *,
                 creation_type: _builtins.str,
                 dblink_user_password: _builtins.str,
                 dblink_username: _builtins.str,
                 is_thin_clone: _builtins.bool,
                 refreshable_clone_details: Sequence['outputs.GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult'],
                 source_container_database_admin_password: _builtins.str,
                 source_pluggable_database_id: _builtins.str,
                 source_pluggable_database_snapshot_id: _builtins.str):
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "dblink_user_password", dblink_user_password)
        pulumi.set(__self__, "dblink_username", dblink_username)
        pulumi.set(__self__, "is_thin_clone", is_thin_clone)
        pulumi.set(__self__, "refreshable_clone_details", refreshable_clone_details)
        pulumi.set(__self__, "source_container_database_admin_password", source_container_database_admin_password)
        pulumi.set(__self__, "source_pluggable_database_id", source_pluggable_database_id)
        pulumi.set(__self__, "source_pluggable_database_snapshot_id", source_pluggable_database_snapshot_id)

    @_builtins.property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> _builtins.str:
        return pulumi.get(self, "creation_type")

    @_builtins.property
    @pulumi.getter(name="dblinkUserPassword")
    def dblink_user_password(self) -> _builtins.str:
        return pulumi.get(self, "dblink_user_password")

    @_builtins.property
    @pulumi.getter(name="dblinkUsername")
    def dblink_username(self) -> _builtins.str:
        return pulumi.get(self, "dblink_username")

    @_builtins.property
    @pulumi.getter(name="isThinClone")
    def is_thin_clone(self) -> _builtins.bool:
        return pulumi.get(self, "is_thin_clone")

    @_builtins.property
    @pulumi.getter(name="refreshableCloneDetails")
    def refreshable_clone_details(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult']:
        return pulumi.get(self, "refreshable_clone_details")

    @_builtins.property
    @pulumi.getter(name="sourceContainerDatabaseAdminPassword")
    def source_container_database_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "source_container_database_admin_password")

    @_builtins.property
    @pulumi.getter(name="sourcePluggableDatabaseId")
    def source_pluggable_database_id(self) -> _builtins.str:
        return pulumi.get(self, "source_pluggable_database_id")

    @_builtins.property
    @pulumi.getter(name="sourcePluggableDatabaseSnapshotId")
    def source_pluggable_database_snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "source_pluggable_database_snapshot_id")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabasePdbCreationTypeDetailRefreshableCloneDetailResult(dict):
    def __init__(__self__, *,
                 is_refreshable_clone: _builtins.bool):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> _builtins.bool:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabasePdbNodeLevelDetailResult(dict):
    def __init__(__self__, *,
                 node_name: _builtins.str,
                 open_mode: _builtins.str):
        """
        :param _builtins.str node_name: The Node name of the Database Instance.
        :param _builtins.str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "open_mode", open_mode)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> _builtins.str:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: _builtins.str):
        """
        :param _builtins.str management_status: The status of the Pluggable Database Management service.
        """
        pulumi.set(__self__, "management_status", management_status)

    @_builtins.property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> _builtins.str:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabaseRefreshableCloneConfigResult(dict):
    def __init__(__self__, *,
                 is_refreshable_clone: _builtins.bool):
        """
        :param _builtins.bool is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @_builtins.property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> _builtins.bool:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")


@pulumi.output_type
class GetScheduledActionActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated patching time for the scheduled action.
        :param _builtins.str member_id: The ocid of the action member.
        :param _builtins.int member_order: The order of the action member in a scheduled action.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated patching time for the scheduled action.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The ocid of the action member.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The order of the action member in a scheduled action.
        """
        return pulumi.get(self, "member_order")


@pulumi.output_type
class GetScheduledActionParamsActionParamValuesCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetScheduledActionParamsActionParamValuesCollectionItemResult']):
        """
        :param Sequence['GetScheduledActionParamsActionParamValuesCollectionItemArgs'] items: List of Action Parameters and their possible values.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetScheduledActionParamsActionParamValuesCollectionItemResult']:
        """
        List of Action Parameters and their possible values.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetScheduledActionParamsActionParamValuesCollectionItemResult(dict):
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 is_required: _builtins.bool,
                 parameter_name: _builtins.str,
                 parameter_type: _builtins.str,
                 parameter_values: Sequence[_builtins.str]):
        """
        :param _builtins.str default_value: The default value for this parameter.
        :param _builtins.bool is_required: Whether this parameter is required or not for this action type.
        :param _builtins.str parameter_name: The name of this parameter.
        :param _builtins.str parameter_type: The type of the parameter.
        :param Sequence[_builtins.str] parameter_values: Possible values for this parameter. In case of integer it's min and max values.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "is_required", is_required)
        pulumi.set(__self__, "parameter_name", parameter_name)
        pulumi.set(__self__, "parameter_type", parameter_type)
        pulumi.set(__self__, "parameter_values", parameter_values)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> _builtins.bool:
        """
        Whether this parameter is required or not for this action type.
        """
        return pulumi.get(self, "is_required")

    @_builtins.property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> _builtins.str:
        """
        The name of this parameter.
        """
        return pulumi.get(self, "parameter_name")

    @_builtins.property
    @pulumi.getter(name="parameterType")
    def parameter_type(self) -> _builtins.str:
        """
        The type of the parameter.
        """
        return pulumi.get(self, "parameter_type")

    @_builtins.property
    @pulumi.getter(name="parameterValues")
    def parameter_values(self) -> Sequence[_builtins.str]:
        """
        Possible values for this parameter. In case of integer it's min and max values.
        """
        return pulumi.get(self, "parameter_values")


@pulumi.output_type
class GetScheduledActionParamsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetScheduledActionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetScheduledActionsScheduledActionCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetScheduledActionsScheduledActionCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetScheduledActionsScheduledActionCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetScheduledActionsScheduledActionCollectionItemResult(dict):
    def __init__(__self__, *,
                 action_members: Sequence['outputs.GetScheduledActionsScheduledActionCollectionItemActionMemberResult'],
                 action_order: _builtins.int,
                 action_params: Mapping[str, _builtins.str],
                 action_type: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 scheduling_plan_id: _builtins.str,
                 scheduling_window_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param Sequence['GetScheduledActionsScheduledActionCollectionItemActionMemberArgs'] action_members: The list of action members in a scheduled action.
        :param _builtins.int action_order: The order of the scheduled action.
        :param Mapping[str, _builtins.str] action_params: Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        :param _builtins.str action_type: The type of the scheduled action being performed
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.int estimated_time_in_mins: The estimated patching time for the scheduled action.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: A filter to return only resources that match the given Scheduled Action id exactly.
        :param _builtins.str scheduling_plan_id: A filter to return only resources that match the given scheduling policy id exactly.
        :param _builtins.str scheduling_window_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Scheduling Window.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Scheduled Action Resource was created.
        :param _builtins.str time_updated: The date and time the Scheduled Action Resource was updated.
        """
        pulumi.set(__self__, "action_members", action_members)
        pulumi.set(__self__, "action_order", action_order)
        pulumi.set(__self__, "action_params", action_params)
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "scheduling_plan_id", scheduling_plan_id)
        pulumi.set(__self__, "scheduling_window_id", scheduling_window_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="actionMembers")
    def action_members(self) -> Sequence['outputs.GetScheduledActionsScheduledActionCollectionItemActionMemberResult']:
        """
        The list of action members in a scheduled action.
        """
        return pulumi.get(self, "action_members")

    @_builtins.property
    @pulumi.getter(name="actionOrder")
    def action_order(self) -> _builtins.int:
        """
        The order of the scheduled action.
        """
        return pulumi.get(self, "action_order")

    @_builtins.property
    @pulumi.getter(name="actionParams")
    def action_params(self) -> Mapping[str, _builtins.str]:
        """
        Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        """
        return pulumi.get(self, "action_params")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The type of the scheduled action being performed
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated patching time for the scheduled action.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given Scheduled Action id exactly.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="schedulingPlanId")
    def scheduling_plan_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given scheduling policy id exactly.
        """
        return pulumi.get(self, "scheduling_plan_id")

    @_builtins.property
    @pulumi.getter(name="schedulingWindowId")
    def scheduling_window_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Scheduling Window.
        """
        return pulumi.get(self, "scheduling_window_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Scheduled Action Resource was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the Scheduled Action Resource was updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetScheduledActionsScheduledActionCollectionItemActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated patching time for the scheduled action.
        :param _builtins.str member_id: The ocid of the action member.
        :param _builtins.int member_order: The order of the action member in a scheduled action.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated patching time for the scheduled action.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The ocid of the action member.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The order of the action member in a scheduled action.
        """
        return pulumi.get(self, "member_order")


@pulumi.output_type
class GetSchedulingPlansFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSchedulingPlansSchedulingPlanCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSchedulingPlansSchedulingPlanCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSchedulingPlansSchedulingPlanCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSchedulingPlansSchedulingPlanCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_using_recommended_scheduled_actions: _builtins.bool,
                 lifecycle_details: _builtins.str,
                 plan_intent: _builtins.str,
                 resource_id: _builtins.str,
                 scheduling_policy_id: _builtins.str,
                 service_type: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.int estimated_time_in_mins: The estimated time for the Scheduling Plan.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: A filter to return only resources that match the given Schedule Plan id exactly.
        :param _builtins.bool is_using_recommended_scheduled_actions: If true, recommended scheduled actions will be generated for the scheduling plan.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str plan_intent: The current intent the Scheduling Plan. Valid states is EXADATA_INFRASTRUCTURE_FULL_SOFTWARE_UPDATE.
        :param _builtins.str resource_id: A filter to return only resources that match the given resource id exactly.
        :param _builtins.str scheduling_policy_id: A filter to return only resources that match the given scheduling policy id exactly.
        :param _builtins.str service_type: The service type of the Scheduling Plan.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time the Scheduling Plan Resource was created.
        :param _builtins.str time_updated: The date and time the Scheduling Plan Resource was updated.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_using_recommended_scheduled_actions", is_using_recommended_scheduled_actions)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "plan_intent", plan_intent)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "scheduling_policy_id", scheduling_policy_id)
        pulumi.set(__self__, "service_type", service_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated time for the Scheduling Plan.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given Schedule Plan id exactly.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isUsingRecommendedScheduledActions")
    def is_using_recommended_scheduled_actions(self) -> _builtins.bool:
        """
        If true, recommended scheduled actions will be generated for the scheduling plan.
        """
        return pulumi.get(self, "is_using_recommended_scheduled_actions")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="planIntent")
    def plan_intent(self) -> _builtins.str:
        """
        The current intent the Scheduling Plan. Valid states is EXADATA_INFRASTRUCTURE_FULL_SOFTWARE_UPDATE.
        """
        return pulumi.get(self, "plan_intent")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given resource id exactly.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicyId")
    def scheduling_policy_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the given scheduling policy id exactly.
        """
        return pulumi.get(self, "scheduling_policy_id")

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> _builtins.str:
        """
        The service type of the Scheduling Plan.
        """
        return pulumi.get(self, "service_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Scheduling Plan Resource was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the Scheduling Plan Resource was updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetSchedulingPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSchedulingPoliciesSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 cadence: _builtins.str,
                 cadence_start_months: Sequence['outputs.GetSchedulingPoliciesSchedulingPolicyCadenceStartMonthResult'],
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_next_window_starts: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str cadence: The cadence period.
        :param Sequence['GetSchedulingPoliciesSchedulingPolicyCadenceStartMonthArgs'] cadence_start_months: Start of the month to be followed during the cadence period.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Scheduling Policy.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the Scheduling Policy was created.
        :param _builtins.str time_next_window_starts: The date and time of the next scheduling window associated with the schedulingPolicy is planned to start.
        :param _builtins.str time_updated: The last date and time that the Scheduling Policy was updated.
        """
        pulumi.set(__self__, "cadence", cadence)
        pulumi.set(__self__, "cadence_start_months", cadence_start_months)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_next_window_starts", time_next_window_starts)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> _builtins.str:
        """
        The cadence period.
        """
        return pulumi.get(self, "cadence")

    @_builtins.property
    @pulumi.getter(name="cadenceStartMonths")
    def cadence_start_months(self) -> Sequence['outputs.GetSchedulingPoliciesSchedulingPolicyCadenceStartMonthResult']:
        """
        Start of the month to be followed during the cadence period.
        """
        return pulumi.get(self, "cadence_start_months")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Scheduling Policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Scheduling Policy was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeNextWindowStarts")
    def time_next_window_starts(self) -> _builtins.str:
        """
        The date and time of the next scheduling window associated with the schedulingPolicy is planned to start.
        """
        return pulumi.get(self, "time_next_window_starts")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the Scheduling Policy was updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetSchedulingPoliciesSchedulingPolicyCadenceStartMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSchedulingPolicyCadenceStartMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSchedulingPolicyRecommendedScheduledActionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemResult']):
        """
        :param Sequence['GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemArgs'] items: List of scheduled actions.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemResult']:
        """
        List of scheduled actions.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemResult(dict):
    def __init__(__self__, *,
                 action_members: Sequence['outputs.GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemActionMemberResult'],
                 action_order: _builtins.int,
                 action_params: Mapping[str, _builtins.str],
                 action_type: _builtins.str,
                 display_name: _builtins.str,
                 estimated_time_in_mins: _builtins.int,
                 scheduling_window_id: _builtins.str):
        """
        :param Sequence['GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemActionMemberArgs'] action_members: The list of action members in a scheduled action.
        :param _builtins.int action_order: The order of the scheduled action.
        :param Mapping[str, _builtins.str] action_params: Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        :param _builtins.str action_type: The type of the scheduled action being performed
        :param _builtins.str display_name: Description of the scheduled action being performed, i.e. apply full update to DB Servers 1,2,3,4.
        :param _builtins.int estimated_time_in_mins: The estimated patching time in minutes for the entire scheduled action.
        :param _builtins.str scheduling_window_id: The id of the scheduling window this scheduled action belongs to.
        """
        pulumi.set(__self__, "action_members", action_members)
        pulumi.set(__self__, "action_order", action_order)
        pulumi.set(__self__, "action_params", action_params)
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "scheduling_window_id", scheduling_window_id)

    @_builtins.property
    @pulumi.getter(name="actionMembers")
    def action_members(self) -> Sequence['outputs.GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemActionMemberResult']:
        """
        The list of action members in a scheduled action.
        """
        return pulumi.get(self, "action_members")

    @_builtins.property
    @pulumi.getter(name="actionOrder")
    def action_order(self) -> _builtins.int:
        """
        The order of the scheduled action.
        """
        return pulumi.get(self, "action_order")

    @_builtins.property
    @pulumi.getter(name="actionParams")
    def action_params(self) -> Mapping[str, _builtins.str]:
        """
        Map<ParamName, ParamValue> where a key value pair describes the specific action parameter. Example: `{"count": "3"}`
        """
        return pulumi.get(self, "action_params")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The type of the scheduled action being performed
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Description of the scheduled action being performed, i.e. apply full update to DB Servers 1,2,3,4.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated patching time in minutes for the entire scheduled action.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="schedulingWindowId")
    def scheduling_window_id(self) -> _builtins.str:
        """
        The id of the scheduling window this scheduled action belongs to.
        """
        return pulumi.get(self, "scheduling_window_id")


@pulumi.output_type
class GetSchedulingPolicyRecommendedScheduledActionsRecommendedScheduledActionsCollectionItemActionMemberResult(dict):
    def __init__(__self__, *,
                 estimated_time_in_mins: _builtins.int,
                 member_id: _builtins.str,
                 member_order: _builtins.int):
        """
        :param _builtins.int estimated_time_in_mins: The estimated patching time in minutes for the entire scheduled action.
        :param _builtins.str member_id: The ocid of the action member.
        :param _builtins.int member_order: The order of the action member in a scheduled action.
        """
        pulumi.set(__self__, "estimated_time_in_mins", estimated_time_in_mins)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "member_order", member_order)

    @_builtins.property
    @pulumi.getter(name="estimatedTimeInMins")
    def estimated_time_in_mins(self) -> _builtins.int:
        """
        The estimated patching time in minutes for the entire scheduled action.
        """
        return pulumi.get(self, "estimated_time_in_mins")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        The ocid of the action member.
        """
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="memberOrder")
    def member_order(self) -> _builtins.int:
        """
        The order of the action member in a scheduled action.
        """
        return pulumi.get(self, "member_order")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowWindowPreferenceResult(dict):
    def __init__(__self__, *,
                 days_of_weeks: Sequence['outputs.GetSchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeekResult'],
                 duration: _builtins.int,
                 is_enforced_duration: _builtins.bool,
                 months: Sequence['outputs.GetSchedulingPolicySchedulingWindowWindowPreferenceMonthResult'],
                 start_time: _builtins.str,
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['GetSchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeekArgs'] days_of_weeks: Days during the week when scheduling window should be performed.
        :param _builtins.int duration: Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        :param _builtins.bool is_enforced_duration: Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        :param Sequence['GetSchedulingPolicySchedulingWindowWindowPreferenceMonthArgs'] months: Months during the year when scheduled window should be performed.
        :param _builtins.str start_time: The scheduling window start time. The value must use the ISO-8601 format "hh:mm".
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when scheduled window should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow scheduling window during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Scheduling window cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and startTime parameters to allow you to specify specific days of the week and hours that scheduled window will be performed.
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "is_enforced_duration", is_enforced_duration)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetSchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeekResult']:
        """
        Days during the week when scheduling window should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="isEnforcedDuration")
    def is_enforced_duration(self) -> _builtins.bool:
        """
        Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_enforced_duration")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetSchedulingPolicySchedulingWindowWindowPreferenceMonthResult']:
        """
        Months during the year when scheduled window should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The scheduling window start time. The value must use the ISO-8601 format "hh:mm".
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when scheduled window should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow scheduling window during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Scheduling window cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and startTime parameters to allow you to specify specific days of the week and hours that scheduled window will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowWindowPreferenceDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowWindowPreferenceMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowsSchedulingWindowResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 scheduling_policy_id: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_next_scheduling_window_starts: _builtins.str,
                 time_updated: _builtins.str,
                 window_preferences: Sequence['outputs.GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceResult']):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Scheduling Window.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.str scheduling_policy_id: The Scheduling Policy [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_created: The date and time the Scheduling Window was created.
        :param _builtins.str time_next_scheduling_window_starts: The date and time of the next upcoming window associated within the schedulingWindow is planned to start.
        :param _builtins.str time_updated: The last date and time that the Scheduling Window was updated.
        :param Sequence['GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceArgs'] window_preferences: The Single Scheduling Window details.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "scheduling_policy_id", scheduling_policy_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_next_scheduling_window_starts", time_next_scheduling_window_starts)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "window_preferences", window_preferences)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Scheduling Window.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicyId")
    def scheduling_policy_id(self) -> _builtins.str:
        """
        The Scheduling Policy [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "scheduling_policy_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the Scheduling Window was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeNextSchedulingWindowStarts")
    def time_next_scheduling_window_starts(self) -> _builtins.str:
        """
        The date and time of the next upcoming window associated within the schedulingWindow is planned to start.
        """
        return pulumi.get(self, "time_next_scheduling_window_starts")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The last date and time that the Scheduling Window was updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="windowPreferences")
    def window_preferences(self) -> Sequence['outputs.GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceResult']:
        """
        The Single Scheduling Window details.
        """
        return pulumi.get(self, "window_preferences")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceResult(dict):
    def __init__(__self__, *,
                 days_of_weeks: Sequence['outputs.GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceDaysOfWeekResult'],
                 duration: _builtins.int,
                 is_enforced_duration: _builtins.bool,
                 months: Sequence['outputs.GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceMonthResult'],
                 start_time: _builtins.str,
                 weeks_of_months: Sequence[_builtins.int]):
        """
        :param Sequence['GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceDaysOfWeekArgs'] days_of_weeks: Days during the week when scheduling window should be performed.
        :param _builtins.int duration: Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        :param _builtins.bool is_enforced_duration: Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        :param Sequence['GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceMonthArgs'] months: Months during the year when scheduled window should be performed.
        :param _builtins.str start_time: The scheduling window start time. The value must use the ISO-8601 format "hh:mm".
        :param Sequence[_builtins.int] weeks_of_months: Weeks during the month when scheduled window should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow scheduling window during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Scheduling window cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and startTime parameters to allow you to specify specific days of the week and hours that scheduled window will be performed.
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "is_enforced_duration", is_enforced_duration)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceDaysOfWeekResult']:
        """
        Days during the week when scheduling window should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        Duration window allows user to set a duration they plan to allocate for Scheduling window. The duration is in minutes.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="isEnforcedDuration")
    def is_enforced_duration(self) -> _builtins.bool:
        """
        Indicates if duration the user plans to allocate for scheduling window is strictly enforced. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_enforced_duration")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceMonthResult']:
        """
        Months during the year when scheduled window should be performed.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The scheduling window start time. The value must use the ISO-8601 format "hh:mm".
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[_builtins.int]:
        """
        Weeks during the month when scheduled window should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow scheduling window during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Scheduling window cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and startTime parameters to allow you to specify specific days of the week and hours that scheduled window will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSchedulingPolicySchedulingWindowsSchedulingWindowWindowPreferenceMonthResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSystemVersionMinorVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionItemResult']):
        """
        :param Sequence['GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionItemArgs'] items: List of System minor versions.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionItemResult']:
        """
        List of System minor versions.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSystemVersionMinorVersionsSystemVersionMinorVersionCollectionItemResult(dict):
    def __init__(__self__, *,
                 version: _builtins.str):
        """
        :param _builtins.str version: A valid system minor version.
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A valid system minor version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSystemVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSystemVersionsSystemVersionCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSystemVersionsSystemVersionCollectionItemResult']):
        """
        :param Sequence['GetSystemVersionsSystemVersionCollectionItemArgs'] items: List of System versions.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSystemVersionsSystemVersionCollectionItemResult']:
        """
        List of System versions.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSystemVersionsSystemVersionCollectionItemResult(dict):
    def __init__(__self__, *,
                 gi_version: _builtins.str,
                 shape: _builtins.str,
                 system_versions: Sequence[_builtins.str]):
        """
        :param _builtins.str gi_version: Specifies gi version query parameter.
        :param _builtins.str shape: If provided, filters the results for the given shape.
        :param Sequence[_builtins.str] system_versions: Compatible Exadata system versions for a given shape and GI version.
        """
        pulumi.set(__self__, "gi_version", gi_version)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "system_versions", system_versions)

    @_builtins.property
    @pulumi.getter(name="giVersion")
    def gi_version(self) -> _builtins.str:
        """
        Specifies gi version query parameter.
        """
        return pulumi.get(self, "gi_version")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        If provided, filters the results for the given shape.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="systemVersions")
    def system_versions(self) -> Sequence[_builtins.str]:
        """
        Compatible Exadata system versions for a given shape and GI version.
        """
        return pulumi.get(self, "system_versions")


@pulumi.output_type
class GetVmClusterCloudAutomationUpdateDetailResult(dict):
    def __init__(__self__, *,
                 apply_update_time_preferences: Sequence['outputs.GetVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult'],
                 freeze_periods: Sequence['outputs.GetVmClusterCloudAutomationUpdateDetailFreezePeriodResult'],
                 is_early_adoption_enabled: _builtins.bool,
                 is_freeze_period_enabled: _builtins.bool):
        """
        :param Sequence['GetVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs'] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param Sequence['GetVmClusterCloudAutomationUpdateDetailFreezePeriodArgs'] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        pulumi.set(__self__, "freeze_periods", freeze_periods)
        pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Sequence['outputs.GetVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult']:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @_builtins.property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Sequence['outputs.GetVmClusterCloudAutomationUpdateDetailFreezePeriodResult']:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> _builtins.bool:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> _builtins.bool:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class GetVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult(dict):
    def __init__(__self__, *,
                 apply_update_preferred_end_time: _builtins.str,
                 apply_update_preferred_start_time: _builtins.str):
        """
        :param _builtins.str apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> _builtins.str:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> _builtins.str:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class GetVmClusterCloudAutomationUpdateDetailFreezePeriodResult(dict):
    def __init__(__self__, *,
                 freeze_period_end_time: _builtins.str,
                 freeze_period_start_time: _builtins.str):
        """
        :param _builtins.str freeze_period_end_time: End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: Start time of the freeze period cycle.
        """
        pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> _builtins.str:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> _builtins.str:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class GetVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetVmClusterFileSystemConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 file_system_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.int file_system_size_gb: The file system size to be allocated in GBs.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> _builtins.int:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


@pulumi.output_type
class GetVmClusterNetworkDrScanResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 scan_listener_port_tcp: _builtins.int):
        """
        :param _builtins.str hostname: The node host name.
        :param Sequence[_builtins.str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class GetVmClusterNetworkScanResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 port: _builtins.int,
                 scan_listener_port_tcp: _builtins.int,
                 scan_listener_port_tcp_ssl: _builtins.int):
        """
        :param _builtins.str hostname: The node host name.
        :param Sequence[_builtins.str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int port: **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp_ssl: The SCAN TCPIP SSL port. Default is 2484.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> _builtins.int:
        """
        The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class GetVmClusterNetworkVmNetworkResult(dict):
    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 gateway: _builtins.str,
                 netmask: _builtins.str,
                 network_type: _builtins.str,
                 nodes: Sequence['outputs.GetVmClusterNetworkVmNetworkNodeResult'],
                 vlan_id: _builtins.str):
        """
        :param _builtins.str domain_name: The network domain name.
        :param _builtins.str gateway: The network gateway.
        :param _builtins.str netmask: The network netmask.
        :param _builtins.str network_type: The network type.
        :param Sequence['GetVmClusterNetworkVmNetworkNodeArgs'] nodes: The list of node details.
        :param _builtins.str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetVmClusterNetworkVmNetworkNodeResult']:
        """
        The list of node details.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterNetworkVmNetworkNodeResult(dict):
    def __init__(__self__, *,
                 db_server_id: _builtins.str,
                 hostname: _builtins.str,
                 ip: _builtins.str,
                 state: _builtins.str,
                 vip: _builtins.str,
                 vip_hostname: _builtins.str):
        """
        :param _builtins.str db_server_id: The Db server associated with the node.
        :param _builtins.str hostname: The node host name.
        :param _builtins.str ip: The node IP address.
        :param _builtins.str state: The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param _builtins.str vip: The node virtual IP (VIP) address.
        :param _builtins.str vip_hostname: The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vip_hostname", vip_hostname)

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The node IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> _builtins.str:
        """
        The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class GetVmClusterNetworksFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 dns: Sequence[_builtins.str],
                 dr_scans: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkDrScanResult'],
                 exadata_infrastructure_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 ntps: Sequence[_builtins.str],
                 scans: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkScanResult'],
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 validate_vm_cluster_network: _builtins.bool,
                 vm_cluster_id: _builtins.str,
                 vm_networks: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkResult']):
        """
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Sequence[_builtins.str] dns: The list of DNS server IP addresses. Maximum of 3 allowed.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkDrScanArgs'] dr_scans: The SCAN details for DR network
        :param _builtins.str exadata_infrastructure_id: The Exadata infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[_builtins.str] ntps: The list of NTP server IP addresses. Maximum of 3 allowed.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkScanArgs'] scans: The SCAN details.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str time_created: The date and time when the VM cluster network was created.
        :param _builtins.str vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated VM Cluster.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkVmNetworkArgs'] vm_networks: Details of the client and backup networks.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dr_scans", dr_scans)
        pulumi.set(__self__, "exadata_infrastructure_id", exadata_infrastructure_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "ntps", ntps)
        pulumi.set(__self__, "scans", scans)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "validate_vm_cluster_network", validate_vm_cluster_network)
        pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)
        pulumi.set(__self__, "vm_networks", vm_networks)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        """
        The list of DNS server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="drScans")
    def dr_scans(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkDrScanResult']:
        """
        The SCAN details for DR network
        """
        return pulumi.get(self, "dr_scans")

    @_builtins.property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> _builtins.str:
        """
        The Exadata infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def ntps(self) -> Sequence[_builtins.str]:
        """
        The list of NTP server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "ntps")

    @_builtins.property
    @pulumi.getter
    def scans(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkScanResult']:
        """
        The SCAN details.
        """
        return pulumi.get(self, "scans")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time when the VM cluster network was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="validateVmClusterNetwork")
    def validate_vm_cluster_network(self) -> _builtins.bool:
        return pulumi.get(self, "validate_vm_cluster_network")

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated VM Cluster.
        """
        return pulumi.get(self, "vm_cluster_id")

    @_builtins.property
    @pulumi.getter(name="vmNetworks")
    def vm_networks(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkResult']:
        """
        Details of the client and backup networks.
        """
        return pulumi.get(self, "vm_networks")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkDrScanResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 scan_listener_port_tcp: _builtins.int):
        """
        :param _builtins.str hostname: The node host name.
        :param Sequence[_builtins.str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkScanResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 port: _builtins.int,
                 scan_listener_port_tcp: _builtins.int,
                 scan_listener_port_tcp_ssl: _builtins.int):
        """
        :param _builtins.str hostname: The node host name.
        :param Sequence[_builtins.str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int port: **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp_ssl: The SCAN TCPIP SSL port. Default is 2484.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> _builtins.int:
        """
        The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkVmNetworkResult(dict):
    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 gateway: _builtins.str,
                 netmask: _builtins.str,
                 network_type: _builtins.str,
                 nodes: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult'],
                 vlan_id: _builtins.str):
        """
        :param _builtins.str domain_name: The network domain name.
        :param _builtins.str gateway: The network gateway.
        :param _builtins.str netmask: The network netmask.
        :param _builtins.str network_type: The network type.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkVmNetworkNodeArgs'] nodes: The list of node details.
        :param _builtins.str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult']:
        """
        The list of node details.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult(dict):
    def __init__(__self__, *,
                 db_server_id: _builtins.str,
                 hostname: _builtins.str,
                 ip: _builtins.str,
                 state: _builtins.str,
                 vip: _builtins.str,
                 vip_hostname: _builtins.str):
        """
        :param _builtins.str db_server_id: The Db server associated with the node.
        :param _builtins.str hostname: The node host name.
        :param _builtins.str ip: The node IP address.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str vip: The node virtual IP (VIP) address.
        :param _builtins.str vip_hostname: The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vip_hostname", vip_hostname)

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The node IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> _builtins.str:
        """
        The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class GetVmClusterPatchHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterPatchHistoryEntriesPatchHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 patch_id: _builtins.str,
                 state: _builtins.str,
                 time_ended: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str action: The action being performed or was completed.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param _builtins.str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str state: The current state of the action.
        :param _builtins.str time_ended: The date and time when the patch action completed
        :param _builtins.str time_started: The date and time when the patch action started.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "patch_id", patch_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_ended", time_ended)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action being performed or was completed.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "patch_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the action.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> _builtins.str:
        """
        The date and time when the patch action completed
        """
        return pulumi.get(self, "time_ended")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the patch action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetVmClusterPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterPatchesPatchResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[_builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 last_action: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_released: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence[_builtins.str] available_actions: Actions that can possibly be performed using this patch.
        :param _builtins.str description: The text describing this patch package.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param _builtins.str last_action: Action that is currently being performed or was completed last.
        :param _builtins.str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param _builtins.str state: The current state of the patch as a result of lastAction.
        :param _builtins.str time_released: The date and time that the patch was released.
        :param _builtins.str version: The version of this patch package.
        """
        pulumi.set(__self__, "available_actions", available_actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_action", last_action)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[_builtins.str]:
        """
        Actions that can possibly be performed using this patch.
        """
        return pulumi.get(self, "available_actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> _builtins.str:
        """
        Action that is currently being performed or was completed last.
        """
        return pulumi.get(self, "last_action")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVmClusterRecommendedNetworkDrScanResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 scan_listener_port_tcp: _builtins.int):
        """
        :param _builtins.str hostname: The node host name.
        :param Sequence[_builtins.str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class GetVmClusterRecommendedNetworkNetworkResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 domain: _builtins.str,
                 gateway: _builtins.str,
                 netmask: _builtins.str,
                 network_type: _builtins.str,
                 prefix: _builtins.str,
                 vlan_id: _builtins.str):
        """
        :param _builtins.str cidr: The cidr for the network.
        :param _builtins.str domain: The network domain name.
        :param _builtins.str gateway: The network gateway.
        :param _builtins.str netmask: The network netmask.
        :param _builtins.str network_type: The network type.
        :param _builtins.str prefix: The network domain name.
        :param _builtins.str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        The cidr for the network.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        The network domain name.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterRecommendedNetworkScanResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 ips: Sequence[_builtins.str],
                 port: _builtins.int,
                 scan_listener_port_tcp: _builtins.int,
                 scan_listener_port_tcp_ssl: _builtins.int):
        """
        :param _builtins.str hostname: The node host name.
        :param Sequence[_builtins.str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param _builtins.int port: **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        :param _builtins.int scan_listener_port_tcp_ssl: The SCAN TCPIP SSL port. Default is 2484.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> _builtins.int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @_builtins.property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> _builtins.int:
        """
        The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class GetVmClusterRecommendedNetworkVmNetworkResult(dict):
    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 gateway: _builtins.str,
                 netmask: _builtins.str,
                 network_type: _builtins.str,
                 nodes: Sequence['outputs.GetVmClusterRecommendedNetworkVmNetworkNodeResult'],
                 vlan_id: _builtins.str):
        """
        :param _builtins.str domain_name: The network domain name.
        :param _builtins.str gateway: The network gateway.
        :param _builtins.str netmask: The network netmask.
        :param _builtins.str network_type: The network type.
        :param Sequence['GetVmClusterRecommendedNetworkVmNetworkNodeArgs'] nodes: The list of node details.
        :param _builtins.str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetVmClusterRecommendedNetworkVmNetworkNodeResult']:
        """
        The list of node details.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterRecommendedNetworkVmNetworkNodeResult(dict):
    def __init__(__self__, *,
                 db_server_id: _builtins.str,
                 hostname: _builtins.str,
                 ip: _builtins.str,
                 state: _builtins.str,
                 vip: _builtins.str,
                 vip_hostname: _builtins.str):
        """
        :param _builtins.str db_server_id: The Db server associated with the node.
        :param _builtins.str hostname: The node host name.
        :param _builtins.str ip: The node IP address.
        :param _builtins.str state: The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param _builtins.str vip: The node virtual IP (VIP) address.
        :param _builtins.str vip_hostname: The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vip_hostname", vip_hostname)

    @_builtins.property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> _builtins.str:
        """
        The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The node IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def vip(self) -> _builtins.str:
        """
        The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @_builtins.property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> _builtins.str:
        """
        The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class GetVmClusterUpdateHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterUpdateHistoryEntriesVmClusterUpdateHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_completed: _builtins.str,
                 time_started: _builtins.str,
                 update_action: _builtins.str,
                 update_id: _builtins.str,
                 update_type: _builtins.str):
        """
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update history entry.
        :param _builtins.str lifecycle_details: Descriptive text providing additional details about the lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_completed: The date and time when the maintenance update action completed.
        :param _builtins.str time_started: The date and time when the maintenance update action started.
        :param _builtins.str update_action: The update action performed using this maintenance update.
        :param _builtins.str update_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        :param _builtins.str update_type: A filter to return only resources that match the given update type exactly.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_completed", time_completed)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "update_action", update_action)
        pulumi.set(__self__, "update_id", update_id)
        pulumi.set(__self__, "update_type", update_type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update history entry.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Descriptive text providing additional details about the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCompleted")
    def time_completed(self) -> _builtins.str:
        """
        The date and time when the maintenance update action completed.
        """
        return pulumi.get(self, "time_completed")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        The date and time when the maintenance update action started.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="updateAction")
    def update_action(self) -> _builtins.str:
        """
        The update action performed using this maintenance update.
        """
        return pulumi.get(self, "update_action")

    @_builtins.property
    @pulumi.getter(name="updateId")
    def update_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        """
        return pulumi.get(self, "update_id")

    @_builtins.property
    @pulumi.getter(name="updateType")
    def update_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given update type exactly.
        """
        return pulumi.get(self, "update_type")


@pulumi.output_type
class GetVmClusterUpdatesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterUpdatesVmClusterUpdateResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[_builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 last_action: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 time_released: _builtins.str,
                 update_type: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence[_builtins.str] available_actions: The possible actions that can be performed using this maintenance update.
        :param _builtins.str description: Details of the maintenance update package.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        :param _builtins.str last_action: The update action performed most recently using this maintenance update.
        :param _builtins.str lifecycle_details: Descriptive text providing additional details about the lifecycle state.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str time_released: The date and time the maintenance update was released.
        :param _builtins.str update_type: A filter to return only resources that match the given update type exactly.
        :param _builtins.str version: The version of the maintenance update package.
        """
        pulumi.set(__self__, "available_actions", available_actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_action", last_action)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "update_type", update_type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[_builtins.str]:
        """
        The possible actions that can be performed using this maintenance update.
        """
        return pulumi.get(self, "available_actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Details of the maintenance update package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> _builtins.str:
        """
        The update action performed most recently using this maintenance update.
        """
        return pulumi.get(self, "last_action")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Descriptive text providing additional details about the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The date and time the maintenance update was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter(name="updateType")
    def update_type(self) -> _builtins.str:
        """
        A filter to return only resources that match the given update type exactly.
        """
        return pulumi.get(self, "update_type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the maintenance update package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClustersVmClusterResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 cloud_automation_update_details: Sequence['outputs.GetVmClustersVmClusterCloudAutomationUpdateDetailResult'],
                 compartment_id: _builtins.str,
                 compute_model: _builtins.str,
                 cpu_core_count: _builtins.int,
                 cpus_enabled: _builtins.int,
                 data_collection_options: Sequence['outputs.GetVmClustersVmClusterDataCollectionOptionResult'],
                 data_storage_size_in_gb: _builtins.float,
                 data_storage_size_in_tbs: _builtins.float,
                 db_node_storage_size_in_gbs: _builtins.int,
                 db_servers: Sequence[_builtins.str],
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 exadata_infrastructure_id: _builtins.str,
                 exascale_db_storage_vault_id: _builtins.str,
                 file_system_configuration_details: Sequence['outputs.GetVmClustersVmClusterFileSystemConfigurationDetailResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 gi_version: _builtins.str,
                 id: _builtins.str,
                 is_local_backup_enabled: _builtins.bool,
                 is_sparse_diskgroup_enabled: _builtins.bool,
                 last_patch_history_entry_id: _builtins.str,
                 license_model: _builtins.str,
                 lifecycle_details: _builtins.str,
                 memory_size_in_gbs: _builtins.int,
                 ocpu_count: _builtins.float,
                 ocpus_enabled: _builtins.float,
                 shape: _builtins.str,
                 ssh_public_keys: Sequence[_builtins.str],
                 state: _builtins.str,
                 storage_management_type: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 system_version: _builtins.str,
                 time_created: _builtins.str,
                 time_zone: _builtins.str,
                 vm_cluster_network_id: _builtins.str,
                 vm_cluster_type: _builtins.str):
        """
        :param _builtins.str availability_domain: The name of the availability domain that the VM cluster is located in.
        :param Sequence['GetVmClustersVmClusterCloudAutomationUpdateDetailArgs'] cloud_automation_update_details: Specifies the properties necessary for cloud automation updates. This includes modifying the apply update time preference, enabling or disabling early adoption, and enabling, modifying, or disabling the update freeze period.
        :param _builtins.str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        :param _builtins.int cpus_enabled: The number of enabled CPU cores.
        :param Sequence['GetVmClustersVmClusterDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param _builtins.float data_storage_size_in_gb: Size of the DATA disk group in GBs.
        :param _builtins.float data_storage_size_in_tbs: Size, in terabytes, of the DATA disk group.
        :param _builtins.int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param Sequence[_builtins.str] db_servers: The list of Db server.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param _builtins.str exadata_infrastructure_id: If provided, filters the results for the given Exadata Infrastructure.
        :param _builtins.str exascale_db_storage_vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata Database Storage Vault.
        :param Sequence['GetVmClustersVmClusterFileSystemConfigurationDetailArgs'] file_system_configuration_details: Details of the file system configuration of the VM cluster.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param _builtins.str gi_version: The Oracle Grid Infrastructure software version for the VM cluster.
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        :param _builtins.bool is_local_backup_enabled: If true, database backup on local Exadata storage is configured for the VM cluster. If false, database backup on local Exadata storage is not available in the VM cluster.
        :param _builtins.bool is_sparse_diskgroup_enabled: If true, sparse disk group is configured for the VM cluster. If false, sparse disk group is not created.
        :param _builtins.str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param _builtins.str license_model: The Oracle license model that applies to the VM cluster. The default is LICENSE_INCLUDED.
        :param _builtins.str lifecycle_details: Additional information about the current lifecycle state.
        :param _builtins.int memory_size_in_gbs: The memory allocated in GBs.
        :param _builtins.str shape: The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        :param Sequence[_builtins.str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the VM cluster.
        :param _builtins.str state: A filter to return only resources that match the given lifecycle state exactly.
        :param _builtins.str storage_management_type: Specifies whether the type of storage management for the VM cluster is ASM or Exascale.
        :param Mapping[str, _builtins.str] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param _builtins.str system_version: Operating system version of the image.
        :param _builtins.str time_created: The date and time that the VM cluster was created.
        :param _builtins.str time_zone: The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param _builtins.str vm_cluster_network_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        :param _builtins.str vm_cluster_type: A filter to return only vmclusters that match the given vmcluster type exactly.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "cloud_automation_update_details", cloud_automation_update_details)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_model", compute_model)
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "cpus_enabled", cpus_enabled)
        pulumi.set(__self__, "data_collection_options", data_collection_options)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        pulumi.set(__self__, "db_servers", db_servers)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "exadata_infrastructure_id", exadata_infrastructure_id)
        pulumi.set(__self__, "exascale_db_storage_vault_id", exascale_db_storage_vault_id)
        pulumi.set(__self__, "file_system_configuration_details", file_system_configuration_details)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "gi_version", gi_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_local_backup_enabled", is_local_backup_enabled)
        pulumi.set(__self__, "is_sparse_diskgroup_enabled", is_sparse_diskgroup_enabled)
        pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        pulumi.set(__self__, "license_model", license_model)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        pulumi.set(__self__, "ocpus_enabled", ocpus_enabled)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_management_type", storage_management_type)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "system_version", system_version)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "vm_cluster_network_id", vm_cluster_network_id)
        pulumi.set(__self__, "vm_cluster_type", vm_cluster_type)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain that the VM cluster is located in.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="cloudAutomationUpdateDetails")
    def cloud_automation_update_details(self) -> Sequence['outputs.GetVmClustersVmClusterCloudAutomationUpdateDetailResult']:
        """
        Specifies the properties necessary for cloud automation updates. This includes modifying the apply update time preference, enabling or disabling early adoption, and enabling, modifying, or disabling the update freeze period.
        """
        return pulumi.get(self, "cloud_automation_update_details")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> _builtins.str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value. ECPU compute model is the recommended model and OCPU compute model is legacy.
        """
        return pulumi.get(self, "compute_model")

    @_builtins.property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> _builtins.int:
        return pulumi.get(self, "cpu_core_count")

    @_builtins.property
    @pulumi.getter(name="cpusEnabled")
    def cpus_enabled(self) -> _builtins.int:
        """
        The number of enabled CPU cores.
        """
        return pulumi.get(self, "cpus_enabled")

    @_builtins.property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetVmClustersVmClusterDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> _builtins.float:
        """
        Size of the DATA disk group in GBs.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> _builtins.float:
        """
        Size, in terabytes, of the DATA disk group.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @_builtins.property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> _builtins.int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[_builtins.str]:
        """
        The list of Db server.
        """
        return pulumi.get(self, "db_servers")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> _builtins.str:
        """
        If provided, filters the results for the given Exadata Infrastructure.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @_builtins.property
    @pulumi.getter(name="exascaleDbStorageVaultId")
    def exascale_db_storage_vault_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata Database Storage Vault.
        """
        return pulumi.get(self, "exascale_db_storage_vault_id")

    @_builtins.property
    @pulumi.getter(name="fileSystemConfigurationDetails")
    def file_system_configuration_details(self) -> Sequence['outputs.GetVmClustersVmClusterFileSystemConfigurationDetailResult']:
        """
        Details of the file system configuration of the VM cluster.
        """
        return pulumi.get(self, "file_system_configuration_details")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter(name="giVersion")
    def gi_version(self) -> _builtins.str:
        """
        The Oracle Grid Infrastructure software version for the VM cluster.
        """
        return pulumi.get(self, "gi_version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isLocalBackupEnabled")
    def is_local_backup_enabled(self) -> _builtins.bool:
        """
        If true, database backup on local Exadata storage is configured for the VM cluster. If false, database backup on local Exadata storage is not available in the VM cluster.
        """
        return pulumi.get(self, "is_local_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="isSparseDiskgroupEnabled")
    def is_sparse_diskgroup_enabled(self) -> _builtins.bool:
        """
        If true, sparse disk group is configured for the VM cluster. If false, sparse disk group is not created.
        """
        return pulumi.get(self, "is_sparse_diskgroup_enabled")

    @_builtins.property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> _builtins.str:
        """
        The Oracle license model that applies to the VM cluster. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> _builtins.int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> _builtins.float:
        return pulumi.get(self, "ocpu_count")

    @_builtins.property
    @pulumi.getter(name="ocpusEnabled")
    def ocpus_enabled(self) -> _builtins.float:
        return pulumi.get(self, "ocpus_enabled")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[_builtins.str]:
        """
        The public key portion of one or more key pairs used for SSH access to the VM cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageManagementType")
    def storage_management_type(self) -> _builtins.str:
        """
        Specifies whether the type of storage management for the VM cluster is ASM or Exascale.
        """
        return pulumi.get(self, "storage_management_type")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="systemVersion")
    def system_version(self) -> _builtins.str:
        """
        Operating system version of the image.
        """
        return pulumi.get(self, "system_version")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time that the VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="vmClusterNetworkId")
    def vm_cluster_network_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        return pulumi.get(self, "vm_cluster_network_id")

    @_builtins.property
    @pulumi.getter(name="vmClusterType")
    def vm_cluster_type(self) -> _builtins.str:
        """
        A filter to return only vmclusters that match the given vmcluster type exactly.
        """
        return pulumi.get(self, "vm_cluster_type")


@pulumi.output_type
class GetVmClustersVmClusterCloudAutomationUpdateDetailResult(dict):
    def __init__(__self__, *,
                 apply_update_time_preferences: Sequence['outputs.GetVmClustersVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult'],
                 freeze_periods: Sequence['outputs.GetVmClustersVmClusterCloudAutomationUpdateDetailFreezePeriodResult'],
                 is_early_adoption_enabled: _builtins.bool,
                 is_freeze_period_enabled: _builtins.bool):
        """
        :param Sequence['GetVmClustersVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs'] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param Sequence['GetVmClustersVmClusterCloudAutomationUpdateDetailFreezePeriodArgs'] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param _builtins.bool is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param _builtins.bool is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        pulumi.set(__self__, "freeze_periods", freeze_periods)
        pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @_builtins.property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Sequence['outputs.GetVmClustersVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult']:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @_builtins.property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Sequence['outputs.GetVmClustersVmClusterCloudAutomationUpdateDetailFreezePeriodResult']:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @_builtins.property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> _builtins.bool:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @_builtins.property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> _builtins.bool:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")


@pulumi.output_type
class GetVmClustersVmClusterCloudAutomationUpdateDetailApplyUpdateTimePreferenceResult(dict):
    def __init__(__self__, *,
                 apply_update_preferred_end_time: _builtins.str,
                 apply_update_preferred_start_time: _builtins.str):
        """
        :param _builtins.str apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param _builtins.str apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> _builtins.str:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @_builtins.property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> _builtins.str:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")


@pulumi.output_type
class GetVmClustersVmClusterCloudAutomationUpdateDetailFreezePeriodResult(dict):
    def __init__(__self__, *,
                 freeze_period_end_time: _builtins.str,
                 freeze_period_start_time: _builtins.str):
        """
        :param _builtins.str freeze_period_end_time: End time of the freeze period cycle.
        :param _builtins.str freeze_period_start_time: Start time of the freeze period cycle.
        """
        pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @_builtins.property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> _builtins.str:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @_builtins.property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> _builtins.str:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")


@pulumi.output_type
class GetVmClustersVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: _builtins.bool,
                 is_health_monitoring_enabled: _builtins.bool,
                 is_incident_logs_enabled: _builtins.bool):
        """
        :param _builtins.bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param _builtins.bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param _builtins.bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> _builtins.bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> _builtins.bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> _builtins.bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetVmClustersVmClusterFileSystemConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 file_system_size_gb: _builtins.int,
                 mount_point: _builtins.str):
        """
        :param _builtins.int file_system_size_gb: The file system size to be allocated in GBs.
        :param _builtins.str mount_point: The mount point of file system.
        """
        pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        pulumi.set(__self__, "mount_point", mount_point)

    @_builtins.property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> _builtins.int:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @_builtins.property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> _builtins.str:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")


