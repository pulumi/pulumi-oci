# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlertPolicyAlertPolicyRuleDetailArgs',
    'AlertPolicyAlertPolicyRuleDetailArgsDict',
    'AuditPolicyAuditConditionArgs',
    'AuditPolicyAuditConditionArgsDict',
    'AuditPolicyAuditConditionEnableConditionArgs',
    'AuditPolicyAuditConditionEnableConditionArgsDict',
    'AuditPolicyAuditSpecificationArgs',
    'AuditPolicyAuditSpecificationArgsDict',
    'AuditPolicyManagementAuditConditionArgs',
    'AuditPolicyManagementAuditConditionArgsDict',
    'AuditPolicyManagementAuditConditionEnableConditionArgs',
    'AuditPolicyManagementAuditConditionEnableConditionArgsDict',
    'AuditPolicyManagementAuditSpecificationArgs',
    'AuditPolicyManagementAuditSpecificationArgsDict',
    'AuditProfileAuditTrailArgs',
    'AuditProfileAuditTrailArgsDict',
    'CalculateAuditVolumeAvailableAvailableAuditVolumeArgs',
    'CalculateAuditVolumeAvailableAvailableAuditVolumeArgsDict',
    'CalculateAuditVolumeCollectedCollectedAuditVolumeArgs',
    'CalculateAuditVolumeCollectedCollectedAuditVolumeArgsDict',
    'DataSafeConfigurationGlobalSettingArgs',
    'DataSafeConfigurationGlobalSettingArgsDict',
    'DatabaseSecurityConfigManagementSqlFirewallConfigArgs',
    'DatabaseSecurityConfigManagementSqlFirewallConfigArgsDict',
    'DatabaseSecurityConfigSqlFirewallConfigArgs',
    'DatabaseSecurityConfigSqlFirewallConfigArgsDict',
    'DiscoveryJobsResultModifiedAttributeArgs',
    'DiscoveryJobsResultModifiedAttributeArgsDict',
    'DiscoveryModTablesForDiscoveryArgs',
    'DiscoveryModTablesForDiscoveryArgsDict',
    'LibraryMasingFormatFormatEntryArgs',
    'LibraryMasingFormatFormatEntryArgsDict',
    'MaskingPoliciesMaskingColumnMaskingFormatArgs',
    'MaskingPoliciesMaskingColumnMaskingFormatArgsDict',
    'MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs',
    'MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgsDict',
    'MaskingPolicyColumnSourceArgs',
    'MaskingPolicyColumnSourceArgsDict',
    'ReportDefinitionColumnFilterArgs',
    'ReportDefinitionColumnFilterArgsDict',
    'ReportDefinitionColumnInfoArgs',
    'ReportDefinitionColumnInfoArgsDict',
    'ReportDefinitionColumnSortingArgs',
    'ReportDefinitionColumnSortingArgsDict',
    'ReportDefinitionSummaryArgs',
    'ReportDefinitionSummaryArgsDict',
    'SecurityAssessmentStatisticArgs',
    'SecurityAssessmentStatisticArgsDict',
    'SecurityAssessmentStatisticAdvisoryArgs',
    'SecurityAssessmentStatisticAdvisoryArgsDict',
    'SecurityAssessmentStatisticDeferredArgs',
    'SecurityAssessmentStatisticDeferredArgsDict',
    'SecurityAssessmentStatisticEvaluateArgs',
    'SecurityAssessmentStatisticEvaluateArgsDict',
    'SecurityAssessmentStatisticHighRiskArgs',
    'SecurityAssessmentStatisticHighRiskArgsDict',
    'SecurityAssessmentStatisticLowRiskArgs',
    'SecurityAssessmentStatisticLowRiskArgsDict',
    'SecurityAssessmentStatisticMediumRiskArgs',
    'SecurityAssessmentStatisticMediumRiskArgsDict',
    'SecurityAssessmentStatisticPassArgs',
    'SecurityAssessmentStatisticPassArgsDict',
    'SensitiveDataModelReferentialRelationChildArgs',
    'SensitiveDataModelReferentialRelationChildArgsDict',
    'SensitiveDataModelReferentialRelationParentArgs',
    'SensitiveDataModelReferentialRelationParentArgsDict',
    'SensitiveDataModelTablesForDiscoveryArgs',
    'SensitiveDataModelTablesForDiscoveryArgsDict',
    'SensitiveTypeGroupGroupedSensitiveTypeItemArgs',
    'SensitiveTypeGroupGroupedSensitiveTypeItemArgsDict',
    'SensitiveTypeGroupGroupedSensitiveTypePatchOperationArgs',
    'SensitiveTypeGroupGroupedSensitiveTypePatchOperationArgsDict',
    'TargetDatabaseConnectionOptionArgs',
    'TargetDatabaseConnectionOptionArgsDict',
    'TargetDatabaseCredentialsArgs',
    'TargetDatabaseCredentialsArgsDict',
    'TargetDatabaseDatabaseDetailsArgs',
    'TargetDatabaseDatabaseDetailsArgsDict',
    'TargetDatabasePeerTargetDatabaseArgs',
    'TargetDatabasePeerTargetDatabaseArgsDict',
    'TargetDatabasePeerTargetDatabaseDatabaseDetailArgs',
    'TargetDatabasePeerTargetDatabaseDatabaseDetailArgsDict',
    'TargetDatabasePeerTargetDatabaseDatabaseDetailsArgs',
    'TargetDatabasePeerTargetDatabaseDatabaseDetailsArgsDict',
    'TargetDatabasePeerTargetDatabaseDetailArgs',
    'TargetDatabasePeerTargetDatabaseDetailArgsDict',
    'TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgs',
    'TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgsDict',
    'TargetDatabasePeerTargetDatabaseDetailTlsConfigArgs',
    'TargetDatabasePeerTargetDatabaseDetailTlsConfigArgsDict',
    'TargetDatabasePeerTargetDatabaseTlsConfigArgs',
    'TargetDatabasePeerTargetDatabaseTlsConfigArgsDict',
    'TargetDatabaseTlsConfigArgs',
    'TargetDatabaseTlsConfigArgsDict',
    'UserAssessmentIgnoredTargetArgs',
    'UserAssessmentIgnoredTargetArgsDict',
    'GetAlertPoliciesFilterArgs',
    'GetAlertPoliciesFilterArgsDict',
    'GetAlertPolicyRulesFilterArgs',
    'GetAlertPolicyRulesFilterArgsDict',
    'GetAlertsFilterArgs',
    'GetAlertsFilterArgsDict',
    'GetAuditArchiveRetrievalsFilterArgs',
    'GetAuditArchiveRetrievalsFilterArgsDict',
    'GetAuditEventsFilterArgs',
    'GetAuditEventsFilterArgsDict',
    'GetAuditPoliciesFilterArgs',
    'GetAuditPoliciesFilterArgsDict',
    'GetAuditProfileAvailableAuditVolumesFilterArgs',
    'GetAuditProfileAvailableAuditVolumesFilterArgsDict',
    'GetAuditProfileCollectedAuditVolumesFilterArgs',
    'GetAuditProfileCollectedAuditVolumesFilterArgsDict',
    'GetAuditProfilesFilterArgs',
    'GetAuditProfilesFilterArgsDict',
    'GetAuditTrailsFilterArgs',
    'GetAuditTrailsFilterArgsDict',
    'GetDataSafePrivateEndpointsFilterArgs',
    'GetDataSafePrivateEndpointsFilterArgsDict',
    'GetDatabaseSecurityConfigsFilterArgs',
    'GetDatabaseSecurityConfigsFilterArgsDict',
    'GetDiscoveryAnalyticsFilterArgs',
    'GetDiscoveryAnalyticsFilterArgsDict',
    'GetDiscoveryJobsResultsFilterArgs',
    'GetDiscoveryJobsResultsFilterArgsDict',
    'GetLibraryMaskingFormatsFilterArgs',
    'GetLibraryMaskingFormatsFilterArgsDict',
    'GetListUserGrantsFilterArgs',
    'GetListUserGrantsFilterArgsDict',
    'GetMaskingAnalyticsFilterArgs',
    'GetMaskingAnalyticsFilterArgsDict',
    'GetMaskingPoliciesFilterArgs',
    'GetMaskingPoliciesFilterArgsDict',
    'GetMaskingPoliciesMaskingColumnsFilterArgs',
    'GetMaskingPoliciesMaskingColumnsFilterArgsDict',
    'GetMaskingPolicyHealthReportLogsFilterArgs',
    'GetMaskingPolicyHealthReportLogsFilterArgsDict',
    'GetMaskingPolicyHealthReportsFilterArgs',
    'GetMaskingPolicyHealthReportsFilterArgsDict',
    'GetMaskingPolicyMaskingObjectsFilterArgs',
    'GetMaskingPolicyMaskingObjectsFilterArgsDict',
    'GetMaskingPolicyMaskingSchemasFilterArgs',
    'GetMaskingPolicyMaskingSchemasFilterArgsDict',
    'GetMaskingPolicyReferentialRelationsFilterArgs',
    'GetMaskingPolicyReferentialRelationsFilterArgsDict',
    'GetMaskingReportMaskedColumnsFilterArgs',
    'GetMaskingReportMaskedColumnsFilterArgsDict',
    'GetMaskingReportMaskingErrorsFilterArgs',
    'GetMaskingReportMaskingErrorsFilterArgsDict',
    'GetMaskingReportsFilterArgs',
    'GetMaskingReportsFilterArgsDict',
    'GetOnpremConnectorsFilterArgs',
    'GetOnpremConnectorsFilterArgsDict',
    'GetReportDefinitionsFilterArgs',
    'GetReportDefinitionsFilterArgsDict',
    'GetReportsFilterArgs',
    'GetReportsFilterArgsDict',
    'GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterArgs',
    'GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterArgsDict',
    'GetSdmMaskingPolicyDifferencesFilterArgs',
    'GetSdmMaskingPolicyDifferencesFilterArgsDict',
    'GetSecurityAssessmentFindingAnalyticsFilterArgs',
    'GetSecurityAssessmentFindingAnalyticsFilterArgsDict',
    'GetSecurityAssessmentFindingFilterArgs',
    'GetSecurityAssessmentFindingFilterArgsDict',
    'GetSecurityAssessmentFindingsChangeAuditLogsFilterArgs',
    'GetSecurityAssessmentFindingsChangeAuditLogsFilterArgsDict',
    'GetSecurityAssessmentFindingsFilterArgs',
    'GetSecurityAssessmentFindingsFilterArgsDict',
    'GetSecurityAssessmentSecurityFeatureAnalyticsFilterArgs',
    'GetSecurityAssessmentSecurityFeatureAnalyticsFilterArgsDict',
    'GetSecurityAssessmentSecurityFeaturesFilterArgs',
    'GetSecurityAssessmentSecurityFeaturesFilterArgsDict',
    'GetSecurityAssessmentsFilterArgs',
    'GetSecurityAssessmentsFilterArgsDict',
    'GetSecurityPoliciesFilterArgs',
    'GetSecurityPoliciesFilterArgsDict',
    'GetSecurityPolicyDeploymentSecurityPolicyEntryStatesFilterArgs',
    'GetSecurityPolicyDeploymentSecurityPolicyEntryStatesFilterArgsDict',
    'GetSecurityPolicyDeploymentsFilterArgs',
    'GetSecurityPolicyDeploymentsFilterArgsDict',
    'GetSecurityPolicyReportDatabaseTableAccessEntriesFilterArgs',
    'GetSecurityPolicyReportDatabaseTableAccessEntriesFilterArgsDict',
    'GetSecurityPolicyReportDatabaseViewAccessEntriesFilterArgs',
    'GetSecurityPolicyReportDatabaseViewAccessEntriesFilterArgsDict',
    'GetSecurityPolicyReportRoleGrantPathsFilterArgs',
    'GetSecurityPolicyReportRoleGrantPathsFilterArgsDict',
    'GetSecurityPolicyReportsFilterArgs',
    'GetSecurityPolicyReportsFilterArgsDict',
    'GetSensitiveColumnAnalyticsFilterArgs',
    'GetSensitiveColumnAnalyticsFilterArgsDict',
    'GetSensitiveDataModelReferentialRelationsFilterArgs',
    'GetSensitiveDataModelReferentialRelationsFilterArgsDict',
    'GetSensitiveDataModelSensitiveObjectsFilterArgs',
    'GetSensitiveDataModelSensitiveObjectsFilterArgsDict',
    'GetSensitiveDataModelSensitiveSchemasFilterArgs',
    'GetSensitiveDataModelSensitiveSchemasFilterArgsDict',
    'GetSensitiveDataModelSensitiveTypesFilterArgs',
    'GetSensitiveDataModelSensitiveTypesFilterArgsDict',
    'GetSensitiveDataModelsFilterArgs',
    'GetSensitiveDataModelsFilterArgsDict',
    'GetSensitiveDataModelsSensitiveColumnsFilterArgs',
    'GetSensitiveDataModelsSensitiveColumnsFilterArgsDict',
    'GetSensitiveTypeGroupGroupedSensitiveTypesFilterArgs',
    'GetSensitiveTypeGroupGroupedSensitiveTypesFilterArgsDict',
    'GetSensitiveTypeGroupsFilterArgs',
    'GetSensitiveTypeGroupsFilterArgsDict',
    'GetSensitiveTypesExportsFilterArgs',
    'GetSensitiveTypesExportsFilterArgsDict',
    'GetSensitiveTypesFilterArgs',
    'GetSensitiveTypesFilterArgsDict',
    'GetSqlCollectionAnalyticsFilterArgs',
    'GetSqlCollectionAnalyticsFilterArgsDict',
    'GetSqlCollectionLogInsightsFilterArgs',
    'GetSqlCollectionLogInsightsFilterArgsDict',
    'GetSqlCollectionsFilterArgs',
    'GetSqlCollectionsFilterArgsDict',
    'GetSqlFirewallAllowedSqlAnalyticsFilterArgs',
    'GetSqlFirewallAllowedSqlAnalyticsFilterArgsDict',
    'GetSqlFirewallAllowedSqlsFilterArgs',
    'GetSqlFirewallAllowedSqlsFilterArgsDict',
    'GetSqlFirewallPoliciesFilterArgs',
    'GetSqlFirewallPoliciesFilterArgsDict',
    'GetSqlFirewallPolicyAnalyticsFilterArgs',
    'GetSqlFirewallPolicyAnalyticsFilterArgsDict',
    'GetSqlFirewallViolationAnalyticsFilterArgs',
    'GetSqlFirewallViolationAnalyticsFilterArgsDict',
    'GetSqlFirewallViolationsFilterArgs',
    'GetSqlFirewallViolationsFilterArgsDict',
    'GetTargetAlertPolicyAssociationsFilterArgs',
    'GetTargetAlertPolicyAssociationsFilterArgsDict',
    'GetTargetDatabasePeerTargetDatabasesFilterArgs',
    'GetTargetDatabasePeerTargetDatabasesFilterArgsDict',
    'GetTargetDatabaseRoleFilterArgs',
    'GetTargetDatabaseRoleFilterArgsDict',
    'GetTargetDatabaseRolesFilterArgs',
    'GetTargetDatabaseRolesFilterArgsDict',
    'GetTargetDatabasesColumnsFilterArgs',
    'GetTargetDatabasesColumnsFilterArgsDict',
    'GetTargetDatabasesFilterArgs',
    'GetTargetDatabasesFilterArgsDict',
    'GetTargetDatabasesSchemasFilterArgs',
    'GetTargetDatabasesSchemasFilterArgsDict',
    'GetTargetDatabasesTablesFilterArgs',
    'GetTargetDatabasesTablesFilterArgsDict',
    'GetUserAssessmentPasswordExpiryDateAnalyticsFilterArgs',
    'GetUserAssessmentPasswordExpiryDateAnalyticsFilterArgsDict',
    'GetUserAssessmentProfileAnalyticsFilterArgs',
    'GetUserAssessmentProfileAnalyticsFilterArgsDict',
    'GetUserAssessmentProfilesFilterArgs',
    'GetUserAssessmentProfilesFilterArgsDict',
    'GetUserAssessmentUserAccessAnalyticsFilterArgs',
    'GetUserAssessmentUserAccessAnalyticsFilterArgsDict',
    'GetUserAssessmentUserAnalyticsFilterArgs',
    'GetUserAssessmentUserAnalyticsFilterArgsDict',
    'GetUserAssessmentUsersFilterArgs',
    'GetUserAssessmentUsersFilterArgsDict',
    'GetUserAssessmentsFilterArgs',
    'GetUserAssessmentsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AlertPolicyAlertPolicyRuleDetailArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        The conditional expression of the alert policy rule which evaluates to boolean value.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes the alert policy rule.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the alert policy rule.
        """
elif False:
    AlertPolicyAlertPolicyRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyAlertPolicyRuleDetailArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: The conditional expression of the alert policy rule which evaluates to boolean value.
        :param pulumi.Input[_builtins.str] description: Describes the alert policy rule.
        :param pulumi.Input[_builtins.str] display_name: The display name of the alert policy rule.
        """
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        The conditional expression of the alert policy rule which evaluates to boolean value.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes the alert policy rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the alert policy rule.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class AuditPolicyAuditConditionArgsDict(TypedDict):
        audit_policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        enable_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuditPolicyAuditConditionEnableConditionArgsDict']]]]
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        is_data_safe_service_account_audited: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        is_priv_users_managed_by_data_safe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the privileged user list is managed by Data Safe.
        """
elif False:
    AuditPolicyAuditConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditPolicyAuditConditionArgs:
    def __init__(__self__, *,
                 audit_policy_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AuditPolicyAuditConditionEnableConditionArgs']]]] = None,
                 is_data_safe_service_account_audited: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_priv_users_managed_by_data_safe: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param pulumi.Input[Sequence[pulumi.Input['AuditPolicyAuditConditionEnableConditionArgs']]] enable_conditions: Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        :param pulumi.Input[_builtins.bool] is_data_safe_service_account_audited: Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        :param pulumi.Input[_builtins.bool] is_priv_users_managed_by_data_safe: Indicates whether the privileged user list is managed by Data Safe.
        """
        if audit_policy_name is not None:
            pulumi.set(__self__, "audit_policy_name", audit_policy_name)
        if enable_conditions is not None:
            pulumi.set(__self__, "enable_conditions", enable_conditions)
        if is_data_safe_service_account_audited is not None:
            pulumi.set(__self__, "is_data_safe_service_account_audited", is_data_safe_service_account_audited)
        if is_priv_users_managed_by_data_safe is not None:
            pulumi.set(__self__, "is_priv_users_managed_by_data_safe", is_priv_users_managed_by_data_safe)

    @_builtins.property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @audit_policy_name.setter
    def audit_policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_policy_name", value)

    @_builtins.property
    @pulumi.getter(name="enableConditions")
    def enable_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuditPolicyAuditConditionEnableConditionArgs']]]]:
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        return pulumi.get(self, "enable_conditions")

    @enable_conditions.setter
    def enable_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuditPolicyAuditConditionEnableConditionArgs']]]]):
        pulumi.set(self, "enable_conditions", value)

    @_builtins.property
    @pulumi.getter(name="isDataSafeServiceAccountAudited")
    def is_data_safe_service_account_audited(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        return pulumi.get(self, "is_data_safe_service_account_audited")

    @is_data_safe_service_account_audited.setter
    def is_data_safe_service_account_audited(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_data_safe_service_account_audited", value)

    @_builtins.property
    @pulumi.getter(name="isPrivUsersManagedByDataSafe")
    def is_priv_users_managed_by_data_safe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the privileged user list is managed by Data Safe.
        """
        return pulumi.get(self, "is_priv_users_managed_by_data_safe")

    @is_priv_users_managed_by_data_safe.setter
    def is_priv_users_managed_by_data_safe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_priv_users_managed_by_data_safe", value)


if not MYPY:
    class AuditPolicyAuditConditionEnableConditionArgsDict(TypedDict):
        entity_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of users or roles that the policy must be enabled for.
        """
        entity_selection: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity include or exclude selection.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity type that the policy must be enabled for.
        """
        operation_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operation status that the policy must be enabled for.
        """
elif False:
    AuditPolicyAuditConditionEnableConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditPolicyAuditConditionEnableConditionArgs:
    def __init__(__self__, *,
                 entity_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entity_selection: Optional[pulumi.Input[_builtins.str]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operation_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entity_names: List of users or roles that the policy must be enabled for.
        :param pulumi.Input[_builtins.str] entity_selection: The entity include or exclude selection.
        :param pulumi.Input[_builtins.str] entity_type: The entity type that the policy must be enabled for.
        :param pulumi.Input[_builtins.str] operation_status: The operation status that the policy must be enabled for.
        """
        if entity_names is not None:
            pulumi.set(__self__, "entity_names", entity_names)
        if entity_selection is not None:
            pulumi.set(__self__, "entity_selection", entity_selection)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if operation_status is not None:
            pulumi.set(__self__, "operation_status", operation_status)

    @_builtins.property
    @pulumi.getter(name="entityNames")
    def entity_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of users or roles that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_names")

    @entity_names.setter
    def entity_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entity_names", value)

    @_builtins.property
    @pulumi.getter(name="entitySelection")
    def entity_selection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity include or exclude selection.
        """
        return pulumi.get(self, "entity_selection")

    @entity_selection.setter
    def entity_selection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_selection", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity type that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)

    @_builtins.property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation status that the policy must be enabled for.
        """
        return pulumi.get(self, "operation_status")

    @operation_status.setter
    def operation_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation_status", value)


if not MYPY:
    class AuditPolicyAuditSpecificationArgsDict(TypedDict):
        audit_policy_category: NotRequired[pulumi.Input[_builtins.str]]
        """
        The category to which the audit policy belongs.
        """
        audit_policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        database_policy_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        enable_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        enabled_entities: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates on whom the audit policy is enabled.
        """
        is_created: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the policy is already created on the target database.
        """
        is_enabled_for_all_users: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        is_seeded_in_data_safe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        is_seeded_in_target: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        is_view_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        partially_enabled_msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides information about the policy that has been only partially enabled.
        """
elif False:
    AuditPolicyAuditSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditPolicyAuditSpecificationArgs:
    def __init__(__self__, *,
                 audit_policy_category: Optional[pulumi.Input[_builtins.str]] = None,
                 audit_policy_name: Optional[pulumi.Input[_builtins.str]] = None,
                 database_policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enable_status: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled_entities: Optional[pulumi.Input[_builtins.str]] = None,
                 is_created: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_enabled_for_all_users: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_seeded_in_data_safe: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_seeded_in_target: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_view_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 partially_enabled_msg: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_policy_category: The category to which the audit policy belongs.
        :param pulumi.Input[_builtins.str] audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] database_policy_names: Indicates the names of corresponding database policy ( or policies) in the target database.
        :param pulumi.Input[_builtins.str] enable_status: Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        :param pulumi.Input[_builtins.str] enabled_entities: Indicates on whom the audit policy is enabled.
        :param pulumi.Input[_builtins.bool] is_created: Indicates whether the policy is already created on the target database.
        :param pulumi.Input[_builtins.bool] is_enabled_for_all_users: Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        :param pulumi.Input[_builtins.bool] is_seeded_in_data_safe: Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        :param pulumi.Input[_builtins.bool] is_seeded_in_target: Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        :param pulumi.Input[_builtins.bool] is_view_only: Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        :param pulumi.Input[_builtins.str] partially_enabled_msg: Provides information about the policy that has been only partially enabled.
        """
        if audit_policy_category is not None:
            pulumi.set(__self__, "audit_policy_category", audit_policy_category)
        if audit_policy_name is not None:
            pulumi.set(__self__, "audit_policy_name", audit_policy_name)
        if database_policy_names is not None:
            pulumi.set(__self__, "database_policy_names", database_policy_names)
        if enable_status is not None:
            pulumi.set(__self__, "enable_status", enable_status)
        if enabled_entities is not None:
            pulumi.set(__self__, "enabled_entities", enabled_entities)
        if is_created is not None:
            pulumi.set(__self__, "is_created", is_created)
        if is_enabled_for_all_users is not None:
            pulumi.set(__self__, "is_enabled_for_all_users", is_enabled_for_all_users)
        if is_seeded_in_data_safe is not None:
            pulumi.set(__self__, "is_seeded_in_data_safe", is_seeded_in_data_safe)
        if is_seeded_in_target is not None:
            pulumi.set(__self__, "is_seeded_in_target", is_seeded_in_target)
        if is_view_only is not None:
            pulumi.set(__self__, "is_view_only", is_view_only)
        if partially_enabled_msg is not None:
            pulumi.set(__self__, "partially_enabled_msg", partially_enabled_msg)

    @_builtins.property
    @pulumi.getter(name="auditPolicyCategory")
    def audit_policy_category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The category to which the audit policy belongs.
        """
        return pulumi.get(self, "audit_policy_category")

    @audit_policy_category.setter
    def audit_policy_category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_policy_category", value)

    @_builtins.property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @audit_policy_name.setter
    def audit_policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_policy_name", value)

    @_builtins.property
    @pulumi.getter(name="databasePolicyNames")
    def database_policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        return pulumi.get(self, "database_policy_names")

    @database_policy_names.setter
    def database_policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "database_policy_names", value)

    @_builtins.property
    @pulumi.getter(name="enableStatus")
    def enable_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        return pulumi.get(self, "enable_status")

    @enable_status.setter
    def enable_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable_status", value)

    @_builtins.property
    @pulumi.getter(name="enabledEntities")
    def enabled_entities(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates on whom the audit policy is enabled.
        """
        return pulumi.get(self, "enabled_entities")

    @enabled_entities.setter
    def enabled_entities(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enabled_entities", value)

    @_builtins.property
    @pulumi.getter(name="isCreated")
    def is_created(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the policy is already created on the target database.
        """
        return pulumi.get(self, "is_created")

    @is_created.setter
    def is_created(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_created", value)

    @_builtins.property
    @pulumi.getter(name="isEnabledForAllUsers")
    def is_enabled_for_all_users(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        return pulumi.get(self, "is_enabled_for_all_users")

    @is_enabled_for_all_users.setter
    def is_enabled_for_all_users(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled_for_all_users", value)

    @_builtins.property
    @pulumi.getter(name="isSeededInDataSafe")
    def is_seeded_in_data_safe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        return pulumi.get(self, "is_seeded_in_data_safe")

    @is_seeded_in_data_safe.setter
    def is_seeded_in_data_safe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_seeded_in_data_safe", value)

    @_builtins.property
    @pulumi.getter(name="isSeededInTarget")
    def is_seeded_in_target(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        return pulumi.get(self, "is_seeded_in_target")

    @is_seeded_in_target.setter
    def is_seeded_in_target(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_seeded_in_target", value)

    @_builtins.property
    @pulumi.getter(name="isViewOnly")
    def is_view_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        return pulumi.get(self, "is_view_only")

    @is_view_only.setter
    def is_view_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_view_only", value)

    @_builtins.property
    @pulumi.getter(name="partiallyEnabledMsg")
    def partially_enabled_msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides information about the policy that has been only partially enabled.
        """
        return pulumi.get(self, "partially_enabled_msg")

    @partially_enabled_msg.setter
    def partially_enabled_msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partially_enabled_msg", value)


if not MYPY:
    class AuditPolicyManagementAuditConditionArgsDict(TypedDict):
        audit_policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        enable_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuditPolicyManagementAuditConditionEnableConditionArgsDict']]]]
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        is_data_safe_service_account_audited: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the policy has to be enabled or disabled in the target database. Set this to true if you want the audit policy to be enabled in the target database. If the seeded audit policy is not already created in the database, the provisioning creates and enables them. If this is set to false, the policy will be disabled in the target database.
        """
        is_priv_users_managed_by_data_safe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the privileged user list is managed by Data Safe.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    AuditPolicyManagementAuditConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditPolicyManagementAuditConditionArgs:
    def __init__(__self__, *,
                 audit_policy_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AuditPolicyManagementAuditConditionEnableConditionArgs']]]] = None,
                 is_data_safe_service_account_audited: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_priv_users_managed_by_data_safe: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param pulumi.Input[Sequence[pulumi.Input['AuditPolicyManagementAuditConditionEnableConditionArgs']]] enable_conditions: Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        :param pulumi.Input[_builtins.bool] is_data_safe_service_account_audited: Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        :param pulumi.Input[_builtins.bool] is_enabled: Indicates whether the policy has to be enabled or disabled in the target database. Set this to true if you want the audit policy to be enabled in the target database. If the seeded audit policy is not already created in the database, the provisioning creates and enables them. If this is set to false, the policy will be disabled in the target database.
        :param pulumi.Input[_builtins.bool] is_priv_users_managed_by_data_safe: Indicates whether the privileged user list is managed by Data Safe.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if audit_policy_name is not None:
            pulumi.set(__self__, "audit_policy_name", audit_policy_name)
        if enable_conditions is not None:
            pulumi.set(__self__, "enable_conditions", enable_conditions)
        if is_data_safe_service_account_audited is not None:
            pulumi.set(__self__, "is_data_safe_service_account_audited", is_data_safe_service_account_audited)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_priv_users_managed_by_data_safe is not None:
            pulumi.set(__self__, "is_priv_users_managed_by_data_safe", is_priv_users_managed_by_data_safe)

    @_builtins.property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @audit_policy_name.setter
    def audit_policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_policy_name", value)

    @_builtins.property
    @pulumi.getter(name="enableConditions")
    def enable_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuditPolicyManagementAuditConditionEnableConditionArgs']]]]:
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        return pulumi.get(self, "enable_conditions")

    @enable_conditions.setter
    def enable_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuditPolicyManagementAuditConditionEnableConditionArgs']]]]):
        pulumi.set(self, "enable_conditions", value)

    @_builtins.property
    @pulumi.getter(name="isDataSafeServiceAccountAudited")
    def is_data_safe_service_account_audited(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        return pulumi.get(self, "is_data_safe_service_account_audited")

    @is_data_safe_service_account_audited.setter
    def is_data_safe_service_account_audited(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_data_safe_service_account_audited", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the policy has to be enabled or disabled in the target database. Set this to true if you want the audit policy to be enabled in the target database. If the seeded audit policy is not already created in the database, the provisioning creates and enables them. If this is set to false, the policy will be disabled in the target database.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isPrivUsersManagedByDataSafe")
    def is_priv_users_managed_by_data_safe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the privileged user list is managed by Data Safe.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "is_priv_users_managed_by_data_safe")

    @is_priv_users_managed_by_data_safe.setter
    def is_priv_users_managed_by_data_safe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_priv_users_managed_by_data_safe", value)


if not MYPY:
    class AuditPolicyManagementAuditConditionEnableConditionArgsDict(TypedDict):
        entity_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of users or roles that the policy must be enabled for.
        """
        entity_selection: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity include or exclude selection.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity type that the policy must be enabled for.
        """
        operation_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operation status that the policy must be enabled for.
        """
elif False:
    AuditPolicyManagementAuditConditionEnableConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditPolicyManagementAuditConditionEnableConditionArgs:
    def __init__(__self__, *,
                 entity_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entity_selection: Optional[pulumi.Input[_builtins.str]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operation_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entity_names: List of users or roles that the policy must be enabled for.
        :param pulumi.Input[_builtins.str] entity_selection: The entity include or exclude selection.
        :param pulumi.Input[_builtins.str] entity_type: The entity type that the policy must be enabled for.
        :param pulumi.Input[_builtins.str] operation_status: The operation status that the policy must be enabled for.
        """
        if entity_names is not None:
            pulumi.set(__self__, "entity_names", entity_names)
        if entity_selection is not None:
            pulumi.set(__self__, "entity_selection", entity_selection)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if operation_status is not None:
            pulumi.set(__self__, "operation_status", operation_status)

    @_builtins.property
    @pulumi.getter(name="entityNames")
    def entity_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of users or roles that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_names")

    @entity_names.setter
    def entity_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entity_names", value)

    @_builtins.property
    @pulumi.getter(name="entitySelection")
    def entity_selection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity include or exclude selection.
        """
        return pulumi.get(self, "entity_selection")

    @entity_selection.setter
    def entity_selection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_selection", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity type that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)

    @_builtins.property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation status that the policy must be enabled for.
        """
        return pulumi.get(self, "operation_status")

    @operation_status.setter
    def operation_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation_status", value)


if not MYPY:
    class AuditPolicyManagementAuditSpecificationArgsDict(TypedDict):
        audit_policy_category: NotRequired[pulumi.Input[_builtins.str]]
        """
        The category to which the audit policy belongs.
        """
        audit_policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        database_policy_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        enable_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        enabled_entities: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates on whom the audit policy is enabled.
        """
        is_created: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the policy is already created on the target database.
        """
        is_enabled_for_all_users: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        is_seeded_in_data_safe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        is_seeded_in_target: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        is_view_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        partially_enabled_msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides information about the policy that has been only partially enabled.
        """
elif False:
    AuditPolicyManagementAuditSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditPolicyManagementAuditSpecificationArgs:
    def __init__(__self__, *,
                 audit_policy_category: Optional[pulumi.Input[_builtins.str]] = None,
                 audit_policy_name: Optional[pulumi.Input[_builtins.str]] = None,
                 database_policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enable_status: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled_entities: Optional[pulumi.Input[_builtins.str]] = None,
                 is_created: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_enabled_for_all_users: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_seeded_in_data_safe: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_seeded_in_target: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_view_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 partially_enabled_msg: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_policy_category: The category to which the audit policy belongs.
        :param pulumi.Input[_builtins.str] audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] database_policy_names: Indicates the names of corresponding database policy ( or policies) in the target database.
        :param pulumi.Input[_builtins.str] enable_status: Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        :param pulumi.Input[_builtins.str] enabled_entities: Indicates on whom the audit policy is enabled.
        :param pulumi.Input[_builtins.bool] is_created: Indicates whether the policy is already created on the target database.
        :param pulumi.Input[_builtins.bool] is_enabled_for_all_users: Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        :param pulumi.Input[_builtins.bool] is_seeded_in_data_safe: Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        :param pulumi.Input[_builtins.bool] is_seeded_in_target: Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        :param pulumi.Input[_builtins.bool] is_view_only: Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        :param pulumi.Input[_builtins.str] partially_enabled_msg: Provides information about the policy that has been only partially enabled.
        """
        if audit_policy_category is not None:
            pulumi.set(__self__, "audit_policy_category", audit_policy_category)
        if audit_policy_name is not None:
            pulumi.set(__self__, "audit_policy_name", audit_policy_name)
        if database_policy_names is not None:
            pulumi.set(__self__, "database_policy_names", database_policy_names)
        if enable_status is not None:
            pulumi.set(__self__, "enable_status", enable_status)
        if enabled_entities is not None:
            pulumi.set(__self__, "enabled_entities", enabled_entities)
        if is_created is not None:
            pulumi.set(__self__, "is_created", is_created)
        if is_enabled_for_all_users is not None:
            pulumi.set(__self__, "is_enabled_for_all_users", is_enabled_for_all_users)
        if is_seeded_in_data_safe is not None:
            pulumi.set(__self__, "is_seeded_in_data_safe", is_seeded_in_data_safe)
        if is_seeded_in_target is not None:
            pulumi.set(__self__, "is_seeded_in_target", is_seeded_in_target)
        if is_view_only is not None:
            pulumi.set(__self__, "is_view_only", is_view_only)
        if partially_enabled_msg is not None:
            pulumi.set(__self__, "partially_enabled_msg", partially_enabled_msg)

    @_builtins.property
    @pulumi.getter(name="auditPolicyCategory")
    def audit_policy_category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The category to which the audit policy belongs.
        """
        return pulumi.get(self, "audit_policy_category")

    @audit_policy_category.setter
    def audit_policy_category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_policy_category", value)

    @_builtins.property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @audit_policy_name.setter
    def audit_policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_policy_name", value)

    @_builtins.property
    @pulumi.getter(name="databasePolicyNames")
    def database_policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        return pulumi.get(self, "database_policy_names")

    @database_policy_names.setter
    def database_policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "database_policy_names", value)

    @_builtins.property
    @pulumi.getter(name="enableStatus")
    def enable_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        return pulumi.get(self, "enable_status")

    @enable_status.setter
    def enable_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable_status", value)

    @_builtins.property
    @pulumi.getter(name="enabledEntities")
    def enabled_entities(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates on whom the audit policy is enabled.
        """
        return pulumi.get(self, "enabled_entities")

    @enabled_entities.setter
    def enabled_entities(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enabled_entities", value)

    @_builtins.property
    @pulumi.getter(name="isCreated")
    def is_created(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the policy is already created on the target database.
        """
        return pulumi.get(self, "is_created")

    @is_created.setter
    def is_created(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_created", value)

    @_builtins.property
    @pulumi.getter(name="isEnabledForAllUsers")
    def is_enabled_for_all_users(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        return pulumi.get(self, "is_enabled_for_all_users")

    @is_enabled_for_all_users.setter
    def is_enabled_for_all_users(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled_for_all_users", value)

    @_builtins.property
    @pulumi.getter(name="isSeededInDataSafe")
    def is_seeded_in_data_safe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        return pulumi.get(self, "is_seeded_in_data_safe")

    @is_seeded_in_data_safe.setter
    def is_seeded_in_data_safe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_seeded_in_data_safe", value)

    @_builtins.property
    @pulumi.getter(name="isSeededInTarget")
    def is_seeded_in_target(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        return pulumi.get(self, "is_seeded_in_target")

    @is_seeded_in_target.setter
    def is_seeded_in_target(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_seeded_in_target", value)

    @_builtins.property
    @pulumi.getter(name="isViewOnly")
    def is_view_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        return pulumi.get(self, "is_view_only")

    @is_view_only.setter
    def is_view_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_view_only", value)

    @_builtins.property
    @pulumi.getter(name="partiallyEnabledMsg")
    def partially_enabled_msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides information about the policy that has been only partially enabled.
        """
        return pulumi.get(self, "partially_enabled_msg")

    @partially_enabled_msg.setter
    def partially_enabled_msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partially_enabled_msg", value)


if not MYPY:
    class AuditProfileAuditTrailArgsDict(TypedDict):
        audit_collection_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        """
        audit_profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the audit.
        """
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the compartment that contains the audit.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm) Example: `{"Operations.CostCenter": "42"}`
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the audit profile.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The display name of the audit profile. The name does not have to be unique, and it's updatable.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the audit profile.
        """
        is_auto_purge_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        """
        lifecycle_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        Details about the current state of the audit profile in Data Safe.
        """
        peer_target_database_key: NotRequired[pulumi.Input[_builtins.int]]
        """
        The secondary id assigned for the peer database registered with Data Safe.
        """
        purge_job_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The details of the audit trail purge job that ran on the "purgeJobTime".
        """
        purge_job_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the audit trail purge job.
        """
        purge_job_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the last purge job, which deletes audit data in the target database every seven days so that the database's audit trail does not become too large. In the format defined by RFC3339.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of the audit profile.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current sub-state of the audit trail.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the Data Safe target for which the audit profile is created.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the audit profile was created, in the format defined by RFC3339.
        """
        time_last_collected: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        trail_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        trail_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The underlying source of unified audit trail.
        """
        work_request_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the workrequest for audit trail which collects audit records.
        """
elif False:
    AuditProfileAuditTrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditProfileAuditTrailArgs:
    def __init__(__self__, *,
                 audit_collection_start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 audit_profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_auto_purge_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 lifecycle_details: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_target_database_key: Optional[pulumi.Input[_builtins.int]] = None,
                 purge_job_details: Optional[pulumi.Input[_builtins.str]] = None,
                 purge_job_status: Optional[pulumi.Input[_builtins.str]] = None,
                 purge_job_time: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_collected: Optional[pulumi.Input[_builtins.str]] = None,
                 time_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 trail_location: Optional[pulumi.Input[_builtins.str]] = None,
                 trail_source: Optional[pulumi.Input[_builtins.str]] = None,
                 work_request_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_collection_start_time: The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] audit_profile_id: The OCID of the audit.
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The OCID of the compartment that contains the audit.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm) Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the audit profile.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The display name of the audit profile. The name does not have to be unique, and it's updatable.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param pulumi.Input[_builtins.str] id: The OCID of the audit profile.
        :param pulumi.Input[_builtins.bool] is_auto_purge_enabled: Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        :param pulumi.Input[_builtins.str] lifecycle_details: Details about the current state of the audit profile in Data Safe.
        :param pulumi.Input[_builtins.int] peer_target_database_key: The secondary id assigned for the peer database registered with Data Safe.
        :param pulumi.Input[_builtins.str] purge_job_details: The details of the audit trail purge job that ran on the "purgeJobTime".
        :param pulumi.Input[_builtins.str] purge_job_status: The current status of the audit trail purge job.
        :param pulumi.Input[_builtins.str] purge_job_time: The date and time of the last purge job, which deletes audit data in the target database every seven days so that the database's audit trail does not become too large. In the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] state: The current state of the audit profile.
        :param pulumi.Input[_builtins.str] status: The current sub-state of the audit trail.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[_builtins.str] target_id: The OCID of the Data Safe target for which the audit profile is created.
        :param pulumi.Input[_builtins.str] time_created: The date and time the audit profile was created, in the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] time_last_collected: The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] time_updated: The date and time the audit profile was updated, in the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] trail_location: An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        :param pulumi.Input[_builtins.str] trail_source: The underlying source of unified audit trail.
        :param pulumi.Input[_builtins.str] work_request_id: The OCID of the workrequest for audit trail which collects audit records.
        """
        if audit_collection_start_time is not None:
            pulumi.set(__self__, "audit_collection_start_time", audit_collection_start_time)
        if audit_profile_id is not None:
            pulumi.set(__self__, "audit_profile_id", audit_profile_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_auto_purge_enabled is not None:
            pulumi.set(__self__, "is_auto_purge_enabled", is_auto_purge_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if peer_target_database_key is not None:
            pulumi.set(__self__, "peer_target_database_key", peer_target_database_key)
        if purge_job_details is not None:
            pulumi.set(__self__, "purge_job_details", purge_job_details)
        if purge_job_status is not None:
            pulumi.set(__self__, "purge_job_status", purge_job_status)
        if purge_job_time is not None:
            pulumi.set(__self__, "purge_job_time", purge_job_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_last_collected is not None:
            pulumi.set(__self__, "time_last_collected", time_last_collected)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if trail_location is not None:
            pulumi.set(__self__, "trail_location", trail_location)
        if trail_source is not None:
            pulumi.set(__self__, "trail_source", trail_source)
        if work_request_id is not None:
            pulumi.set(__self__, "work_request_id", work_request_id)

    @_builtins.property
    @pulumi.getter(name="auditCollectionStartTime")
    def audit_collection_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        """
        return pulumi.get(self, "audit_collection_start_time")

    @audit_collection_start_time.setter
    def audit_collection_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_collection_start_time", value)

    @_builtins.property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @audit_profile_id.setter
    def audit_profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_profile_id", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the compartment that contains the audit.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm) Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the audit profile.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The display name of the audit profile. The name does not have to be unique, and it's updatable.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the audit profile.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isAutoPurgeEnabled")
    def is_auto_purge_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        """
        return pulumi.get(self, "is_auto_purge_enabled")

    @is_auto_purge_enabled.setter
    def is_auto_purge_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_auto_purge_enabled", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Details about the current state of the audit profile in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifecycle_details", value)

    @_builtins.property
    @pulumi.getter(name="peerTargetDatabaseKey")
    def peer_target_database_key(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The secondary id assigned for the peer database registered with Data Safe.
        """
        return pulumi.get(self, "peer_target_database_key")

    @peer_target_database_key.setter
    def peer_target_database_key(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "peer_target_database_key", value)

    @_builtins.property
    @pulumi.getter(name="purgeJobDetails")
    def purge_job_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The details of the audit trail purge job that ran on the "purgeJobTime".
        """
        return pulumi.get(self, "purge_job_details")

    @purge_job_details.setter
    def purge_job_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purge_job_details", value)

    @_builtins.property
    @pulumi.getter(name="purgeJobStatus")
    def purge_job_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the audit trail purge job.
        """
        return pulumi.get(self, "purge_job_status")

    @purge_job_status.setter
    def purge_job_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purge_job_status", value)

    @_builtins.property
    @pulumi.getter(name="purgeJobTime")
    def purge_job_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the last purge job, which deletes audit data in the target database every seven days so that the database's audit trail does not become too large. In the format defined by RFC3339.
        """
        return pulumi.get(self, "purge_job_time")

    @purge_job_time.setter
    def purge_job_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purge_job_time", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of the audit profile.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current sub-state of the audit trail.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_tags", value)

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the Data Safe target for which the audit profile is created.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the audit profile was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="timeLastCollected")
    def time_last_collected(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_collected")

    @time_last_collected.setter
    def time_last_collected(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_collected", value)

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_updated", value)

    @_builtins.property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        return pulumi.get(self, "trail_location")

    @trail_location.setter
    def trail_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trail_location", value)

    @_builtins.property
    @pulumi.getter(name="trailSource")
    def trail_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The underlying source of unified audit trail.
        """
        return pulumi.get(self, "trail_source")

    @trail_source.setter
    def trail_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trail_source", value)

    @_builtins.property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the workrequest for audit trail which collects audit records.
        """
        return pulumi.get(self, "work_request_id")

    @work_request_id.setter
    def work_request_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "work_request_id", value)


if not MYPY:
    class CalculateAuditVolumeAvailableAvailableAuditVolumeArgsDict(TypedDict):
        audit_profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the audit.
        """
        month_in_consideration: NotRequired[pulumi.Input[_builtins.str]]
        trail_location: NotRequired[pulumi.Input[_builtins.str]]
        volume: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CalculateAuditVolumeAvailableAvailableAuditVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculateAuditVolumeAvailableAvailableAuditVolumeArgs:
    def __init__(__self__, *,
                 audit_profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 month_in_consideration: Optional[pulumi.Input[_builtins.str]] = None,
                 trail_location: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_profile_id: The OCID of the audit.
        """
        if audit_profile_id is not None:
            pulumi.set(__self__, "audit_profile_id", audit_profile_id)
        if month_in_consideration is not None:
            pulumi.set(__self__, "month_in_consideration", month_in_consideration)
        if trail_location is not None:
            pulumi.set(__self__, "trail_location", trail_location)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @audit_profile_id.setter
    def audit_profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_profile_id", value)

    @_builtins.property
    @pulumi.getter(name="monthInConsideration")
    def month_in_consideration(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "month_in_consideration")

    @month_in_consideration.setter
    def month_in_consideration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "month_in_consideration", value)

    @_builtins.property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trail_location")

    @trail_location.setter
    def trail_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trail_location", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class CalculateAuditVolumeCollectedCollectedAuditVolumeArgsDict(TypedDict):
        archived_volume: NotRequired[pulumi.Input[_builtins.str]]
        audit_profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the audit.
        """
        month_in_consideration: NotRequired[pulumi.Input[_builtins.str]]
        online_volume: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CalculateAuditVolumeCollectedCollectedAuditVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculateAuditVolumeCollectedCollectedAuditVolumeArgs:
    def __init__(__self__, *,
                 archived_volume: Optional[pulumi.Input[_builtins.str]] = None,
                 audit_profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 month_in_consideration: Optional[pulumi.Input[_builtins.str]] = None,
                 online_volume: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_profile_id: The OCID of the audit.
        """
        if archived_volume is not None:
            pulumi.set(__self__, "archived_volume", archived_volume)
        if audit_profile_id is not None:
            pulumi.set(__self__, "audit_profile_id", audit_profile_id)
        if month_in_consideration is not None:
            pulumi.set(__self__, "month_in_consideration", month_in_consideration)
        if online_volume is not None:
            pulumi.set(__self__, "online_volume", online_volume)

    @_builtins.property
    @pulumi.getter(name="archivedVolume")
    def archived_volume(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "archived_volume")

    @archived_volume.setter
    def archived_volume(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "archived_volume", value)

    @_builtins.property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @audit_profile_id.setter
    def audit_profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_profile_id", value)

    @_builtins.property
    @pulumi.getter(name="monthInConsideration")
    def month_in_consideration(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "month_in_consideration")

    @month_in_consideration.setter
    def month_in_consideration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "month_in_consideration", value)

    @_builtins.property
    @pulumi.getter(name="onlineVolume")
    def online_volume(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "online_volume")

    @online_volume.setter
    def online_volume(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "online_volume", value)


if not MYPY:
    class DataSafeConfigurationGlobalSettingArgsDict(TypedDict):
        is_paid_usage: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The paid usage option chosen by the customer admin.
        """
        offline_retention_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The offline retention period in months.
        """
        online_retention_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The online retention period in months.
        """
elif False:
    DataSafeConfigurationGlobalSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSafeConfigurationGlobalSettingArgs:
    def __init__(__self__, *,
                 is_paid_usage: Optional[pulumi.Input[_builtins.bool]] = None,
                 offline_retention_period: Optional[pulumi.Input[_builtins.int]] = None,
                 online_retention_period: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_paid_usage: The paid usage option chosen by the customer admin.
        :param pulumi.Input[_builtins.int] offline_retention_period: The offline retention period in months.
        :param pulumi.Input[_builtins.int] online_retention_period: The online retention period in months.
        """
        if is_paid_usage is not None:
            pulumi.set(__self__, "is_paid_usage", is_paid_usage)
        if offline_retention_period is not None:
            pulumi.set(__self__, "offline_retention_period", offline_retention_period)
        if online_retention_period is not None:
            pulumi.set(__self__, "online_retention_period", online_retention_period)

    @_builtins.property
    @pulumi.getter(name="isPaidUsage")
    def is_paid_usage(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The paid usage option chosen by the customer admin.
        """
        return pulumi.get(self, "is_paid_usage")

    @is_paid_usage.setter
    def is_paid_usage(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_paid_usage", value)

    @_builtins.property
    @pulumi.getter(name="offlineRetentionPeriod")
    def offline_retention_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The offline retention period in months.
        """
        return pulumi.get(self, "offline_retention_period")

    @offline_retention_period.setter
    def offline_retention_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "offline_retention_period", value)

    @_builtins.property
    @pulumi.getter(name="onlineRetentionPeriod")
    def online_retention_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The online retention period in months.
        """
        return pulumi.get(self, "online_retention_period")

    @online_retention_period.setter
    def online_retention_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "online_retention_period", value)


if not MYPY:
    class DatabaseSecurityConfigManagementSqlFirewallConfigArgsDict(TypedDict):
        exclude_job: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies whether the firewall should include or exclude the database internal job activities.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies whether the firewall is enabled or disabled on the target database.
        """
        time_status_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        The most recent time when the firewall status is updated, in the format defined by RFC3339.
        """
        violation_log_auto_purge: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies whether Data Safe should automatically purge the violation logs  from the database after collecting the violation logs and persisting on Data Safe.
        """
elif False:
    DatabaseSecurityConfigManagementSqlFirewallConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseSecurityConfigManagementSqlFirewallConfigArgs:
    def __init__(__self__, *,
                 exclude_job: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_status_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 violation_log_auto_purge: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exclude_job: (Updatable) Specifies whether the firewall should include or exclude the database internal job activities.
        :param pulumi.Input[_builtins.str] status: (Updatable) Specifies whether the firewall is enabled or disabled on the target database.
        :param pulumi.Input[_builtins.str] time_status_updated: The most recent time when the firewall status is updated, in the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] violation_log_auto_purge: (Updatable) Specifies whether Data Safe should automatically purge the violation logs  from the database after collecting the violation logs and persisting on Data Safe.
        """
        if exclude_job is not None:
            pulumi.set(__self__, "exclude_job", exclude_job)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_status_updated is not None:
            pulumi.set(__self__, "time_status_updated", time_status_updated)
        if violation_log_auto_purge is not None:
            pulumi.set(__self__, "violation_log_auto_purge", violation_log_auto_purge)

    @_builtins.property
    @pulumi.getter(name="excludeJob")
    def exclude_job(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies whether the firewall should include or exclude the database internal job activities.
        """
        return pulumi.get(self, "exclude_job")

    @exclude_job.setter
    def exclude_job(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_job", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies whether the firewall is enabled or disabled on the target database.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeStatusUpdated")
    def time_status_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The most recent time when the firewall status is updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_status_updated")

    @time_status_updated.setter
    def time_status_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_status_updated", value)

    @_builtins.property
    @pulumi.getter(name="violationLogAutoPurge")
    def violation_log_auto_purge(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies whether Data Safe should automatically purge the violation logs  from the database after collecting the violation logs and persisting on Data Safe.
        """
        return pulumi.get(self, "violation_log_auto_purge")

    @violation_log_auto_purge.setter
    def violation_log_auto_purge(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "violation_log_auto_purge", value)


if not MYPY:
    class DatabaseSecurityConfigSqlFirewallConfigArgsDict(TypedDict):
        exclude_job: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies whether the firewall should include or exclude the database internal job activities.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies whether the firewall is enabled or disabled on the target database.
        """
        time_status_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        The most recent time when the firewall status is updated, in the format defined by RFC3339.
        """
        violation_log_auto_purge: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies whether Data Safe should automatically purge the violation logs  from the database after collecting the violation logs and persisting on Data Safe.
        """
elif False:
    DatabaseSecurityConfigSqlFirewallConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseSecurityConfigSqlFirewallConfigArgs:
    def __init__(__self__, *,
                 exclude_job: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_status_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 violation_log_auto_purge: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exclude_job: (Updatable) Specifies whether the firewall should include or exclude the database internal job activities.
        :param pulumi.Input[_builtins.str] status: (Updatable) Specifies whether the firewall is enabled or disabled on the target database.
        :param pulumi.Input[_builtins.str] time_status_updated: The most recent time when the firewall status is updated, in the format defined by RFC3339.
        :param pulumi.Input[_builtins.str] violation_log_auto_purge: (Updatable) Specifies whether Data Safe should automatically purge the violation logs  from the database after collecting the violation logs and persisting on Data Safe.
        """
        if exclude_job is not None:
            pulumi.set(__self__, "exclude_job", exclude_job)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_status_updated is not None:
            pulumi.set(__self__, "time_status_updated", time_status_updated)
        if violation_log_auto_purge is not None:
            pulumi.set(__self__, "violation_log_auto_purge", violation_log_auto_purge)

    @_builtins.property
    @pulumi.getter(name="excludeJob")
    def exclude_job(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies whether the firewall should include or exclude the database internal job activities.
        """
        return pulumi.get(self, "exclude_job")

    @exclude_job.setter
    def exclude_job(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_job", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies whether the firewall is enabled or disabled on the target database.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeStatusUpdated")
    def time_status_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The most recent time when the firewall status is updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_status_updated")

    @time_status_updated.setter
    def time_status_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_status_updated", value)

    @_builtins.property
    @pulumi.getter(name="violationLogAutoPurge")
    def violation_log_auto_purge(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies whether Data Safe should automatically purge the violation logs  from the database after collecting the violation logs and persisting on Data Safe.
        """
        return pulumi.get(self, "violation_log_auto_purge")

    @violation_log_auto_purge.setter
    def violation_log_auto_purge(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "violation_log_auto_purge", value)


if not MYPY:
    class DiscoveryJobsResultModifiedAttributeArgsDict(TypedDict):
        app_defined_child_column_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        db_defined_child_column_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
elif False:
    DiscoveryJobsResultModifiedAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryJobsResultModifiedAttributeArgs:
    def __init__(__self__, *,
                 app_defined_child_column_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 db_defined_child_column_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] app_defined_child_column_keys: Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] db_defined_child_column_keys: Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        if app_defined_child_column_keys is not None:
            pulumi.set(__self__, "app_defined_child_column_keys", app_defined_child_column_keys)
        if db_defined_child_column_keys is not None:
            pulumi.set(__self__, "db_defined_child_column_keys", db_defined_child_column_keys)

    @_builtins.property
    @pulumi.getter(name="appDefinedChildColumnKeys")
    def app_defined_child_column_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        return pulumi.get(self, "app_defined_child_column_keys")

    @app_defined_child_column_keys.setter
    def app_defined_child_column_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "app_defined_child_column_keys", value)

    @_builtins.property
    @pulumi.getter(name="dbDefinedChildColumnKeys")
    def db_defined_child_column_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        return pulumi.get(self, "db_defined_child_column_keys")

    @db_defined_child_column_keys.setter
    def db_defined_child_column_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "db_defined_child_column_keys", value)


if not MYPY:
    class DiscoveryModTablesForDiscoveryArgsDict(TypedDict):
        schema_name: pulumi.Input[_builtins.str]
        """
        This contains the name of the schema.
        """
        table_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        This contains an optional list of the table names.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    DiscoveryModTablesForDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryModTablesForDiscoveryArgs:
    def __init__(__self__, *,
                 schema_name: pulumi.Input[_builtins.str],
                 table_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] schema_name: This contains the name of the schema.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] table_names: This contains an optional list of the table names.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "schema_name", schema_name)
        if table_names is not None:
            pulumi.set(__self__, "table_names", table_names)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> pulumi.Input[_builtins.str]:
        """
        This contains the name of the schema.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        This contains an optional list of the table names.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "table_names", value)


if not MYPY:
    class LibraryMasingFormatFormatEntryArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of the format entry.
        """
        column_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the substitution column.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the format entry.
        """
        end_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        end_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        end_value: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        fixed_number: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The constant number to be used for masking.
        """
        fixed_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The constant string to be used for masking.
        """
        grouping_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        library_masking_format_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the library masking format.
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The pattern that should be used to mask data.
        """
        post_processing_function: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        random_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        regular_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.

        In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.

        If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        """
        replace_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the schema that contains the substitution column.
        """
        sql_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        start_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        start_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        start_position: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        start_value: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the table that contains the substitution column.
        """
        user_defined_function: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
elif False:
    LibraryMasingFormatFormatEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LibraryMasingFormatFormatEntryArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 column_name: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 end_date: Optional[pulumi.Input[_builtins.str]] = None,
                 end_length: Optional[pulumi.Input[_builtins.int]] = None,
                 end_value: Optional[pulumi.Input[_builtins.float]] = None,
                 fixed_number: Optional[pulumi.Input[_builtins.float]] = None,
                 fixed_string: Optional[pulumi.Input[_builtins.str]] = None,
                 grouping_columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 length: Optional[pulumi.Input[_builtins.int]] = None,
                 library_masking_format_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 post_processing_function: Optional[pulumi.Input[_builtins.str]] = None,
                 random_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 regular_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 replace_with: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sql_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 start_date: Optional[pulumi.Input[_builtins.str]] = None,
                 start_length: Optional[pulumi.Input[_builtins.int]] = None,
                 start_position: Optional[pulumi.Input[_builtins.int]] = None,
                 start_value: Optional[pulumi.Input[_builtins.float]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None,
                 user_defined_function: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of the format entry.
        :param pulumi.Input[_builtins.str] column_name: (Updatable) The name of the substitution column.
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the format entry.
        :param pulumi.Input[_builtins.str] end_date: (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param pulumi.Input[_builtins.int] end_length: (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param pulumi.Input[_builtins.float] end_value: (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param pulumi.Input[_builtins.float] fixed_number: (Updatable) The constant number to be used for masking.
        :param pulumi.Input[_builtins.str] fixed_string: (Updatable) The constant string to be used for masking.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] grouping_columns: (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param pulumi.Input[_builtins.int] length: (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param pulumi.Input[_builtins.str] library_masking_format_id: (Updatable) The OCID of the library masking format.
        :param pulumi.Input[_builtins.str] pattern: (Updatable) The pattern that should be used to mask data.
        :param pulumi.Input[_builtins.str] post_processing_function: (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] random_lists: (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param pulumi.Input[_builtins.str] regular_expression: (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
               
               In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.
               
               If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        :param pulumi.Input[_builtins.str] replace_with: (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
        :param pulumi.Input[_builtins.str] schema_name: (Updatable) The name of the schema that contains the substitution column.
        :param pulumi.Input[_builtins.str] sql_expression: (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param pulumi.Input[_builtins.str] start_date: (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param pulumi.Input[_builtins.int] start_length: (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param pulumi.Input[_builtins.int] start_position: (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param pulumi.Input[_builtins.float] start_value: (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param pulumi.Input[_builtins.str] table_name: (Updatable) The name of the table that contains the substitution column.
        :param pulumi.Input[_builtins.str] user_defined_function: (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        pulumi.set(__self__, "type", type)
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if end_length is not None:
            pulumi.set(__self__, "end_length", end_length)
        if end_value is not None:
            pulumi.set(__self__, "end_value", end_value)
        if fixed_number is not None:
            pulumi.set(__self__, "fixed_number", fixed_number)
        if fixed_string is not None:
            pulumi.set(__self__, "fixed_string", fixed_string)
        if grouping_columns is not None:
            pulumi.set(__self__, "grouping_columns", grouping_columns)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if library_masking_format_id is not None:
            pulumi.set(__self__, "library_masking_format_id", library_masking_format_id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if post_processing_function is not None:
            pulumi.set(__self__, "post_processing_function", post_processing_function)
        if random_lists is not None:
            pulumi.set(__self__, "random_lists", random_lists)
        if regular_expression is not None:
            pulumi.set(__self__, "regular_expression", regular_expression)
        if replace_with is not None:
            pulumi.set(__self__, "replace_with", replace_with)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if sql_expression is not None:
            pulumi.set(__self__, "sql_expression", sql_expression)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_length is not None:
            pulumi.set(__self__, "start_length", start_length)
        if start_position is not None:
            pulumi.set(__self__, "start_position", start_position)
        if start_value is not None:
            pulumi.set(__self__, "start_value", start_value)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if user_defined_function is not None:
            pulumi.set(__self__, "user_defined_function", user_defined_function)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of the format entry.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the format entry.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_date", value)

    @_builtins.property
    @pulumi.getter(name="endLength")
    def end_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @end_length.setter
    def end_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_length", value)

    @_builtins.property
    @pulumi.getter(name="endValue")
    def end_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @end_value.setter
    def end_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "end_value", value)

    @_builtins.property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @fixed_number.setter
    def fixed_number(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fixed_number", value)

    @_builtins.property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @fixed_string.setter
    def fixed_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fixed_string", value)

    @_builtins.property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @grouping_columns.setter
    def grouping_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "grouping_columns", value)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @library_masking_format_id.setter
    def library_masking_format_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "library_masking_format_id", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The pattern that should be used to mask data.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @post_processing_function.setter
    def post_processing_function(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "post_processing_function", value)

    @_builtins.property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @random_lists.setter
    def random_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "random_lists", value)

    @_builtins.property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.

        In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.

        If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        """
        return pulumi.get(self, "regular_expression")

    @regular_expression.setter
    def regular_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regular_expression", value)

    @_builtins.property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
        """
        return pulumi.get(self, "replace_with")

    @replace_with.setter
    def replace_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replace_with", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the schema that contains the substitution column.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql_expression", value)

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_date", value)

    @_builtins.property
    @pulumi.getter(name="startLength")
    def start_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @start_length.setter
    def start_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_length", value)

    @_builtins.property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @start_position.setter
    def start_position(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_position", value)

    @_builtins.property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @start_value.setter
    def start_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "start_value", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")

    @user_defined_function.setter
    def user_defined_function(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_defined_function", value)


if not MYPY:
    class MaskingPoliciesMaskingColumnMaskingFormatArgsDict(TypedDict):
        format_entries: pulumi.Input[Sequence[pulumi.Input['MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgsDict']]]
        """
        (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the masking format.
        """
elif False:
    MaskingPoliciesMaskingColumnMaskingFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaskingPoliciesMaskingColumnMaskingFormatArgs:
    def __init__(__self__, *,
                 format_entries: pulumi.Input[Sequence[pulumi.Input['MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs']]],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs']]] format_entries: (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        :param pulumi.Input[_builtins.str] condition: (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the masking format.
        """
        pulumi.set(__self__, "format_entries", format_entries)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="formatEntries")
    def format_entries(self) -> pulumi.Input[Sequence[pulumi.Input['MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs']]]:
        """
        (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        return pulumi.get(self, "format_entries")

    @format_entries.setter
    def format_entries(self, value: pulumi.Input[Sequence[pulumi.Input['MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs']]]):
        pulumi.set(self, "format_entries", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the masking format.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of the format entry.
        """
        column_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the substitution column.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the format entry.
        """
        end_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        end_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        end_value: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        fixed_number: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The constant number to be used for masking.
        """
        fixed_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The constant string to be used for masking.
        """
        grouping_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        library_masking_format_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the library masking format.
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The pattern that should be used to mask data.
        """
        post_processing_function: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        random_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        regular_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.

        In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.

        If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        """
        replace_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the schema that contains the substitution column.
        """
        sql_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        start_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        start_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        start_position: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        start_value: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the table that contains the substitution column.
        """
        user_defined_function: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
elif False:
    MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 column_name: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 end_date: Optional[pulumi.Input[_builtins.str]] = None,
                 end_length: Optional[pulumi.Input[_builtins.int]] = None,
                 end_value: Optional[pulumi.Input[_builtins.float]] = None,
                 fixed_number: Optional[pulumi.Input[_builtins.float]] = None,
                 fixed_string: Optional[pulumi.Input[_builtins.str]] = None,
                 grouping_columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 length: Optional[pulumi.Input[_builtins.int]] = None,
                 library_masking_format_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 post_processing_function: Optional[pulumi.Input[_builtins.str]] = None,
                 random_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 regular_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 replace_with: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sql_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 start_date: Optional[pulumi.Input[_builtins.str]] = None,
                 start_length: Optional[pulumi.Input[_builtins.int]] = None,
                 start_position: Optional[pulumi.Input[_builtins.int]] = None,
                 start_value: Optional[pulumi.Input[_builtins.float]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None,
                 user_defined_function: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of the format entry.
        :param pulumi.Input[_builtins.str] column_name: (Updatable) The name of the substitution column.
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the format entry.
        :param pulumi.Input[_builtins.str] end_date: (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param pulumi.Input[_builtins.int] end_length: (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param pulumi.Input[_builtins.float] end_value: (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param pulumi.Input[_builtins.float] fixed_number: (Updatable) The constant number to be used for masking.
        :param pulumi.Input[_builtins.str] fixed_string: (Updatable) The constant string to be used for masking.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] grouping_columns: (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param pulumi.Input[_builtins.int] length: (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param pulumi.Input[_builtins.str] library_masking_format_id: (Updatable) The OCID of the library masking format.
        :param pulumi.Input[_builtins.str] pattern: (Updatable) The pattern that should be used to mask data.
        :param pulumi.Input[_builtins.str] post_processing_function: (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] random_lists: (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param pulumi.Input[_builtins.str] regular_expression: (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
               
               In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.
               
               If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        :param pulumi.Input[_builtins.str] replace_with: (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
        :param pulumi.Input[_builtins.str] schema_name: (Updatable) The name of the schema that contains the substitution column.
        :param pulumi.Input[_builtins.str] sql_expression: (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param pulumi.Input[_builtins.str] start_date: (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param pulumi.Input[_builtins.int] start_length: (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param pulumi.Input[_builtins.int] start_position: (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param pulumi.Input[_builtins.float] start_value: (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param pulumi.Input[_builtins.str] table_name: (Updatable) The name of the table that contains the substitution column.
        :param pulumi.Input[_builtins.str] user_defined_function: (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        pulumi.set(__self__, "type", type)
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if end_length is not None:
            pulumi.set(__self__, "end_length", end_length)
        if end_value is not None:
            pulumi.set(__self__, "end_value", end_value)
        if fixed_number is not None:
            pulumi.set(__self__, "fixed_number", fixed_number)
        if fixed_string is not None:
            pulumi.set(__self__, "fixed_string", fixed_string)
        if grouping_columns is not None:
            pulumi.set(__self__, "grouping_columns", grouping_columns)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if library_masking_format_id is not None:
            pulumi.set(__self__, "library_masking_format_id", library_masking_format_id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if post_processing_function is not None:
            pulumi.set(__self__, "post_processing_function", post_processing_function)
        if random_lists is not None:
            pulumi.set(__self__, "random_lists", random_lists)
        if regular_expression is not None:
            pulumi.set(__self__, "regular_expression", regular_expression)
        if replace_with is not None:
            pulumi.set(__self__, "replace_with", replace_with)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if sql_expression is not None:
            pulumi.set(__self__, "sql_expression", sql_expression)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_length is not None:
            pulumi.set(__self__, "start_length", start_length)
        if start_position is not None:
            pulumi.set(__self__, "start_position", start_position)
        if start_value is not None:
            pulumi.set(__self__, "start_value", start_value)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if user_defined_function is not None:
            pulumi.set(__self__, "user_defined_function", user_defined_function)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of the format entry.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the format entry.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_date", value)

    @_builtins.property
    @pulumi.getter(name="endLength")
    def end_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @end_length.setter
    def end_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_length", value)

    @_builtins.property
    @pulumi.getter(name="endValue")
    def end_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @end_value.setter
    def end_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "end_value", value)

    @_builtins.property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @fixed_number.setter
    def fixed_number(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fixed_number", value)

    @_builtins.property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @fixed_string.setter
    def fixed_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fixed_string", value)

    @_builtins.property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @grouping_columns.setter
    def grouping_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "grouping_columns", value)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @library_masking_format_id.setter
    def library_masking_format_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "library_masking_format_id", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The pattern that should be used to mask data.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @post_processing_function.setter
    def post_processing_function(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "post_processing_function", value)

    @_builtins.property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @random_lists.setter
    def random_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "random_lists", value)

    @_builtins.property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.

        In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.

        If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        """
        return pulumi.get(self, "regular_expression")

    @regular_expression.setter
    def regular_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regular_expression", value)

    @_builtins.property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
        """
        return pulumi.get(self, "replace_with")

    @replace_with.setter
    def replace_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replace_with", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the schema that contains the substitution column.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql_expression", value)

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_date", value)

    @_builtins.property
    @pulumi.getter(name="startLength")
    def start_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @start_length.setter
    def start_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_length", value)

    @_builtins.property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @start_position.setter
    def start_position(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_position", value)

    @_builtins.property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @start_value.setter
    def start_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "start_value", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")

    @user_defined_function.setter
    def user_defined_function(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_defined_function", value)


if not MYPY:
    class MaskingPolicyColumnSourceArgsDict(TypedDict):
        column_source: pulumi.Input[_builtins.str]
        """
        (Updatable) The source of masking columns.
        """
        sensitive_data_model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the sensitive data model to be associated as the column source with the masking policy.
        """
        target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the target database to be associated as the column source with the masking policy.
        """
elif False:
    MaskingPolicyColumnSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaskingPolicyColumnSourceArgs:
    def __init__(__self__, *,
                 column_source: pulumi.Input[_builtins.str],
                 sensitive_data_model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 target_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] column_source: (Updatable) The source of masking columns.
        :param pulumi.Input[_builtins.str] sensitive_data_model_id: (Updatable) The OCID of the sensitive data model to be associated as the column source with the masking policy.
        :param pulumi.Input[_builtins.str] target_id: (Updatable) The OCID of the target database to be associated as the column source with the masking policy.
        """
        pulumi.set(__self__, "column_source", column_source)
        if sensitive_data_model_id is not None:
            pulumi.set(__self__, "sensitive_data_model_id", sensitive_data_model_id)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @_builtins.property
    @pulumi.getter(name="columnSource")
    def column_source(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The source of masking columns.
        """
        return pulumi.get(self, "column_source")

    @column_source.setter
    def column_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_source", value)

    @_builtins.property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the sensitive data model to be associated as the column source with the masking policy.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @sensitive_data_model_id.setter
    def sensitive_data_model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitive_data_model_id", value)

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the target database to be associated as the column source with the masking policy.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_id", value)


if not MYPY:
    class ReportDefinitionColumnFilterArgsDict(TypedDict):
        expressions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) An array of expressions based on the operator type. A filter may have one or more expressions.
        """
        field_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the column on which the filter must be applied.
        """
        is_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        """
        is_hidden: pulumi.Input[_builtins.bool]
        """
        (Updatable) Indicates whether the filter is hidden. Values can either be 'true' or 'false'.
        """
        operator: pulumi.Input[_builtins.str]
        """
        (Updatable) Specifies the type of operator that must be applied for example in, eq etc.
        """
elif False:
    ReportDefinitionColumnFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportDefinitionColumnFilterArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 field_name: pulumi.Input[_builtins.str],
                 is_enabled: pulumi.Input[_builtins.bool],
                 is_hidden: pulumi.Input[_builtins.bool],
                 operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expressions: (Updatable) An array of expressions based on the operator type. A filter may have one or more expressions.
        :param pulumi.Input[_builtins.str] field_name: (Updatable) Name of the column on which the filter must be applied.
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        :param pulumi.Input[_builtins.bool] is_hidden: (Updatable) Indicates whether the filter is hidden. Values can either be 'true' or 'false'.
        :param pulumi.Input[_builtins.str] operator: (Updatable) Specifies the type of operator that must be applied for example in, eq etc.
        """
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "is_hidden", is_hidden)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) An array of expressions based on the operator type. A filter may have one or more expressions.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "expressions", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the column on which the filter must be applied.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Indicates whether the filter is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_hidden", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Specifies the type of operator that must be applied for example in, eq etc.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class ReportDefinitionColumnInfoArgsDict(TypedDict):
        display_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the column displayed on UI.
        """
        display_order: pulumi.Input[_builtins.int]
        """
        (Updatable) Specifies the display order of the column.
        """
        field_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Specifies the corresponding field name in the data source.
        """
        is_hidden: pulumi.Input[_builtins.bool]
        """
        (Updatable) Indicates if the column is hidden. Values can either be 'true' or 'false'.
        """
        data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies the data type of the column.
        """
elif False:
    ReportDefinitionColumnInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportDefinitionColumnInfoArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[_builtins.str],
                 display_order: pulumi.Input[_builtins.int],
                 field_name: pulumi.Input[_builtins.str],
                 is_hidden: pulumi.Input[_builtins.bool],
                 data_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) Name of the column displayed on UI.
        :param pulumi.Input[_builtins.int] display_order: (Updatable) Specifies the display order of the column.
        :param pulumi.Input[_builtins.str] field_name: (Updatable) Specifies the corresponding field name in the data source.
        :param pulumi.Input[_builtins.bool] is_hidden: (Updatable) Indicates if the column is hidden. Values can either be 'true' or 'false'.
        :param pulumi.Input[_builtins.str] data_type: (Updatable) Specifies the data type of the column.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "display_order", display_order)
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "is_hidden", is_hidden)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the column displayed on UI.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Specifies the display order of the column.
        """
        return pulumi.get(self, "display_order")

    @display_order.setter
    def display_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "display_order", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Specifies the corresponding field name in the data source.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Indicates if the column is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_hidden", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies the data type of the column.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_type", value)


if not MYPY:
    class ReportDefinitionColumnSortingArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the column that must be sorted.
        """
        is_ascending: pulumi.Input[_builtins.bool]
        """
        (Updatable) Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        """
        sorting_order: pulumi.Input[_builtins.int]
        """
        (Updatable) Indicates the order at which column must be sorted.
        """
elif False:
    ReportDefinitionColumnSortingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportDefinitionColumnSortingArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 is_ascending: pulumi.Input[_builtins.bool],
                 sorting_order: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] field_name: (Updatable) Name of the column that must be sorted.
        :param pulumi.Input[_builtins.bool] is_ascending: (Updatable) Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        :param pulumi.Input[_builtins.int] sorting_order: (Updatable) Indicates the order at which column must be sorted.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "is_ascending", is_ascending)
        pulumi.set(__self__, "sorting_order", sorting_order)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAscending")
    def is_ascending(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_ascending")

    @is_ascending.setter
    def is_ascending(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_ascending", value)

    @_builtins.property
    @pulumi.getter(name="sortingOrder")
    def sorting_order(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Indicates the order at which column must be sorted.
        """
        return pulumi.get(self, "sorting_order")

    @sorting_order.setter
    def sorting_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "sorting_order", value)


if not MYPY:
    class ReportDefinitionSummaryArgsDict(TypedDict):
        display_order: pulumi.Input[_builtins.int]
        """
        (Updatable) Specifies the order in which the summary must be displayed.
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the report summary.
        """
        count_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the key or count of object.
        """
        group_by_field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        """
        is_hidden: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        scim_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Additional scim filters used to get the specific summary.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ReportDefinitionSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReportDefinitionSummaryArgs:
    def __init__(__self__, *,
                 display_order: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 count_of: Optional[pulumi.Input[_builtins.str]] = None,
                 group_by_field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_hidden: Optional[pulumi.Input[_builtins.bool]] = None,
                 scim_filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] display_order: (Updatable) Specifies the order in which the summary must be displayed.
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the report summary.
        :param pulumi.Input[_builtins.str] count_of: (Updatable) Name of the key or count of object.
        :param pulumi.Input[_builtins.str] group_by_field_name: (Updatable) A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        :param pulumi.Input[_builtins.bool] is_hidden: (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param pulumi.Input[_builtins.str] scim_filter: (Updatable) Additional scim filters used to get the specific summary.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "display_order", display_order)
        pulumi.set(__self__, "name", name)
        if count_of is not None:
            pulumi.set(__self__, "count_of", count_of)
        if group_by_field_name is not None:
            pulumi.set(__self__, "group_by_field_name", group_by_field_name)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if scim_filter is not None:
            pulumi.set(__self__, "scim_filter", scim_filter)

    @_builtins.property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @display_order.setter
    def display_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "display_order", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the report summary.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="countOf")
    def count_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the key or count of object.
        """
        return pulumi.get(self, "count_of")

    @count_of.setter
    def count_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "count_of", value)

    @_builtins.property
    @pulumi.getter(name="groupByFieldName")
    def group_by_field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        """
        return pulumi.get(self, "group_by_field_name")

    @group_by_field_name.setter
    def group_by_field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_by_field_name", value)

    @_builtins.property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_hidden", value)

    @_builtins.property
    @pulumi.getter(name="scimFilter")
    def scim_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Additional scim filters used to get the specific summary.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "scim_filter")

    @scim_filter.setter
    def scim_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scim_filter", value)


if not MYPY:
    class SecurityAssessmentStatisticArgsDict(TypedDict):
        advisories: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticAdvisoryArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        deferreds: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticDeferredArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        evaluates: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticEvaluateArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        high_risks: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticHighRiskArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        low_risks: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticLowRiskArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        medium_risks: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticMediumRiskArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        passes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticPassArgsDict']]]]
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
elif False:
    SecurityAssessmentStatisticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticArgs:
    def __init__(__self__, *,
                 advisories: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticAdvisoryArgs']]]] = None,
                 deferreds: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticDeferredArgs']]]] = None,
                 evaluates: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticEvaluateArgs']]]] = None,
                 high_risks: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticHighRiskArgs']]]] = None,
                 low_risks: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticLowRiskArgs']]]] = None,
                 medium_risks: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticMediumRiskArgs']]]] = None,
                 passes: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticPassArgs']]]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticAdvisoryArgs']]] advisories: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticDeferredArgs']]] deferreds: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticEvaluateArgs']]] evaluates: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticHighRiskArgs']]] high_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticLowRiskArgs']]] low_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticMediumRiskArgs']]] medium_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticPassArgs']]] passes: Statistics showing the number of findings with a particular risk level for each category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        """
        if advisories is not None:
            pulumi.set(__self__, "advisories", advisories)
        if deferreds is not None:
            pulumi.set(__self__, "deferreds", deferreds)
        if evaluates is not None:
            pulumi.set(__self__, "evaluates", evaluates)
        if high_risks is not None:
            pulumi.set(__self__, "high_risks", high_risks)
        if low_risks is not None:
            pulumi.set(__self__, "low_risks", low_risks)
        if medium_risks is not None:
            pulumi.set(__self__, "medium_risks", medium_risks)
        if passes is not None:
            pulumi.set(__self__, "passes", passes)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)

    @_builtins.property
    @pulumi.getter
    def advisories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticAdvisoryArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "advisories")

    @advisories.setter
    def advisories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticAdvisoryArgs']]]]):
        pulumi.set(self, "advisories", value)

    @_builtins.property
    @pulumi.getter
    def deferreds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticDeferredArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "deferreds")

    @deferreds.setter
    def deferreds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticDeferredArgs']]]]):
        pulumi.set(self, "deferreds", value)

    @_builtins.property
    @pulumi.getter
    def evaluates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticEvaluateArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "evaluates")

    @evaluates.setter
    def evaluates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticEvaluateArgs']]]]):
        pulumi.set(self, "evaluates", value)

    @_builtins.property
    @pulumi.getter(name="highRisks")
    def high_risks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticHighRiskArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "high_risks")

    @high_risks.setter
    def high_risks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticHighRiskArgs']]]]):
        pulumi.set(self, "high_risks", value)

    @_builtins.property
    @pulumi.getter(name="lowRisks")
    def low_risks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticLowRiskArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "low_risks")

    @low_risks.setter
    def low_risks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticLowRiskArgs']]]]):
        pulumi.set(self, "low_risks", value)

    @_builtins.property
    @pulumi.getter(name="mediumRisks")
    def medium_risks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticMediumRiskArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "medium_risks")

    @medium_risks.setter
    def medium_risks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticMediumRiskArgs']]]]):
        pulumi.set(self, "medium_risks", value)

    @_builtins.property
    @pulumi.getter
    def passes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticPassArgs']]]]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "passes")

    @passes.setter
    def passes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityAssessmentStatisticPassArgs']]]]):
        pulumi.set(self, "passes", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)


if not MYPY:
    class SecurityAssessmentStatisticAdvisoryArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticAdvisoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticAdvisoryArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SecurityAssessmentStatisticDeferredArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticDeferredArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticDeferredArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SecurityAssessmentStatisticEvaluateArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticEvaluateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticEvaluateArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SecurityAssessmentStatisticHighRiskArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticHighRiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticHighRiskArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SecurityAssessmentStatisticLowRiskArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticLowRiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticLowRiskArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SecurityAssessmentStatisticMediumRiskArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticMediumRiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticMediumRiskArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SecurityAssessmentStatisticPassArgsDict(TypedDict):
        auditing_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Auditing category.
        """
        authorization_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Authorization Control category.
        """
        data_encryption_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Data Encryption category.
        """
        db_configuration_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Database Configuration category.
        """
        fine_grained_access_control_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        privileges_and_roles_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the Privileges and Roles category.
        """
        targets_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of targets in this security assessment.
        """
        user_accounts_findings_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of findings in the User Accounts category.
        """
elif False:
    SecurityAssessmentStatisticPassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentStatisticPassArgs:
    def __init__(__self__, *,
                 auditing_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 authorization_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 data_encryption_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 db_configuration_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 fine_grained_access_control_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 privileges_and_roles_findings_count: Optional[pulumi.Input[_builtins.int]] = None,
                 targets_count: Optional[pulumi.Input[_builtins.int]] = None,
                 user_accounts_findings_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auditing_findings_count: The number of findings in the Auditing category.
        :param pulumi.Input[_builtins.int] authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param pulumi.Input[_builtins.int] data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param pulumi.Input[_builtins.int] db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param pulumi.Input[_builtins.int] fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param pulumi.Input[_builtins.int] privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param pulumi.Input[_builtins.int] targets_count: The total number of targets in this security assessment.
        :param pulumi.Input[_builtins.int] user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        if auditing_findings_count is not None:
            pulumi.set(__self__, "auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            pulumi.set(__self__, "authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            pulumi.set(__self__, "data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            pulumi.set(__self__, "db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            pulumi.set(__self__, "fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            pulumi.set(__self__, "privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            pulumi.set(__self__, "targets_count", targets_count)
        if user_accounts_findings_count is not None:
            pulumi.set(__self__, "user_accounts_findings_count", user_accounts_findings_count)

    @_builtins.property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @auditing_findings_count.setter
    def auditing_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auditing_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @authorization_control_findings_count.setter
    def authorization_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "authorization_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @data_encryption_findings_count.setter
    def data_encryption_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_encryption_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @db_configuration_findings_count.setter
    def db_configuration_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db_configuration_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @fine_grained_access_control_findings_count.setter
    def fine_grained_access_control_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fine_grained_access_control_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @privileges_and_roles_findings_count.setter
    def privileges_and_roles_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "privileges_and_roles_findings_count", value)

    @_builtins.property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @targets_count.setter
    def targets_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "targets_count", value)

    @_builtins.property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")

    @user_accounts_findings_count.setter
    def user_accounts_findings_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_accounts_findings_count", value)


if not MYPY:
    class SensitiveDataModelReferentialRelationChildArgsDict(TypedDict):
        app_name: pulumi.Input[_builtins.str]
        """
        The application name.
        """
        column_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Group of columns in referential relation. Order needs to be maintained in the elements of the parent/child array listing.
        """
        object: pulumi.Input[_builtins.str]
        """
        The database object that contains the columns.
        """
        object_type: pulumi.Input[_builtins.str]
        """
        The type of the database object that contains the sensitive column.
        """
        schema_name: pulumi.Input[_builtins.str]
        """
        The schema name.
        """
        sensitive_type_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Sensitive type ocids of each column groups. Order needs to be maintained with the parent column group. For the DB defined referential relations identified during SDM creation, we cannot add sensitive types.  Instead use the sensitiveColumn POST API to mark the columns sensitive.
        """
elif False:
    SensitiveDataModelReferentialRelationChildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensitiveDataModelReferentialRelationChildArgs:
    def __init__(__self__, *,
                 app_name: pulumi.Input[_builtins.str],
                 column_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 object: pulumi.Input[_builtins.str],
                 object_type: pulumi.Input[_builtins.str],
                 schema_name: pulumi.Input[_builtins.str],
                 sensitive_type_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] app_name: The application name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] column_groups: Group of columns in referential relation. Order needs to be maintained in the elements of the parent/child array listing.
        :param pulumi.Input[_builtins.str] object: The database object that contains the columns.
        :param pulumi.Input[_builtins.str] object_type: The type of the database object that contains the sensitive column.
        :param pulumi.Input[_builtins.str] schema_name: The schema name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sensitive_type_ids: Sensitive type ocids of each column groups. Order needs to be maintained with the parent column group. For the DB defined referential relations identified during SDM creation, we cannot add sensitive types.  Instead use the sensitiveColumn POST API to mark the columns sensitive.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "column_groups", column_groups)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "object_type", object_type)
        pulumi.set(__self__, "schema_name", schema_name)
        if sensitive_type_ids is not None:
            pulumi.set(__self__, "sensitive_type_ids", sensitive_type_ids)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> pulumi.Input[_builtins.str]:
        """
        The application name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_name", value)

    @_builtins.property
    @pulumi.getter(name="columnGroups")
    def column_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Group of columns in referential relation. Order needs to be maintained in the elements of the parent/child array listing.
        """
        return pulumi.get(self, "column_groups")

    @column_groups.setter
    def column_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "column_groups", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input[_builtins.str]:
        """
        The database object that contains the columns.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the database object that contains the sensitive column.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema name.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="sensitiveTypeIds")
    def sensitive_type_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Sensitive type ocids of each column groups. Order needs to be maintained with the parent column group. For the DB defined referential relations identified during SDM creation, we cannot add sensitive types.  Instead use the sensitiveColumn POST API to mark the columns sensitive.
        """
        return pulumi.get(self, "sensitive_type_ids")

    @sensitive_type_ids.setter
    def sensitive_type_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sensitive_type_ids", value)


if not MYPY:
    class SensitiveDataModelReferentialRelationParentArgsDict(TypedDict):
        app_name: pulumi.Input[_builtins.str]
        """
        The application name.
        """
        column_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Group of columns in referential relation. Order needs to be maintained in the elements of the parent/child array listing.
        """
        object: pulumi.Input[_builtins.str]
        """
        The database object that contains the columns.
        """
        object_type: pulumi.Input[_builtins.str]
        """
        The type of the database object that contains the sensitive column.
        """
        schema_name: pulumi.Input[_builtins.str]
        """
        The schema name.
        """
        sensitive_type_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Sensitive type ocids of each column groups. Order needs to be maintained with the parent column group. For the DB defined referential relations identified during SDM creation, we cannot add sensitive types.  Instead use the sensitiveColumn POST API to mark the columns sensitive.
        """
elif False:
    SensitiveDataModelReferentialRelationParentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensitiveDataModelReferentialRelationParentArgs:
    def __init__(__self__, *,
                 app_name: pulumi.Input[_builtins.str],
                 column_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 object: pulumi.Input[_builtins.str],
                 object_type: pulumi.Input[_builtins.str],
                 schema_name: pulumi.Input[_builtins.str],
                 sensitive_type_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] app_name: The application name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] column_groups: Group of columns in referential relation. Order needs to be maintained in the elements of the parent/child array listing.
        :param pulumi.Input[_builtins.str] object: The database object that contains the columns.
        :param pulumi.Input[_builtins.str] object_type: The type of the database object that contains the sensitive column.
        :param pulumi.Input[_builtins.str] schema_name: The schema name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sensitive_type_ids: Sensitive type ocids of each column groups. Order needs to be maintained with the parent column group. For the DB defined referential relations identified during SDM creation, we cannot add sensitive types.  Instead use the sensitiveColumn POST API to mark the columns sensitive.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "column_groups", column_groups)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "object_type", object_type)
        pulumi.set(__self__, "schema_name", schema_name)
        if sensitive_type_ids is not None:
            pulumi.set(__self__, "sensitive_type_ids", sensitive_type_ids)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> pulumi.Input[_builtins.str]:
        """
        The application name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_name", value)

    @_builtins.property
    @pulumi.getter(name="columnGroups")
    def column_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Group of columns in referential relation. Order needs to be maintained in the elements of the parent/child array listing.
        """
        return pulumi.get(self, "column_groups")

    @column_groups.setter
    def column_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "column_groups", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input[_builtins.str]:
        """
        The database object that contains the columns.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the database object that contains the sensitive column.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema name.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="sensitiveTypeIds")
    def sensitive_type_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Sensitive type ocids of each column groups. Order needs to be maintained with the parent column group. For the DB defined referential relations identified during SDM creation, we cannot add sensitive types.  Instead use the sensitiveColumn POST API to mark the columns sensitive.
        """
        return pulumi.get(self, "sensitive_type_ids")

    @sensitive_type_ids.setter
    def sensitive_type_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sensitive_type_ids", value)


if not MYPY:
    class SensitiveDataModelTablesForDiscoveryArgsDict(TypedDict):
        schema_name: pulumi.Input[_builtins.str]
        """
        (Updatable) This contains the name of the schema.
        """
        table_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) This contains an optional list of the table names.
        """
elif False:
    SensitiveDataModelTablesForDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensitiveDataModelTablesForDiscoveryArgs:
    def __init__(__self__, *,
                 schema_name: pulumi.Input[_builtins.str],
                 table_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] schema_name: (Updatable) This contains the name of the schema.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] table_names: (Updatable) This contains an optional list of the table names.
        """
        pulumi.set(__self__, "schema_name", schema_name)
        if table_names is not None:
            pulumi.set(__self__, "table_names", table_names)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) This contains the name of the schema.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) This contains an optional list of the table names.
        """
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "table_names", value)


if not MYPY:
    class SensitiveTypeGroupGroupedSensitiveTypeItemArgsDict(TypedDict):
        sensitive_type_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the sensitive type.
        """
elif False:
    SensitiveTypeGroupGroupedSensitiveTypeItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensitiveTypeGroupGroupedSensitiveTypeItemArgs:
    def __init__(__self__, *,
                 sensitive_type_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sensitive_type_id: The OCID of the sensitive type.
        """
        if sensitive_type_id is not None:
            pulumi.set(__self__, "sensitive_type_id", sensitive_type_id)

    @_builtins.property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the sensitive type.
        """
        return pulumi.get(self, "sensitive_type_id")

    @sensitive_type_id.setter
    def sensitive_type_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitive_type_id", value)


if not MYPY:
    class SensitiveTypeGroupGroupedSensitiveTypePatchOperationArgsDict(TypedDict):
        operation: pulumi.Input[_builtins.str]
        """
        (Updatable) The operation can be one of these values: `INSERT`, `MERGE`, `REMOVE`
        """
        selection: pulumi.Input[_builtins.str]
        """
        (Updatable)
        """
        value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable)
        """
elif False:
    SensitiveTypeGroupGroupedSensitiveTypePatchOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensitiveTypeGroupGroupedSensitiveTypePatchOperationArgs:
    def __init__(__self__, *,
                 operation: pulumi.Input[_builtins.str],
                 selection: pulumi.Input[_builtins.str],
                 value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] operation: (Updatable) The operation can be one of these values: `INSERT`, `MERGE`, `REMOVE`
        :param pulumi.Input[_builtins.str] selection: (Updatable)
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] value: (Updatable)
        """
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "selection", selection)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The operation can be one of these values: `INSERT`, `MERGE`, `REMOVE`
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def selection(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable)
        """
        return pulumi.get(self, "selection")

    @selection.setter
    def selection(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "selection", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TargetDatabaseConnectionOptionArgsDict(TypedDict):
        connection_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The connection type used to connect to the database. Allowed values:
        * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
        * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        """
        datasafe_private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the Data Safe private endpoint.
        """
        on_prem_connector_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the on-premises connector.
        """
elif False:
    TargetDatabaseConnectionOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabaseConnectionOptionArgs:
    def __init__(__self__, *,
                 connection_type: pulumi.Input[_builtins.str],
                 datasafe_private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 on_prem_connector_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_type: (Updatable) The connection type used to connect to the database. Allowed values:
               * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
               * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        :param pulumi.Input[_builtins.str] datasafe_private_endpoint_id: (Updatable) The OCID of the Data Safe private endpoint.
        :param pulumi.Input[_builtins.str] on_prem_connector_id: (Updatable) The OCID of the on-premises connector.
        """
        pulumi.set(__self__, "connection_type", connection_type)
        if datasafe_private_endpoint_id is not None:
            pulumi.set(__self__, "datasafe_private_endpoint_id", datasafe_private_endpoint_id)
        if on_prem_connector_id is not None:
            pulumi.set(__self__, "on_prem_connector_id", on_prem_connector_id)

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The connection type used to connect to the database. Allowed values:
        * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
        * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_type", value)

    @_builtins.property
    @pulumi.getter(name="datasafePrivateEndpointId")
    def datasafe_private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the Data Safe private endpoint.
        """
        return pulumi.get(self, "datasafe_private_endpoint_id")

    @datasafe_private_endpoint_id.setter
    def datasafe_private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datasafe_private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="onPremConnectorId")
    def on_prem_connector_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the on-premises connector.
        """
        return pulumi.get(self, "on_prem_connector_id")

    @on_prem_connector_id.setter
    def on_prem_connector_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_prem_connector_id", value)


if not MYPY:
    class TargetDatabaseCredentialsArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        (Updatable) The password of the database user.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The database user name.
        """
elif False:
    TargetDatabaseCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabaseCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 user_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: (Updatable) The password of the database user.
        :param pulumi.Input[_builtins.str] user_name: (Updatable) The database user name.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The password of the database user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The database user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class TargetDatabaseDatabaseDetailsArgsDict(TypedDict):
        database_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The database type.
        """
        infrastructure_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The infrastructure type the database is running on.
        """
        autonomous_database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        db_system_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        listener_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port number of the database listener.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The service name of the database registered as target database.
        """
        vm_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
elif False:
    TargetDatabaseDatabaseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabaseDatabaseDetailsArgs:
    def __init__(__self__, *,
                 database_type: pulumi.Input[_builtins.str],
                 infrastructure_type: pulumi.Input[_builtins.str],
                 autonomous_database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 db_system_id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 listener_port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vm_cluster_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_type: (Updatable) The database type.
        :param pulumi.Input[_builtins.str] infrastructure_type: (Updatable) The infrastructure type the database is running on.
        :param pulumi.Input[_builtins.str] autonomous_database_id: (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] db_system_id: (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] instance_id: (Updatable) The OCID of the compute instance on which the database is running.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_addresses: (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param pulumi.Input[_builtins.int] listener_port: (Updatable) The port number of the database listener.
        :param pulumi.Input[_builtins.str] service_name: (Updatable) The service name of the database registered as target database.
        :param pulumi.Input[_builtins.str] vm_cluster_id: (Updatable) The OCID of the VM cluster in which the database is running.
        """
        pulumi.set(__self__, "database_type", database_type)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        if autonomous_database_id is not None:
            pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if vm_cluster_id is not None:
            pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @_builtins.property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The database type.
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_type", value)

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @autonomous_database_id.setter
    def autonomous_database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autonomous_database_id", value)

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_system_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_port", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")

    @vm_cluster_id.setter
    def vm_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_cluster_id", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseArgsDict(TypedDict):
        database_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseDatabaseDetailArgsDict']]]]
        """
        (Updatable) Details of the database for the registration in Data Safe.
        """
        database_unique_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique name of the database associated to the peer target database.
        """
        dataguard_association_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the Data Guard Association resource in which the database associated to the peer target database is considered as peer database to the primary database.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the target database in Data Safe.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The display name of the target database in Data Safe. The name is modifiable and does not need to be unique.
        """
        key: NotRequired[pulumi.Input[_builtins.int]]
        """
        The secondary key assigned for the peer target database in Data Safe.
        """
        lifecycle_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        Details about the current state of the peer target database in Data Safe.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role of the database associated to the peer target database.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of the target database in Data Safe.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the database was registered in Data Safe and created as a target database in Data Safe.
        """
        tls_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseTlsConfigArgsDict']]]]
        """
        (Updatable) The details required to establish a TLS enabled connection.
        """
elif False:
    TargetDatabasePeerTargetDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseArgs:
    def __init__(__self__, *,
                 database_details: Optional[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseDatabaseDetailArgs']]]] = None,
                 database_unique_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dataguard_association_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.int]] = None,
                 lifecycle_details: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseTlsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseDatabaseDetailArgs']]] database_details: (Updatable) Details of the database for the registration in Data Safe.
        :param pulumi.Input[_builtins.str] database_unique_name: Unique name of the database associated to the peer target database.
        :param pulumi.Input[_builtins.str] dataguard_association_id: The OCID of the Data Guard Association resource in which the database associated to the peer target database is considered as peer database to the primary database.
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the target database in Data Safe.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The display name of the target database in Data Safe. The name is modifiable and does not need to be unique.
        :param pulumi.Input[_builtins.int] key: The secondary key assigned for the peer target database in Data Safe.
        :param pulumi.Input[_builtins.str] lifecycle_details: Details about the current state of the peer target database in Data Safe.
        :param pulumi.Input[_builtins.str] role: Role of the database associated to the peer target database.
        :param pulumi.Input[_builtins.str] state: The current state of the target database in Data Safe.
        :param pulumi.Input[_builtins.str] time_created: The date and time the database was registered in Data Safe and created as a target database in Data Safe.
        :param pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseTlsConfigArgs']]] tls_configs: (Updatable) The details required to establish a TLS enabled connection.
        """
        if database_details is not None:
            pulumi.set(__self__, "database_details", database_details)
        if database_unique_name is not None:
            pulumi.set(__self__, "database_unique_name", database_unique_name)
        if dataguard_association_id is not None:
            pulumi.set(__self__, "dataguard_association_id", dataguard_association_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)

    @_builtins.property
    @pulumi.getter(name="databaseDetails")
    def database_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseDatabaseDetailArgs']]]]:
        """
        (Updatable) Details of the database for the registration in Data Safe.
        """
        return pulumi.get(self, "database_details")

    @database_details.setter
    def database_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseDatabaseDetailArgs']]]]):
        pulumi.set(self, "database_details", value)

    @_builtins.property
    @pulumi.getter(name="databaseUniqueName")
    def database_unique_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique name of the database associated to the peer target database.
        """
        return pulumi.get(self, "database_unique_name")

    @database_unique_name.setter
    def database_unique_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_unique_name", value)

    @_builtins.property
    @pulumi.getter(name="dataguardAssociationId")
    def dataguard_association_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the Data Guard Association resource in which the database associated to the peer target database is considered as peer database to the primary database.
        """
        return pulumi.get(self, "dataguard_association_id")

    @dataguard_association_id.setter
    def dataguard_association_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataguard_association_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the target database in Data Safe.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The display name of the target database in Data Safe. The name is modifiable and does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The secondary key assigned for the peer target database in Data Safe.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Details about the current state of the peer target database in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifecycle_details", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role of the database associated to the peer target database.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of the target database in Data Safe.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the database was registered in Data Safe and created as a target database in Data Safe.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseTlsConfigArgs']]]]:
        """
        (Updatable) The details required to establish a TLS enabled connection.
        """
        return pulumi.get(self, "tls_configs")

    @tls_configs.setter
    def tls_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetDatabasePeerTargetDatabaseTlsConfigArgs']]]]):
        pulumi.set(self, "tls_configs", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseDatabaseDetailArgsDict(TypedDict):
        autonomous_database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        database_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The database type.
        """
        db_system_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        infrastructure_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The infrastructure type the database is running on.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        listener_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port number of the database listener.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The service name of the database registered as target database.
        """
        vm_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
elif False:
    TargetDatabasePeerTargetDatabaseDatabaseDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseDatabaseDetailArgs:
    def __init__(__self__, *,
                 autonomous_database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 database_type: Optional[pulumi.Input[_builtins.str]] = None,
                 db_system_id: Optional[pulumi.Input[_builtins.str]] = None,
                 infrastructure_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 listener_port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vm_cluster_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] autonomous_database_id: (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] database_type: (Updatable) The database type.
        :param pulumi.Input[_builtins.str] db_system_id: (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] infrastructure_type: (Updatable) The infrastructure type the database is running on.
        :param pulumi.Input[_builtins.str] instance_id: (Updatable) The OCID of the compute instance on which the database is running.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_addresses: (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param pulumi.Input[_builtins.int] listener_port: (Updatable) The port number of the database listener.
        :param pulumi.Input[_builtins.str] service_name: (Updatable) The service name of the database registered as target database.
        :param pulumi.Input[_builtins.str] vm_cluster_id: (Updatable) The OCID of the VM cluster in which the database is running.
        """
        if autonomous_database_id is not None:
            pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        if database_type is not None:
            pulumi.set(__self__, "database_type", database_type)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if infrastructure_type is not None:
            pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if vm_cluster_id is not None:
            pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @autonomous_database_id.setter
    def autonomous_database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autonomous_database_id", value)

    @_builtins.property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The database type.
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_type", value)

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_system_id", value)

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_port", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")

    @vm_cluster_id.setter
    def vm_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_cluster_id", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseDatabaseDetailsArgsDict(TypedDict):
        database_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The database type.
        """
        infrastructure_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The infrastructure type the database is running on.
        """
        autonomous_database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        db_system_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        listener_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port number of the database listener.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The service name of the database registered as target database.
        """
        vm_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
elif False:
    TargetDatabasePeerTargetDatabaseDatabaseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseDatabaseDetailsArgs:
    def __init__(__self__, *,
                 database_type: pulumi.Input[_builtins.str],
                 infrastructure_type: pulumi.Input[_builtins.str],
                 autonomous_database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 db_system_id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 listener_port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vm_cluster_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_type: (Updatable) The database type.
        :param pulumi.Input[_builtins.str] infrastructure_type: (Updatable) The infrastructure type the database is running on.
        :param pulumi.Input[_builtins.str] autonomous_database_id: (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] db_system_id: (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] instance_id: (Updatable) The OCID of the compute instance on which the database is running.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_addresses: (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param pulumi.Input[_builtins.int] listener_port: (Updatable) The port number of the database listener.
        :param pulumi.Input[_builtins.str] service_name: (Updatable) The service name of the database registered as target database.
        :param pulumi.Input[_builtins.str] vm_cluster_id: (Updatable) The OCID of the VM cluster in which the database is running.
        """
        pulumi.set(__self__, "database_type", database_type)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        if autonomous_database_id is not None:
            pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if vm_cluster_id is not None:
            pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @_builtins.property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The database type.
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_type", value)

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @autonomous_database_id.setter
    def autonomous_database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autonomous_database_id", value)

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_system_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_port", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")

    @vm_cluster_id.setter
    def vm_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_cluster_id", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseDetailArgsDict(TypedDict):
        database_details: pulumi.Input['TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgsDict']
        """
        Details of the database for the registration in Data Safe.
        """
        dataguard_association_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the Data Guard Association resource in which the database being registered is considered as peer database to the primary database.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the peer target database in Data Safe.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the peer target database in Data Safe. The name is modifiable and does not need to be unique.
        """
        tls_config: NotRequired[pulumi.Input['TargetDatabasePeerTargetDatabaseDetailTlsConfigArgsDict']]
        """
        The details required to establish a TLS enabled connection.
        """
elif False:
    TargetDatabasePeerTargetDatabaseDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseDetailArgs:
    def __init__(__self__, *,
                 database_details: pulumi.Input['TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgs'],
                 dataguard_association_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_config: Optional[pulumi.Input['TargetDatabasePeerTargetDatabaseDetailTlsConfigArgs']] = None):
        """
        :param pulumi.Input['TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgs'] database_details: Details of the database for the registration in Data Safe.
        :param pulumi.Input[_builtins.str] dataguard_association_id: The OCID of the Data Guard Association resource in which the database being registered is considered as peer database to the primary database.
        :param pulumi.Input[_builtins.str] description: The description of the peer target database in Data Safe.
        :param pulumi.Input[_builtins.str] display_name: The display name of the peer target database in Data Safe. The name is modifiable and does not need to be unique.
        :param pulumi.Input['TargetDatabasePeerTargetDatabaseDetailTlsConfigArgs'] tls_config: The details required to establish a TLS enabled connection.
        """
        pulumi.set(__self__, "database_details", database_details)
        if dataguard_association_id is not None:
            pulumi.set(__self__, "dataguard_association_id", dataguard_association_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @_builtins.property
    @pulumi.getter(name="databaseDetails")
    def database_details(self) -> pulumi.Input['TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgs']:
        """
        Details of the database for the registration in Data Safe.
        """
        return pulumi.get(self, "database_details")

    @database_details.setter
    def database_details(self, value: pulumi.Input['TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgs']):
        pulumi.set(self, "database_details", value)

    @_builtins.property
    @pulumi.getter(name="dataguardAssociationId")
    def dataguard_association_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the Data Guard Association resource in which the database being registered is considered as peer database to the primary database.
        """
        return pulumi.get(self, "dataguard_association_id")

    @dataguard_association_id.setter
    def dataguard_association_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataguard_association_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the peer target database in Data Safe.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the peer target database in Data Safe. The name is modifiable and does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['TargetDatabasePeerTargetDatabaseDetailTlsConfigArgs']]:
        """
        The details required to establish a TLS enabled connection.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['TargetDatabasePeerTargetDatabaseDetailTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgsDict(TypedDict):
        database_type: pulumi.Input[_builtins.str]
        """
        The database type.
        """
        infrastructure_type: pulumi.Input[_builtins.str]
        """
        The infrastructure type the database is running on.
        """
        autonomous_database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        db_system_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the cloud database registered as a target database in Data Safe.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the compute instance on which the database is running.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        listener_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number of the database listener.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service name of the database registered as target database.
        """
        vm_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the VM cluster in which the database is running.
        """
elif False:
    TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseDetailDatabaseDetailsArgs:
    def __init__(__self__, *,
                 database_type: pulumi.Input[_builtins.str],
                 infrastructure_type: pulumi.Input[_builtins.str],
                 autonomous_database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 db_system_id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 listener_port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vm_cluster_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_type: The database type.
        :param pulumi.Input[_builtins.str] infrastructure_type: The infrastructure type the database is running on.
        :param pulumi.Input[_builtins.str] autonomous_database_id: The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] db_system_id: The OCID of the cloud database registered as a target database in Data Safe.
        :param pulumi.Input[_builtins.str] instance_id: The OCID of the compute instance on which the database is running.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_addresses: The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param pulumi.Input[_builtins.int] listener_port: The port number of the database listener.
        :param pulumi.Input[_builtins.str] service_name: The service name of the database registered as target database.
        :param pulumi.Input[_builtins.str] vm_cluster_id: The OCID of the VM cluster in which the database is running.
        """
        pulumi.set(__self__, "database_type", database_type)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        if autonomous_database_id is not None:
            pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if vm_cluster_id is not None:
            pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @_builtins.property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> pulumi.Input[_builtins.str]:
        """
        The database type.
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_type", value)

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @autonomous_database_id.setter
    def autonomous_database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autonomous_database_id", value)

    @_builtins.property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_system_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_port", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")

    @vm_cluster_id.setter
    def vm_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_cluster_id", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseDetailTlsConfigArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Status to represent whether the database connection is TLS enabled or not.
        """
        certificate_store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the certificate store.
        """
        key_store_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base64 encoded string of key store file content.
        """
        store_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to read the trust store and key store files, if they are password protected.
        """
        trust_store_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base64 encoded string of trust store file content.
        """
elif False:
    TargetDatabasePeerTargetDatabaseDetailTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseDetailTlsConfigArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 certificate_store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_store_content: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_store_content: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Status to represent whether the database connection is TLS enabled or not.
        :param pulumi.Input[_builtins.str] certificate_store_type: The format of the certificate store.
        :param pulumi.Input[_builtins.str] key_store_content: Base64 encoded string of key store file content.
        :param pulumi.Input[_builtins.str] store_password: The password to read the trust store and key store files, if they are password protected.
        :param pulumi.Input[_builtins.str] trust_store_content: Base64 encoded string of trust store file content.
        """
        pulumi.set(__self__, "status", status)
        if certificate_store_type is not None:
            pulumi.set(__self__, "certificate_store_type", certificate_store_type)
        if key_store_content is not None:
            pulumi.set(__self__, "key_store_content", key_store_content)
        if store_password is not None:
            pulumi.set(__self__, "store_password", store_password)
        if trust_store_content is not None:
            pulumi.set(__self__, "trust_store_content", trust_store_content)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @certificate_store_type.setter
    def certificate_store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_store_type", value)

    @_builtins.property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @key_store_content.setter
    def key_store_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_store_content", value)

    @_builtins.property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @store_password.setter
    def store_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_password", value)

    @_builtins.property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base64 encoded string of trust store file content.
        """
        return pulumi.get(self, "trust_store_content")

    @trust_store_content.setter
    def trust_store_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_store_content", value)


if not MYPY:
    class TargetDatabasePeerTargetDatabaseTlsConfigArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        (Updatable) Status to represent whether the database connection is TLS enabled or not.
        """
        certificate_store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The format of the certificate store.
        """
        key_store_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Base64 encoded string of key store file content.
        """
        store_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The password to read the trust store and key store files, if they are password protected.
        """
        trust_store_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Base64 encoded string of trust store file content.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    TargetDatabasePeerTargetDatabaseTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabasePeerTargetDatabaseTlsConfigArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 certificate_store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_store_content: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_store_content: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: (Updatable) Status to represent whether the database connection is TLS enabled or not.
        :param pulumi.Input[_builtins.str] certificate_store_type: (Updatable) The format of the certificate store.
        :param pulumi.Input[_builtins.str] key_store_content: (Updatable) Base64 encoded string of key store file content.
        :param pulumi.Input[_builtins.str] store_password: (Updatable) The password to read the trust store and key store files, if they are password protected.
        :param pulumi.Input[_builtins.str] trust_store_content: (Updatable) Base64 encoded string of trust store file content.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "status", status)
        if certificate_store_type is not None:
            pulumi.set(__self__, "certificate_store_type", certificate_store_type)
        if key_store_content is not None:
            pulumi.set(__self__, "key_store_content", key_store_content)
        if store_password is not None:
            pulumi.set(__self__, "store_password", store_password)
        if trust_store_content is not None:
            pulumi.set(__self__, "trust_store_content", trust_store_content)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @certificate_store_type.setter
    def certificate_store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_store_type", value)

    @_builtins.property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @key_store_content.setter
    def key_store_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_store_content", value)

    @_builtins.property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @store_password.setter
    def store_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_password", value)

    @_builtins.property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Base64 encoded string of trust store file content.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "trust_store_content")

    @trust_store_content.setter
    def trust_store_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_store_content", value)


if not MYPY:
    class TargetDatabaseTlsConfigArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        (Updatable) Status to represent whether the database connection is TLS enabled or not.
        """
        certificate_store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The format of the certificate store.
        """
        key_store_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Base64 encoded string of key store file content.
        """
        store_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The password to read the trust store and key store files, if they are password protected.
        """
        trust_store_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Base64 encoded string of trust store file content.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    TargetDatabaseTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetDatabaseTlsConfigArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 certificate_store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_store_content: Optional[pulumi.Input[_builtins.str]] = None,
                 store_password: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_store_content: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: (Updatable) Status to represent whether the database connection is TLS enabled or not.
        :param pulumi.Input[_builtins.str] certificate_store_type: (Updatable) The format of the certificate store.
        :param pulumi.Input[_builtins.str] key_store_content: (Updatable) Base64 encoded string of key store file content.
        :param pulumi.Input[_builtins.str] store_password: (Updatable) The password to read the trust store and key store files, if they are password protected.
        :param pulumi.Input[_builtins.str] trust_store_content: (Updatable) Base64 encoded string of trust store file content.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "status", status)
        if certificate_store_type is not None:
            pulumi.set(__self__, "certificate_store_type", certificate_store_type)
        if key_store_content is not None:
            pulumi.set(__self__, "key_store_content", key_store_content)
        if store_password is not None:
            pulumi.set(__self__, "store_password", store_password)
        if trust_store_content is not None:
            pulumi.set(__self__, "trust_store_content", trust_store_content)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @certificate_store_type.setter
    def certificate_store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_store_type", value)

    @_builtins.property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @key_store_content.setter
    def key_store_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_store_content", value)

    @_builtins.property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @store_password.setter
    def store_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_password", value)

    @_builtins.property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Base64 encoded string of trust store file content.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "trust_store_content")

    @trust_store_content.setter
    def trust_store_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_store_content", value)


if not MYPY:
    class UserAssessmentIgnoredTargetArgsDict(TypedDict):
        lifecycle_state: NotRequired[pulumi.Input[_builtins.str]]
        target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the target database on which the user assessment is to be run.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        user_assessment_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    UserAssessmentIgnoredTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAssessmentIgnoredTargetArgs:
    def __init__(__self__, *,
                 lifecycle_state: Optional[pulumi.Input[_builtins.str]] = None,
                 target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_assessment_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target_id: The OCID of the target database on which the user assessment is to be run.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if lifecycle_state is not None:
            pulumi.set(__self__, "lifecycle_state", lifecycle_state)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)
        if user_assessment_id is not None:
            pulumi.set(__self__, "user_assessment_id", user_assessment_id)

    @_builtins.property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lifecycle_state")

    @lifecycle_state.setter
    def lifecycle_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifecycle_state", value)

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the target database on which the user assessment is to be run.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_id", value)

    @_builtins.property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user_assessment_id")

    @user_assessment_id.setter
    def user_assessment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_assessment_id", value)


if not MYPY:
    class GetAlertPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAlertPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlertPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAlertPolicyRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAlertPolicyRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlertPolicyRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAlertsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAlertsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlertsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditArchiveRetrievalsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditArchiveRetrievalsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditArchiveRetrievalsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditEventsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditEventsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditEventsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditProfileAvailableAuditVolumesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditProfileAvailableAuditVolumesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditProfileAvailableAuditVolumesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditProfileCollectedAuditVolumesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditProfileCollectedAuditVolumesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditProfileCollectedAuditVolumesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditProfilesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditProfilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAuditTrailsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAuditTrailsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuditTrailsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDataSafePrivateEndpointsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDataSafePrivateEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDataSafePrivateEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabaseSecurityConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDatabaseSecurityConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseSecurityConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDiscoveryAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDiscoveryAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiscoveryAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDiscoveryJobsResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDiscoveryJobsResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiscoveryJobsResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLibraryMaskingFormatsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLibraryMaskingFormatsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLibraryMaskingFormatsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetListUserGrantsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetListUserGrantsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetListUserGrantsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPoliciesMaskingColumnsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPoliciesMaskingColumnsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPoliciesMaskingColumnsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPolicyHealthReportLogsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPolicyHealthReportLogsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPolicyHealthReportLogsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPolicyHealthReportsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPolicyHealthReportsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPolicyHealthReportsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPolicyMaskingObjectsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPolicyMaskingObjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPolicyMaskingObjectsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPolicyMaskingSchemasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPolicyMaskingSchemasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPolicyMaskingSchemasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingPolicyReferentialRelationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingPolicyReferentialRelationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingPolicyReferentialRelationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingReportMaskedColumnsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingReportMaskedColumnsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingReportMaskedColumnsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingReportMaskingErrorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingReportMaskingErrorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingReportMaskingErrorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaskingReportsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaskingReportsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaskingReportsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetOnpremConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetOnpremConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOnpremConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetReportDefinitionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the report summary.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetReportDefinitionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReportDefinitionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the report summary.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the report summary.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetReportsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetReportsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReportsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSdmMaskingPolicyDifferencesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSdmMaskingPolicyDifferencesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSdmMaskingPolicyDifferencesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentFindingAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentFindingAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentFindingAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentFindingFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentFindingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentFindingFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentFindingsChangeAuditLogsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentFindingsChangeAuditLogsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentFindingsChangeAuditLogsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentFindingsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentFindingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentFindingsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentSecurityFeatureAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentSecurityFeatureAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentSecurityFeatureAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentSecurityFeaturesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentSecurityFeaturesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentSecurityFeaturesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityAssessmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityAssessmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityAssessmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPolicyDeploymentSecurityPolicyEntryStatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPolicyDeploymentSecurityPolicyEntryStatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDeploymentSecurityPolicyEntryStatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPolicyDeploymentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPolicyDeploymentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPolicyReportDatabaseTableAccessEntriesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPolicyReportDatabaseTableAccessEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyReportDatabaseTableAccessEntriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPolicyReportDatabaseViewAccessEntriesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPolicyReportDatabaseViewAccessEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyReportDatabaseViewAccessEntriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPolicyReportRoleGrantPathsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPolicyReportRoleGrantPathsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyReportRoleGrantPathsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPolicyReportsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSecurityPolicyReportsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyReportsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveColumnAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveColumnAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveColumnAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveDataModelReferentialRelationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveDataModelReferentialRelationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveDataModelReferentialRelationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveDataModelSensitiveObjectsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveDataModelSensitiveObjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveDataModelSensitiveObjectsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveDataModelSensitiveSchemasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveDataModelSensitiveSchemasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveDataModelSensitiveSchemasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveDataModelSensitiveTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveDataModelSensitiveTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveDataModelSensitiveTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveDataModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveDataModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveDataModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveDataModelsSensitiveColumnsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveDataModelsSensitiveColumnsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveDataModelsSensitiveColumnsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveTypeGroupGroupedSensitiveTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveTypeGroupGroupedSensitiveTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveTypeGroupGroupedSensitiveTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveTypeGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveTypeGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveTypeGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveTypesExportsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveTypesExportsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveTypesExportsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSensitiveTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSensitiveTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSensitiveTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlCollectionAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlCollectionAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlCollectionAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlCollectionLogInsightsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlCollectionLogInsightsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlCollectionLogInsightsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlCollectionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlCollectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlCollectionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlFirewallAllowedSqlAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlFirewallAllowedSqlAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlFirewallAllowedSqlAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlFirewallAllowedSqlsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlFirewallAllowedSqlsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlFirewallAllowedSqlsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlFirewallPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlFirewallPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlFirewallPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlFirewallPolicyAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlFirewallPolicyAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlFirewallPolicyAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlFirewallViolationAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlFirewallViolationAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlFirewallViolationAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSqlFirewallViolationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSqlFirewallViolationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlFirewallViolationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetAlertPolicyAssociationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetAlertPolicyAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetAlertPolicyAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabasePeerTargetDatabasesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabasePeerTargetDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabasePeerTargetDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabaseRoleFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabaseRoleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabaseRoleFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabaseRolesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabaseRolesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabaseRolesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabasesColumnsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabasesColumnsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabasesColumnsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabasesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabasesSchemasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabasesSchemasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabasesSchemasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTargetDatabasesTablesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTargetDatabasesTablesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTargetDatabasesTablesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentPasswordExpiryDateAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentPasswordExpiryDateAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentPasswordExpiryDateAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentProfileAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentProfileAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentProfileAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentProfilesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentProfilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentUserAccessAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentUserAccessAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentUserAccessAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentUserAnalyticsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentUserAnalyticsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentUserAnalyticsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentUsersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentUsersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentUsersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUserAssessmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUserAssessmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAssessmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


