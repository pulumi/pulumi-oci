# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AuditPolicyAuditCondition',
    'AuditPolicyAuditConditionEnableCondition',
    'AuditPolicyAuditSpecification',
    'AuditProfileAuditTrail',
    'DataSafeConfigurationGlobalSetting',
    'DiscoveryJobsResultModifiedAttribute',
    'LibraryMasingFormatFormatEntry',
    'MaskingPoliciesMaskingColumnMaskingFormat',
    'MaskingPoliciesMaskingColumnMaskingFormatFormatEntry',
    'MaskingPolicyColumnSource',
    'ReportDefinitionColumnFilter',
    'ReportDefinitionColumnInfo',
    'ReportDefinitionColumnSorting',
    'ReportDefinitionSummary',
    'SecurityAssessmentStatistic',
    'SecurityAssessmentStatisticAdvisory',
    'SecurityAssessmentStatisticEvaluate',
    'SecurityAssessmentStatisticHighRisk',
    'SecurityAssessmentStatisticLowRisk',
    'SecurityAssessmentStatisticMediumRisk',
    'SecurityAssessmentStatisticPass',
    'TargetDatabaseConnectionOption',
    'TargetDatabaseCredentials',
    'TargetDatabaseDatabaseDetails',
    'TargetDatabaseTlsConfig',
    'UserAssessmentIgnoredTarget',
    'GetAlertAnalyticItemResult',
    'GetAlertAnalyticItemDimensionResult',
    'GetAlertPoliciesAlertPolicyCollectionResult',
    'GetAlertPoliciesAlertPolicyCollectionItemResult',
    'GetAlertPoliciesFilterResult',
    'GetAlertPolicyRuleItemResult',
    'GetAlertPolicyRulesAlertPolicyRuleCollectionResult',
    'GetAlertPolicyRulesAlertPolicyRuleCollectionItemResult',
    'GetAlertPolicyRulesFilterResult',
    'GetAlertsAlertCollectionResult',
    'GetAlertsAlertCollectionItemResult',
    'GetAlertsFilterResult',
    'GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionResult',
    'GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionItemResult',
    'GetAuditArchiveRetrievalsFilterResult',
    'GetAuditEventAnalyticItemResult',
    'GetAuditEventAnalyticItemDimensionResult',
    'GetAuditEventItemResult',
    'GetAuditEventsAuditEventCollectionResult',
    'GetAuditEventsAuditEventCollectionItemResult',
    'GetAuditEventsFilterResult',
    'GetAuditPoliciesAuditPolicyCollectionResult',
    'GetAuditPoliciesAuditPolicyCollectionItemResult',
    'GetAuditPoliciesAuditPolicyCollectionItemAuditConditionResult',
    'GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionResult',
    'GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationResult',
    'GetAuditPoliciesFilterResult',
    'GetAuditPolicyAuditConditionResult',
    'GetAuditPolicyAuditConditionEnableConditionResult',
    'GetAuditPolicyAuditSpecificationResult',
    'GetAuditProfileAnalyticItemResult',
    'GetAuditProfileAnalyticItemDimensionResult',
    'GetAuditProfileAuditTrailResult',
    'GetAuditProfileAvailableAuditVolumeItemResult',
    'GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionResult',
    'GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemResult',
    'GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemResult',
    'GetAuditProfileAvailableAuditVolumesFilterResult',
    'GetAuditProfileCollectedAuditVolumeItemResult',
    'GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionResult',
    'GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemResult',
    'GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemResult',
    'GetAuditProfileCollectedAuditVolumesFilterResult',
    'GetAuditProfilesAuditProfileCollectionResult',
    'GetAuditProfilesAuditProfileCollectionItemResult',
    'GetAuditProfilesAuditProfileCollectionItemAuditTrailResult',
    'GetAuditProfilesFilterResult',
    'GetAuditTrailAnalyticItemResult',
    'GetAuditTrailAnalyticItemDimensionResult',
    'GetAuditTrailsAuditTrailCollectionResult',
    'GetAuditTrailsAuditTrailCollectionItemResult',
    'GetAuditTrailsFilterResult',
    'GetCompatibleFormatsForDataTypeFormatsForDataTypeResult',
    'GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatResult',
    'GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeResult',
    'GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatResult',
    'GetDataSafeConfigurationGlobalSettingResult',
    'GetDataSafePrivateEndpointsDataSafePrivateEndpointResult',
    'GetDataSafePrivateEndpointsFilterResult',
    'GetDiscoveryAnalyticItemResult',
    'GetDiscoveryAnalyticItemDimensionResult',
    'GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionResult',
    'GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemResult',
    'GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionResult',
    'GetDiscoveryAnalyticsFilterResult',
    'GetDiscoveryJobsResultModifiedAttributeResult',
    'GetDiscoveryJobsResultsDiscoveryJobResultCollectionResult',
    'GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemResult',
    'GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeResult',
    'GetDiscoveryJobsResultsFilterResult',
    'GetLibraryMaskingFormatFormatEntryResult',
    'GetLibraryMaskingFormatsFilterResult',
    'GetLibraryMaskingFormatsLibraryMaskingFormatCollectionResult',
    'GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemResult',
    'GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryResult',
    'GetListUserGrantsFilterResult',
    'GetListUserGrantsGrantResult',
    'GetMaskingAnalyticItemResult',
    'GetMaskingAnalyticItemDimensionResult',
    'GetMaskingAnalyticsFilterResult',
    'GetMaskingAnalyticsMaskingAnalyticsCollectionResult',
    'GetMaskingAnalyticsMaskingAnalyticsCollectionItemResult',
    'GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionResult',
    'GetMaskingPoliciesFilterResult',
    'GetMaskingPoliciesMaskingColumnMaskingFormatResult',
    'GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryResult',
    'GetMaskingPoliciesMaskingColumnsFilterResult',
    'GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionResult',
    'GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemResult',
    'GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatResult',
    'GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryResult',
    'GetMaskingPoliciesMaskingPolicyCollectionResult',
    'GetMaskingPoliciesMaskingPolicyCollectionItemResult',
    'GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceResult',
    'GetMaskingPolicyColumnSourceResult',
    'GetMaskingPolicyMaskingObjectsFilterResult',
    'GetMaskingPolicyMaskingObjectsMaskingObjectCollectionResult',
    'GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemResult',
    'GetMaskingPolicyMaskingSchemasFilterResult',
    'GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionResult',
    'GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemResult',
    'GetMaskingReportMaskedColumnsFilterResult',
    'GetMaskingReportMaskedColumnsMaskedColumnCollectionResult',
    'GetMaskingReportMaskedColumnsMaskedColumnCollectionItemResult',
    'GetMaskingReportsFilterResult',
    'GetMaskingReportsMaskedColumnItemResult',
    'GetMaskingReportsMaskingReportCollectionResult',
    'GetMaskingReportsMaskingReportCollectionItemResult',
    'GetOnpremConnectorsFilterResult',
    'GetOnpremConnectorsOnPremConnectorResult',
    'GetReportDefinitionColumnFilterResult',
    'GetReportDefinitionColumnInfoResult',
    'GetReportDefinitionColumnSortingResult',
    'GetReportDefinitionSummaryResult',
    'GetReportDefinitionsFilterResult',
    'GetReportDefinitionsReportDefinitionCollectionResult',
    'GetReportDefinitionsReportDefinitionCollectionItemResult',
    'GetReportDefinitionsReportDefinitionCollectionItemColumnFilterResult',
    'GetReportDefinitionsReportDefinitionCollectionItemColumnInfoResult',
    'GetReportDefinitionsReportDefinitionCollectionItemColumnSortingResult',
    'GetReportDefinitionsReportDefinitionCollectionItemSummaryResult',
    'GetReportsFilterResult',
    'GetReportsReportCollectionResult',
    'GetReportsReportCollectionItemResult',
    'GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterResult',
    'GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionResult',
    'GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionItemResult',
    'GetSdmMaskingPolicyDifferencesFilterResult',
    'GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionResult',
    'GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionItemResult',
    'GetSecurityAssessmentComparisonTargetResult',
    'GetSecurityAssessmentComparisonTargetAuditingResult',
    'GetSecurityAssessmentComparisonTargetAuditingBaselineResult',
    'GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetAuditingCurrentResult',
    'GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceResult',
    'GetSecurityAssessmentComparisonTargetAuthorizationControlResult',
    'GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineResult',
    'GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentResult',
    'GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceResult',
    'GetSecurityAssessmentComparisonTargetDataEncryptionResult',
    'GetSecurityAssessmentComparisonTargetDataEncryptionBaselineResult',
    'GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetDataEncryptionCurrentResult',
    'GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceResult',
    'GetSecurityAssessmentComparisonTargetDbConfigurationResult',
    'GetSecurityAssessmentComparisonTargetDbConfigurationBaselineResult',
    'GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetDbConfigurationCurrentResult',
    'GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceResult',
    'GetSecurityAssessmentComparisonTargetFineGrainedAccessControlResult',
    'GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineResult',
    'GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentResult',
    'GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceResult',
    'GetSecurityAssessmentComparisonTargetPrivilegesAndRoleResult',
    'GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineResult',
    'GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentResult',
    'GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceResult',
    'GetSecurityAssessmentComparisonTargetUserAccountResult',
    'GetSecurityAssessmentComparisonTargetUserAccountBaselineResult',
    'GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceResult',
    'GetSecurityAssessmentComparisonTargetUserAccountCurrentResult',
    'GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceResult',
    'GetSecurityAssessmentFindingFilterResult',
    'GetSecurityAssessmentFindingFindingResult',
    'GetSecurityAssessmentFindingFindingReferenceResult',
    'GetSecurityAssessmentFindingsFilterResult',
    'GetSecurityAssessmentFindingsFindingResult',
    'GetSecurityAssessmentFindingsFindingReferenceResult',
    'GetSecurityAssessmentStatisticResult',
    'GetSecurityAssessmentStatisticAdvisoryResult',
    'GetSecurityAssessmentStatisticEvaluateResult',
    'GetSecurityAssessmentStatisticHighRiskResult',
    'GetSecurityAssessmentStatisticLowRiskResult',
    'GetSecurityAssessmentStatisticMediumRiskResult',
    'GetSecurityAssessmentStatisticPassResult',
    'GetSecurityAssessmentsFilterResult',
    'GetSecurityAssessmentsSecurityAssessmentResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskResult',
    'GetSecurityAssessmentsSecurityAssessmentStatisticPassResult',
    'GetSensitiveDataModelSensitiveObjectsFilterResult',
    'GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionResult',
    'GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemResult',
    'GetSensitiveDataModelSensitiveSchemasFilterResult',
    'GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionResult',
    'GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemResult',
    'GetSensitiveDataModelsFilterResult',
    'GetSensitiveDataModelsSensitiveColumnsFilterResult',
    'GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionResult',
    'GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionItemResult',
    'GetSensitiveDataModelsSensitiveDataModelCollectionResult',
    'GetSensitiveDataModelsSensitiveDataModelCollectionItemResult',
    'GetSensitiveTypesFilterResult',
    'GetSensitiveTypesSensitiveTypeCollectionResult',
    'GetSensitiveTypesSensitiveTypeCollectionItemResult',
    'GetTargetAlertPolicyAssociationsFilterResult',
    'GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionResult',
    'GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionItemResult',
    'GetTargetDatabaseConnectionOptionResult',
    'GetTargetDatabaseCredentialResult',
    'GetTargetDatabaseDatabaseDetailResult',
    'GetTargetDatabaseRoleFilterResult',
    'GetTargetDatabaseRoleRoleResult',
    'GetTargetDatabaseRolesFilterResult',
    'GetTargetDatabaseRolesRoleResult',
    'GetTargetDatabaseTlsConfigResult',
    'GetTargetDatabasesColumnsColumnResult',
    'GetTargetDatabasesColumnsFilterResult',
    'GetTargetDatabasesFilterResult',
    'GetTargetDatabasesSchemasFilterResult',
    'GetTargetDatabasesSchemasSchemaResult',
    'GetTargetDatabasesTablesFilterResult',
    'GetTargetDatabasesTablesTableResult',
    'GetTargetDatabasesTargetDatabaseResult',
    'GetTargetDatabasesTargetDatabaseConnectionOptionResult',
    'GetTargetDatabasesTargetDatabaseCredentialResult',
    'GetTargetDatabasesTargetDatabaseDatabaseDetailResult',
    'GetTargetDatabasesTargetDatabaseTlsConfigResult',
    'GetUserAssessmentComparisonSummaryResult',
    'GetUserAssessmentComparisonSummaryBaselineResult',
    'GetUserAssessmentComparisonSummaryCurrentResult',
    'GetUserAssessmentIgnoredTargetResult',
    'GetUserAssessmentProfileAnalyticsFilterResult',
    'GetUserAssessmentProfileAnalyticsProfileAggregationResult',
    'GetUserAssessmentProfilesFilterResult',
    'GetUserAssessmentProfilesProfileResult',
    'GetUserAssessmentUserAnalyticsFilterResult',
    'GetUserAssessmentUserAnalyticsUserAggregationResult',
    'GetUserAssessmentUserAnalyticsUserAggregationItemResult',
    'GetUserAssessmentUsersFilterResult',
    'GetUserAssessmentUsersUserResult',
    'GetUserAssessmentsFilterResult',
    'GetUserAssessmentsIgnoredTargetResult',
    'GetUserAssessmentsUserAssessmentResult',
    'GetUserAssessmentsUserAssessmentIgnoredTargetResult',
]

@pulumi.output_type
class AuditPolicyAuditCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditPolicyName":
            suggest = "audit_policy_name"
        elif key == "enableConditions":
            suggest = "enable_conditions"
        elif key == "isDataSafeServiceAccountAudited":
            suggest = "is_data_safe_service_account_audited"
        elif key == "isPrivUsersManagedByDataSafe":
            suggest = "is_priv_users_managed_by_data_safe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditPolicyAuditCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditPolicyAuditCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditPolicyAuditCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_policy_name: Optional[str] = None,
                 enable_conditions: Optional[Sequence['outputs.AuditPolicyAuditConditionEnableCondition']] = None,
                 is_data_safe_service_account_audited: Optional[bool] = None,
                 is_priv_users_managed_by_data_safe: Optional[bool] = None):
        """
        :param str audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param Sequence['AuditPolicyAuditConditionEnableConditionArgs'] enable_conditions: Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        :param bool is_data_safe_service_account_audited: Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        :param bool is_priv_users_managed_by_data_safe: Indicates whether the privileged user list is managed by Data Safe.
        """
        AuditPolicyAuditCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_policy_name=audit_policy_name,
            enable_conditions=enable_conditions,
            is_data_safe_service_account_audited=is_data_safe_service_account_audited,
            is_priv_users_managed_by_data_safe=is_priv_users_managed_by_data_safe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_policy_name: Optional[str] = None,
             enable_conditions: Optional[Sequence['outputs.AuditPolicyAuditConditionEnableCondition']] = None,
             is_data_safe_service_account_audited: Optional[bool] = None,
             is_priv_users_managed_by_data_safe: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_policy_name is None and 'auditPolicyName' in kwargs:
            audit_policy_name = kwargs['auditPolicyName']
        if enable_conditions is None and 'enableConditions' in kwargs:
            enable_conditions = kwargs['enableConditions']
        if is_data_safe_service_account_audited is None and 'isDataSafeServiceAccountAudited' in kwargs:
            is_data_safe_service_account_audited = kwargs['isDataSafeServiceAccountAudited']
        if is_priv_users_managed_by_data_safe is None and 'isPrivUsersManagedByDataSafe' in kwargs:
            is_priv_users_managed_by_data_safe = kwargs['isPrivUsersManagedByDataSafe']

        if audit_policy_name is not None:
            _setter("audit_policy_name", audit_policy_name)
        if enable_conditions is not None:
            _setter("enable_conditions", enable_conditions)
        if is_data_safe_service_account_audited is not None:
            _setter("is_data_safe_service_account_audited", is_data_safe_service_account_audited)
        if is_priv_users_managed_by_data_safe is not None:
            _setter("is_priv_users_managed_by_data_safe", is_priv_users_managed_by_data_safe)

    @property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> Optional[str]:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @property
    @pulumi.getter(name="enableConditions")
    def enable_conditions(self) -> Optional[Sequence['outputs.AuditPolicyAuditConditionEnableCondition']]:
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        return pulumi.get(self, "enable_conditions")

    @property
    @pulumi.getter(name="isDataSafeServiceAccountAudited")
    def is_data_safe_service_account_audited(self) -> Optional[bool]:
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        return pulumi.get(self, "is_data_safe_service_account_audited")

    @property
    @pulumi.getter(name="isPrivUsersManagedByDataSafe")
    def is_priv_users_managed_by_data_safe(self) -> Optional[bool]:
        """
        Indicates whether the privileged user list is managed by Data Safe.
        """
        return pulumi.get(self, "is_priv_users_managed_by_data_safe")


@pulumi.output_type
class AuditPolicyAuditConditionEnableCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityNames":
            suggest = "entity_names"
        elif key == "entitySelection":
            suggest = "entity_selection"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "operationStatus":
            suggest = "operation_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditPolicyAuditConditionEnableCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditPolicyAuditConditionEnableCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditPolicyAuditConditionEnableCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_names: Optional[Sequence[str]] = None,
                 entity_selection: Optional[str] = None,
                 entity_type: Optional[str] = None,
                 operation_status: Optional[str] = None):
        """
        :param Sequence[str] entity_names: List of users or roles that the policy must be enabled for.
        :param str entity_selection: The entity include or exclude selection.
        :param str entity_type: The entity type that the policy must be enabled for.
        :param str operation_status: The operation status that the policy must be enabled for.
        """
        AuditPolicyAuditConditionEnableCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_names=entity_names,
            entity_selection=entity_selection,
            entity_type=entity_type,
            operation_status=operation_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_names: Optional[Sequence[str]] = None,
             entity_selection: Optional[str] = None,
             entity_type: Optional[str] = None,
             operation_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_names is None and 'entityNames' in kwargs:
            entity_names = kwargs['entityNames']
        if entity_selection is None and 'entitySelection' in kwargs:
            entity_selection = kwargs['entitySelection']
        if entity_type is None and 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if operation_status is None and 'operationStatus' in kwargs:
            operation_status = kwargs['operationStatus']

        if entity_names is not None:
            _setter("entity_names", entity_names)
        if entity_selection is not None:
            _setter("entity_selection", entity_selection)
        if entity_type is not None:
            _setter("entity_type", entity_type)
        if operation_status is not None:
            _setter("operation_status", operation_status)

    @property
    @pulumi.getter(name="entityNames")
    def entity_names(self) -> Optional[Sequence[str]]:
        """
        List of users or roles that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_names")

    @property
    @pulumi.getter(name="entitySelection")
    def entity_selection(self) -> Optional[str]:
        """
        The entity include or exclude selection.
        """
        return pulumi.get(self, "entity_selection")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        The entity type that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional[str]:
        """
        The operation status that the policy must be enabled for.
        """
        return pulumi.get(self, "operation_status")


@pulumi.output_type
class AuditPolicyAuditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditPolicyCategory":
            suggest = "audit_policy_category"
        elif key == "auditPolicyName":
            suggest = "audit_policy_name"
        elif key == "databasePolicyNames":
            suggest = "database_policy_names"
        elif key == "enableStatus":
            suggest = "enable_status"
        elif key == "enabledEntities":
            suggest = "enabled_entities"
        elif key == "isCreated":
            suggest = "is_created"
        elif key == "isEnabledForAllUsers":
            suggest = "is_enabled_for_all_users"
        elif key == "isSeededInDataSafe":
            suggest = "is_seeded_in_data_safe"
        elif key == "isSeededInTarget":
            suggest = "is_seeded_in_target"
        elif key == "isViewOnly":
            suggest = "is_view_only"
        elif key == "partiallyEnabledMsg":
            suggest = "partially_enabled_msg"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditPolicyAuditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditPolicyAuditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditPolicyAuditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_policy_category: Optional[str] = None,
                 audit_policy_name: Optional[str] = None,
                 database_policy_names: Optional[Sequence[str]] = None,
                 enable_status: Optional[str] = None,
                 enabled_entities: Optional[str] = None,
                 is_created: Optional[bool] = None,
                 is_enabled_for_all_users: Optional[bool] = None,
                 is_seeded_in_data_safe: Optional[bool] = None,
                 is_seeded_in_target: Optional[bool] = None,
                 is_view_only: Optional[bool] = None,
                 partially_enabled_msg: Optional[str] = None):
        """
        :param str audit_policy_category: The category to which the audit policy belongs.
        :param str audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param Sequence[str] database_policy_names: Indicates the names of corresponding database policy ( or policies) in the target database.
        :param str enable_status: Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        :param str enabled_entities: Indicates on whom the audit policy is enabled.
        :param bool is_created: Indicates whether the policy is already created on the target database.
        :param bool is_enabled_for_all_users: Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        :param bool is_seeded_in_data_safe: Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        :param bool is_seeded_in_target: Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        :param bool is_view_only: Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        :param str partially_enabled_msg: Provides information about the policy that has been only partially enabled.
        """
        AuditPolicyAuditSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_policy_category=audit_policy_category,
            audit_policy_name=audit_policy_name,
            database_policy_names=database_policy_names,
            enable_status=enable_status,
            enabled_entities=enabled_entities,
            is_created=is_created,
            is_enabled_for_all_users=is_enabled_for_all_users,
            is_seeded_in_data_safe=is_seeded_in_data_safe,
            is_seeded_in_target=is_seeded_in_target,
            is_view_only=is_view_only,
            partially_enabled_msg=partially_enabled_msg,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_policy_category: Optional[str] = None,
             audit_policy_name: Optional[str] = None,
             database_policy_names: Optional[Sequence[str]] = None,
             enable_status: Optional[str] = None,
             enabled_entities: Optional[str] = None,
             is_created: Optional[bool] = None,
             is_enabled_for_all_users: Optional[bool] = None,
             is_seeded_in_data_safe: Optional[bool] = None,
             is_seeded_in_target: Optional[bool] = None,
             is_view_only: Optional[bool] = None,
             partially_enabled_msg: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_policy_category is None and 'auditPolicyCategory' in kwargs:
            audit_policy_category = kwargs['auditPolicyCategory']
        if audit_policy_name is None and 'auditPolicyName' in kwargs:
            audit_policy_name = kwargs['auditPolicyName']
        if database_policy_names is None and 'databasePolicyNames' in kwargs:
            database_policy_names = kwargs['databasePolicyNames']
        if enable_status is None and 'enableStatus' in kwargs:
            enable_status = kwargs['enableStatus']
        if enabled_entities is None and 'enabledEntities' in kwargs:
            enabled_entities = kwargs['enabledEntities']
        if is_created is None and 'isCreated' in kwargs:
            is_created = kwargs['isCreated']
        if is_enabled_for_all_users is None and 'isEnabledForAllUsers' in kwargs:
            is_enabled_for_all_users = kwargs['isEnabledForAllUsers']
        if is_seeded_in_data_safe is None and 'isSeededInDataSafe' in kwargs:
            is_seeded_in_data_safe = kwargs['isSeededInDataSafe']
        if is_seeded_in_target is None and 'isSeededInTarget' in kwargs:
            is_seeded_in_target = kwargs['isSeededInTarget']
        if is_view_only is None and 'isViewOnly' in kwargs:
            is_view_only = kwargs['isViewOnly']
        if partially_enabled_msg is None and 'partiallyEnabledMsg' in kwargs:
            partially_enabled_msg = kwargs['partiallyEnabledMsg']

        if audit_policy_category is not None:
            _setter("audit_policy_category", audit_policy_category)
        if audit_policy_name is not None:
            _setter("audit_policy_name", audit_policy_name)
        if database_policy_names is not None:
            _setter("database_policy_names", database_policy_names)
        if enable_status is not None:
            _setter("enable_status", enable_status)
        if enabled_entities is not None:
            _setter("enabled_entities", enabled_entities)
        if is_created is not None:
            _setter("is_created", is_created)
        if is_enabled_for_all_users is not None:
            _setter("is_enabled_for_all_users", is_enabled_for_all_users)
        if is_seeded_in_data_safe is not None:
            _setter("is_seeded_in_data_safe", is_seeded_in_data_safe)
        if is_seeded_in_target is not None:
            _setter("is_seeded_in_target", is_seeded_in_target)
        if is_view_only is not None:
            _setter("is_view_only", is_view_only)
        if partially_enabled_msg is not None:
            _setter("partially_enabled_msg", partially_enabled_msg)

    @property
    @pulumi.getter(name="auditPolicyCategory")
    def audit_policy_category(self) -> Optional[str]:
        """
        The category to which the audit policy belongs.
        """
        return pulumi.get(self, "audit_policy_category")

    @property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> Optional[str]:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @property
    @pulumi.getter(name="databasePolicyNames")
    def database_policy_names(self) -> Optional[Sequence[str]]:
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        return pulumi.get(self, "database_policy_names")

    @property
    @pulumi.getter(name="enableStatus")
    def enable_status(self) -> Optional[str]:
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        return pulumi.get(self, "enable_status")

    @property
    @pulumi.getter(name="enabledEntities")
    def enabled_entities(self) -> Optional[str]:
        """
        Indicates on whom the audit policy is enabled.
        """
        return pulumi.get(self, "enabled_entities")

    @property
    @pulumi.getter(name="isCreated")
    def is_created(self) -> Optional[bool]:
        """
        Indicates whether the policy is already created on the target database.
        """
        return pulumi.get(self, "is_created")

    @property
    @pulumi.getter(name="isEnabledForAllUsers")
    def is_enabled_for_all_users(self) -> Optional[bool]:
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        return pulumi.get(self, "is_enabled_for_all_users")

    @property
    @pulumi.getter(name="isSeededInDataSafe")
    def is_seeded_in_data_safe(self) -> Optional[bool]:
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        return pulumi.get(self, "is_seeded_in_data_safe")

    @property
    @pulumi.getter(name="isSeededInTarget")
    def is_seeded_in_target(self) -> Optional[bool]:
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        return pulumi.get(self, "is_seeded_in_target")

    @property
    @pulumi.getter(name="isViewOnly")
    def is_view_only(self) -> Optional[bool]:
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        return pulumi.get(self, "is_view_only")

    @property
    @pulumi.getter(name="partiallyEnabledMsg")
    def partially_enabled_msg(self) -> Optional[str]:
        """
        Provides information about the policy that has been only partially enabled.
        """
        return pulumi.get(self, "partially_enabled_msg")


@pulumi.output_type
class AuditProfileAuditTrail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditCollectionStartTime":
            suggest = "audit_collection_start_time"
        elif key == "auditProfileId":
            suggest = "audit_profile_id"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isAutoPurgeEnabled":
            suggest = "is_auto_purge_enabled"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "systemTags":
            suggest = "system_tags"
        elif key == "targetId":
            suggest = "target_id"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeLastCollected":
            suggest = "time_last_collected"
        elif key == "timeUpdated":
            suggest = "time_updated"
        elif key == "trailLocation":
            suggest = "trail_location"
        elif key == "workRequestId":
            suggest = "work_request_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditProfileAuditTrail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditProfileAuditTrail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditProfileAuditTrail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_collection_start_time: Optional[str] = None,
                 audit_profile_id: Optional[str] = None,
                 compartment_id: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 is_auto_purge_enabled: Optional[bool] = None,
                 lifecycle_details: Optional[str] = None,
                 state: Optional[str] = None,
                 status: Optional[str] = None,
                 system_tags: Optional[Mapping[str, Any]] = None,
                 target_id: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_last_collected: Optional[str] = None,
                 time_updated: Optional[str] = None,
                 trail_location: Optional[str] = None,
                 work_request_id: Optional[str] = None):
        """
        :param str audit_collection_start_time: The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        :param str audit_profile_id: The OCID of the audit.
        :param str compartment_id: (Updatable) The OCID of the compartment that contains the audit.
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: (Updatable) The description of the audit profile.
        :param str display_name: (Updatable) The display name of the audit profile. The name does not have to be unique, and it's changeable.
        :param Mapping[str, Any] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit profile.
        :param bool is_auto_purge_enabled: Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        :param str lifecycle_details: Details about the current state of the audit profile in Data Safe.
        :param str state: The current state of the audit profile.
        :param str status: The current sub-state of the audit trail.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: The OCID of the Data Safe target for which the audit profile is created.
        :param str time_created: The date and time the audit profile was created, in the format defined by RFC3339.
        :param str time_last_collected: The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        :param str time_updated: The date and time the audit profile was updated, in the format defined by RFC3339.
        :param str trail_location: An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        :param str work_request_id: The OCID of the workrequest for audit trail which collects audit records.
        """
        AuditProfileAuditTrail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_collection_start_time=audit_collection_start_time,
            audit_profile_id=audit_profile_id,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_auto_purge_enabled=is_auto_purge_enabled,
            lifecycle_details=lifecycle_details,
            state=state,
            status=status,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_last_collected=time_last_collected,
            time_updated=time_updated,
            trail_location=trail_location,
            work_request_id=work_request_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_collection_start_time: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_auto_purge_enabled: Optional[bool] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_last_collected: Optional[str] = None,
             time_updated: Optional[str] = None,
             trail_location: Optional[str] = None,
             work_request_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_collection_start_time is None and 'auditCollectionStartTime' in kwargs:
            audit_collection_start_time = kwargs['auditCollectionStartTime']
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if is_auto_purge_enabled is None and 'isAutoPurgeEnabled' in kwargs:
            is_auto_purge_enabled = kwargs['isAutoPurgeEnabled']
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_last_collected is None and 'timeLastCollected' in kwargs:
            time_last_collected = kwargs['timeLastCollected']
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if trail_location is None and 'trailLocation' in kwargs:
            trail_location = kwargs['trailLocation']
        if work_request_id is None and 'workRequestId' in kwargs:
            work_request_id = kwargs['workRequestId']

        if audit_collection_start_time is not None:
            _setter("audit_collection_start_time", audit_collection_start_time)
        if audit_profile_id is not None:
            _setter("audit_profile_id", audit_profile_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if id is not None:
            _setter("id", id)
        if is_auto_purge_enabled is not None:
            _setter("is_auto_purge_enabled", is_auto_purge_enabled)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if state is not None:
            _setter("state", state)
        if status is not None:
            _setter("status", status)
        if system_tags is not None:
            _setter("system_tags", system_tags)
        if target_id is not None:
            _setter("target_id", target_id)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_last_collected is not None:
            _setter("time_last_collected", time_last_collected)
        if time_updated is not None:
            _setter("time_updated", time_updated)
        if trail_location is not None:
            _setter("trail_location", trail_location)
        if work_request_id is not None:
            _setter("work_request_id", work_request_id)

    @property
    @pulumi.getter(name="auditCollectionStartTime")
    def audit_collection_start_time(self) -> Optional[str]:
        """
        The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        """
        return pulumi.get(self, "audit_collection_start_time")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> Optional[str]:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the compartment that contains the audit.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) The description of the audit profile.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) The display name of the audit profile. The name does not have to be unique, and it's changeable.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The OCID of the audit profile.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutoPurgeEnabled")
    def is_auto_purge_enabled(self) -> Optional[bool]:
        """
        Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        """
        return pulumi.get(self, "is_auto_purge_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Details about the current state of the audit profile in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the audit profile.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current sub-state of the audit trail.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[Mapping[str, Any]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[str]:
        """
        The OCID of the Data Safe target for which the audit profile is created.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the audit profile was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastCollected")
    def time_last_collected(self) -> Optional[str]:
        """
        The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_collected")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> Optional[str]:
        """
        An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        return pulumi.get(self, "trail_location")

    @property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> Optional[str]:
        """
        The OCID of the workrequest for audit trail which collects audit records.
        """
        return pulumi.get(self, "work_request_id")


@pulumi.output_type
class DataSafeConfigurationGlobalSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPaidUsage":
            suggest = "is_paid_usage"
        elif key == "offlineRetentionPeriod":
            suggest = "offline_retention_period"
        elif key == "onlineRetentionPeriod":
            suggest = "online_retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSafeConfigurationGlobalSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSafeConfigurationGlobalSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSafeConfigurationGlobalSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_paid_usage: Optional[bool] = None,
                 offline_retention_period: Optional[int] = None,
                 online_retention_period: Optional[int] = None):
        """
        :param bool is_paid_usage: The paid usage option chosen by the customer admin.
        :param int offline_retention_period: The offline retention period in months.
        :param int online_retention_period: The online retention period in months.
        """
        DataSafeConfigurationGlobalSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_paid_usage=is_paid_usage,
            offline_retention_period=offline_retention_period,
            online_retention_period=online_retention_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_paid_usage: Optional[bool] = None,
             offline_retention_period: Optional[int] = None,
             online_retention_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_paid_usage is None and 'isPaidUsage' in kwargs:
            is_paid_usage = kwargs['isPaidUsage']
        if offline_retention_period is None and 'offlineRetentionPeriod' in kwargs:
            offline_retention_period = kwargs['offlineRetentionPeriod']
        if online_retention_period is None and 'onlineRetentionPeriod' in kwargs:
            online_retention_period = kwargs['onlineRetentionPeriod']

        if is_paid_usage is not None:
            _setter("is_paid_usage", is_paid_usage)
        if offline_retention_period is not None:
            _setter("offline_retention_period", offline_retention_period)
        if online_retention_period is not None:
            _setter("online_retention_period", online_retention_period)

    @property
    @pulumi.getter(name="isPaidUsage")
    def is_paid_usage(self) -> Optional[bool]:
        """
        The paid usage option chosen by the customer admin.
        """
        return pulumi.get(self, "is_paid_usage")

    @property
    @pulumi.getter(name="offlineRetentionPeriod")
    def offline_retention_period(self) -> Optional[int]:
        """
        The offline retention period in months.
        """
        return pulumi.get(self, "offline_retention_period")

    @property
    @pulumi.getter(name="onlineRetentionPeriod")
    def online_retention_period(self) -> Optional[int]:
        """
        The online retention period in months.
        """
        return pulumi.get(self, "online_retention_period")


@pulumi.output_type
class DiscoveryJobsResultModifiedAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appDefinedChildColumnKeys":
            suggest = "app_defined_child_column_keys"
        elif key == "dbDefinedChildColumnKeys":
            suggest = "db_defined_child_column_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveryJobsResultModifiedAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveryJobsResultModifiedAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveryJobsResultModifiedAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_defined_child_column_keys: Optional[Sequence[str]] = None,
                 db_defined_child_column_keys: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_defined_child_column_keys: Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        :param Sequence[str] db_defined_child_column_keys: Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        DiscoveryJobsResultModifiedAttribute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_defined_child_column_keys=app_defined_child_column_keys,
            db_defined_child_column_keys=db_defined_child_column_keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_defined_child_column_keys: Optional[Sequence[str]] = None,
             db_defined_child_column_keys: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_defined_child_column_keys is None and 'appDefinedChildColumnKeys' in kwargs:
            app_defined_child_column_keys = kwargs['appDefinedChildColumnKeys']
        if db_defined_child_column_keys is None and 'dbDefinedChildColumnKeys' in kwargs:
            db_defined_child_column_keys = kwargs['dbDefinedChildColumnKeys']

        if app_defined_child_column_keys is not None:
            _setter("app_defined_child_column_keys", app_defined_child_column_keys)
        if db_defined_child_column_keys is not None:
            _setter("db_defined_child_column_keys", db_defined_child_column_keys)

    @property
    @pulumi.getter(name="appDefinedChildColumnKeys")
    def app_defined_child_column_keys(self) -> Optional[Sequence[str]]:
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        return pulumi.get(self, "app_defined_child_column_keys")

    @property
    @pulumi.getter(name="dbDefinedChildColumnKeys")
    def db_defined_child_column_keys(self) -> Optional[Sequence[str]]:
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        return pulumi.get(self, "db_defined_child_column_keys")


@pulumi.output_type
class LibraryMasingFormatFormatEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "endLength":
            suggest = "end_length"
        elif key == "endValue":
            suggest = "end_value"
        elif key == "fixedNumber":
            suggest = "fixed_number"
        elif key == "fixedString":
            suggest = "fixed_string"
        elif key == "groupingColumns":
            suggest = "grouping_columns"
        elif key == "libraryMaskingFormatId":
            suggest = "library_masking_format_id"
        elif key == "postProcessingFunction":
            suggest = "post_processing_function"
        elif key == "randomLists":
            suggest = "random_lists"
        elif key == "regularExpression":
            suggest = "regular_expression"
        elif key == "replaceWith":
            suggest = "replace_with"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "sqlExpression":
            suggest = "sql_expression"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "startLength":
            suggest = "start_length"
        elif key == "startPosition":
            suggest = "start_position"
        elif key == "startValue":
            suggest = "start_value"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "userDefinedFunction":
            suggest = "user_defined_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LibraryMasingFormatFormatEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LibraryMasingFormatFormatEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LibraryMasingFormatFormatEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 column_name: Optional[str] = None,
                 description: Optional[str] = None,
                 end_date: Optional[str] = None,
                 end_length: Optional[int] = None,
                 end_value: Optional[float] = None,
                 fixed_number: Optional[float] = None,
                 fixed_string: Optional[str] = None,
                 grouping_columns: Optional[Sequence[str]] = None,
                 length: Optional[int] = None,
                 library_masking_format_id: Optional[str] = None,
                 post_processing_function: Optional[str] = None,
                 random_lists: Optional[Sequence[str]] = None,
                 regular_expression: Optional[str] = None,
                 replace_with: Optional[str] = None,
                 schema_name: Optional[str] = None,
                 sql_expression: Optional[str] = None,
                 start_date: Optional[str] = None,
                 start_length: Optional[int] = None,
                 start_position: Optional[int] = None,
                 start_value: Optional[float] = None,
                 table_name: Optional[str] = None,
                 user_defined_function: Optional[str] = None):
        """
        :param str type: (Updatable) The type of the format entry.
        :param str column_name: (Updatable) The name of the substitution column.
        :param str description: (Updatable) The description of the format entry.
        :param str end_date: (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param int end_length: (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param float end_value: (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param float fixed_number: (Updatable) The constant number to be used for masking.
        :param str fixed_string: (Updatable) The constant string to be used for masking.
        :param Sequence[str] grouping_columns: (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param int length: (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param str library_masking_format_id: (Updatable) The OCID of the library masking format.
        :param str post_processing_function: (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param Sequence[str] random_lists: (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param str regular_expression: (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
               
               In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.
               
               If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        :param str replace_with: (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        :param str schema_name: (Updatable) The name of the schema that contains the substitution column.
        :param str sql_expression: (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param str start_date: (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param int start_length: (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param int start_position: (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param float start_value: (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param str table_name: (Updatable) The name of the table that contains the substitution column.
        :param str user_defined_function: (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        LibraryMasingFormatFormatEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            column_name=column_name,
            description=description,
            end_date=end_date,
            end_length=end_length,
            end_value=end_value,
            fixed_number=fixed_number,
            fixed_string=fixed_string,
            grouping_columns=grouping_columns,
            length=length,
            library_masking_format_id=library_masking_format_id,
            post_processing_function=post_processing_function,
            random_lists=random_lists,
            regular_expression=regular_expression,
            replace_with=replace_with,
            schema_name=schema_name,
            sql_expression=sql_expression,
            start_date=start_date,
            start_length=start_length,
            start_position=start_position,
            start_value=start_value,
            table_name=table_name,
            user_defined_function=user_defined_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             column_name: Optional[str] = None,
             description: Optional[str] = None,
             end_date: Optional[str] = None,
             end_length: Optional[int] = None,
             end_value: Optional[float] = None,
             fixed_number: Optional[float] = None,
             fixed_string: Optional[str] = None,
             grouping_columns: Optional[Sequence[str]] = None,
             length: Optional[int] = None,
             library_masking_format_id: Optional[str] = None,
             post_processing_function: Optional[str] = None,
             random_lists: Optional[Sequence[str]] = None,
             regular_expression: Optional[str] = None,
             replace_with: Optional[str] = None,
             schema_name: Optional[str] = None,
             sql_expression: Optional[str] = None,
             start_date: Optional[str] = None,
             start_length: Optional[int] = None,
             start_position: Optional[int] = None,
             start_value: Optional[float] = None,
             table_name: Optional[str] = None,
             user_defined_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_length is None and 'endLength' in kwargs:
            end_length = kwargs['endLength']
        if end_value is None and 'endValue' in kwargs:
            end_value = kwargs['endValue']
        if fixed_number is None and 'fixedNumber' in kwargs:
            fixed_number = kwargs['fixedNumber']
        if fixed_string is None and 'fixedString' in kwargs:
            fixed_string = kwargs['fixedString']
        if grouping_columns is None and 'groupingColumns' in kwargs:
            grouping_columns = kwargs['groupingColumns']
        if library_masking_format_id is None and 'libraryMaskingFormatId' in kwargs:
            library_masking_format_id = kwargs['libraryMaskingFormatId']
        if post_processing_function is None and 'postProcessingFunction' in kwargs:
            post_processing_function = kwargs['postProcessingFunction']
        if random_lists is None and 'randomLists' in kwargs:
            random_lists = kwargs['randomLists']
        if regular_expression is None and 'regularExpression' in kwargs:
            regular_expression = kwargs['regularExpression']
        if replace_with is None and 'replaceWith' in kwargs:
            replace_with = kwargs['replaceWith']
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if sql_expression is None and 'sqlExpression' in kwargs:
            sql_expression = kwargs['sqlExpression']
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_length is None and 'startLength' in kwargs:
            start_length = kwargs['startLength']
        if start_position is None and 'startPosition' in kwargs:
            start_position = kwargs['startPosition']
        if start_value is None and 'startValue' in kwargs:
            start_value = kwargs['startValue']
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if user_defined_function is None and 'userDefinedFunction' in kwargs:
            user_defined_function = kwargs['userDefinedFunction']

        _setter("type", type)
        if column_name is not None:
            _setter("column_name", column_name)
        if description is not None:
            _setter("description", description)
        if end_date is not None:
            _setter("end_date", end_date)
        if end_length is not None:
            _setter("end_length", end_length)
        if end_value is not None:
            _setter("end_value", end_value)
        if fixed_number is not None:
            _setter("fixed_number", fixed_number)
        if fixed_string is not None:
            _setter("fixed_string", fixed_string)
        if grouping_columns is not None:
            _setter("grouping_columns", grouping_columns)
        if length is not None:
            _setter("length", length)
        if library_masking_format_id is not None:
            _setter("library_masking_format_id", library_masking_format_id)
        if post_processing_function is not None:
            _setter("post_processing_function", post_processing_function)
        if random_lists is not None:
            _setter("random_lists", random_lists)
        if regular_expression is not None:
            _setter("regular_expression", regular_expression)
        if replace_with is not None:
            _setter("replace_with", replace_with)
        if schema_name is not None:
            _setter("schema_name", schema_name)
        if sql_expression is not None:
            _setter("sql_expression", sql_expression)
        if start_date is not None:
            _setter("start_date", start_date)
        if start_length is not None:
            _setter("start_length", start_length)
        if start_position is not None:
            _setter("start_position", start_position)
        if start_value is not None:
            _setter("start_value", start_value)
        if table_name is not None:
            _setter("table_name", table_name)
        if user_defined_function is not None:
            _setter("user_defined_function", user_defined_function)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Updatable) The type of the format entry.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        (Updatable) The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endLength")
    def end_length(self) -> Optional[int]:
        """
        (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @property
    @pulumi.getter(name="endValue")
    def end_value(self) -> Optional[float]:
        """
        (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> Optional[float]:
        """
        (Updatable) The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> Optional[str]:
        """
        (Updatable) The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Optional[Sequence[str]]:
        """
        (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @property
    @pulumi.getter
    def length(self) -> Optional[int]:
        """
        (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> Optional[str]:
        """
        (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Optional[Sequence[str]]:
        """
        (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[str]:
        """
        (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.

        In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.

        If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> Optional[str]:
        """
        (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        """
        return pulumi.get(self, "replace_with")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        (Updatable) The name of the schema that contains the substitution column.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> Optional[str]:
        """
        (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startLength")
    def start_length(self) -> Optional[int]:
        """
        (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> Optional[int]:
        """
        (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[float]:
        """
        (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[str]:
        """
        (Updatable) The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> Optional[str]:
        """
        (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")


@pulumi.output_type
class MaskingPoliciesMaskingColumnMaskingFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatEntries":
            suggest = "format_entries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaskingPoliciesMaskingColumnMaskingFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaskingPoliciesMaskingColumnMaskingFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaskingPoliciesMaskingColumnMaskingFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_entries: Sequence['outputs.MaskingPoliciesMaskingColumnMaskingFormatFormatEntry'],
                 condition: Optional[str] = None,
                 description: Optional[str] = None):
        """
        :param Sequence['MaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs'] format_entries: (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        :param str condition: (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        :param str description: (Updatable) The description of the format entry.
        """
        MaskingPoliciesMaskingColumnMaskingFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_entries=format_entries,
            condition=condition,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_entries: Optional[Sequence['outputs.MaskingPoliciesMaskingColumnMaskingFormatFormatEntry']] = None,
             condition: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if format_entries is None and 'formatEntries' in kwargs:
            format_entries = kwargs['formatEntries']
        if format_entries is None:
            raise TypeError("Missing 'format_entries' argument")

        _setter("format_entries", format_entries)
        if condition is not None:
            _setter("condition", condition)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="formatEntries")
    def format_entries(self) -> Sequence['outputs.MaskingPoliciesMaskingColumnMaskingFormatFormatEntry']:
        """
        (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        return pulumi.get(self, "format_entries")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) The description of the format entry.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MaskingPoliciesMaskingColumnMaskingFormatFormatEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "endLength":
            suggest = "end_length"
        elif key == "endValue":
            suggest = "end_value"
        elif key == "fixedNumber":
            suggest = "fixed_number"
        elif key == "fixedString":
            suggest = "fixed_string"
        elif key == "groupingColumns":
            suggest = "grouping_columns"
        elif key == "libraryMaskingFormatId":
            suggest = "library_masking_format_id"
        elif key == "postProcessingFunction":
            suggest = "post_processing_function"
        elif key == "randomLists":
            suggest = "random_lists"
        elif key == "regularExpression":
            suggest = "regular_expression"
        elif key == "replaceWith":
            suggest = "replace_with"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "sqlExpression":
            suggest = "sql_expression"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "startLength":
            suggest = "start_length"
        elif key == "startPosition":
            suggest = "start_position"
        elif key == "startValue":
            suggest = "start_value"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "userDefinedFunction":
            suggest = "user_defined_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaskingPoliciesMaskingColumnMaskingFormatFormatEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaskingPoliciesMaskingColumnMaskingFormatFormatEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaskingPoliciesMaskingColumnMaskingFormatFormatEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 column_name: Optional[str] = None,
                 description: Optional[str] = None,
                 end_date: Optional[str] = None,
                 end_length: Optional[int] = None,
                 end_value: Optional[float] = None,
                 fixed_number: Optional[float] = None,
                 fixed_string: Optional[str] = None,
                 grouping_columns: Optional[Sequence[str]] = None,
                 length: Optional[int] = None,
                 library_masking_format_id: Optional[str] = None,
                 post_processing_function: Optional[str] = None,
                 random_lists: Optional[Sequence[str]] = None,
                 regular_expression: Optional[str] = None,
                 replace_with: Optional[str] = None,
                 schema_name: Optional[str] = None,
                 sql_expression: Optional[str] = None,
                 start_date: Optional[str] = None,
                 start_length: Optional[int] = None,
                 start_position: Optional[int] = None,
                 start_value: Optional[float] = None,
                 table_name: Optional[str] = None,
                 user_defined_function: Optional[str] = None):
        """
        :param str type: (Updatable) The type of the format entry.
        :param str column_name: (Updatable) The name of the substitution column.
        :param str description: (Updatable) The description of the format entry.
        :param str end_date: (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param int end_length: (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param float end_value: (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param float fixed_number: (Updatable) The constant number to be used for masking.
        :param str fixed_string: (Updatable) The constant string to be used for masking.
        :param Sequence[str] grouping_columns: (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param int length: (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param str library_masking_format_id: (Updatable) The OCID of the library masking format.
        :param str post_processing_function: (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param Sequence[str] random_lists: (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param str regular_expression: (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
               
               In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.
               
               If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        :param str replace_with: (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        :param str schema_name: The name of the schema that contains the database column. This attribute cannot be updated for an existing masking column.
        :param str sql_expression: (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param str start_date: (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param int start_length: (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param int start_position: (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param float start_value: (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param str table_name: (Updatable) The name of the table that contains the substitution column.
        :param str user_defined_function: (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        MaskingPoliciesMaskingColumnMaskingFormatFormatEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            column_name=column_name,
            description=description,
            end_date=end_date,
            end_length=end_length,
            end_value=end_value,
            fixed_number=fixed_number,
            fixed_string=fixed_string,
            grouping_columns=grouping_columns,
            length=length,
            library_masking_format_id=library_masking_format_id,
            post_processing_function=post_processing_function,
            random_lists=random_lists,
            regular_expression=regular_expression,
            replace_with=replace_with,
            schema_name=schema_name,
            sql_expression=sql_expression,
            start_date=start_date,
            start_length=start_length,
            start_position=start_position,
            start_value=start_value,
            table_name=table_name,
            user_defined_function=user_defined_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             column_name: Optional[str] = None,
             description: Optional[str] = None,
             end_date: Optional[str] = None,
             end_length: Optional[int] = None,
             end_value: Optional[float] = None,
             fixed_number: Optional[float] = None,
             fixed_string: Optional[str] = None,
             grouping_columns: Optional[Sequence[str]] = None,
             length: Optional[int] = None,
             library_masking_format_id: Optional[str] = None,
             post_processing_function: Optional[str] = None,
             random_lists: Optional[Sequence[str]] = None,
             regular_expression: Optional[str] = None,
             replace_with: Optional[str] = None,
             schema_name: Optional[str] = None,
             sql_expression: Optional[str] = None,
             start_date: Optional[str] = None,
             start_length: Optional[int] = None,
             start_position: Optional[int] = None,
             start_value: Optional[float] = None,
             table_name: Optional[str] = None,
             user_defined_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_length is None and 'endLength' in kwargs:
            end_length = kwargs['endLength']
        if end_value is None and 'endValue' in kwargs:
            end_value = kwargs['endValue']
        if fixed_number is None and 'fixedNumber' in kwargs:
            fixed_number = kwargs['fixedNumber']
        if fixed_string is None and 'fixedString' in kwargs:
            fixed_string = kwargs['fixedString']
        if grouping_columns is None and 'groupingColumns' in kwargs:
            grouping_columns = kwargs['groupingColumns']
        if library_masking_format_id is None and 'libraryMaskingFormatId' in kwargs:
            library_masking_format_id = kwargs['libraryMaskingFormatId']
        if post_processing_function is None and 'postProcessingFunction' in kwargs:
            post_processing_function = kwargs['postProcessingFunction']
        if random_lists is None and 'randomLists' in kwargs:
            random_lists = kwargs['randomLists']
        if regular_expression is None and 'regularExpression' in kwargs:
            regular_expression = kwargs['regularExpression']
        if replace_with is None and 'replaceWith' in kwargs:
            replace_with = kwargs['replaceWith']
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if sql_expression is None and 'sqlExpression' in kwargs:
            sql_expression = kwargs['sqlExpression']
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_length is None and 'startLength' in kwargs:
            start_length = kwargs['startLength']
        if start_position is None and 'startPosition' in kwargs:
            start_position = kwargs['startPosition']
        if start_value is None and 'startValue' in kwargs:
            start_value = kwargs['startValue']
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if user_defined_function is None and 'userDefinedFunction' in kwargs:
            user_defined_function = kwargs['userDefinedFunction']

        _setter("type", type)
        if column_name is not None:
            _setter("column_name", column_name)
        if description is not None:
            _setter("description", description)
        if end_date is not None:
            _setter("end_date", end_date)
        if end_length is not None:
            _setter("end_length", end_length)
        if end_value is not None:
            _setter("end_value", end_value)
        if fixed_number is not None:
            _setter("fixed_number", fixed_number)
        if fixed_string is not None:
            _setter("fixed_string", fixed_string)
        if grouping_columns is not None:
            _setter("grouping_columns", grouping_columns)
        if length is not None:
            _setter("length", length)
        if library_masking_format_id is not None:
            _setter("library_masking_format_id", library_masking_format_id)
        if post_processing_function is not None:
            _setter("post_processing_function", post_processing_function)
        if random_lists is not None:
            _setter("random_lists", random_lists)
        if regular_expression is not None:
            _setter("regular_expression", regular_expression)
        if replace_with is not None:
            _setter("replace_with", replace_with)
        if schema_name is not None:
            _setter("schema_name", schema_name)
        if sql_expression is not None:
            _setter("sql_expression", sql_expression)
        if start_date is not None:
            _setter("start_date", start_date)
        if start_length is not None:
            _setter("start_length", start_length)
        if start_position is not None:
            _setter("start_position", start_position)
        if start_value is not None:
            _setter("start_value", start_value)
        if table_name is not None:
            _setter("table_name", table_name)
        if user_defined_function is not None:
            _setter("user_defined_function", user_defined_function)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Updatable) The type of the format entry.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        (Updatable) The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endLength")
    def end_length(self) -> Optional[int]:
        """
        (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @property
    @pulumi.getter(name="endValue")
    def end_value(self) -> Optional[float]:
        """
        (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> Optional[float]:
        """
        (Updatable) The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> Optional[str]:
        """
        (Updatable) The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Optional[Sequence[str]]:
        """
        (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @property
    @pulumi.getter
    def length(self) -> Optional[int]:
        """
        (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> Optional[str]:
        """
        (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Optional[Sequence[str]]:
        """
        (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[str]:
        """
        (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.

        In the case of ASCII characters, if a regular expression is not provided,  Deterministic Encryption can encrypt variable-length column values while  preserving their original format.

        If a regular expression is provided, the column values in all the rows must match  the regular expression. Deterministic Encryption supports a subset of the regular  expression language. It supports encryption of fixed-length strings, and does not  support * or + syntax of regular expressions. The encrypted values also match the  regular expression, which helps to ensure that the original format is preserved.  If an original value does not match the regular expression, Deterministic Encryption  might not produce a one-to-one mapping. All non-confirming values are mapped to a  single encrypted value, thereby producing a many-to-one mapping.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> Optional[str]:
        """
        (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        """
        return pulumi.get(self, "replace_with")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The name of the schema that contains the database column. This attribute cannot be updated for an existing masking column.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> Optional[str]:
        """
        (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startLength")
    def start_length(self) -> Optional[int]:
        """
        (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> Optional[int]:
        """
        (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[float]:
        """
        (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[str]:
        """
        (Updatable) The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> Optional[str]:
        """
        (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")


@pulumi.output_type
class MaskingPolicyColumnSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSource":
            suggest = "column_source"
        elif key == "sensitiveDataModelId":
            suggest = "sensitive_data_model_id"
        elif key == "targetId":
            suggest = "target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaskingPolicyColumnSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaskingPolicyColumnSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaskingPolicyColumnSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_source: str,
                 sensitive_data_model_id: Optional[str] = None,
                 target_id: Optional[str] = None):
        """
        :param str column_source: (Updatable) The source of masking columns.
        :param str sensitive_data_model_id: (Updatable) The OCID of the sensitive data model to be associated as the column source with the masking policy.
        :param str target_id: (Updatable) The OCID of the target database to be associated as the column source with the masking policy.
        """
        MaskingPolicyColumnSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_source=column_source,
            sensitive_data_model_id=sensitive_data_model_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_source: Optional[str] = None,
             sensitive_data_model_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_source is None and 'columnSource' in kwargs:
            column_source = kwargs['columnSource']
        if column_source is None:
            raise TypeError("Missing 'column_source' argument")
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']

        _setter("column_source", column_source)
        if sensitive_data_model_id is not None:
            _setter("sensitive_data_model_id", sensitive_data_model_id)
        if target_id is not None:
            _setter("target_id", target_id)

    @property
    @pulumi.getter(name="columnSource")
    def column_source(self) -> str:
        """
        (Updatable) The source of masking columns.
        """
        return pulumi.get(self, "column_source")

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the sensitive data model to be associated as the column source with the masking policy.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the target database to be associated as the column source with the masking policy.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class ReportDefinitionColumnFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isHidden":
            suggest = "is_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportDefinitionColumnFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportDefinitionColumnFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportDefinitionColumnFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expressions: Sequence[str],
                 field_name: str,
                 is_enabled: bool,
                 is_hidden: bool,
                 operator: str):
        """
        :param Sequence[str] expressions: (Updatable) An array of expressions based on the operator type. A filter may have one or more expressions.
        :param str field_name: (Updatable) Name of the column that must be sorted.
        :param bool is_enabled: (Updatable) Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        :param bool is_hidden: (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str operator: (Updatable) Specifies the type of operator that must be applied for example in, eq etc.
        """
        ReportDefinitionColumnFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expressions=expressions,
            field_name=field_name,
            is_enabled=is_enabled,
            is_hidden=is_hidden,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expressions: Optional[Sequence[str]] = None,
             field_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             is_hidden: Optional[bool] = None,
             operator: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expressions is None:
            raise TypeError("Missing 'expressions' argument")
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")
        if operator is None:
            raise TypeError("Missing 'operator' argument")

        _setter("expressions", expressions)
        _setter("field_name", field_name)
        _setter("is_enabled", is_enabled)
        _setter("is_hidden", is_hidden)
        _setter("operator", operator)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence[str]:
        """
        (Updatable) An array of expressions based on the operator type. A filter may have one or more expressions.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        (Updatable) Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        (Updatable) Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        (Updatable) Specifies the type of operator that must be applied for example in, eq etc.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class ReportDefinitionColumnInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "displayOrder":
            suggest = "display_order"
        elif key == "fieldName":
            suggest = "field_name"
        elif key == "isHidden":
            suggest = "is_hidden"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportDefinitionColumnInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportDefinitionColumnInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportDefinitionColumnInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str,
                 display_order: int,
                 field_name: str,
                 is_hidden: bool,
                 data_type: Optional[str] = None):
        """
        :param str display_name: (Updatable) Specifies the name of the report definition.
        :param int display_order: (Updatable) Specifies the order in which the summary must be displayed.
        :param str field_name: (Updatable) Name of the column that must be sorted.
        :param bool is_hidden: (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str data_type: (Updatable) Specifies the data type of the column.
        """
        ReportDefinitionColumnInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            display_order=display_order,
            field_name=field_name,
            is_hidden=is_hidden,
            data_type=data_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             display_order: Optional[int] = None,
             field_name: Optional[str] = None,
             is_hidden: Optional[bool] = None,
             data_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("display_name", display_name)
        _setter("display_order", display_order)
        _setter("field_name", field_name)
        _setter("is_hidden", is_hidden)
        if data_type is not None:
            _setter("data_type", data_type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        (Updatable) Specifies the name of the report definition.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        (Updatable) Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        (Updatable) Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        (Updatable) Specifies the data type of the column.
        """
        return pulumi.get(self, "data_type")


@pulumi.output_type
class ReportDefinitionColumnSorting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAscending":
            suggest = "is_ascending"
        elif key == "sortingOrder":
            suggest = "sorting_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportDefinitionColumnSorting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportDefinitionColumnSorting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportDefinitionColumnSorting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 is_ascending: bool,
                 sorting_order: int):
        """
        :param str field_name: (Updatable) Name of the column that must be sorted.
        :param bool is_ascending: (Updatable) Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        :param int sorting_order: (Updatable) Indicates the order at which column must be sorted.
        """
        ReportDefinitionColumnSorting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            is_ascending=is_ascending,
            sorting_order=sorting_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: Optional[str] = None,
             is_ascending: Optional[bool] = None,
             sorting_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_ascending is None and 'isAscending' in kwargs:
            is_ascending = kwargs['isAscending']
        if is_ascending is None:
            raise TypeError("Missing 'is_ascending' argument")
        if sorting_order is None and 'sortingOrder' in kwargs:
            sorting_order = kwargs['sortingOrder']
        if sorting_order is None:
            raise TypeError("Missing 'sorting_order' argument")

        _setter("field_name", field_name)
        _setter("is_ascending", is_ascending)
        _setter("sorting_order", sorting_order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        (Updatable) Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isAscending")
    def is_ascending(self) -> bool:
        """
        (Updatable) Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_ascending")

    @property
    @pulumi.getter(name="sortingOrder")
    def sorting_order(self) -> int:
        """
        (Updatable) Indicates the order at which column must be sorted.
        """
        return pulumi.get(self, "sorting_order")


@pulumi.output_type
class ReportDefinitionSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayOrder":
            suggest = "display_order"
        elif key == "countOf":
            suggest = "count_of"
        elif key == "groupByFieldName":
            suggest = "group_by_field_name"
        elif key == "isHidden":
            suggest = "is_hidden"
        elif key == "scimFilter":
            suggest = "scim_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportDefinitionSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportDefinitionSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportDefinitionSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_order: int,
                 name: str,
                 count_of: Optional[str] = None,
                 group_by_field_name: Optional[str] = None,
                 is_hidden: Optional[bool] = None,
                 scim_filter: Optional[str] = None):
        """
        :param int display_order: (Updatable) Specifies the order in which the summary must be displayed.
        :param str name: (Updatable) Name of the report summary.
        :param str count_of: (Updatable) Name of the key or count of object.
        :param str group_by_field_name: (Updatable) A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        :param bool is_hidden: (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str scim_filter: (Updatable) Additional scim filters used to get the specific summary.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        ReportDefinitionSummary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_order=display_order,
            name=name,
            count_of=count_of,
            group_by_field_name=group_by_field_name,
            is_hidden=is_hidden,
            scim_filter=scim_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_order: Optional[int] = None,
             name: Optional[str] = None,
             count_of: Optional[str] = None,
             group_by_field_name: Optional[str] = None,
             is_hidden: Optional[bool] = None,
             scim_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if count_of is None and 'countOf' in kwargs:
            count_of = kwargs['countOf']
        if group_by_field_name is None and 'groupByFieldName' in kwargs:
            group_by_field_name = kwargs['groupByFieldName']
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if scim_filter is None and 'scimFilter' in kwargs:
            scim_filter = kwargs['scimFilter']

        _setter("display_order", display_order)
        _setter("name", name)
        if count_of is not None:
            _setter("count_of", count_of)
        if group_by_field_name is not None:
            _setter("group_by_field_name", group_by_field_name)
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if scim_filter is not None:
            _setter("scim_filter", scim_filter)

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        (Updatable) Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the report summary.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="countOf")
    def count_of(self) -> Optional[str]:
        """
        (Updatable) Name of the key or count of object.
        """
        return pulumi.get(self, "count_of")

    @property
    @pulumi.getter(name="groupByFieldName")
    def group_by_field_name(self) -> Optional[str]:
        """
        (Updatable) A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        """
        return pulumi.get(self, "group_by_field_name")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        (Updatable) Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter(name="scimFilter")
    def scim_filter(self) -> Optional[str]:
        """
        (Updatable) Additional scim filters used to get the specific summary.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "scim_filter")


@pulumi.output_type
class SecurityAssessmentStatistic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highRisks":
            suggest = "high_risks"
        elif key == "lowRisks":
            suggest = "low_risks"
        elif key == "mediumRisks":
            suggest = "medium_risks"
        elif key == "targetsCount":
            suggest = "targets_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatistic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatistic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatistic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advisories: Optional[Sequence['outputs.SecurityAssessmentStatisticAdvisory']] = None,
                 evaluates: Optional[Sequence['outputs.SecurityAssessmentStatisticEvaluate']] = None,
                 high_risks: Optional[Sequence['outputs.SecurityAssessmentStatisticHighRisk']] = None,
                 low_risks: Optional[Sequence['outputs.SecurityAssessmentStatisticLowRisk']] = None,
                 medium_risks: Optional[Sequence['outputs.SecurityAssessmentStatisticMediumRisk']] = None,
                 passes: Optional[Sequence['outputs.SecurityAssessmentStatisticPass']] = None,
                 targets_count: Optional[int] = None):
        """
        :param Sequence['SecurityAssessmentStatisticAdvisoryArgs'] advisories: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['SecurityAssessmentStatisticEvaluateArgs'] evaluates: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['SecurityAssessmentStatisticHighRiskArgs'] high_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['SecurityAssessmentStatisticLowRiskArgs'] low_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['SecurityAssessmentStatisticMediumRiskArgs'] medium_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['SecurityAssessmentStatisticPassArgs'] passes: Statistics showing the number of findings with a particular risk level for each category.
        :param int targets_count: The total number of targets in this security assessment.
        """
        SecurityAssessmentStatistic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advisories=advisories,
            evaluates=evaluates,
            high_risks=high_risks,
            low_risks=low_risks,
            medium_risks=medium_risks,
            passes=passes,
            targets_count=targets_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advisories: Optional[Sequence['outputs.SecurityAssessmentStatisticAdvisory']] = None,
             evaluates: Optional[Sequence['outputs.SecurityAssessmentStatisticEvaluate']] = None,
             high_risks: Optional[Sequence['outputs.SecurityAssessmentStatisticHighRisk']] = None,
             low_risks: Optional[Sequence['outputs.SecurityAssessmentStatisticLowRisk']] = None,
             medium_risks: Optional[Sequence['outputs.SecurityAssessmentStatisticMediumRisk']] = None,
             passes: Optional[Sequence['outputs.SecurityAssessmentStatisticPass']] = None,
             targets_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if high_risks is None and 'highRisks' in kwargs:
            high_risks = kwargs['highRisks']
        if low_risks is None and 'lowRisks' in kwargs:
            low_risks = kwargs['lowRisks']
        if medium_risks is None and 'mediumRisks' in kwargs:
            medium_risks = kwargs['mediumRisks']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']

        if advisories is not None:
            _setter("advisories", advisories)
        if evaluates is not None:
            _setter("evaluates", evaluates)
        if high_risks is not None:
            _setter("high_risks", high_risks)
        if low_risks is not None:
            _setter("low_risks", low_risks)
        if medium_risks is not None:
            _setter("medium_risks", medium_risks)
        if passes is not None:
            _setter("passes", passes)
        if targets_count is not None:
            _setter("targets_count", targets_count)

    @property
    @pulumi.getter
    def advisories(self) -> Optional[Sequence['outputs.SecurityAssessmentStatisticAdvisory']]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "advisories")

    @property
    @pulumi.getter
    def evaluates(self) -> Optional[Sequence['outputs.SecurityAssessmentStatisticEvaluate']]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "evaluates")

    @property
    @pulumi.getter(name="highRisks")
    def high_risks(self) -> Optional[Sequence['outputs.SecurityAssessmentStatisticHighRisk']]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "high_risks")

    @property
    @pulumi.getter(name="lowRisks")
    def low_risks(self) -> Optional[Sequence['outputs.SecurityAssessmentStatisticLowRisk']]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "low_risks")

    @property
    @pulumi.getter(name="mediumRisks")
    def medium_risks(self) -> Optional[Sequence['outputs.SecurityAssessmentStatisticMediumRisk']]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "medium_risks")

    @property
    @pulumi.getter
    def passes(self) -> Optional[Sequence['outputs.SecurityAssessmentStatisticPass']]:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "passes")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")


@pulumi.output_type
class SecurityAssessmentStatisticAdvisory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditingFindingsCount":
            suggest = "auditing_findings_count"
        elif key == "authorizationControlFindingsCount":
            suggest = "authorization_control_findings_count"
        elif key == "dataEncryptionFindingsCount":
            suggest = "data_encryption_findings_count"
        elif key == "dbConfigurationFindingsCount":
            suggest = "db_configuration_findings_count"
        elif key == "fineGrainedAccessControlFindingsCount":
            suggest = "fine_grained_access_control_findings_count"
        elif key == "privilegesAndRolesFindingsCount":
            suggest = "privileges_and_roles_findings_count"
        elif key == "targetsCount":
            suggest = "targets_count"
        elif key == "userAccountsFindingsCount":
            suggest = "user_accounts_findings_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatisticAdvisory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatisticAdvisory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatisticAdvisory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auditing_findings_count: Optional[int] = None,
                 authorization_control_findings_count: Optional[int] = None,
                 data_encryption_findings_count: Optional[int] = None,
                 db_configuration_findings_count: Optional[int] = None,
                 fine_grained_access_control_findings_count: Optional[int] = None,
                 privileges_and_roles_findings_count: Optional[int] = None,
                 targets_count: Optional[int] = None,
                 user_accounts_findings_count: Optional[int] = None):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        SecurityAssessmentStatisticAdvisory._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']

        if auditing_findings_count is not None:
            _setter("auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            _setter("authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            _setter("data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            _setter("db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            _setter("targets_count", targets_count)
        if user_accounts_findings_count is not None:
            _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[int]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class SecurityAssessmentStatisticEvaluate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditingFindingsCount":
            suggest = "auditing_findings_count"
        elif key == "authorizationControlFindingsCount":
            suggest = "authorization_control_findings_count"
        elif key == "dataEncryptionFindingsCount":
            suggest = "data_encryption_findings_count"
        elif key == "dbConfigurationFindingsCount":
            suggest = "db_configuration_findings_count"
        elif key == "fineGrainedAccessControlFindingsCount":
            suggest = "fine_grained_access_control_findings_count"
        elif key == "privilegesAndRolesFindingsCount":
            suggest = "privileges_and_roles_findings_count"
        elif key == "targetsCount":
            suggest = "targets_count"
        elif key == "userAccountsFindingsCount":
            suggest = "user_accounts_findings_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatisticEvaluate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatisticEvaluate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatisticEvaluate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auditing_findings_count: Optional[int] = None,
                 authorization_control_findings_count: Optional[int] = None,
                 data_encryption_findings_count: Optional[int] = None,
                 db_configuration_findings_count: Optional[int] = None,
                 fine_grained_access_control_findings_count: Optional[int] = None,
                 privileges_and_roles_findings_count: Optional[int] = None,
                 targets_count: Optional[int] = None,
                 user_accounts_findings_count: Optional[int] = None):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        SecurityAssessmentStatisticEvaluate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']

        if auditing_findings_count is not None:
            _setter("auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            _setter("authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            _setter("data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            _setter("db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            _setter("targets_count", targets_count)
        if user_accounts_findings_count is not None:
            _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[int]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class SecurityAssessmentStatisticHighRisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditingFindingsCount":
            suggest = "auditing_findings_count"
        elif key == "authorizationControlFindingsCount":
            suggest = "authorization_control_findings_count"
        elif key == "dataEncryptionFindingsCount":
            suggest = "data_encryption_findings_count"
        elif key == "dbConfigurationFindingsCount":
            suggest = "db_configuration_findings_count"
        elif key == "fineGrainedAccessControlFindingsCount":
            suggest = "fine_grained_access_control_findings_count"
        elif key == "privilegesAndRolesFindingsCount":
            suggest = "privileges_and_roles_findings_count"
        elif key == "targetsCount":
            suggest = "targets_count"
        elif key == "userAccountsFindingsCount":
            suggest = "user_accounts_findings_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatisticHighRisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatisticHighRisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatisticHighRisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auditing_findings_count: Optional[int] = None,
                 authorization_control_findings_count: Optional[int] = None,
                 data_encryption_findings_count: Optional[int] = None,
                 db_configuration_findings_count: Optional[int] = None,
                 fine_grained_access_control_findings_count: Optional[int] = None,
                 privileges_and_roles_findings_count: Optional[int] = None,
                 targets_count: Optional[int] = None,
                 user_accounts_findings_count: Optional[int] = None):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        SecurityAssessmentStatisticHighRisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']

        if auditing_findings_count is not None:
            _setter("auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            _setter("authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            _setter("data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            _setter("db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            _setter("targets_count", targets_count)
        if user_accounts_findings_count is not None:
            _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[int]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class SecurityAssessmentStatisticLowRisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditingFindingsCount":
            suggest = "auditing_findings_count"
        elif key == "authorizationControlFindingsCount":
            suggest = "authorization_control_findings_count"
        elif key == "dataEncryptionFindingsCount":
            suggest = "data_encryption_findings_count"
        elif key == "dbConfigurationFindingsCount":
            suggest = "db_configuration_findings_count"
        elif key == "fineGrainedAccessControlFindingsCount":
            suggest = "fine_grained_access_control_findings_count"
        elif key == "privilegesAndRolesFindingsCount":
            suggest = "privileges_and_roles_findings_count"
        elif key == "targetsCount":
            suggest = "targets_count"
        elif key == "userAccountsFindingsCount":
            suggest = "user_accounts_findings_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatisticLowRisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatisticLowRisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatisticLowRisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auditing_findings_count: Optional[int] = None,
                 authorization_control_findings_count: Optional[int] = None,
                 data_encryption_findings_count: Optional[int] = None,
                 db_configuration_findings_count: Optional[int] = None,
                 fine_grained_access_control_findings_count: Optional[int] = None,
                 privileges_and_roles_findings_count: Optional[int] = None,
                 targets_count: Optional[int] = None,
                 user_accounts_findings_count: Optional[int] = None):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        SecurityAssessmentStatisticLowRisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']

        if auditing_findings_count is not None:
            _setter("auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            _setter("authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            _setter("data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            _setter("db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            _setter("targets_count", targets_count)
        if user_accounts_findings_count is not None:
            _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[int]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class SecurityAssessmentStatisticMediumRisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditingFindingsCount":
            suggest = "auditing_findings_count"
        elif key == "authorizationControlFindingsCount":
            suggest = "authorization_control_findings_count"
        elif key == "dataEncryptionFindingsCount":
            suggest = "data_encryption_findings_count"
        elif key == "dbConfigurationFindingsCount":
            suggest = "db_configuration_findings_count"
        elif key == "fineGrainedAccessControlFindingsCount":
            suggest = "fine_grained_access_control_findings_count"
        elif key == "privilegesAndRolesFindingsCount":
            suggest = "privileges_and_roles_findings_count"
        elif key == "targetsCount":
            suggest = "targets_count"
        elif key == "userAccountsFindingsCount":
            suggest = "user_accounts_findings_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatisticMediumRisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatisticMediumRisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatisticMediumRisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auditing_findings_count: Optional[int] = None,
                 authorization_control_findings_count: Optional[int] = None,
                 data_encryption_findings_count: Optional[int] = None,
                 db_configuration_findings_count: Optional[int] = None,
                 fine_grained_access_control_findings_count: Optional[int] = None,
                 privileges_and_roles_findings_count: Optional[int] = None,
                 targets_count: Optional[int] = None,
                 user_accounts_findings_count: Optional[int] = None):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        SecurityAssessmentStatisticMediumRisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']

        if auditing_findings_count is not None:
            _setter("auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            _setter("authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            _setter("data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            _setter("db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            _setter("targets_count", targets_count)
        if user_accounts_findings_count is not None:
            _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[int]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class SecurityAssessmentStatisticPass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditingFindingsCount":
            suggest = "auditing_findings_count"
        elif key == "authorizationControlFindingsCount":
            suggest = "authorization_control_findings_count"
        elif key == "dataEncryptionFindingsCount":
            suggest = "data_encryption_findings_count"
        elif key == "dbConfigurationFindingsCount":
            suggest = "db_configuration_findings_count"
        elif key == "fineGrainedAccessControlFindingsCount":
            suggest = "fine_grained_access_control_findings_count"
        elif key == "privilegesAndRolesFindingsCount":
            suggest = "privileges_and_roles_findings_count"
        elif key == "targetsCount":
            suggest = "targets_count"
        elif key == "userAccountsFindingsCount":
            suggest = "user_accounts_findings_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentStatisticPass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentStatisticPass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentStatisticPass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auditing_findings_count: Optional[int] = None,
                 authorization_control_findings_count: Optional[int] = None,
                 data_encryption_findings_count: Optional[int] = None,
                 db_configuration_findings_count: Optional[int] = None,
                 fine_grained_access_control_findings_count: Optional[int] = None,
                 privileges_and_roles_findings_count: Optional[int] = None,
                 targets_count: Optional[int] = None,
                 user_accounts_findings_count: Optional[int] = None):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        SecurityAssessmentStatisticPass._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']

        if auditing_findings_count is not None:
            _setter("auditing_findings_count", auditing_findings_count)
        if authorization_control_findings_count is not None:
            _setter("authorization_control_findings_count", authorization_control_findings_count)
        if data_encryption_findings_count is not None:
            _setter("data_encryption_findings_count", data_encryption_findings_count)
        if db_configuration_findings_count is not None:
            _setter("db_configuration_findings_count", db_configuration_findings_count)
        if fine_grained_access_control_findings_count is not None:
            _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        if privileges_and_roles_findings_count is not None:
            _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        if targets_count is not None:
            _setter("targets_count", targets_count)
        if user_accounts_findings_count is not None:
            _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> Optional[int]:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> Optional[int]:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> Optional[int]:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class TargetDatabaseConnectionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionType":
            suggest = "connection_type"
        elif key == "datasafePrivateEndpointId":
            suggest = "datasafe_private_endpoint_id"
        elif key == "onPremConnectorId":
            suggest = "on_prem_connector_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetDatabaseConnectionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetDatabaseConnectionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetDatabaseConnectionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_type: str,
                 datasafe_private_endpoint_id: Optional[str] = None,
                 on_prem_connector_id: Optional[str] = None):
        """
        :param str connection_type: (Updatable) The connection type used to connect to the database. Allowed values:
               * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
               * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        :param str datasafe_private_endpoint_id: (Updatable) The OCID of the Data Safe private endpoint.
        :param str on_prem_connector_id: (Updatable) The OCID of the on-premises connector.
        """
        TargetDatabaseConnectionOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_type=connection_type,
            datasafe_private_endpoint_id=datasafe_private_endpoint_id,
            on_prem_connector_id=on_prem_connector_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_type: Optional[str] = None,
             datasafe_private_endpoint_id: Optional[str] = None,
             on_prem_connector_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_type is None and 'connectionType' in kwargs:
            connection_type = kwargs['connectionType']
        if connection_type is None:
            raise TypeError("Missing 'connection_type' argument")
        if datasafe_private_endpoint_id is None and 'datasafePrivateEndpointId' in kwargs:
            datasafe_private_endpoint_id = kwargs['datasafePrivateEndpointId']
        if on_prem_connector_id is None and 'onPremConnectorId' in kwargs:
            on_prem_connector_id = kwargs['onPremConnectorId']

        _setter("connection_type", connection_type)
        if datasafe_private_endpoint_id is not None:
            _setter("datasafe_private_endpoint_id", datasafe_private_endpoint_id)
        if on_prem_connector_id is not None:
            _setter("on_prem_connector_id", on_prem_connector_id)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        (Updatable) The connection type used to connect to the database. Allowed values:
        * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
        * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="datasafePrivateEndpointId")
    def datasafe_private_endpoint_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the Data Safe private endpoint.
        """
        return pulumi.get(self, "datasafe_private_endpoint_id")

    @property
    @pulumi.getter(name="onPremConnectorId")
    def on_prem_connector_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the on-premises connector.
        """
        return pulumi.get(self, "on_prem_connector_id")


@pulumi.output_type
class TargetDatabaseCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetDatabaseCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetDatabaseCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetDatabaseCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 user_name: str):
        """
        :param str password: (Updatable) The password of the database user.
        :param str user_name: (Updatable) The database user name.
        """
        TargetDatabaseCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']
        if user_name is None:
            raise TypeError("Missing 'user_name' argument")

        _setter("password", password)
        _setter("user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        (Updatable) The password of the database user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        (Updatable) The database user name.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class TargetDatabaseDatabaseDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseType":
            suggest = "database_type"
        elif key == "infrastructureType":
            suggest = "infrastructure_type"
        elif key == "autonomousDatabaseId":
            suggest = "autonomous_database_id"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "listenerPort":
            suggest = "listener_port"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "vmClusterId":
            suggest = "vm_cluster_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetDatabaseDatabaseDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetDatabaseDatabaseDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetDatabaseDatabaseDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_type: str,
                 infrastructure_type: str,
                 autonomous_database_id: Optional[str] = None,
                 db_system_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 ip_addresses: Optional[Sequence[str]] = None,
                 listener_port: Optional[int] = None,
                 service_name: Optional[str] = None,
                 vm_cluster_id: Optional[str] = None):
        """
        :param str database_type: (Updatable) The database type.
        :param str infrastructure_type: (Updatable) The infrastructure type the database is running on.
        :param str autonomous_database_id: (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param str db_system_id: (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        :param str instance_id: (Updatable) The OCID of the compute instance on which the database is running.
        :param Sequence[str] ip_addresses: (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param int listener_port: (Updatable) The port number of the database listener.
        :param str service_name: (Updatable) The service name of the database registered as target database.
        :param str vm_cluster_id: (Updatable) The OCID of the VM cluster in which the database is running.
        """
        TargetDatabaseDatabaseDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_type=database_type,
            infrastructure_type=infrastructure_type,
            autonomous_database_id=autonomous_database_id,
            db_system_id=db_system_id,
            instance_id=instance_id,
            ip_addresses=ip_addresses,
            listener_port=listener_port,
            service_name=service_name,
            vm_cluster_id=vm_cluster_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_type: Optional[str] = None,
             infrastructure_type: Optional[str] = None,
             autonomous_database_id: Optional[str] = None,
             db_system_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             ip_addresses: Optional[Sequence[str]] = None,
             listener_port: Optional[int] = None,
             service_name: Optional[str] = None,
             vm_cluster_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_type is None and 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if database_type is None:
            raise TypeError("Missing 'database_type' argument")
        if infrastructure_type is None and 'infrastructureType' in kwargs:
            infrastructure_type = kwargs['infrastructureType']
        if infrastructure_type is None:
            raise TypeError("Missing 'infrastructure_type' argument")
        if autonomous_database_id is None and 'autonomousDatabaseId' in kwargs:
            autonomous_database_id = kwargs['autonomousDatabaseId']
        if db_system_id is None and 'dbSystemId' in kwargs:
            db_system_id = kwargs['dbSystemId']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if ip_addresses is None and 'ipAddresses' in kwargs:
            ip_addresses = kwargs['ipAddresses']
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if vm_cluster_id is None and 'vmClusterId' in kwargs:
            vm_cluster_id = kwargs['vmClusterId']

        _setter("database_type", database_type)
        _setter("infrastructure_type", infrastructure_type)
        if autonomous_database_id is not None:
            _setter("autonomous_database_id", autonomous_database_id)
        if db_system_id is not None:
            _setter("db_system_id", db_system_id)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if ip_addresses is not None:
            _setter("ip_addresses", ip_addresses)
        if listener_port is not None:
            _setter("listener_port", listener_port)
        if service_name is not None:
            _setter("service_name", service_name)
        if vm_cluster_id is not None:
            _setter("vm_cluster_id", vm_cluster_id)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        (Updatable) The database type.
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> str:
        """
        (Updatable) The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        (Updatable) The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[int]:
        """
        (Updatable) The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        (Updatable) The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class TargetDatabaseTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStoreType":
            suggest = "certificate_store_type"
        elif key == "keyStoreContent":
            suggest = "key_store_content"
        elif key == "storePassword":
            suggest = "store_password"
        elif key == "trustStoreContent":
            suggest = "trust_store_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetDatabaseTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetDatabaseTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetDatabaseTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 certificate_store_type: Optional[str] = None,
                 key_store_content: Optional[str] = None,
                 store_password: Optional[str] = None,
                 trust_store_content: Optional[str] = None):
        """
        :param str status: (Updatable) Status to represent whether the database connection is TLS enabled or not.
        :param str certificate_store_type: (Updatable) The format of the certificate store.
        :param str key_store_content: (Updatable) Base64 encoded string of key store file content.
        :param str store_password: (Updatable) The password to read the trust store and key store files, if they are password protected.
        :param str trust_store_content: (Updatable) Base64 encoded string of trust store file content.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        TargetDatabaseTlsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            certificate_store_type=certificate_store_type,
            key_store_content=key_store_content,
            store_password=store_password,
            trust_store_content=trust_store_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional[str] = None,
             certificate_store_type: Optional[str] = None,
             key_store_content: Optional[str] = None,
             store_password: Optional[str] = None,
             trust_store_content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if status is None:
            raise TypeError("Missing 'status' argument")
        if certificate_store_type is None and 'certificateStoreType' in kwargs:
            certificate_store_type = kwargs['certificateStoreType']
        if key_store_content is None and 'keyStoreContent' in kwargs:
            key_store_content = kwargs['keyStoreContent']
        if store_password is None and 'storePassword' in kwargs:
            store_password = kwargs['storePassword']
        if trust_store_content is None and 'trustStoreContent' in kwargs:
            trust_store_content = kwargs['trustStoreContent']

        _setter("status", status)
        if certificate_store_type is not None:
            _setter("certificate_store_type", certificate_store_type)
        if key_store_content is not None:
            _setter("key_store_content", key_store_content)
        if store_password is not None:
            _setter("store_password", store_password)
        if trust_store_content is not None:
            _setter("trust_store_content", trust_store_content)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        (Updatable) Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> Optional[str]:
        """
        (Updatable) The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> Optional[str]:
        """
        (Updatable) Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[str]:
        """
        (Updatable) The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> Optional[str]:
        """
        (Updatable) Base64 encoded string of trust store file content.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "trust_store_content")


@pulumi.output_type
class UserAssessmentIgnoredTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifecycleState":
            suggest = "lifecycle_state"
        elif key == "targetId":
            suggest = "target_id"
        elif key == "userAssessmentId":
            suggest = "user_assessment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssessmentIgnoredTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssessmentIgnoredTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssessmentIgnoredTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycle_state: Optional[str] = None,
                 target_id: Optional[str] = None,
                 user_assessment_id: Optional[str] = None):
        """
        :param str target_id: The OCID of the target database on which the user assessment is to be run.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        UserAssessmentIgnoredTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lifecycle_state=lifecycle_state,
            target_id=target_id,
            user_assessment_id=user_assessment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lifecycle_state: Optional[str] = None,
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lifecycle_state is None and 'lifecycleState' in kwargs:
            lifecycle_state = kwargs['lifecycleState']
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']

        if lifecycle_state is not None:
            _setter("lifecycle_state", lifecycle_state)
        if target_id is not None:
            _setter("target_id", target_id)
        if user_assessment_id is not None:
            _setter("user_assessment_id", user_assessment_id)

    @property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> Optional[str]:
        return pulumi.get(self, "lifecycle_state")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[str]:
        """
        The OCID of the target database on which the user assessment is to be run.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> Optional[str]:
        return pulumi.get(self, "user_assessment_id")


@pulumi.output_type
class GetAlertAnalyticItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetAlertAnalyticItemDimensionResult'],
                 metric_name: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str count: Total count of aggregated values.
        :param Sequence['GetAlertAnalyticItemDimensionArgs'] dimensions: Details of aggregation dimension summarizing alerts.
        :param str metric_name: The name of the aggregation.
        :param str time_ended: An optional filter to return audit events whose creation time in the database is less than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_started: An optional filter to return audit events whose creation time in the database is greater than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetAlertAnalyticItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
            metric_name=metric_name,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetAlertAnalyticItemDimensionResult']] = None,
             metric_name: Optional[str] = None,
             time_ended: Optional[str] = None,
             time_started: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if time_ended is None and 'timeEnded' in kwargs:
            time_ended = kwargs['timeEnded']
        if time_ended is None:
            raise TypeError("Missing 'time_ended' argument")
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']
        if time_started is None:
            raise TypeError("Missing 'time_started' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)
        _setter("metric_name", metric_name)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Total count of aggregated values.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetAlertAnalyticItemDimensionResult']:
        """
        Details of aggregation dimension summarizing alerts.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the aggregation.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        An optional filter to return audit events whose creation time in the database is less than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        An optional filter to return audit events whose creation time in the database is greater than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetAlertAnalyticItemDimensionResult(dict):
    def __init__(__self__, *,
                 group_by: Mapping[str, Any]):
        """
        :param Mapping[str, Any] group_by: A groupBy can only be used in combination with summaryField parameter. A groupBy value has to be a subset of the values mentioned in summaryField parameter.
        """
        GetAlertAnalyticItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_by is None and 'groupBy' in kwargs:
            group_by = kwargs['groupBy']
        if group_by is None:
            raise TypeError("Missing 'group_by' argument")

        _setter("group_by", group_by)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Mapping[str, Any]:
        """
        A groupBy can only be used in combination with summaryField parameter. A groupBy value has to be a subset of the values mentioned in summaryField parameter.
        """
        return pulumi.get(self, "group_by")


@pulumi.output_type
class GetAlertPoliciesAlertPolicyCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAlertPoliciesAlertPolicyCollectionItemResult']):
        GetAlertPoliciesAlertPolicyCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAlertPoliciesAlertPolicyCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAlertPoliciesAlertPolicyCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAlertPoliciesAlertPolicyCollectionItemResult(dict):
    def __init__(__self__, *,
                 alert_policy_type: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_user_defined: bool,
                 severity: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str alert_policy_type: Indicates the Data Safe feature to which the alert policy belongs.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the alert policy.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the alert policy.
        :param bool is_user_defined: An optional filter to return only alert policies that are user-defined or not.
        :param str severity: Severity level of the alert raised by this policy.
        :param str state: An optional filter to return only alert policies that have the given life-cycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: Creation date and time of the alert policy, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: Last date and time the alert policy was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetAlertPoliciesAlertPolicyCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_policy_type=alert_policy_type,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_user_defined=is_user_defined,
            severity=severity,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_policy_type: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_user_defined: Optional[bool] = None,
             severity: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_policy_type is None and 'alertPolicyType' in kwargs:
            alert_policy_type = kwargs['alertPolicyType']
        if alert_policy_type is None:
            raise TypeError("Missing 'alert_policy_type' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_user_defined is None and 'isUserDefined' in kwargs:
            is_user_defined = kwargs['isUserDefined']
        if is_user_defined is None:
            raise TypeError("Missing 'is_user_defined' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("alert_policy_type", alert_policy_type)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_user_defined", is_user_defined)
        _setter("severity", severity)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="alertPolicyType")
    def alert_policy_type(self) -> str:
        """
        Indicates the Data Safe feature to which the alert policy belongs.
        """
        return pulumi.get(self, "alert_policy_type")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the alert policy.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the alert policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isUserDefined")
    def is_user_defined(self) -> bool:
        """
        An optional filter to return only alert policies that are user-defined or not.
        """
        return pulumi.get(self, "is_user_defined")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        Severity level of the alert raised by this policy.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        An optional filter to return only alert policies that have the given life-cycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Creation date and time of the alert policy, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        Last date and time the alert policy was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetAlertPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAlertPoliciesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAlertPolicyRuleItemResult(dict):
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 key: str):
        """
        :param str description: Describes the alert policy rule.
        :param str expression: The conditional expression of the alert policy rule which evaluates to boolean value.
        :param str key: The unique key of the alert policy rule.
        """
        GetAlertPolicyRuleItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            expression=expression,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             expression: Optional[str] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if expression is None:
            raise TypeError("Missing 'expression' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("description", description)
        _setter("expression", expression)
        _setter("key", key)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Describes the alert policy rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The conditional expression of the alert policy rule which evaluates to boolean value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key of the alert policy rule.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetAlertPolicyRulesAlertPolicyRuleCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAlertPolicyRulesAlertPolicyRuleCollectionItemResult']):
        """
        :param Sequence['GetAlertPolicyRulesAlertPolicyRuleCollectionItemArgs'] items: Array of alert policy rules summary
        """
        GetAlertPolicyRulesAlertPolicyRuleCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAlertPolicyRulesAlertPolicyRuleCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAlertPolicyRulesAlertPolicyRuleCollectionItemResult']:
        """
        Array of alert policy rules summary
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAlertPolicyRulesAlertPolicyRuleCollectionItemResult(dict):
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 key: str):
        """
        :param str description: Describes the alert policy rule.
        :param str expression: The conditional expression of the alert policy rule which evaluates to boolean value.
        :param str key: The unique key of the alert policy rule.
        """
        GetAlertPolicyRulesAlertPolicyRuleCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            expression=expression,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             expression: Optional[str] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if expression is None:
            raise TypeError("Missing 'expression' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("description", description)
        _setter("expression", expression)
        _setter("key", key)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Describes the alert policy rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The conditional expression of the alert policy rule which evaluates to boolean value.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key of the alert policy rule.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetAlertPolicyRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAlertPolicyRulesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAlertsAlertCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAlertsAlertCollectionItemResult']):
        GetAlertsAlertCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAlertsAlertCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAlertsAlertCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAlertsAlertCollectionItemResult(dict):
    def __init__(__self__, *,
                 alert_id: str,
                 alert_type: str,
                 comment: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 feature_details: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 operation: str,
                 operation_status: str,
                 operation_time: str,
                 policy_id: str,
                 resource_name: str,
                 severity: str,
                 state: str,
                 status: str,
                 system_tags: Mapping[str, Any],
                 target_ids: Sequence[str],
                 target_names: Sequence[str],
                 time_created: str,
                 time_updated: str):
        """
        :param str alert_type: Type of the alert. Indicates the Data Safe feature triggering the alert.
        :param str comment: A comment for the alert. Entered by the user.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the alert.
        :param str display_name: The display name of the alert.
        :param Mapping[str, Any] feature_details: Map that contains maps of values. Example: `{"Operations": {"CostCenter": "42"}}`
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: A filter to return alert by it's OCID.
        :param str operation: The operation (event) that triggered alert.
        :param str operation_status: The result of the operation (event) that triggered alert.
        :param str operation_time: Creation date and time of the operation that triggered alert, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str policy_id: The OCID of the policy that triggered alert.
        :param str resource_name: The resource endpoint that triggered the alert.
        :param str severity: Severity level of the alert.
        :param str state: The current state of the alert.
        :param str status: The status of the alert.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param Sequence[str] target_ids: Array of OCIDs of the target database which are associated with the alert.
        :param Sequence[str] target_names: Array of names of the target database.
        :param str time_created: Creation date and time of the alert, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: Last date and time the alert was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetAlertsAlertCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            alert_type=alert_type,
            comment=comment,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            feature_details=feature_details,
            freeform_tags=freeform_tags,
            id=id,
            operation=operation,
            operation_status=operation_status,
            operation_time=operation_time,
            policy_id=policy_id,
            resource_name=resource_name,
            severity=severity,
            state=state,
            status=status,
            system_tags=system_tags,
            target_ids=target_ids,
            target_names=target_names,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: Optional[str] = None,
             alert_type: Optional[str] = None,
             comment: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             feature_details: Optional[Mapping[str, Any]] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             operation: Optional[str] = None,
             operation_status: Optional[str] = None,
             operation_time: Optional[str] = None,
             policy_id: Optional[str] = None,
             resource_name: Optional[str] = None,
             severity: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_ids: Optional[Sequence[str]] = None,
             target_names: Optional[Sequence[str]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_id is None and 'alertId' in kwargs:
            alert_id = kwargs['alertId']
        if alert_id is None:
            raise TypeError("Missing 'alert_id' argument")
        if alert_type is None and 'alertType' in kwargs:
            alert_type = kwargs['alertType']
        if alert_type is None:
            raise TypeError("Missing 'alert_type' argument")
        if comment is None:
            raise TypeError("Missing 'comment' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if feature_details is None and 'featureDetails' in kwargs:
            feature_details = kwargs['featureDetails']
        if feature_details is None:
            raise TypeError("Missing 'feature_details' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if operation is None:
            raise TypeError("Missing 'operation' argument")
        if operation_status is None and 'operationStatus' in kwargs:
            operation_status = kwargs['operationStatus']
        if operation_status is None:
            raise TypeError("Missing 'operation_status' argument")
        if operation_time is None and 'operationTime' in kwargs:
            operation_time = kwargs['operationTime']
        if operation_time is None:
            raise TypeError("Missing 'operation_time' argument")
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if policy_id is None:
            raise TypeError("Missing 'policy_id' argument")
        if resource_name is None and 'resourceName' in kwargs:
            resource_name = kwargs['resourceName']
        if resource_name is None:
            raise TypeError("Missing 'resource_name' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_ids is None and 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if target_ids is None:
            raise TypeError("Missing 'target_ids' argument")
        if target_names is None and 'targetNames' in kwargs:
            target_names = kwargs['targetNames']
        if target_names is None:
            raise TypeError("Missing 'target_names' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("alert_id", alert_id)
        _setter("alert_type", alert_type)
        _setter("comment", comment)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("feature_details", feature_details)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("operation", operation)
        _setter("operation_status", operation_status)
        _setter("operation_time", operation_time)
        _setter("policy_id", policy_id)
        _setter("resource_name", resource_name)
        _setter("severity", severity)
        _setter("state", state)
        _setter("status", status)
        _setter("system_tags", system_tags)
        _setter("target_ids", target_ids)
        _setter("target_names", target_names)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="alertType")
    def alert_type(self) -> str:
        """
        Type of the alert. Indicates the Data Safe feature triggering the alert.
        """
        return pulumi.get(self, "alert_type")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        A comment for the alert. Entered by the user.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the alert.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="featureDetails")
    def feature_details(self) -> Mapping[str, Any]:
        """
        Map that contains maps of values. Example: `{"Operations": {"CostCenter": "42"}}`
        """
        return pulumi.get(self, "feature_details")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A filter to return alert by it's OCID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        The operation (event) that triggered alert.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> str:
        """
        The result of the operation (event) that triggered alert.
        """
        return pulumi.get(self, "operation_status")

    @property
    @pulumi.getter(name="operationTime")
    def operation_time(self) -> str:
        """
        Creation date and time of the operation that triggered alert, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "operation_time")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        The OCID of the policy that triggered alert.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        The resource endpoint that triggered the alert.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        Severity level of the alert.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the alert.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the alert.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        Array of OCIDs of the target database which are associated with the alert.
        """
        return pulumi.get(self, "target_ids")

    @property
    @pulumi.getter(name="targetNames")
    def target_names(self) -> Sequence[str]:
        """
        Array of names of the target database.
        """
        return pulumi.get(self, "target_names")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Creation date and time of the alert, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        Last date and time the alert was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetAlertsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAlertsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionItemResult']):
        GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionItemResult(dict):
    def __init__(__self__, *,
                 audit_event_count: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 end_date: str,
                 error_info: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 start_date: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_completed: str,
                 time_of_expiry: str,
                 time_requested: str):
        """
        :param str audit_event_count: Total count of audit events to be retrieved from the archive for the specified date range.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: Description of the archive retrieval.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param str end_date: End month of the archive retrieval, in the format defined by RFC3339.
        :param str error_info: The Error details of a failed archive retrieval.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the archive retrieval.
        :param str lifecycle_details: Details about the current state of the archive retrieval.
        :param str start_date: Start month of the archive retrieval, in the format defined by RFC3339.
        :param str state: A filter to return only resources that matches the specified lifecycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: The OCID of the target associated with the archive retrieval.
        :param str time_completed: The date time when archive retrieval request was fulfilled, in the format defined by RFC3339.
        :param str time_of_expiry: The date time when retrieved archive data will be deleted from Data Safe and unloaded back into archival.
        :param str time_requested: The date time when archive retrieval was requested, in the format defined by RFC3339.
        """
        GetAuditArchiveRetrievalsAuditArchiveRetrievalCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_event_count=audit_event_count,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            end_date=end_date,
            error_info=error_info,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            start_date=start_date,
            state=state,
            system_tags=system_tags,
            target_id=target_id,
            time_completed=time_completed,
            time_of_expiry=time_of_expiry,
            time_requested=time_requested,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_event_count: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             end_date: Optional[str] = None,
             error_info: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             start_date: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_completed: Optional[str] = None,
             time_of_expiry: Optional[str] = None,
             time_requested: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_event_count is None and 'auditEventCount' in kwargs:
            audit_event_count = kwargs['auditEventCount']
        if audit_event_count is None:
            raise TypeError("Missing 'audit_event_count' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_date is None:
            raise TypeError("Missing 'end_date' argument")
        if error_info is None and 'errorInfo' in kwargs:
            error_info = kwargs['errorInfo']
        if error_info is None:
            raise TypeError("Missing 'error_info' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_date is None:
            raise TypeError("Missing 'start_date' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_completed is None and 'timeCompleted' in kwargs:
            time_completed = kwargs['timeCompleted']
        if time_completed is None:
            raise TypeError("Missing 'time_completed' argument")
        if time_of_expiry is None and 'timeOfExpiry' in kwargs:
            time_of_expiry = kwargs['timeOfExpiry']
        if time_of_expiry is None:
            raise TypeError("Missing 'time_of_expiry' argument")
        if time_requested is None and 'timeRequested' in kwargs:
            time_requested = kwargs['timeRequested']
        if time_requested is None:
            raise TypeError("Missing 'time_requested' argument")

        _setter("audit_event_count", audit_event_count)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("end_date", end_date)
        _setter("error_info", error_info)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("start_date", start_date)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_completed", time_completed)
        _setter("time_of_expiry", time_of_expiry)
        _setter("time_requested", time_requested)

    @property
    @pulumi.getter(name="auditEventCount")
    def audit_event_count(self) -> str:
        """
        Total count of audit events to be retrieved from the archive for the specified date range.
        """
        return pulumi.get(self, "audit_event_count")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the archive retrieval.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        End month of the archive retrieval, in the format defined by RFC3339.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="errorInfo")
    def error_info(self) -> str:
        """
        The Error details of a failed archive retrieval.
        """
        return pulumi.get(self, "error_info")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the archive retrieval.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the archive retrieval.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start month of the archive retrieval, in the format defined by RFC3339.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that matches the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The OCID of the target associated with the archive retrieval.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCompleted")
    def time_completed(self) -> str:
        """
        The date time when archive retrieval request was fulfilled, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_completed")

    @property
    @pulumi.getter(name="timeOfExpiry")
    def time_of_expiry(self) -> str:
        """
        The date time when retrieved archive data will be deleted from Data Safe and unloaded back into archival.
        """
        return pulumi.get(self, "time_of_expiry")

    @property
    @pulumi.getter(name="timeRequested")
    def time_requested(self) -> str:
        """
        The date time when archive retrieval was requested, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_requested")


@pulumi.output_type
class GetAuditArchiveRetrievalsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditArchiveRetrievalsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditEventAnalyticItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetAuditEventAnalyticItemDimensionResult'],
                 display_name: str,
                 metric_name: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str count: Total count of aggregated value.
        :param Sequence['GetAuditEventAnalyticItemDimensionArgs'] dimensions: Details of aggregation dimensions used for summarizing audit events.
        :param str display_name: Display Name of aggregation field.
        :param str metric_name: Name of the aggregation.
        :param str time_ended: An optional filter to return audit events whose creation time in the database is less than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_started: An optional filter to return audit events whose creation time in the database is greater than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetAuditEventAnalyticItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
            display_name=display_name,
            metric_name=metric_name,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetAuditEventAnalyticItemDimensionResult']] = None,
             display_name: Optional[str] = None,
             metric_name: Optional[str] = None,
             time_ended: Optional[str] = None,
             time_started: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if time_ended is None and 'timeEnded' in kwargs:
            time_ended = kwargs['timeEnded']
        if time_ended is None:
            raise TypeError("Missing 'time_ended' argument")
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']
        if time_started is None:
            raise TypeError("Missing 'time_started' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)
        _setter("display_name", display_name)
        _setter("metric_name", metric_name)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Total count of aggregated value.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetAuditEventAnalyticItemDimensionResult']:
        """
        Details of aggregation dimensions used for summarizing audit events.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Display Name of aggregation field.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the aggregation.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        An optional filter to return audit events whose creation time in the database is less than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        An optional filter to return audit events whose creation time in the database is greater than and equal to the date-time specified, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetAuditEventAnalyticItemDimensionResult(dict):
    def __init__(__self__, *,
                 audit_event_times: Sequence[str],
                 audit_types: Sequence[str],
                 client_hostnames: Sequence[str],
                 client_ids: Sequence[str],
                 client_programs: Sequence[str],
                 db_user_names: Sequence[str],
                 event_names: Sequence[str],
                 object_types: Sequence[str],
                 target_classes: Sequence[str],
                 target_ids: Sequence[str],
                 target_names: Sequence[str]):
        """
        :param Sequence[str] audit_event_times: Time of audit event occurrence in the target database.
        :param Sequence[str] audit_types: Type of auditing.
        :param Sequence[str] client_hostnames: Name of the host machine from which the session was spawned.
        :param Sequence[str] client_ids: The client identifier in each Oracle session.
        :param Sequence[str] client_programs: The application from which the audit event was generated. Examples SQL Plus or SQL Developer.
        :param Sequence[str] db_user_names: Name of the database user whose actions were audited.
        :param Sequence[str] event_names: Name of the detail action executed by the user on the target database. i.e ALTER SEQUENCE, CREATE TRIGGER, CREATE INDEX.
        :param Sequence[str] object_types: Type of object in the source database affected by the action. i.e PL/SQL, SYNONYM, PACKAGE BODY.
        :param Sequence[str] target_classes: Class of the target that was audited.
        :param Sequence[str] target_ids: The OCID of the target database that was audited.
        :param Sequence[str] target_names: The name of the target database that was audited.
        """
        GetAuditEventAnalyticItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_event_times=audit_event_times,
            audit_types=audit_types,
            client_hostnames=client_hostnames,
            client_ids=client_ids,
            client_programs=client_programs,
            db_user_names=db_user_names,
            event_names=event_names,
            object_types=object_types,
            target_classes=target_classes,
            target_ids=target_ids,
            target_names=target_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_event_times: Optional[Sequence[str]] = None,
             audit_types: Optional[Sequence[str]] = None,
             client_hostnames: Optional[Sequence[str]] = None,
             client_ids: Optional[Sequence[str]] = None,
             client_programs: Optional[Sequence[str]] = None,
             db_user_names: Optional[Sequence[str]] = None,
             event_names: Optional[Sequence[str]] = None,
             object_types: Optional[Sequence[str]] = None,
             target_classes: Optional[Sequence[str]] = None,
             target_ids: Optional[Sequence[str]] = None,
             target_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_event_times is None and 'auditEventTimes' in kwargs:
            audit_event_times = kwargs['auditEventTimes']
        if audit_event_times is None:
            raise TypeError("Missing 'audit_event_times' argument")
        if audit_types is None and 'auditTypes' in kwargs:
            audit_types = kwargs['auditTypes']
        if audit_types is None:
            raise TypeError("Missing 'audit_types' argument")
        if client_hostnames is None and 'clientHostnames' in kwargs:
            client_hostnames = kwargs['clientHostnames']
        if client_hostnames is None:
            raise TypeError("Missing 'client_hostnames' argument")
        if client_ids is None and 'clientIds' in kwargs:
            client_ids = kwargs['clientIds']
        if client_ids is None:
            raise TypeError("Missing 'client_ids' argument")
        if client_programs is None and 'clientPrograms' in kwargs:
            client_programs = kwargs['clientPrograms']
        if client_programs is None:
            raise TypeError("Missing 'client_programs' argument")
        if db_user_names is None and 'dbUserNames' in kwargs:
            db_user_names = kwargs['dbUserNames']
        if db_user_names is None:
            raise TypeError("Missing 'db_user_names' argument")
        if event_names is None and 'eventNames' in kwargs:
            event_names = kwargs['eventNames']
        if event_names is None:
            raise TypeError("Missing 'event_names' argument")
        if object_types is None and 'objectTypes' in kwargs:
            object_types = kwargs['objectTypes']
        if object_types is None:
            raise TypeError("Missing 'object_types' argument")
        if target_classes is None and 'targetClasses' in kwargs:
            target_classes = kwargs['targetClasses']
        if target_classes is None:
            raise TypeError("Missing 'target_classes' argument")
        if target_ids is None and 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if target_ids is None:
            raise TypeError("Missing 'target_ids' argument")
        if target_names is None and 'targetNames' in kwargs:
            target_names = kwargs['targetNames']
        if target_names is None:
            raise TypeError("Missing 'target_names' argument")

        _setter("audit_event_times", audit_event_times)
        _setter("audit_types", audit_types)
        _setter("client_hostnames", client_hostnames)
        _setter("client_ids", client_ids)
        _setter("client_programs", client_programs)
        _setter("db_user_names", db_user_names)
        _setter("event_names", event_names)
        _setter("object_types", object_types)
        _setter("target_classes", target_classes)
        _setter("target_ids", target_ids)
        _setter("target_names", target_names)

    @property
    @pulumi.getter(name="auditEventTimes")
    def audit_event_times(self) -> Sequence[str]:
        """
        Time of audit event occurrence in the target database.
        """
        return pulumi.get(self, "audit_event_times")

    @property
    @pulumi.getter(name="auditTypes")
    def audit_types(self) -> Sequence[str]:
        """
        Type of auditing.
        """
        return pulumi.get(self, "audit_types")

    @property
    @pulumi.getter(name="clientHostnames")
    def client_hostnames(self) -> Sequence[str]:
        """
        Name of the host machine from which the session was spawned.
        """
        return pulumi.get(self, "client_hostnames")

    @property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Sequence[str]:
        """
        The client identifier in each Oracle session.
        """
        return pulumi.get(self, "client_ids")

    @property
    @pulumi.getter(name="clientPrograms")
    def client_programs(self) -> Sequence[str]:
        """
        The application from which the audit event was generated. Examples SQL Plus or SQL Developer.
        """
        return pulumi.get(self, "client_programs")

    @property
    @pulumi.getter(name="dbUserNames")
    def db_user_names(self) -> Sequence[str]:
        """
        Name of the database user whose actions were audited.
        """
        return pulumi.get(self, "db_user_names")

    @property
    @pulumi.getter(name="eventNames")
    def event_names(self) -> Sequence[str]:
        """
        Name of the detail action executed by the user on the target database. i.e ALTER SEQUENCE, CREATE TRIGGER, CREATE INDEX.
        """
        return pulumi.get(self, "event_names")

    @property
    @pulumi.getter(name="objectTypes")
    def object_types(self) -> Sequence[str]:
        """
        Type of object in the source database affected by the action. i.e PL/SQL, SYNONYM, PACKAGE BODY.
        """
        return pulumi.get(self, "object_types")

    @property
    @pulumi.getter(name="targetClasses")
    def target_classes(self) -> Sequence[str]:
        """
        Class of the target that was audited.
        """
        return pulumi.get(self, "target_classes")

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        The OCID of the target database that was audited.
        """
        return pulumi.get(self, "target_ids")

    @property
    @pulumi.getter(name="targetNames")
    def target_names(self) -> Sequence[str]:
        """
        The name of the target database that was audited.
        """
        return pulumi.get(self, "target_names")


@pulumi.output_type
class GetAuditEventItemResult(dict):
    def __init__(__self__, *,
                 action_taken: str,
                 audit_event_time: str,
                 audit_location: str,
                 audit_policies: str,
                 audit_trail_id: str,
                 audit_type: str,
                 client_hostname: str,
                 client_id: str,
                 client_ip: str,
                 client_program: str,
                 command_param: str,
                 command_text: str,
                 compartment_id: str,
                 database_type: str,
                 db_user_name: str,
                 defined_tags: Mapping[str, Any],
                 error_code: str,
                 error_message: str,
                 event_name: str,
                 extended_event_attributes: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_alerted: bool,
                 object: str,
                 object_owner: str,
                 object_type: str,
                 operation: str,
                 operation_status: str,
                 os_terminal: str,
                 os_user_name: str,
                 target_class: str,
                 target_id: str,
                 target_name: str,
                 time_collected: str):
        """
        :param str action_taken: The action taken for this audit event.
        :param str audit_event_time: Time of audit event occurrence in the target database.
        :param str audit_location: The location of the audit. Currently the value is audit table.
        :param str audit_policies: Comma-seperated list of audit policies that caused the current audit event.
        :param str audit_trail_id: The OCID of the audit trail that generated this audit event. To be noted, this field has been deprecated.
        :param str audit_type: Type of auditing.
        :param str client_hostname: Name of the host machine from which the session was spawned.
        :param str client_id: The client identifier in each Oracle session.
        :param str client_ip: IP address of the host from which the session was spawned.
        :param str client_program: The application from which the audit event was generated. Examples SQL Plus or SQL Developer.
        :param str command_param: List of bind variables associated with the command text.
        :param str command_text: The SQL associated with the audit event.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param str database_type: The type of the target database that was audited. Allowed values are
               * DATABASE_CLOUD_SERVICE - Represents Oracle Database Cloud Services.
               * AUTONOMOUS_DATABASE - Represents Oracle Autonomous Databases.
               * INSTALLED_DATABASE - Represents databases running on-premises or on compute instances.
        :param str db_user_name: Name of the database user whose actions were audited.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str error_code: Oracle Error code generated by the action. Zero indicates the action was successful.
        :param str error_message: Detailed message on why the Error occurred.
        :param str event_name: Name of the detail action executed by the user on the target database. i.e ALTER SEQUENCE, CREATE TRIGGER, CREATE INDEX.
        :param str extended_event_attributes: List of all other attributes of the audit event seperated by a colon other than the one returned in audit record.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit event.
        :param bool is_alerted: Indicates whether an alert was raised for this audit event.
        :param str object: Name of the object affected by the action.
        :param str object_owner: Schema name of object affected but the action.
        :param str object_type: Type of object in the source database affected by the action. i.e PL/SQL, SYNONYM, PACKAGE BODY.
        :param str operation: Name of the action executed by the user on the target database. i.e ALTER, CREATE, DROP.
        :param str operation_status: Indicates whether the operation was a success or a failure.
        :param str os_terminal: The operating system terminal of the user session.
        :param str os_user_name: Name of the operating system user for the database session.
        :param str target_class: Class of the target that was audited.
        :param str target_id: The OCID of the target database that was audited.
        :param str target_name: The name of the target database that was audited.
        :param str time_collected: Timestamp when this audit event was collected from the target database by Data Safe.
        """
        GetAuditEventItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_taken=action_taken,
            audit_event_time=audit_event_time,
            audit_location=audit_location,
            audit_policies=audit_policies,
            audit_trail_id=audit_trail_id,
            audit_type=audit_type,
            client_hostname=client_hostname,
            client_id=client_id,
            client_ip=client_ip,
            client_program=client_program,
            command_param=command_param,
            command_text=command_text,
            compartment_id=compartment_id,
            database_type=database_type,
            db_user_name=db_user_name,
            defined_tags=defined_tags,
            error_code=error_code,
            error_message=error_message,
            event_name=event_name,
            extended_event_attributes=extended_event_attributes,
            freeform_tags=freeform_tags,
            id=id,
            is_alerted=is_alerted,
            object=object,
            object_owner=object_owner,
            object_type=object_type,
            operation=operation,
            operation_status=operation_status,
            os_terminal=os_terminal,
            os_user_name=os_user_name,
            target_class=target_class,
            target_id=target_id,
            target_name=target_name,
            time_collected=time_collected,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_taken: Optional[str] = None,
             audit_event_time: Optional[str] = None,
             audit_location: Optional[str] = None,
             audit_policies: Optional[str] = None,
             audit_trail_id: Optional[str] = None,
             audit_type: Optional[str] = None,
             client_hostname: Optional[str] = None,
             client_id: Optional[str] = None,
             client_ip: Optional[str] = None,
             client_program: Optional[str] = None,
             command_param: Optional[str] = None,
             command_text: Optional[str] = None,
             compartment_id: Optional[str] = None,
             database_type: Optional[str] = None,
             db_user_name: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             error_code: Optional[str] = None,
             error_message: Optional[str] = None,
             event_name: Optional[str] = None,
             extended_event_attributes: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_alerted: Optional[bool] = None,
             object: Optional[str] = None,
             object_owner: Optional[str] = None,
             object_type: Optional[str] = None,
             operation: Optional[str] = None,
             operation_status: Optional[str] = None,
             os_terminal: Optional[str] = None,
             os_user_name: Optional[str] = None,
             target_class: Optional[str] = None,
             target_id: Optional[str] = None,
             target_name: Optional[str] = None,
             time_collected: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_taken is None and 'actionTaken' in kwargs:
            action_taken = kwargs['actionTaken']
        if action_taken is None:
            raise TypeError("Missing 'action_taken' argument")
        if audit_event_time is None and 'auditEventTime' in kwargs:
            audit_event_time = kwargs['auditEventTime']
        if audit_event_time is None:
            raise TypeError("Missing 'audit_event_time' argument")
        if audit_location is None and 'auditLocation' in kwargs:
            audit_location = kwargs['auditLocation']
        if audit_location is None:
            raise TypeError("Missing 'audit_location' argument")
        if audit_policies is None and 'auditPolicies' in kwargs:
            audit_policies = kwargs['auditPolicies']
        if audit_policies is None:
            raise TypeError("Missing 'audit_policies' argument")
        if audit_trail_id is None and 'auditTrailId' in kwargs:
            audit_trail_id = kwargs['auditTrailId']
        if audit_trail_id is None:
            raise TypeError("Missing 'audit_trail_id' argument")
        if audit_type is None and 'auditType' in kwargs:
            audit_type = kwargs['auditType']
        if audit_type is None:
            raise TypeError("Missing 'audit_type' argument")
        if client_hostname is None and 'clientHostname' in kwargs:
            client_hostname = kwargs['clientHostname']
        if client_hostname is None:
            raise TypeError("Missing 'client_hostname' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_ip is None and 'clientIp' in kwargs:
            client_ip = kwargs['clientIp']
        if client_ip is None:
            raise TypeError("Missing 'client_ip' argument")
        if client_program is None and 'clientProgram' in kwargs:
            client_program = kwargs['clientProgram']
        if client_program is None:
            raise TypeError("Missing 'client_program' argument")
        if command_param is None and 'commandParam' in kwargs:
            command_param = kwargs['commandParam']
        if command_param is None:
            raise TypeError("Missing 'command_param' argument")
        if command_text is None and 'commandText' in kwargs:
            command_text = kwargs['commandText']
        if command_text is None:
            raise TypeError("Missing 'command_text' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if database_type is None and 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if database_type is None:
            raise TypeError("Missing 'database_type' argument")
        if db_user_name is None and 'dbUserName' in kwargs:
            db_user_name = kwargs['dbUserName']
        if db_user_name is None:
            raise TypeError("Missing 'db_user_name' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if error_code is None and 'errorCode' in kwargs:
            error_code = kwargs['errorCode']
        if error_code is None:
            raise TypeError("Missing 'error_code' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if event_name is None and 'eventName' in kwargs:
            event_name = kwargs['eventName']
        if event_name is None:
            raise TypeError("Missing 'event_name' argument")
        if extended_event_attributes is None and 'extendedEventAttributes' in kwargs:
            extended_event_attributes = kwargs['extendedEventAttributes']
        if extended_event_attributes is None:
            raise TypeError("Missing 'extended_event_attributes' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_alerted is None and 'isAlerted' in kwargs:
            is_alerted = kwargs['isAlerted']
        if is_alerted is None:
            raise TypeError("Missing 'is_alerted' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_owner is None and 'objectOwner' in kwargs:
            object_owner = kwargs['objectOwner']
        if object_owner is None:
            raise TypeError("Missing 'object_owner' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if operation is None:
            raise TypeError("Missing 'operation' argument")
        if operation_status is None and 'operationStatus' in kwargs:
            operation_status = kwargs['operationStatus']
        if operation_status is None:
            raise TypeError("Missing 'operation_status' argument")
        if os_terminal is None and 'osTerminal' in kwargs:
            os_terminal = kwargs['osTerminal']
        if os_terminal is None:
            raise TypeError("Missing 'os_terminal' argument")
        if os_user_name is None and 'osUserName' in kwargs:
            os_user_name = kwargs['osUserName']
        if os_user_name is None:
            raise TypeError("Missing 'os_user_name' argument")
        if target_class is None and 'targetClass' in kwargs:
            target_class = kwargs['targetClass']
        if target_class is None:
            raise TypeError("Missing 'target_class' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if target_name is None and 'targetName' in kwargs:
            target_name = kwargs['targetName']
        if target_name is None:
            raise TypeError("Missing 'target_name' argument")
        if time_collected is None and 'timeCollected' in kwargs:
            time_collected = kwargs['timeCollected']
        if time_collected is None:
            raise TypeError("Missing 'time_collected' argument")

        _setter("action_taken", action_taken)
        _setter("audit_event_time", audit_event_time)
        _setter("audit_location", audit_location)
        _setter("audit_policies", audit_policies)
        _setter("audit_trail_id", audit_trail_id)
        _setter("audit_type", audit_type)
        _setter("client_hostname", client_hostname)
        _setter("client_id", client_id)
        _setter("client_ip", client_ip)
        _setter("client_program", client_program)
        _setter("command_param", command_param)
        _setter("command_text", command_text)
        _setter("compartment_id", compartment_id)
        _setter("database_type", database_type)
        _setter("db_user_name", db_user_name)
        _setter("defined_tags", defined_tags)
        _setter("error_code", error_code)
        _setter("error_message", error_message)
        _setter("event_name", event_name)
        _setter("extended_event_attributes", extended_event_attributes)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_alerted", is_alerted)
        _setter("object", object)
        _setter("object_owner", object_owner)
        _setter("object_type", object_type)
        _setter("operation", operation)
        _setter("operation_status", operation_status)
        _setter("os_terminal", os_terminal)
        _setter("os_user_name", os_user_name)
        _setter("target_class", target_class)
        _setter("target_id", target_id)
        _setter("target_name", target_name)
        _setter("time_collected", time_collected)

    @property
    @pulumi.getter(name="actionTaken")
    def action_taken(self) -> str:
        """
        The action taken for this audit event.
        """
        return pulumi.get(self, "action_taken")

    @property
    @pulumi.getter(name="auditEventTime")
    def audit_event_time(self) -> str:
        """
        Time of audit event occurrence in the target database.
        """
        return pulumi.get(self, "audit_event_time")

    @property
    @pulumi.getter(name="auditLocation")
    def audit_location(self) -> str:
        """
        The location of the audit. Currently the value is audit table.
        """
        return pulumi.get(self, "audit_location")

    @property
    @pulumi.getter(name="auditPolicies")
    def audit_policies(self) -> str:
        """
        Comma-seperated list of audit policies that caused the current audit event.
        """
        return pulumi.get(self, "audit_policies")

    @property
    @pulumi.getter(name="auditTrailId")
    def audit_trail_id(self) -> str:
        """
        The OCID of the audit trail that generated this audit event. To be noted, this field has been deprecated.
        """
        return pulumi.get(self, "audit_trail_id")

    @property
    @pulumi.getter(name="auditType")
    def audit_type(self) -> str:
        """
        Type of auditing.
        """
        return pulumi.get(self, "audit_type")

    @property
    @pulumi.getter(name="clientHostname")
    def client_hostname(self) -> str:
        """
        Name of the host machine from which the session was spawned.
        """
        return pulumi.get(self, "client_hostname")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client identifier in each Oracle session.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> str:
        """
        IP address of the host from which the session was spawned.
        """
        return pulumi.get(self, "client_ip")

    @property
    @pulumi.getter(name="clientProgram")
    def client_program(self) -> str:
        """
        The application from which the audit event was generated. Examples SQL Plus or SQL Developer.
        """
        return pulumi.get(self, "client_program")

    @property
    @pulumi.getter(name="commandParam")
    def command_param(self) -> str:
        """
        List of bind variables associated with the command text.
        """
        return pulumi.get(self, "command_param")

    @property
    @pulumi.getter(name="commandText")
    def command_text(self) -> str:
        """
        The SQL associated with the audit event.
        """
        return pulumi.get(self, "command_text")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        The type of the target database that was audited. Allowed values are
        * DATABASE_CLOUD_SERVICE - Represents Oracle Database Cloud Services.
        * AUTONOMOUS_DATABASE - Represents Oracle Autonomous Databases.
        * INSTALLED_DATABASE - Represents databases running on-premises or on compute instances.
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> str:
        """
        Name of the database user whose actions were audited.
        """
        return pulumi.get(self, "db_user_name")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> str:
        """
        Oracle Error code generated by the action. Zero indicates the action was successful.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Detailed message on why the Error occurred.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="eventName")
    def event_name(self) -> str:
        """
        Name of the detail action executed by the user on the target database. i.e ALTER SEQUENCE, CREATE TRIGGER, CREATE INDEX.
        """
        return pulumi.get(self, "event_name")

    @property
    @pulumi.getter(name="extendedEventAttributes")
    def extended_event_attributes(self) -> str:
        """
        List of all other attributes of the audit event seperated by a colon other than the one returned in audit record.
        """
        return pulumi.get(self, "extended_event_attributes")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit event.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAlerted")
    def is_alerted(self) -> bool:
        """
        Indicates whether an alert was raised for this audit event.
        """
        return pulumi.get(self, "is_alerted")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Name of the object affected by the action.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectOwner")
    def object_owner(self) -> str:
        """
        Schema name of object affected but the action.
        """
        return pulumi.get(self, "object_owner")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        Type of object in the source database affected by the action. i.e PL/SQL, SYNONYM, PACKAGE BODY.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Name of the action executed by the user on the target database. i.e ALTER, CREATE, DROP.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> str:
        """
        Indicates whether the operation was a success or a failure.
        """
        return pulumi.get(self, "operation_status")

    @property
    @pulumi.getter(name="osTerminal")
    def os_terminal(self) -> str:
        """
        The operating system terminal of the user session.
        """
        return pulumi.get(self, "os_terminal")

    @property
    @pulumi.getter(name="osUserName")
    def os_user_name(self) -> str:
        """
        Name of the operating system user for the database session.
        """
        return pulumi.get(self, "os_user_name")

    @property
    @pulumi.getter(name="targetClass")
    def target_class(self) -> str:
        """
        Class of the target that was audited.
        """
        return pulumi.get(self, "target_class")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The OCID of the target database that was audited.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> str:
        """
        The name of the target database that was audited.
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter(name="timeCollected")
    def time_collected(self) -> str:
        """
        Timestamp when this audit event was collected from the target database by Data Safe.
        """
        return pulumi.get(self, "time_collected")


@pulumi.output_type
class GetAuditEventsAuditEventCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditEventsAuditEventCollectionItemResult']):
        """
        :param Sequence['GetAuditEventsAuditEventCollectionItemArgs'] items: Array of audit event summary.
        """
        GetAuditEventsAuditEventCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditEventsAuditEventCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditEventsAuditEventCollectionItemResult']:
        """
        Array of audit event summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditEventsAuditEventCollectionItemResult(dict):
    def __init__(__self__, *,
                 action_taken: str,
                 audit_event_time: str,
                 audit_location: str,
                 audit_policies: str,
                 audit_trail_id: str,
                 audit_type: str,
                 client_hostname: str,
                 client_id: str,
                 client_ip: str,
                 client_program: str,
                 command_param: str,
                 command_text: str,
                 compartment_id: str,
                 database_type: str,
                 db_user_name: str,
                 defined_tags: Mapping[str, Any],
                 error_code: str,
                 error_message: str,
                 event_name: str,
                 extended_event_attributes: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_alerted: bool,
                 object: str,
                 object_owner: str,
                 object_type: str,
                 operation: str,
                 operation_status: str,
                 os_terminal: str,
                 os_user_name: str,
                 target_class: str,
                 target_id: str,
                 target_name: str,
                 time_collected: str):
        """
        :param str action_taken: The action taken for this audit event.
        :param str audit_event_time: The time of the audit event occurrence in the target database.
        :param str audit_location: The location of the audit. Currently the value is audit table.
        :param str audit_policies: Comma-seperated list of audit policies that caused the current audit event.
        :param str audit_trail_id: The OCID of the audit trail that generated this audit event. To be noted, this field has been deprecated.
        :param str audit_type: The type of the auditing.
        :param str client_hostname: The name of the host machine from which the session was spawned.
        :param str client_id: The client identifier in each Oracle session.
        :param str client_ip: The IP address of the host machine from which the session was spawned.
        :param str client_program: The application from which the audit event was generated. Examples SQL Plus or SQL Developer.
        :param str command_param: List of bind variables associated with the command text.
        :param str command_text: The SQL associated with the audit event.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param str database_type: The type of the target database that was audited. Allowed values are
               * DATABASE_CLOUD_SERVICE - Represents Oracle Database Cloud Services.
               * AUTONOMOUS_DATABASE - Represents Oracle Autonomous Databases.
               * INSTALLED_DATABASE - Represents databases running on-premises or on compute instances.
        :param str db_user_name: The name of the database user whose actions were audited.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str error_code: Oracle Error code generated by the action. Zero indicates the action was successful.
        :param str error_message: The detailed message on why the Error occurred.
        :param str event_name: The name of the detail action executed by the user on the target database. i.e ALTER SEQUENCE, CREATE TRIGGER, CREATE INDEX.
        :param str extended_event_attributes: List of all other attributes of the audit event seperated by a colon other than the one returned in audit record.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit event.
        :param bool is_alerted: Indicates whether an alert was raised for this audit event.
        :param str object: The name of the object affected by the action.
        :param str object_owner: The schema name of the object affected by the action.
        :param str object_type: The type of the object in the source database affected by the action. i.e PL/SQL, SYNONYM, PACKAGE BODY.
        :param str operation: The name of the action executed by the user on the target database. i.e ALTER, CREATE, DROP.
        :param str operation_status: Indicates whether the operation was a success or a failure.
        :param str os_terminal: The operating system terminal of the user session.
        :param str os_user_name: The name of the operating system user for the database session.
        :param str target_class: The class of the target that was audited.
        :param str target_id: The OCID of the target database that was audited.
        :param str target_name: The name of the target database that was audited.
        :param str time_collected: The timestamp when this audit event was collected from the target database by Data Safe.
        """
        GetAuditEventsAuditEventCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_taken=action_taken,
            audit_event_time=audit_event_time,
            audit_location=audit_location,
            audit_policies=audit_policies,
            audit_trail_id=audit_trail_id,
            audit_type=audit_type,
            client_hostname=client_hostname,
            client_id=client_id,
            client_ip=client_ip,
            client_program=client_program,
            command_param=command_param,
            command_text=command_text,
            compartment_id=compartment_id,
            database_type=database_type,
            db_user_name=db_user_name,
            defined_tags=defined_tags,
            error_code=error_code,
            error_message=error_message,
            event_name=event_name,
            extended_event_attributes=extended_event_attributes,
            freeform_tags=freeform_tags,
            id=id,
            is_alerted=is_alerted,
            object=object,
            object_owner=object_owner,
            object_type=object_type,
            operation=operation,
            operation_status=operation_status,
            os_terminal=os_terminal,
            os_user_name=os_user_name,
            target_class=target_class,
            target_id=target_id,
            target_name=target_name,
            time_collected=time_collected,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_taken: Optional[str] = None,
             audit_event_time: Optional[str] = None,
             audit_location: Optional[str] = None,
             audit_policies: Optional[str] = None,
             audit_trail_id: Optional[str] = None,
             audit_type: Optional[str] = None,
             client_hostname: Optional[str] = None,
             client_id: Optional[str] = None,
             client_ip: Optional[str] = None,
             client_program: Optional[str] = None,
             command_param: Optional[str] = None,
             command_text: Optional[str] = None,
             compartment_id: Optional[str] = None,
             database_type: Optional[str] = None,
             db_user_name: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             error_code: Optional[str] = None,
             error_message: Optional[str] = None,
             event_name: Optional[str] = None,
             extended_event_attributes: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_alerted: Optional[bool] = None,
             object: Optional[str] = None,
             object_owner: Optional[str] = None,
             object_type: Optional[str] = None,
             operation: Optional[str] = None,
             operation_status: Optional[str] = None,
             os_terminal: Optional[str] = None,
             os_user_name: Optional[str] = None,
             target_class: Optional[str] = None,
             target_id: Optional[str] = None,
             target_name: Optional[str] = None,
             time_collected: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_taken is None and 'actionTaken' in kwargs:
            action_taken = kwargs['actionTaken']
        if action_taken is None:
            raise TypeError("Missing 'action_taken' argument")
        if audit_event_time is None and 'auditEventTime' in kwargs:
            audit_event_time = kwargs['auditEventTime']
        if audit_event_time is None:
            raise TypeError("Missing 'audit_event_time' argument")
        if audit_location is None and 'auditLocation' in kwargs:
            audit_location = kwargs['auditLocation']
        if audit_location is None:
            raise TypeError("Missing 'audit_location' argument")
        if audit_policies is None and 'auditPolicies' in kwargs:
            audit_policies = kwargs['auditPolicies']
        if audit_policies is None:
            raise TypeError("Missing 'audit_policies' argument")
        if audit_trail_id is None and 'auditTrailId' in kwargs:
            audit_trail_id = kwargs['auditTrailId']
        if audit_trail_id is None:
            raise TypeError("Missing 'audit_trail_id' argument")
        if audit_type is None and 'auditType' in kwargs:
            audit_type = kwargs['auditType']
        if audit_type is None:
            raise TypeError("Missing 'audit_type' argument")
        if client_hostname is None and 'clientHostname' in kwargs:
            client_hostname = kwargs['clientHostname']
        if client_hostname is None:
            raise TypeError("Missing 'client_hostname' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_ip is None and 'clientIp' in kwargs:
            client_ip = kwargs['clientIp']
        if client_ip is None:
            raise TypeError("Missing 'client_ip' argument")
        if client_program is None and 'clientProgram' in kwargs:
            client_program = kwargs['clientProgram']
        if client_program is None:
            raise TypeError("Missing 'client_program' argument")
        if command_param is None and 'commandParam' in kwargs:
            command_param = kwargs['commandParam']
        if command_param is None:
            raise TypeError("Missing 'command_param' argument")
        if command_text is None and 'commandText' in kwargs:
            command_text = kwargs['commandText']
        if command_text is None:
            raise TypeError("Missing 'command_text' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if database_type is None and 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if database_type is None:
            raise TypeError("Missing 'database_type' argument")
        if db_user_name is None and 'dbUserName' in kwargs:
            db_user_name = kwargs['dbUserName']
        if db_user_name is None:
            raise TypeError("Missing 'db_user_name' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if error_code is None and 'errorCode' in kwargs:
            error_code = kwargs['errorCode']
        if error_code is None:
            raise TypeError("Missing 'error_code' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if event_name is None and 'eventName' in kwargs:
            event_name = kwargs['eventName']
        if event_name is None:
            raise TypeError("Missing 'event_name' argument")
        if extended_event_attributes is None and 'extendedEventAttributes' in kwargs:
            extended_event_attributes = kwargs['extendedEventAttributes']
        if extended_event_attributes is None:
            raise TypeError("Missing 'extended_event_attributes' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_alerted is None and 'isAlerted' in kwargs:
            is_alerted = kwargs['isAlerted']
        if is_alerted is None:
            raise TypeError("Missing 'is_alerted' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_owner is None and 'objectOwner' in kwargs:
            object_owner = kwargs['objectOwner']
        if object_owner is None:
            raise TypeError("Missing 'object_owner' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if operation is None:
            raise TypeError("Missing 'operation' argument")
        if operation_status is None and 'operationStatus' in kwargs:
            operation_status = kwargs['operationStatus']
        if operation_status is None:
            raise TypeError("Missing 'operation_status' argument")
        if os_terminal is None and 'osTerminal' in kwargs:
            os_terminal = kwargs['osTerminal']
        if os_terminal is None:
            raise TypeError("Missing 'os_terminal' argument")
        if os_user_name is None and 'osUserName' in kwargs:
            os_user_name = kwargs['osUserName']
        if os_user_name is None:
            raise TypeError("Missing 'os_user_name' argument")
        if target_class is None and 'targetClass' in kwargs:
            target_class = kwargs['targetClass']
        if target_class is None:
            raise TypeError("Missing 'target_class' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if target_name is None and 'targetName' in kwargs:
            target_name = kwargs['targetName']
        if target_name is None:
            raise TypeError("Missing 'target_name' argument")
        if time_collected is None and 'timeCollected' in kwargs:
            time_collected = kwargs['timeCollected']
        if time_collected is None:
            raise TypeError("Missing 'time_collected' argument")

        _setter("action_taken", action_taken)
        _setter("audit_event_time", audit_event_time)
        _setter("audit_location", audit_location)
        _setter("audit_policies", audit_policies)
        _setter("audit_trail_id", audit_trail_id)
        _setter("audit_type", audit_type)
        _setter("client_hostname", client_hostname)
        _setter("client_id", client_id)
        _setter("client_ip", client_ip)
        _setter("client_program", client_program)
        _setter("command_param", command_param)
        _setter("command_text", command_text)
        _setter("compartment_id", compartment_id)
        _setter("database_type", database_type)
        _setter("db_user_name", db_user_name)
        _setter("defined_tags", defined_tags)
        _setter("error_code", error_code)
        _setter("error_message", error_message)
        _setter("event_name", event_name)
        _setter("extended_event_attributes", extended_event_attributes)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_alerted", is_alerted)
        _setter("object", object)
        _setter("object_owner", object_owner)
        _setter("object_type", object_type)
        _setter("operation", operation)
        _setter("operation_status", operation_status)
        _setter("os_terminal", os_terminal)
        _setter("os_user_name", os_user_name)
        _setter("target_class", target_class)
        _setter("target_id", target_id)
        _setter("target_name", target_name)
        _setter("time_collected", time_collected)

    @property
    @pulumi.getter(name="actionTaken")
    def action_taken(self) -> str:
        """
        The action taken for this audit event.
        """
        return pulumi.get(self, "action_taken")

    @property
    @pulumi.getter(name="auditEventTime")
    def audit_event_time(self) -> str:
        """
        The time of the audit event occurrence in the target database.
        """
        return pulumi.get(self, "audit_event_time")

    @property
    @pulumi.getter(name="auditLocation")
    def audit_location(self) -> str:
        """
        The location of the audit. Currently the value is audit table.
        """
        return pulumi.get(self, "audit_location")

    @property
    @pulumi.getter(name="auditPolicies")
    def audit_policies(self) -> str:
        """
        Comma-seperated list of audit policies that caused the current audit event.
        """
        return pulumi.get(self, "audit_policies")

    @property
    @pulumi.getter(name="auditTrailId")
    def audit_trail_id(self) -> str:
        """
        The OCID of the audit trail that generated this audit event. To be noted, this field has been deprecated.
        """
        return pulumi.get(self, "audit_trail_id")

    @property
    @pulumi.getter(name="auditType")
    def audit_type(self) -> str:
        """
        The type of the auditing.
        """
        return pulumi.get(self, "audit_type")

    @property
    @pulumi.getter(name="clientHostname")
    def client_hostname(self) -> str:
        """
        The name of the host machine from which the session was spawned.
        """
        return pulumi.get(self, "client_hostname")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client identifier in each Oracle session.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> str:
        """
        The IP address of the host machine from which the session was spawned.
        """
        return pulumi.get(self, "client_ip")

    @property
    @pulumi.getter(name="clientProgram")
    def client_program(self) -> str:
        """
        The application from which the audit event was generated. Examples SQL Plus or SQL Developer.
        """
        return pulumi.get(self, "client_program")

    @property
    @pulumi.getter(name="commandParam")
    def command_param(self) -> str:
        """
        List of bind variables associated with the command text.
        """
        return pulumi.get(self, "command_param")

    @property
    @pulumi.getter(name="commandText")
    def command_text(self) -> str:
        """
        The SQL associated with the audit event.
        """
        return pulumi.get(self, "command_text")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        The type of the target database that was audited. Allowed values are
        * DATABASE_CLOUD_SERVICE - Represents Oracle Database Cloud Services.
        * AUTONOMOUS_DATABASE - Represents Oracle Autonomous Databases.
        * INSTALLED_DATABASE - Represents databases running on-premises or on compute instances.
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> str:
        """
        The name of the database user whose actions were audited.
        """
        return pulumi.get(self, "db_user_name")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> str:
        """
        Oracle Error code generated by the action. Zero indicates the action was successful.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        The detailed message on why the Error occurred.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="eventName")
    def event_name(self) -> str:
        """
        The name of the detail action executed by the user on the target database. i.e ALTER SEQUENCE, CREATE TRIGGER, CREATE INDEX.
        """
        return pulumi.get(self, "event_name")

    @property
    @pulumi.getter(name="extendedEventAttributes")
    def extended_event_attributes(self) -> str:
        """
        List of all other attributes of the audit event seperated by a colon other than the one returned in audit record.
        """
        return pulumi.get(self, "extended_event_attributes")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit event.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAlerted")
    def is_alerted(self) -> bool:
        """
        Indicates whether an alert was raised for this audit event.
        """
        return pulumi.get(self, "is_alerted")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        The name of the object affected by the action.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectOwner")
    def object_owner(self) -> str:
        """
        The schema name of the object affected by the action.
        """
        return pulumi.get(self, "object_owner")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        The type of the object in the source database affected by the action. i.e PL/SQL, SYNONYM, PACKAGE BODY.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        The name of the action executed by the user on the target database. i.e ALTER, CREATE, DROP.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> str:
        """
        Indicates whether the operation was a success or a failure.
        """
        return pulumi.get(self, "operation_status")

    @property
    @pulumi.getter(name="osTerminal")
    def os_terminal(self) -> str:
        """
        The operating system terminal of the user session.
        """
        return pulumi.get(self, "os_terminal")

    @property
    @pulumi.getter(name="osUserName")
    def os_user_name(self) -> str:
        """
        The name of the operating system user for the database session.
        """
        return pulumi.get(self, "os_user_name")

    @property
    @pulumi.getter(name="targetClass")
    def target_class(self) -> str:
        """
        The class of the target that was audited.
        """
        return pulumi.get(self, "target_class")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The OCID of the target database that was audited.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> str:
        """
        The name of the target database that was audited.
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter(name="timeCollected")
    def time_collected(self) -> str:
        """
        The timestamp when this audit event was collected from the target database by Data Safe.
        """
        return pulumi.get(self, "time_collected")


@pulumi.output_type
class GetAuditEventsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditEventsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditPoliciesAuditPolicyCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemResult']):
        GetAuditPoliciesAuditPolicyCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditPoliciesAuditPolicyCollectionItemResult(dict):
    def __init__(__self__, *,
                 audit_conditions: Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditConditionResult'],
                 audit_policy_id: str,
                 audit_specifications: Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationResult'],
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_data_safe_service_account_excluded: bool,
                 lifecycle_details: str,
                 provision_trigger: int,
                 retrieve_from_target_trigger: int,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_last_provisioned: str,
                 time_last_retrieved: str,
                 time_updated: str):
        """
        :param Sequence['GetAuditPoliciesAuditPolicyCollectionItemAuditConditionArgs'] audit_conditions: Lists the audit policy provisioning conditions for the target database.
        :param str audit_policy_id: An optional filter to return only resources that match the specified id.
        :param Sequence['GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationArgs'] audit_specifications: Represents all available audit policy specifications relevant for the target database. For more details on available audit polcies, refer to [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827).
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: Description of the audit policy.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit policy.
        :param bool is_data_safe_service_account_excluded: Option provided to users at the target to indicate whether the Data Safe service account has to be excluded while provisioning the audit policies.
        :param str lifecycle_details: Details about the current state of the audit policy in Data Safe.
        :param str state: The current state of the audit policy.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: The time the the audit policy was created, in the format defined by RFC3339.
        :param str time_last_provisioned: Indicates the last provisioning time of audit policies on the target, in the format defined by RFC3339.
        :param str time_last_retrieved: The time when the audit policies was last retrieved from this target, in the format defined by RFC3339.
        :param str time_updated: The last date and time the audit policy was updated, in the format defined by RFC3339.
        """
        GetAuditPoliciesAuditPolicyCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_conditions=audit_conditions,
            audit_policy_id=audit_policy_id,
            audit_specifications=audit_specifications,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_data_safe_service_account_excluded=is_data_safe_service_account_excluded,
            lifecycle_details=lifecycle_details,
            provision_trigger=provision_trigger,
            retrieve_from_target_trigger=retrieve_from_target_trigger,
            state=state,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_last_provisioned=time_last_provisioned,
            time_last_retrieved=time_last_retrieved,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_conditions: Optional[Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditConditionResult']] = None,
             audit_policy_id: Optional[str] = None,
             audit_specifications: Optional[Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationResult']] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_data_safe_service_account_excluded: Optional[bool] = None,
             lifecycle_details: Optional[str] = None,
             provision_trigger: Optional[int] = None,
             retrieve_from_target_trigger: Optional[int] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_last_provisioned: Optional[str] = None,
             time_last_retrieved: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_conditions is None and 'auditConditions' in kwargs:
            audit_conditions = kwargs['auditConditions']
        if audit_conditions is None:
            raise TypeError("Missing 'audit_conditions' argument")
        if audit_policy_id is None and 'auditPolicyId' in kwargs:
            audit_policy_id = kwargs['auditPolicyId']
        if audit_policy_id is None:
            raise TypeError("Missing 'audit_policy_id' argument")
        if audit_specifications is None and 'auditSpecifications' in kwargs:
            audit_specifications = kwargs['auditSpecifications']
        if audit_specifications is None:
            raise TypeError("Missing 'audit_specifications' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_data_safe_service_account_excluded is None and 'isDataSafeServiceAccountExcluded' in kwargs:
            is_data_safe_service_account_excluded = kwargs['isDataSafeServiceAccountExcluded']
        if is_data_safe_service_account_excluded is None:
            raise TypeError("Missing 'is_data_safe_service_account_excluded' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if provision_trigger is None and 'provisionTrigger' in kwargs:
            provision_trigger = kwargs['provisionTrigger']
        if provision_trigger is None:
            raise TypeError("Missing 'provision_trigger' argument")
        if retrieve_from_target_trigger is None and 'retrieveFromTargetTrigger' in kwargs:
            retrieve_from_target_trigger = kwargs['retrieveFromTargetTrigger']
        if retrieve_from_target_trigger is None:
            raise TypeError("Missing 'retrieve_from_target_trigger' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_last_provisioned is None and 'timeLastProvisioned' in kwargs:
            time_last_provisioned = kwargs['timeLastProvisioned']
        if time_last_provisioned is None:
            raise TypeError("Missing 'time_last_provisioned' argument")
        if time_last_retrieved is None and 'timeLastRetrieved' in kwargs:
            time_last_retrieved = kwargs['timeLastRetrieved']
        if time_last_retrieved is None:
            raise TypeError("Missing 'time_last_retrieved' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("audit_conditions", audit_conditions)
        _setter("audit_policy_id", audit_policy_id)
        _setter("audit_specifications", audit_specifications)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_data_safe_service_account_excluded", is_data_safe_service_account_excluded)
        _setter("lifecycle_details", lifecycle_details)
        _setter("provision_trigger", provision_trigger)
        _setter("retrieve_from_target_trigger", retrieve_from_target_trigger)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_last_provisioned", time_last_provisioned)
        _setter("time_last_retrieved", time_last_retrieved)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="auditConditions")
    def audit_conditions(self) -> Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditConditionResult']:
        """
        Lists the audit policy provisioning conditions for the target database.
        """
        return pulumi.get(self, "audit_conditions")

    @property
    @pulumi.getter(name="auditPolicyId")
    def audit_policy_id(self) -> str:
        """
        An optional filter to return only resources that match the specified id.
        """
        return pulumi.get(self, "audit_policy_id")

    @property
    @pulumi.getter(name="auditSpecifications")
    def audit_specifications(self) -> Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationResult']:
        """
        Represents all available audit policy specifications relevant for the target database. For more details on available audit polcies, refer to [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827).
        """
        return pulumi.get(self, "audit_specifications")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the audit policy.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDataSafeServiceAccountExcluded")
    def is_data_safe_service_account_excluded(self) -> bool:
        """
        Option provided to users at the target to indicate whether the Data Safe service account has to be excluded while provisioning the audit policies.
        """
        return pulumi.get(self, "is_data_safe_service_account_excluded")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the audit policy in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="provisionTrigger")
    def provision_trigger(self) -> int:
        return pulumi.get(self, "provision_trigger")

    @property
    @pulumi.getter(name="retrieveFromTargetTrigger")
    def retrieve_from_target_trigger(self) -> int:
        return pulumi.get(self, "retrieve_from_target_trigger")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the audit policy.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time the the audit policy was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastProvisioned")
    def time_last_provisioned(self) -> str:
        """
        Indicates the last provisioning time of audit policies on the target, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_provisioned")

    @property
    @pulumi.getter(name="timeLastRetrieved")
    def time_last_retrieved(self) -> str:
        """
        The time when the audit policies was last retrieved from this target, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_retrieved")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The last date and time the audit policy was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetAuditPoliciesAuditPolicyCollectionItemAuditConditionResult(dict):
    def __init__(__self__, *,
                 audit_policy_name: str,
                 enable_conditions: Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionResult'],
                 is_data_safe_service_account_audited: bool,
                 is_priv_users_managed_by_data_safe: bool):
        """
        :param str audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param Sequence['GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionArgs'] enable_conditions: Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        :param bool is_data_safe_service_account_audited: Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        :param bool is_priv_users_managed_by_data_safe: Indicates whether the privileged user list is managed by Data Safe.
        """
        GetAuditPoliciesAuditPolicyCollectionItemAuditConditionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_policy_name=audit_policy_name,
            enable_conditions=enable_conditions,
            is_data_safe_service_account_audited=is_data_safe_service_account_audited,
            is_priv_users_managed_by_data_safe=is_priv_users_managed_by_data_safe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_policy_name: Optional[str] = None,
             enable_conditions: Optional[Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionResult']] = None,
             is_data_safe_service_account_audited: Optional[bool] = None,
             is_priv_users_managed_by_data_safe: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_policy_name is None and 'auditPolicyName' in kwargs:
            audit_policy_name = kwargs['auditPolicyName']
        if audit_policy_name is None:
            raise TypeError("Missing 'audit_policy_name' argument")
        if enable_conditions is None and 'enableConditions' in kwargs:
            enable_conditions = kwargs['enableConditions']
        if enable_conditions is None:
            raise TypeError("Missing 'enable_conditions' argument")
        if is_data_safe_service_account_audited is None and 'isDataSafeServiceAccountAudited' in kwargs:
            is_data_safe_service_account_audited = kwargs['isDataSafeServiceAccountAudited']
        if is_data_safe_service_account_audited is None:
            raise TypeError("Missing 'is_data_safe_service_account_audited' argument")
        if is_priv_users_managed_by_data_safe is None and 'isPrivUsersManagedByDataSafe' in kwargs:
            is_priv_users_managed_by_data_safe = kwargs['isPrivUsersManagedByDataSafe']
        if is_priv_users_managed_by_data_safe is None:
            raise TypeError("Missing 'is_priv_users_managed_by_data_safe' argument")

        _setter("audit_policy_name", audit_policy_name)
        _setter("enable_conditions", enable_conditions)
        _setter("is_data_safe_service_account_audited", is_data_safe_service_account_audited)
        _setter("is_priv_users_managed_by_data_safe", is_priv_users_managed_by_data_safe)

    @property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> str:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @property
    @pulumi.getter(name="enableConditions")
    def enable_conditions(self) -> Sequence['outputs.GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionResult']:
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        return pulumi.get(self, "enable_conditions")

    @property
    @pulumi.getter(name="isDataSafeServiceAccountAudited")
    def is_data_safe_service_account_audited(self) -> bool:
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        return pulumi.get(self, "is_data_safe_service_account_audited")

    @property
    @pulumi.getter(name="isPrivUsersManagedByDataSafe")
    def is_priv_users_managed_by_data_safe(self) -> bool:
        """
        Indicates whether the privileged user list is managed by Data Safe.
        """
        return pulumi.get(self, "is_priv_users_managed_by_data_safe")


@pulumi.output_type
class GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionResult(dict):
    def __init__(__self__, *,
                 entity_names: Sequence[str],
                 entity_selection: str,
                 entity_type: str,
                 operation_status: str):
        """
        :param Sequence[str] entity_names: List of users or roles that the policy must be enabled for.
        :param str entity_selection: The entity include or exclude selection.
        :param str entity_type: The entity type that the policy must be enabled for.
        :param str operation_status: The operation status that the policy must be enabled for.
        """
        GetAuditPoliciesAuditPolicyCollectionItemAuditConditionEnableConditionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_names=entity_names,
            entity_selection=entity_selection,
            entity_type=entity_type,
            operation_status=operation_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_names: Optional[Sequence[str]] = None,
             entity_selection: Optional[str] = None,
             entity_type: Optional[str] = None,
             operation_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_names is None and 'entityNames' in kwargs:
            entity_names = kwargs['entityNames']
        if entity_names is None:
            raise TypeError("Missing 'entity_names' argument")
        if entity_selection is None and 'entitySelection' in kwargs:
            entity_selection = kwargs['entitySelection']
        if entity_selection is None:
            raise TypeError("Missing 'entity_selection' argument")
        if entity_type is None and 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if entity_type is None:
            raise TypeError("Missing 'entity_type' argument")
        if operation_status is None and 'operationStatus' in kwargs:
            operation_status = kwargs['operationStatus']
        if operation_status is None:
            raise TypeError("Missing 'operation_status' argument")

        _setter("entity_names", entity_names)
        _setter("entity_selection", entity_selection)
        _setter("entity_type", entity_type)
        _setter("operation_status", operation_status)

    @property
    @pulumi.getter(name="entityNames")
    def entity_names(self) -> Sequence[str]:
        """
        List of users or roles that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_names")

    @property
    @pulumi.getter(name="entitySelection")
    def entity_selection(self) -> str:
        """
        The entity include or exclude selection.
        """
        return pulumi.get(self, "entity_selection")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        The entity type that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> str:
        """
        The operation status that the policy must be enabled for.
        """
        return pulumi.get(self, "operation_status")


@pulumi.output_type
class GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationResult(dict):
    def __init__(__self__, *,
                 audit_policy_category: str,
                 audit_policy_name: str,
                 database_policy_names: Sequence[str],
                 enable_status: str,
                 enabled_entities: str,
                 is_created: bool,
                 is_enabled_for_all_users: bool,
                 is_seeded_in_data_safe: bool,
                 is_seeded_in_target: bool,
                 is_view_only: bool,
                 partially_enabled_msg: str):
        """
        :param str audit_policy_category: The category to which the audit policy belongs.
        :param str audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param Sequence[str] database_policy_names: Indicates the names of corresponding database policy ( or policies) in the target database.
        :param str enable_status: Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        :param str enabled_entities: Indicates on whom the audit policy is enabled.
        :param bool is_created: Indicates whether the policy is already created on the target database.
        :param bool is_enabled_for_all_users: Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        :param bool is_seeded_in_data_safe: Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        :param bool is_seeded_in_target: Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        :param bool is_view_only: Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        :param str partially_enabled_msg: Provides information about the policy that has been only partially enabled.
        """
        GetAuditPoliciesAuditPolicyCollectionItemAuditSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_policy_category=audit_policy_category,
            audit_policy_name=audit_policy_name,
            database_policy_names=database_policy_names,
            enable_status=enable_status,
            enabled_entities=enabled_entities,
            is_created=is_created,
            is_enabled_for_all_users=is_enabled_for_all_users,
            is_seeded_in_data_safe=is_seeded_in_data_safe,
            is_seeded_in_target=is_seeded_in_target,
            is_view_only=is_view_only,
            partially_enabled_msg=partially_enabled_msg,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_policy_category: Optional[str] = None,
             audit_policy_name: Optional[str] = None,
             database_policy_names: Optional[Sequence[str]] = None,
             enable_status: Optional[str] = None,
             enabled_entities: Optional[str] = None,
             is_created: Optional[bool] = None,
             is_enabled_for_all_users: Optional[bool] = None,
             is_seeded_in_data_safe: Optional[bool] = None,
             is_seeded_in_target: Optional[bool] = None,
             is_view_only: Optional[bool] = None,
             partially_enabled_msg: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_policy_category is None and 'auditPolicyCategory' in kwargs:
            audit_policy_category = kwargs['auditPolicyCategory']
        if audit_policy_category is None:
            raise TypeError("Missing 'audit_policy_category' argument")
        if audit_policy_name is None and 'auditPolicyName' in kwargs:
            audit_policy_name = kwargs['auditPolicyName']
        if audit_policy_name is None:
            raise TypeError("Missing 'audit_policy_name' argument")
        if database_policy_names is None and 'databasePolicyNames' in kwargs:
            database_policy_names = kwargs['databasePolicyNames']
        if database_policy_names is None:
            raise TypeError("Missing 'database_policy_names' argument")
        if enable_status is None and 'enableStatus' in kwargs:
            enable_status = kwargs['enableStatus']
        if enable_status is None:
            raise TypeError("Missing 'enable_status' argument")
        if enabled_entities is None and 'enabledEntities' in kwargs:
            enabled_entities = kwargs['enabledEntities']
        if enabled_entities is None:
            raise TypeError("Missing 'enabled_entities' argument")
        if is_created is None and 'isCreated' in kwargs:
            is_created = kwargs['isCreated']
        if is_created is None:
            raise TypeError("Missing 'is_created' argument")
        if is_enabled_for_all_users is None and 'isEnabledForAllUsers' in kwargs:
            is_enabled_for_all_users = kwargs['isEnabledForAllUsers']
        if is_enabled_for_all_users is None:
            raise TypeError("Missing 'is_enabled_for_all_users' argument")
        if is_seeded_in_data_safe is None and 'isSeededInDataSafe' in kwargs:
            is_seeded_in_data_safe = kwargs['isSeededInDataSafe']
        if is_seeded_in_data_safe is None:
            raise TypeError("Missing 'is_seeded_in_data_safe' argument")
        if is_seeded_in_target is None and 'isSeededInTarget' in kwargs:
            is_seeded_in_target = kwargs['isSeededInTarget']
        if is_seeded_in_target is None:
            raise TypeError("Missing 'is_seeded_in_target' argument")
        if is_view_only is None and 'isViewOnly' in kwargs:
            is_view_only = kwargs['isViewOnly']
        if is_view_only is None:
            raise TypeError("Missing 'is_view_only' argument")
        if partially_enabled_msg is None and 'partiallyEnabledMsg' in kwargs:
            partially_enabled_msg = kwargs['partiallyEnabledMsg']
        if partially_enabled_msg is None:
            raise TypeError("Missing 'partially_enabled_msg' argument")

        _setter("audit_policy_category", audit_policy_category)
        _setter("audit_policy_name", audit_policy_name)
        _setter("database_policy_names", database_policy_names)
        _setter("enable_status", enable_status)
        _setter("enabled_entities", enabled_entities)
        _setter("is_created", is_created)
        _setter("is_enabled_for_all_users", is_enabled_for_all_users)
        _setter("is_seeded_in_data_safe", is_seeded_in_data_safe)
        _setter("is_seeded_in_target", is_seeded_in_target)
        _setter("is_view_only", is_view_only)
        _setter("partially_enabled_msg", partially_enabled_msg)

    @property
    @pulumi.getter(name="auditPolicyCategory")
    def audit_policy_category(self) -> str:
        """
        The category to which the audit policy belongs.
        """
        return pulumi.get(self, "audit_policy_category")

    @property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> str:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @property
    @pulumi.getter(name="databasePolicyNames")
    def database_policy_names(self) -> Sequence[str]:
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        return pulumi.get(self, "database_policy_names")

    @property
    @pulumi.getter(name="enableStatus")
    def enable_status(self) -> str:
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        return pulumi.get(self, "enable_status")

    @property
    @pulumi.getter(name="enabledEntities")
    def enabled_entities(self) -> str:
        """
        Indicates on whom the audit policy is enabled.
        """
        return pulumi.get(self, "enabled_entities")

    @property
    @pulumi.getter(name="isCreated")
    def is_created(self) -> bool:
        """
        Indicates whether the policy is already created on the target database.
        """
        return pulumi.get(self, "is_created")

    @property
    @pulumi.getter(name="isEnabledForAllUsers")
    def is_enabled_for_all_users(self) -> bool:
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        return pulumi.get(self, "is_enabled_for_all_users")

    @property
    @pulumi.getter(name="isSeededInDataSafe")
    def is_seeded_in_data_safe(self) -> bool:
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        return pulumi.get(self, "is_seeded_in_data_safe")

    @property
    @pulumi.getter(name="isSeededInTarget")
    def is_seeded_in_target(self) -> bool:
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        return pulumi.get(self, "is_seeded_in_target")

    @property
    @pulumi.getter(name="isViewOnly")
    def is_view_only(self) -> bool:
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        return pulumi.get(self, "is_view_only")

    @property
    @pulumi.getter(name="partiallyEnabledMsg")
    def partially_enabled_msg(self) -> str:
        """
        Provides information about the policy that has been only partially enabled.
        """
        return pulumi.get(self, "partially_enabled_msg")


@pulumi.output_type
class GetAuditPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditPoliciesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditPolicyAuditConditionResult(dict):
    def __init__(__self__, *,
                 audit_policy_name: str,
                 enable_conditions: Sequence['outputs.GetAuditPolicyAuditConditionEnableConditionResult'],
                 is_data_safe_service_account_audited: bool,
                 is_priv_users_managed_by_data_safe: bool):
        """
        :param str audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param Sequence['GetAuditPolicyAuditConditionEnableConditionArgs'] enable_conditions: Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        :param bool is_data_safe_service_account_audited: Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        :param bool is_priv_users_managed_by_data_safe: Indicates whether the privileged user list is managed by Data Safe.
        """
        GetAuditPolicyAuditConditionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_policy_name=audit_policy_name,
            enable_conditions=enable_conditions,
            is_data_safe_service_account_audited=is_data_safe_service_account_audited,
            is_priv_users_managed_by_data_safe=is_priv_users_managed_by_data_safe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_policy_name: Optional[str] = None,
             enable_conditions: Optional[Sequence['outputs.GetAuditPolicyAuditConditionEnableConditionResult']] = None,
             is_data_safe_service_account_audited: Optional[bool] = None,
             is_priv_users_managed_by_data_safe: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_policy_name is None and 'auditPolicyName' in kwargs:
            audit_policy_name = kwargs['auditPolicyName']
        if audit_policy_name is None:
            raise TypeError("Missing 'audit_policy_name' argument")
        if enable_conditions is None and 'enableConditions' in kwargs:
            enable_conditions = kwargs['enableConditions']
        if enable_conditions is None:
            raise TypeError("Missing 'enable_conditions' argument")
        if is_data_safe_service_account_audited is None and 'isDataSafeServiceAccountAudited' in kwargs:
            is_data_safe_service_account_audited = kwargs['isDataSafeServiceAccountAudited']
        if is_data_safe_service_account_audited is None:
            raise TypeError("Missing 'is_data_safe_service_account_audited' argument")
        if is_priv_users_managed_by_data_safe is None and 'isPrivUsersManagedByDataSafe' in kwargs:
            is_priv_users_managed_by_data_safe = kwargs['isPrivUsersManagedByDataSafe']
        if is_priv_users_managed_by_data_safe is None:
            raise TypeError("Missing 'is_priv_users_managed_by_data_safe' argument")

        _setter("audit_policy_name", audit_policy_name)
        _setter("enable_conditions", enable_conditions)
        _setter("is_data_safe_service_account_audited", is_data_safe_service_account_audited)
        _setter("is_priv_users_managed_by_data_safe", is_priv_users_managed_by_data_safe)

    @property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> str:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @property
    @pulumi.getter(name="enableConditions")
    def enable_conditions(self) -> Sequence['outputs.GetAuditPolicyAuditConditionEnableConditionResult']:
        """
        Indicates the users/roles in the target database for which the audit policy is enforced, and the success/failure event condition to generate the audit event..
        """
        return pulumi.get(self, "enable_conditions")

    @property
    @pulumi.getter(name="isDataSafeServiceAccountAudited")
    def is_data_safe_service_account_audited(self) -> bool:
        """
        Indicates whether the Data Safe user activity on the target database will be audited by the policy.
        """
        return pulumi.get(self, "is_data_safe_service_account_audited")

    @property
    @pulumi.getter(name="isPrivUsersManagedByDataSafe")
    def is_priv_users_managed_by_data_safe(self) -> bool:
        """
        Indicates whether the privileged user list is managed by Data Safe.
        """
        return pulumi.get(self, "is_priv_users_managed_by_data_safe")


@pulumi.output_type
class GetAuditPolicyAuditConditionEnableConditionResult(dict):
    def __init__(__self__, *,
                 entity_names: Sequence[str],
                 entity_selection: str,
                 entity_type: str,
                 operation_status: str):
        """
        :param Sequence[str] entity_names: List of users or roles that the policy must be enabled for.
        :param str entity_selection: The entity include or exclude selection.
        :param str entity_type: The entity type that the policy must be enabled for.
        :param str operation_status: The operation status that the policy must be enabled for.
        """
        GetAuditPolicyAuditConditionEnableConditionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_names=entity_names,
            entity_selection=entity_selection,
            entity_type=entity_type,
            operation_status=operation_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_names: Optional[Sequence[str]] = None,
             entity_selection: Optional[str] = None,
             entity_type: Optional[str] = None,
             operation_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_names is None and 'entityNames' in kwargs:
            entity_names = kwargs['entityNames']
        if entity_names is None:
            raise TypeError("Missing 'entity_names' argument")
        if entity_selection is None and 'entitySelection' in kwargs:
            entity_selection = kwargs['entitySelection']
        if entity_selection is None:
            raise TypeError("Missing 'entity_selection' argument")
        if entity_type is None and 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if entity_type is None:
            raise TypeError("Missing 'entity_type' argument")
        if operation_status is None and 'operationStatus' in kwargs:
            operation_status = kwargs['operationStatus']
        if operation_status is None:
            raise TypeError("Missing 'operation_status' argument")

        _setter("entity_names", entity_names)
        _setter("entity_selection", entity_selection)
        _setter("entity_type", entity_type)
        _setter("operation_status", operation_status)

    @property
    @pulumi.getter(name="entityNames")
    def entity_names(self) -> Sequence[str]:
        """
        List of users or roles that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_names")

    @property
    @pulumi.getter(name="entitySelection")
    def entity_selection(self) -> str:
        """
        The entity include or exclude selection.
        """
        return pulumi.get(self, "entity_selection")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        The entity type that the policy must be enabled for.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> str:
        """
        The operation status that the policy must be enabled for.
        """
        return pulumi.get(self, "operation_status")


@pulumi.output_type
class GetAuditPolicyAuditSpecificationResult(dict):
    def __init__(__self__, *,
                 audit_policy_category: str,
                 audit_policy_name: str,
                 database_policy_names: Sequence[str],
                 enable_status: str,
                 enabled_entities: str,
                 is_created: bool,
                 is_enabled_for_all_users: bool,
                 is_seeded_in_data_safe: bool,
                 is_seeded_in_target: bool,
                 is_view_only: bool,
                 partially_enabled_msg: str):
        """
        :param str audit_policy_category: The category to which the audit policy belongs.
        :param str audit_policy_name: Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        :param Sequence[str] database_policy_names: Indicates the names of corresponding database policy ( or policies) in the target database.
        :param str enable_status: Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        :param str enabled_entities: Indicates on whom the audit policy is enabled.
        :param bool is_created: Indicates whether the policy is already created on the target database.
        :param bool is_enabled_for_all_users: Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        :param bool is_seeded_in_data_safe: Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        :param bool is_seeded_in_target: Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        :param bool is_view_only: Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        :param str partially_enabled_msg: Provides information about the policy that has been only partially enabled.
        """
        GetAuditPolicyAuditSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_policy_category=audit_policy_category,
            audit_policy_name=audit_policy_name,
            database_policy_names=database_policy_names,
            enable_status=enable_status,
            enabled_entities=enabled_entities,
            is_created=is_created,
            is_enabled_for_all_users=is_enabled_for_all_users,
            is_seeded_in_data_safe=is_seeded_in_data_safe,
            is_seeded_in_target=is_seeded_in_target,
            is_view_only=is_view_only,
            partially_enabled_msg=partially_enabled_msg,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_policy_category: Optional[str] = None,
             audit_policy_name: Optional[str] = None,
             database_policy_names: Optional[Sequence[str]] = None,
             enable_status: Optional[str] = None,
             enabled_entities: Optional[str] = None,
             is_created: Optional[bool] = None,
             is_enabled_for_all_users: Optional[bool] = None,
             is_seeded_in_data_safe: Optional[bool] = None,
             is_seeded_in_target: Optional[bool] = None,
             is_view_only: Optional[bool] = None,
             partially_enabled_msg: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_policy_category is None and 'auditPolicyCategory' in kwargs:
            audit_policy_category = kwargs['auditPolicyCategory']
        if audit_policy_category is None:
            raise TypeError("Missing 'audit_policy_category' argument")
        if audit_policy_name is None and 'auditPolicyName' in kwargs:
            audit_policy_name = kwargs['auditPolicyName']
        if audit_policy_name is None:
            raise TypeError("Missing 'audit_policy_name' argument")
        if database_policy_names is None and 'databasePolicyNames' in kwargs:
            database_policy_names = kwargs['databasePolicyNames']
        if database_policy_names is None:
            raise TypeError("Missing 'database_policy_names' argument")
        if enable_status is None and 'enableStatus' in kwargs:
            enable_status = kwargs['enableStatus']
        if enable_status is None:
            raise TypeError("Missing 'enable_status' argument")
        if enabled_entities is None and 'enabledEntities' in kwargs:
            enabled_entities = kwargs['enabledEntities']
        if enabled_entities is None:
            raise TypeError("Missing 'enabled_entities' argument")
        if is_created is None and 'isCreated' in kwargs:
            is_created = kwargs['isCreated']
        if is_created is None:
            raise TypeError("Missing 'is_created' argument")
        if is_enabled_for_all_users is None and 'isEnabledForAllUsers' in kwargs:
            is_enabled_for_all_users = kwargs['isEnabledForAllUsers']
        if is_enabled_for_all_users is None:
            raise TypeError("Missing 'is_enabled_for_all_users' argument")
        if is_seeded_in_data_safe is None and 'isSeededInDataSafe' in kwargs:
            is_seeded_in_data_safe = kwargs['isSeededInDataSafe']
        if is_seeded_in_data_safe is None:
            raise TypeError("Missing 'is_seeded_in_data_safe' argument")
        if is_seeded_in_target is None and 'isSeededInTarget' in kwargs:
            is_seeded_in_target = kwargs['isSeededInTarget']
        if is_seeded_in_target is None:
            raise TypeError("Missing 'is_seeded_in_target' argument")
        if is_view_only is None and 'isViewOnly' in kwargs:
            is_view_only = kwargs['isViewOnly']
        if is_view_only is None:
            raise TypeError("Missing 'is_view_only' argument")
        if partially_enabled_msg is None and 'partiallyEnabledMsg' in kwargs:
            partially_enabled_msg = kwargs['partiallyEnabledMsg']
        if partially_enabled_msg is None:
            raise TypeError("Missing 'partially_enabled_msg' argument")

        _setter("audit_policy_category", audit_policy_category)
        _setter("audit_policy_name", audit_policy_name)
        _setter("database_policy_names", database_policy_names)
        _setter("enable_status", enable_status)
        _setter("enabled_entities", enabled_entities)
        _setter("is_created", is_created)
        _setter("is_enabled_for_all_users", is_enabled_for_all_users)
        _setter("is_seeded_in_data_safe", is_seeded_in_data_safe)
        _setter("is_seeded_in_target", is_seeded_in_target)
        _setter("is_view_only", is_view_only)
        _setter("partially_enabled_msg", partially_enabled_msg)

    @property
    @pulumi.getter(name="auditPolicyCategory")
    def audit_policy_category(self) -> str:
        """
        The category to which the audit policy belongs.
        """
        return pulumi.get(self, "audit_policy_category")

    @property
    @pulumi.getter(name="auditPolicyName")
    def audit_policy_name(self) -> str:
        """
        Indicates the audit policy name. Refer to the [documentation](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/audit-policies.html#GUID-361A9A9A-7C21-4F5A-8945-9B3A0C472827) for seeded audit policy names. For custom policies, refer to the user-defined policy name created in the target database.
        """
        return pulumi.get(self, "audit_policy_name")

    @property
    @pulumi.getter(name="databasePolicyNames")
    def database_policy_names(self) -> Sequence[str]:
        """
        Indicates the names of corresponding database policy ( or policies) in the target database.
        """
        return pulumi.get(self, "database_policy_names")

    @property
    @pulumi.getter(name="enableStatus")
    def enable_status(self) -> str:
        """
        Indicates whether the policy has been enabled, disabled or partially enabled in the target database. The status is PARTIALLY_ENABLED if any of the constituent database audit policies is not enabled.
        """
        return pulumi.get(self, "enable_status")

    @property
    @pulumi.getter(name="enabledEntities")
    def enabled_entities(self) -> str:
        """
        Indicates on whom the audit policy is enabled.
        """
        return pulumi.get(self, "enabled_entities")

    @property
    @pulumi.getter(name="isCreated")
    def is_created(self) -> bool:
        """
        Indicates whether the policy is already created on the target database.
        """
        return pulumi.get(self, "is_created")

    @property
    @pulumi.getter(name="isEnabledForAllUsers")
    def is_enabled_for_all_users(self) -> bool:
        """
        Indicates whether the policy by default is enabled for all users with no flexibility to alter the enablement conditions.
        """
        return pulumi.get(self, "is_enabled_for_all_users")

    @property
    @pulumi.getter(name="isSeededInDataSafe")
    def is_seeded_in_data_safe(self) -> bool:
        """
        Indicates whether the audit policy is one of the seeded policies provided by Oracle Data Safe.
        """
        return pulumi.get(self, "is_seeded_in_data_safe")

    @property
    @pulumi.getter(name="isSeededInTarget")
    def is_seeded_in_target(self) -> bool:
        """
        Indicates whether the audit policy is one of the predefined policies provided by Oracle Database.
        """
        return pulumi.get(self, "is_seeded_in_target")

    @property
    @pulumi.getter(name="isViewOnly")
    def is_view_only(self) -> bool:
        """
        Indicates whether the audit policy is available for provisioning/ de-provisioning from Oracle Data Safe, or is only available for displaying the current provisioning status from the target.
        """
        return pulumi.get(self, "is_view_only")

    @property
    @pulumi.getter(name="partiallyEnabledMsg")
    def partially_enabled_msg(self) -> str:
        """
        Provides information about the policy that has been only partially enabled.
        """
        return pulumi.get(self, "partially_enabled_msg")


@pulumi.output_type
class GetAuditProfileAnalyticItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetAuditProfileAnalyticItemDimensionResult']):
        """
        :param str count: Total count of aggregated metric.
        :param Sequence['GetAuditProfileAnalyticItemDimensionArgs'] dimensions: Details of aggregation dimensions used for summarizing audit profiles.
        """
        GetAuditProfileAnalyticItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetAuditProfileAnalyticItemDimensionResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Total count of aggregated metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetAuditProfileAnalyticItemDimensionResult']:
        """
        Details of aggregation dimensions used for summarizing audit profiles.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class GetAuditProfileAnalyticItemDimensionResult(dict):
    def __init__(__self__, *,
                 is_paid_usage_enabled: bool):
        """
        :param bool is_paid_usage_enabled: Indicates if you want to continue collecting audit records beyond the free limit of one million audit records per month per target database, potentially incurring additional charges. The default value is inherited from the global settings.  You can change at the global level or at the target level.
        """
        GetAuditProfileAnalyticItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_paid_usage_enabled=is_paid_usage_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_paid_usage_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_paid_usage_enabled is None and 'isPaidUsageEnabled' in kwargs:
            is_paid_usage_enabled = kwargs['isPaidUsageEnabled']
        if is_paid_usage_enabled is None:
            raise TypeError("Missing 'is_paid_usage_enabled' argument")

        _setter("is_paid_usage_enabled", is_paid_usage_enabled)

    @property
    @pulumi.getter(name="isPaidUsageEnabled")
    def is_paid_usage_enabled(self) -> bool:
        """
        Indicates if you want to continue collecting audit records beyond the free limit of one million audit records per month per target database, potentially incurring additional charges. The default value is inherited from the global settings.  You can change at the global level or at the target level.
        """
        return pulumi.get(self, "is_paid_usage_enabled")


@pulumi.output_type
class GetAuditProfileAuditTrailResult(dict):
    def __init__(__self__, *,
                 audit_collection_start_time: str,
                 audit_profile_id: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_auto_purge_enabled: bool,
                 lifecycle_details: str,
                 state: str,
                 status: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_last_collected: str,
                 time_updated: str,
                 trail_location: str,
                 work_request_id: str):
        """
        :param str audit_collection_start_time: The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        :param str audit_profile_id: The OCID of the audit.
        :param str compartment_id: The OCID of the compartment that contains the audit.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the audit profile.
        :param str display_name: The display name of the audit profile.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit profile.
        :param bool is_auto_purge_enabled: Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        :param str lifecycle_details: Details about the current state of the audit profile in Data Safe.
        :param str state: The current state of the audit profile.
        :param str status: The current sub-state of the audit trail.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: The OCID of the Data Safe target for which the audit profile is created.
        :param str time_created: The date and time the audit profile was created, in the format defined by RFC3339.
        :param str time_last_collected: The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        :param str time_updated: The date and time the audit profile was updated, in the format defined by RFC3339.
        :param str trail_location: An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        :param str work_request_id: The OCID of the workrequest for audit trail which collects audit records.
        """
        GetAuditProfileAuditTrailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_collection_start_time=audit_collection_start_time,
            audit_profile_id=audit_profile_id,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_auto_purge_enabled=is_auto_purge_enabled,
            lifecycle_details=lifecycle_details,
            state=state,
            status=status,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_last_collected=time_last_collected,
            time_updated=time_updated,
            trail_location=trail_location,
            work_request_id=work_request_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_collection_start_time: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_auto_purge_enabled: Optional[bool] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_last_collected: Optional[str] = None,
             time_updated: Optional[str] = None,
             trail_location: Optional[str] = None,
             work_request_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_collection_start_time is None and 'auditCollectionStartTime' in kwargs:
            audit_collection_start_time = kwargs['auditCollectionStartTime']
        if audit_collection_start_time is None:
            raise TypeError("Missing 'audit_collection_start_time' argument")
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_auto_purge_enabled is None and 'isAutoPurgeEnabled' in kwargs:
            is_auto_purge_enabled = kwargs['isAutoPurgeEnabled']
        if is_auto_purge_enabled is None:
            raise TypeError("Missing 'is_auto_purge_enabled' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_last_collected is None and 'timeLastCollected' in kwargs:
            time_last_collected = kwargs['timeLastCollected']
        if time_last_collected is None:
            raise TypeError("Missing 'time_last_collected' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if trail_location is None and 'trailLocation' in kwargs:
            trail_location = kwargs['trailLocation']
        if trail_location is None:
            raise TypeError("Missing 'trail_location' argument")
        if work_request_id is None and 'workRequestId' in kwargs:
            work_request_id = kwargs['workRequestId']
        if work_request_id is None:
            raise TypeError("Missing 'work_request_id' argument")

        _setter("audit_collection_start_time", audit_collection_start_time)
        _setter("audit_profile_id", audit_profile_id)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_auto_purge_enabled", is_auto_purge_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("status", status)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_last_collected", time_last_collected)
        _setter("time_updated", time_updated)
        _setter("trail_location", trail_location)
        _setter("work_request_id", work_request_id)

    @property
    @pulumi.getter(name="auditCollectionStartTime")
    def audit_collection_start_time(self) -> str:
        """
        The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        """
        return pulumi.get(self, "audit_collection_start_time")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment that contains the audit.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the audit profile.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the audit profile.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit profile.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutoPurgeEnabled")
    def is_auto_purge_enabled(self) -> bool:
        """
        Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        """
        return pulumi.get(self, "is_auto_purge_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the audit profile in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the audit profile.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current sub-state of the audit trail.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The OCID of the Data Safe target for which the audit profile is created.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the audit profile was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastCollected")
    def time_last_collected(self) -> str:
        """
        The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_collected")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> str:
        """
        An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        return pulumi.get(self, "trail_location")

    @property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> str:
        """
        The OCID of the workrequest for audit trail which collects audit records.
        """
        return pulumi.get(self, "work_request_id")


@pulumi.output_type
class GetAuditProfileAvailableAuditVolumeItemResult(dict):
    def __init__(__self__, *,
                 audit_profile_id: str,
                 month_in_consideration: str,
                 trail_location: str,
                 volume: str):
        """
        :param str audit_profile_id: The OCID of the audit.
        :param str month_in_consideration: Represents the month under consideration for which aggregated audit data volume available at the target is computed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        :param str trail_location: The audit trail location.
        :param str volume: Represents the aggregated audit data volume available in the audit trails on the target database which is yet to be collected by Data Safe for the specified month.
        """
        GetAuditProfileAvailableAuditVolumeItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_profile_id=audit_profile_id,
            month_in_consideration=month_in_consideration,
            trail_location=trail_location,
            volume=volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_profile_id: Optional[str] = None,
             month_in_consideration: Optional[str] = None,
             trail_location: Optional[str] = None,
             volume: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if month_in_consideration is None and 'monthInConsideration' in kwargs:
            month_in_consideration = kwargs['monthInConsideration']
        if month_in_consideration is None:
            raise TypeError("Missing 'month_in_consideration' argument")
        if trail_location is None and 'trailLocation' in kwargs:
            trail_location = kwargs['trailLocation']
        if trail_location is None:
            raise TypeError("Missing 'trail_location' argument")
        if volume is None:
            raise TypeError("Missing 'volume' argument")

        _setter("audit_profile_id", audit_profile_id)
        _setter("month_in_consideration", month_in_consideration)
        _setter("trail_location", trail_location)
        _setter("volume", volume)

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="monthInConsideration")
    def month_in_consideration(self) -> str:
        """
        Represents the month under consideration for which aggregated audit data volume available at the target is computed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        """
        return pulumi.get(self, "month_in_consideration")

    @property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> str:
        """
        The audit trail location.
        """
        return pulumi.get(self, "trail_location")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Represents the aggregated audit data volume available in the audit trails on the target database which is yet to be collected by Data Safe for the specified month.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemResult']):
        """
        :param Sequence['GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemArgs'] items: Array of available audit volume summary.
        """
        GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemResult']:
        """
        Array of available audit volume summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemResult']):
        """
        :param Sequence['GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemArgs'] items: Array of available audit volume summary.
        """
        GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemResult']:
        """
        Array of available audit volume summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemResult(dict):
    def __init__(__self__, *,
                 audit_profile_id: str,
                 month_in_consideration: str,
                 trail_location: str,
                 volume: str):
        """
        :param str audit_profile_id: The OCID of the audit.
        :param str month_in_consideration: Represents the month under consideration for which aggregated audit data volume available at the target is computed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        :param str trail_location: The audit trail location.
        :param str volume: Represents the aggregated audit data volume available in the audit trails on the target database which is yet to be collected by Data Safe for the specified month.
        """
        GetAuditProfileAvailableAuditVolumesAvailableAuditVolumeCollectionItemItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_profile_id=audit_profile_id,
            month_in_consideration=month_in_consideration,
            trail_location=trail_location,
            volume=volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_profile_id: Optional[str] = None,
             month_in_consideration: Optional[str] = None,
             trail_location: Optional[str] = None,
             volume: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if month_in_consideration is None and 'monthInConsideration' in kwargs:
            month_in_consideration = kwargs['monthInConsideration']
        if month_in_consideration is None:
            raise TypeError("Missing 'month_in_consideration' argument")
        if trail_location is None and 'trailLocation' in kwargs:
            trail_location = kwargs['trailLocation']
        if trail_location is None:
            raise TypeError("Missing 'trail_location' argument")
        if volume is None:
            raise TypeError("Missing 'volume' argument")

        _setter("audit_profile_id", audit_profile_id)
        _setter("month_in_consideration", month_in_consideration)
        _setter("trail_location", trail_location)
        _setter("volume", volume)

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="monthInConsideration")
    def month_in_consideration(self) -> str:
        """
        Represents the month under consideration for which aggregated audit data volume available at the target is computed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        """
        return pulumi.get(self, "month_in_consideration")

    @property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> str:
        """
        The audit trail location.
        """
        return pulumi.get(self, "trail_location")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Represents the aggregated audit data volume available in the audit trails on the target database which is yet to be collected by Data Safe for the specified month.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class GetAuditProfileAvailableAuditVolumesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditProfileAvailableAuditVolumesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditProfileCollectedAuditVolumeItemResult(dict):
    def __init__(__self__, *,
                 archived_volume: str,
                 audit_profile_id: str,
                 month_in_consideration: str,
                 online_volume: str):
        """
        :param str archived_volume: The audit data volume collected by Data Safe and is available in archive storage.
        :param str audit_profile_id: The OCID of the audit.
        :param str month_in_consideration: Represents the month under consideration in which the aggregated audit data volume collected by Data Safe is displayed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        :param str online_volume: The audit data volume collected by Data Safe and is available online in repository.
        """
        GetAuditProfileCollectedAuditVolumeItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archived_volume=archived_volume,
            audit_profile_id=audit_profile_id,
            month_in_consideration=month_in_consideration,
            online_volume=online_volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archived_volume: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             month_in_consideration: Optional[str] = None,
             online_volume: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archived_volume is None and 'archivedVolume' in kwargs:
            archived_volume = kwargs['archivedVolume']
        if archived_volume is None:
            raise TypeError("Missing 'archived_volume' argument")
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if month_in_consideration is None and 'monthInConsideration' in kwargs:
            month_in_consideration = kwargs['monthInConsideration']
        if month_in_consideration is None:
            raise TypeError("Missing 'month_in_consideration' argument")
        if online_volume is None and 'onlineVolume' in kwargs:
            online_volume = kwargs['onlineVolume']
        if online_volume is None:
            raise TypeError("Missing 'online_volume' argument")

        _setter("archived_volume", archived_volume)
        _setter("audit_profile_id", audit_profile_id)
        _setter("month_in_consideration", month_in_consideration)
        _setter("online_volume", online_volume)

    @property
    @pulumi.getter(name="archivedVolume")
    def archived_volume(self) -> str:
        """
        The audit data volume collected by Data Safe and is available in archive storage.
        """
        return pulumi.get(self, "archived_volume")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="monthInConsideration")
    def month_in_consideration(self) -> str:
        """
        Represents the month under consideration in which the aggregated audit data volume collected by Data Safe is displayed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        """
        return pulumi.get(self, "month_in_consideration")

    @property
    @pulumi.getter(name="onlineVolume")
    def online_volume(self) -> str:
        """
        The audit data volume collected by Data Safe and is available online in repository.
        """
        return pulumi.get(self, "online_volume")


@pulumi.output_type
class GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemResult']):
        """
        :param Sequence['GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemArgs'] items: Array of collected audit volume summary.
        """
        GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemResult']:
        """
        Array of collected audit volume summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemResult']):
        """
        :param Sequence['GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemArgs'] items: Array of collected audit volume summary.
        """
        GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemResult']:
        """
        Array of collected audit volume summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemResult(dict):
    def __init__(__self__, *,
                 archived_volume: str,
                 audit_profile_id: str,
                 month_in_consideration: str,
                 online_volume: str):
        """
        :param str archived_volume: The audit data volume collected by Data Safe and is available in archive storage.
        :param str audit_profile_id: The OCID of the audit.
        :param str month_in_consideration: Represents the month under consideration in which the aggregated audit data volume collected by Data Safe is displayed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        :param str online_volume: The audit data volume collected by Data Safe and is available online in repository.
        """
        GetAuditProfileCollectedAuditVolumesCollectedAuditVolumeCollectionItemItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archived_volume=archived_volume,
            audit_profile_id=audit_profile_id,
            month_in_consideration=month_in_consideration,
            online_volume=online_volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archived_volume: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             month_in_consideration: Optional[str] = None,
             online_volume: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archived_volume is None and 'archivedVolume' in kwargs:
            archived_volume = kwargs['archivedVolume']
        if archived_volume is None:
            raise TypeError("Missing 'archived_volume' argument")
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if month_in_consideration is None and 'monthInConsideration' in kwargs:
            month_in_consideration = kwargs['monthInConsideration']
        if month_in_consideration is None:
            raise TypeError("Missing 'month_in_consideration' argument")
        if online_volume is None and 'onlineVolume' in kwargs:
            online_volume = kwargs['onlineVolume']
        if online_volume is None:
            raise TypeError("Missing 'online_volume' argument")

        _setter("archived_volume", archived_volume)
        _setter("audit_profile_id", audit_profile_id)
        _setter("month_in_consideration", month_in_consideration)
        _setter("online_volume", online_volume)

    @property
    @pulumi.getter(name="archivedVolume")
    def archived_volume(self) -> str:
        """
        The audit data volume collected by Data Safe and is available in archive storage.
        """
        return pulumi.get(self, "archived_volume")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        The OCID of the audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="monthInConsideration")
    def month_in_consideration(self) -> str:
        """
        Represents the month under consideration in which the aggregated audit data volume collected by Data Safe is displayed. This field will be the UTC start of the day of the first day of the month for which the aggregate count corresponds to, in the format defined by RFC3339.. For instance, the value of 01-01-2021T00:00:00Z represents Jan 2021.
        """
        return pulumi.get(self, "month_in_consideration")

    @property
    @pulumi.getter(name="onlineVolume")
    def online_volume(self) -> str:
        """
        The audit data volume collected by Data Safe and is available online in repository.
        """
        return pulumi.get(self, "online_volume")


@pulumi.output_type
class GetAuditProfileCollectedAuditVolumesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditProfileCollectedAuditVolumesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditProfilesAuditProfileCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditProfilesAuditProfileCollectionItemResult']):
        GetAuditProfilesAuditProfileCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditProfilesAuditProfileCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditProfilesAuditProfileCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditProfilesAuditProfileCollectionItemResult(dict):
    def __init__(__self__, *,
                 audit_collected_volume: str,
                 audit_profile_id: str,
                 audit_trails: Sequence['outputs.GetAuditProfilesAuditProfileCollectionItemAuditTrailResult'],
                 change_retention_trigger: int,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_override_global_retention_setting: bool,
                 is_paid_usage_enabled: bool,
                 lifecycle_details: str,
                 offline_months: int,
                 online_months: int,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str audit_collected_volume: Indicates number of audit records collected by Data Safe in the current calendar month.  Audit records for the Data Safe service account are excluded and are not counted towards your monthly free limit.
        :param str audit_profile_id: A optional filter to return only resources that match the specified id.
        :param Sequence['GetAuditProfilesAuditProfileCollectionItemAuditTrailArgs'] audit_trails: Indicates the list of available audit trails on the target.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the audit profile.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit profile.
        :param bool is_override_global_retention_setting: A optional filter to return only resources that match the specified retention configured value.
        :param bool is_paid_usage_enabled: Indicates if you want to continue audit record collection beyond the free limit of one million audit records per month per target database, incurring additional charges. The default value is inherited from the global settings. You can change at the global level or at the target level.
        :param str lifecycle_details: Details about the current state of the audit profile in Data Safe.
        :param int offline_months: Indicates the number of months the audit records will be stored offline in the Data Safe audit archive. Minimum: 0; Maximum: 72 months. If you have a requirement to store the audit data even longer in archive, please contact the Oracle Support.
        :param int online_months: Indicates the number of months the audit records will be stored online in Oracle Data Safe audit repository for immediate reporting and analysis.  Minimum: 1; Maximum:12 months
        :param str state: A optional filter to return only resources that match the specified lifecycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: The date and time the audit profile was created, in the format defined by RFC3339.
        :param str time_updated: The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        GetAuditProfilesAuditProfileCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_collected_volume=audit_collected_volume,
            audit_profile_id=audit_profile_id,
            audit_trails=audit_trails,
            change_retention_trigger=change_retention_trigger,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_override_global_retention_setting=is_override_global_retention_setting,
            is_paid_usage_enabled=is_paid_usage_enabled,
            lifecycle_details=lifecycle_details,
            offline_months=offline_months,
            online_months=online_months,
            state=state,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_collected_volume: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             audit_trails: Optional[Sequence['outputs.GetAuditProfilesAuditProfileCollectionItemAuditTrailResult']] = None,
             change_retention_trigger: Optional[int] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_override_global_retention_setting: Optional[bool] = None,
             is_paid_usage_enabled: Optional[bool] = None,
             lifecycle_details: Optional[str] = None,
             offline_months: Optional[int] = None,
             online_months: Optional[int] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_collected_volume is None and 'auditCollectedVolume' in kwargs:
            audit_collected_volume = kwargs['auditCollectedVolume']
        if audit_collected_volume is None:
            raise TypeError("Missing 'audit_collected_volume' argument")
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if audit_trails is None and 'auditTrails' in kwargs:
            audit_trails = kwargs['auditTrails']
        if audit_trails is None:
            raise TypeError("Missing 'audit_trails' argument")
        if change_retention_trigger is None and 'changeRetentionTrigger' in kwargs:
            change_retention_trigger = kwargs['changeRetentionTrigger']
        if change_retention_trigger is None:
            raise TypeError("Missing 'change_retention_trigger' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_override_global_retention_setting is None and 'isOverrideGlobalRetentionSetting' in kwargs:
            is_override_global_retention_setting = kwargs['isOverrideGlobalRetentionSetting']
        if is_override_global_retention_setting is None:
            raise TypeError("Missing 'is_override_global_retention_setting' argument")
        if is_paid_usage_enabled is None and 'isPaidUsageEnabled' in kwargs:
            is_paid_usage_enabled = kwargs['isPaidUsageEnabled']
        if is_paid_usage_enabled is None:
            raise TypeError("Missing 'is_paid_usage_enabled' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if offline_months is None and 'offlineMonths' in kwargs:
            offline_months = kwargs['offlineMonths']
        if offline_months is None:
            raise TypeError("Missing 'offline_months' argument")
        if online_months is None and 'onlineMonths' in kwargs:
            online_months = kwargs['onlineMonths']
        if online_months is None:
            raise TypeError("Missing 'online_months' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("audit_collected_volume", audit_collected_volume)
        _setter("audit_profile_id", audit_profile_id)
        _setter("audit_trails", audit_trails)
        _setter("change_retention_trigger", change_retention_trigger)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_override_global_retention_setting", is_override_global_retention_setting)
        _setter("is_paid_usage_enabled", is_paid_usage_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("offline_months", offline_months)
        _setter("online_months", online_months)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="auditCollectedVolume")
    def audit_collected_volume(self) -> str:
        """
        Indicates number of audit records collected by Data Safe in the current calendar month.  Audit records for the Data Safe service account are excluded and are not counted towards your monthly free limit.
        """
        return pulumi.get(self, "audit_collected_volume")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        A optional filter to return only resources that match the specified id.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="auditTrails")
    def audit_trails(self) -> Sequence['outputs.GetAuditProfilesAuditProfileCollectionItemAuditTrailResult']:
        """
        Indicates the list of available audit trails on the target.
        """
        return pulumi.get(self, "audit_trails")

    @property
    @pulumi.getter(name="changeRetentionTrigger")
    def change_retention_trigger(self) -> int:
        return pulumi.get(self, "change_retention_trigger")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the audit profile.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit profile.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isOverrideGlobalRetentionSetting")
    def is_override_global_retention_setting(self) -> bool:
        """
        A optional filter to return only resources that match the specified retention configured value.
        """
        return pulumi.get(self, "is_override_global_retention_setting")

    @property
    @pulumi.getter(name="isPaidUsageEnabled")
    def is_paid_usage_enabled(self) -> bool:
        """
        Indicates if you want to continue audit record collection beyond the free limit of one million audit records per month per target database, incurring additional charges. The default value is inherited from the global settings. You can change at the global level or at the target level.
        """
        return pulumi.get(self, "is_paid_usage_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the audit profile in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="offlineMonths")
    def offline_months(self) -> int:
        """
        Indicates the number of months the audit records will be stored offline in the Data Safe audit archive. Minimum: 0; Maximum: 72 months. If you have a requirement to store the audit data even longer in archive, please contact the Oracle Support.
        """
        return pulumi.get(self, "offline_months")

    @property
    @pulumi.getter(name="onlineMonths")
    def online_months(self) -> int:
        """
        Indicates the number of months the audit records will be stored online in Oracle Data Safe audit repository for immediate reporting and analysis.  Minimum: 1; Maximum:12 months
        """
        return pulumi.get(self, "online_months")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A optional filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the audit profile was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetAuditProfilesAuditProfileCollectionItemAuditTrailResult(dict):
    def __init__(__self__, *,
                 audit_collection_start_time: str,
                 audit_profile_id: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_auto_purge_enabled: bool,
                 lifecycle_details: str,
                 state: str,
                 status: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_last_collected: str,
                 time_updated: str,
                 trail_location: str,
                 work_request_id: str):
        """
        :param str audit_collection_start_time: The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        :param str audit_profile_id: A optional filter to return only resources that match the specified id.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the audit profile.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit profile.
        :param bool is_auto_purge_enabled: Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        :param str lifecycle_details: Details about the current state of the audit profile in Data Safe.
        :param str state: A optional filter to return only resources that match the specified lifecycle state.
        :param str status: The current sub-state of the audit trail.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: The date and time the audit profile was created, in the format defined by RFC3339.
        :param str time_last_collected: The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        :param str time_updated: The date and time the audit profile was updated, in the format defined by RFC3339.
        :param str trail_location: An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        :param str work_request_id: The OCID of the workrequest for audit trail which collects audit records.
        """
        GetAuditProfilesAuditProfileCollectionItemAuditTrailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_collection_start_time=audit_collection_start_time,
            audit_profile_id=audit_profile_id,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_auto_purge_enabled=is_auto_purge_enabled,
            lifecycle_details=lifecycle_details,
            state=state,
            status=status,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_last_collected=time_last_collected,
            time_updated=time_updated,
            trail_location=trail_location,
            work_request_id=work_request_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_collection_start_time: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_auto_purge_enabled: Optional[bool] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_last_collected: Optional[str] = None,
             time_updated: Optional[str] = None,
             trail_location: Optional[str] = None,
             work_request_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_collection_start_time is None and 'auditCollectionStartTime' in kwargs:
            audit_collection_start_time = kwargs['auditCollectionStartTime']
        if audit_collection_start_time is None:
            raise TypeError("Missing 'audit_collection_start_time' argument")
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_auto_purge_enabled is None and 'isAutoPurgeEnabled' in kwargs:
            is_auto_purge_enabled = kwargs['isAutoPurgeEnabled']
        if is_auto_purge_enabled is None:
            raise TypeError("Missing 'is_auto_purge_enabled' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_last_collected is None and 'timeLastCollected' in kwargs:
            time_last_collected = kwargs['timeLastCollected']
        if time_last_collected is None:
            raise TypeError("Missing 'time_last_collected' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if trail_location is None and 'trailLocation' in kwargs:
            trail_location = kwargs['trailLocation']
        if trail_location is None:
            raise TypeError("Missing 'trail_location' argument")
        if work_request_id is None and 'workRequestId' in kwargs:
            work_request_id = kwargs['workRequestId']
        if work_request_id is None:
            raise TypeError("Missing 'work_request_id' argument")

        _setter("audit_collection_start_time", audit_collection_start_time)
        _setter("audit_profile_id", audit_profile_id)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_auto_purge_enabled", is_auto_purge_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("status", status)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_last_collected", time_last_collected)
        _setter("time_updated", time_updated)
        _setter("trail_location", trail_location)
        _setter("work_request_id", work_request_id)

    @property
    @pulumi.getter(name="auditCollectionStartTime")
    def audit_collection_start_time(self) -> str:
        """
        The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        """
        return pulumi.get(self, "audit_collection_start_time")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        A optional filter to return only resources that match the specified id.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the audit profile.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit profile.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutoPurgeEnabled")
    def is_auto_purge_enabled(self) -> bool:
        """
        Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        """
        return pulumi.get(self, "is_auto_purge_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the audit profile in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A optional filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current sub-state of the audit trail.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the audit profile was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastCollected")
    def time_last_collected(self) -> str:
        """
        The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_collected")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the audit profile was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> str:
        """
        An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        return pulumi.get(self, "trail_location")

    @property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> str:
        """
        The OCID of the workrequest for audit trail which collects audit records.
        """
        return pulumi.get(self, "work_request_id")


@pulumi.output_type
class GetAuditProfilesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditProfilesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAuditTrailAnalyticItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetAuditTrailAnalyticItemDimensionResult']):
        """
        :param str count: Total count of aggregated metric.
        :param Sequence['GetAuditTrailAnalyticItemDimensionArgs'] dimensions: Details of aggregation dimensions used for summarizing audit trails.
        """
        GetAuditTrailAnalyticItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetAuditTrailAnalyticItemDimensionResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Total count of aggregated metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetAuditTrailAnalyticItemDimensionResult']:
        """
        Details of aggregation dimensions used for summarizing audit trails.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class GetAuditTrailAnalyticItemDimensionResult(dict):
    def __init__(__self__, *,
                 location: str,
                 state: str,
                 status: str,
                 target_id: str):
        """
        :param str location: The location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        :param str state: The current state of the audit trail.
        :param str status: The current sub-state of the audit trail..
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetAuditTrailAnalyticItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            state=state,
            status=status,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if location is None:
            raise TypeError("Missing 'location' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("location", location)
        _setter("state", state)
        _setter("status", status)
        _setter("target_id", target_id)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the audit trail.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current sub-state of the audit trail..
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetAuditTrailsAuditTrailCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAuditTrailsAuditTrailCollectionItemResult']):
        GetAuditTrailsAuditTrailCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetAuditTrailsAuditTrailCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAuditTrailsAuditTrailCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAuditTrailsAuditTrailCollectionItemResult(dict):
    def __init__(__self__, *,
                 audit_collection_start_time: str,
                 audit_profile_id: str,
                 audit_trail_id: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_auto_purge_enabled: bool,
                 lifecycle_details: str,
                 resume_trigger: int,
                 state: str,
                 status: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_last_collected: str,
                 time_updated: str,
                 trail_location: str,
                 work_request_id: str):
        """
        :param str audit_collection_start_time: The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        :param str audit_profile_id: The OCID of the  parent audit.
        :param str audit_trail_id: A optional filter to return only resources that match the specified id.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the audit trail.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the audit trail.
        :param bool is_auto_purge_enabled: Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        :param str lifecycle_details: Details about the current state of the audit trail in Data Safe.
        :param str state: A optional filter to return only resources that match the specified lifecycle state.
        :param str status: A optional filter to return only resources that match the specified sub-state of audit trail.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: The date and time the audit trail was created, in the format defined by RFC3339.
        :param str time_last_collected: The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        :param str time_updated: The date and time the audit trail was updated, in the format defined by RFC3339.
        :param str trail_location: An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        :param str work_request_id: The OCID of the workrequest for audit trail which collects audit records.
        """
        GetAuditTrailsAuditTrailCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_collection_start_time=audit_collection_start_time,
            audit_profile_id=audit_profile_id,
            audit_trail_id=audit_trail_id,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_auto_purge_enabled=is_auto_purge_enabled,
            lifecycle_details=lifecycle_details,
            resume_trigger=resume_trigger,
            state=state,
            status=status,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_last_collected=time_last_collected,
            time_updated=time_updated,
            trail_location=trail_location,
            work_request_id=work_request_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_collection_start_time: Optional[str] = None,
             audit_profile_id: Optional[str] = None,
             audit_trail_id: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_auto_purge_enabled: Optional[bool] = None,
             lifecycle_details: Optional[str] = None,
             resume_trigger: Optional[int] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_last_collected: Optional[str] = None,
             time_updated: Optional[str] = None,
             trail_location: Optional[str] = None,
             work_request_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if audit_collection_start_time is None and 'auditCollectionStartTime' in kwargs:
            audit_collection_start_time = kwargs['auditCollectionStartTime']
        if audit_collection_start_time is None:
            raise TypeError("Missing 'audit_collection_start_time' argument")
        if audit_profile_id is None and 'auditProfileId' in kwargs:
            audit_profile_id = kwargs['auditProfileId']
        if audit_profile_id is None:
            raise TypeError("Missing 'audit_profile_id' argument")
        if audit_trail_id is None and 'auditTrailId' in kwargs:
            audit_trail_id = kwargs['auditTrailId']
        if audit_trail_id is None:
            raise TypeError("Missing 'audit_trail_id' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_auto_purge_enabled is None and 'isAutoPurgeEnabled' in kwargs:
            is_auto_purge_enabled = kwargs['isAutoPurgeEnabled']
        if is_auto_purge_enabled is None:
            raise TypeError("Missing 'is_auto_purge_enabled' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if resume_trigger is None and 'resumeTrigger' in kwargs:
            resume_trigger = kwargs['resumeTrigger']
        if resume_trigger is None:
            raise TypeError("Missing 'resume_trigger' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_last_collected is None and 'timeLastCollected' in kwargs:
            time_last_collected = kwargs['timeLastCollected']
        if time_last_collected is None:
            raise TypeError("Missing 'time_last_collected' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if trail_location is None and 'trailLocation' in kwargs:
            trail_location = kwargs['trailLocation']
        if trail_location is None:
            raise TypeError("Missing 'trail_location' argument")
        if work_request_id is None and 'workRequestId' in kwargs:
            work_request_id = kwargs['workRequestId']
        if work_request_id is None:
            raise TypeError("Missing 'work_request_id' argument")

        _setter("audit_collection_start_time", audit_collection_start_time)
        _setter("audit_profile_id", audit_profile_id)
        _setter("audit_trail_id", audit_trail_id)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_auto_purge_enabled", is_auto_purge_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("resume_trigger", resume_trigger)
        _setter("state", state)
        _setter("status", status)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_last_collected", time_last_collected)
        _setter("time_updated", time_updated)
        _setter("trail_location", trail_location)
        _setter("work_request_id", work_request_id)

    @property
    @pulumi.getter(name="auditCollectionStartTime")
    def audit_collection_start_time(self) -> str:
        """
        The date from which the audit trail must start collecting data, in the format defined by RFC3339.
        """
        return pulumi.get(self, "audit_collection_start_time")

    @property
    @pulumi.getter(name="auditProfileId")
    def audit_profile_id(self) -> str:
        """
        The OCID of the  parent audit.
        """
        return pulumi.get(self, "audit_profile_id")

    @property
    @pulumi.getter(name="auditTrailId")
    def audit_trail_id(self) -> str:
        """
        A optional filter to return only resources that match the specified id.
        """
        return pulumi.get(self, "audit_trail_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the audit trail.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the audit trail.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutoPurgeEnabled")
    def is_auto_purge_enabled(self) -> bool:
        """
        Indicates if auto purge is enabled on the target database, which helps delete audit data in the target database every seven days so that the database's audit trail does not become too large.
        """
        return pulumi.get(self, "is_auto_purge_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the audit trail in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="resumeTrigger")
    def resume_trigger(self) -> int:
        return pulumi.get(self, "resume_trigger")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A optional filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        A optional filter to return only resources that match the specified sub-state of audit trail.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the audit trail was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastCollected")
    def time_last_collected(self) -> str:
        """
        The date and time until when the audit events were collected from the target database by the Data Safe audit trail  collection process, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_collected")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the audit trail was updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="trailLocation")
    def trail_location(self) -> str:
        """
        An audit trail location represents the source of audit records that provides documentary evidence of the sequence of activities in the target database.
        """
        return pulumi.get(self, "trail_location")

    @property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> str:
        """
        The OCID of the workrequest for audit trail which collects audit records.
        """
        return pulumi.get(self, "work_request_id")


@pulumi.output_type
class GetAuditTrailsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAuditTrailsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCompatibleFormatsForDataTypeFormatsForDataTypeResult(dict):
    def __init__(__self__, *,
                 data_type: str,
                 masking_formats: Sequence['outputs.GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatResult']):
        """
        :param str data_type: The data type category, which can be one of the following - Character - Includes CHAR, NCHAR, VARCHAR2, and NVARCHAR2 Numeric - Includes NUMBER, FLOAT, RAW, BINARY_FLOAT, and BINARY_DOUBLE Date - Includes DATE and TIMESTAMP LOB - Includes BLOB, CLOB, and NCLOB All - Includes all the supported data types
        :param Sequence['GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatArgs'] masking_formats: An array of the basic masking formats compatible with the data type category.
        """
        GetCompatibleFormatsForDataTypeFormatsForDataTypeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            masking_formats=masking_formats,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             masking_formats: Optional[Sequence['outputs.GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if masking_formats is None and 'maskingFormats' in kwargs:
            masking_formats = kwargs['maskingFormats']
        if masking_formats is None:
            raise TypeError("Missing 'masking_formats' argument")

        _setter("data_type", data_type)
        _setter("masking_formats", masking_formats)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        The data type category, which can be one of the following - Character - Includes CHAR, NCHAR, VARCHAR2, and NVARCHAR2 Numeric - Includes NUMBER, FLOAT, RAW, BINARY_FLOAT, and BINARY_DOUBLE Date - Includes DATE and TIMESTAMP LOB - Includes BLOB, CLOB, and NCLOB All - Includes all the supported data types
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="maskingFormats")
    def masking_formats(self) -> Sequence['outputs.GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatResult']:
        """
        An array of the basic masking formats compatible with the data type category.
        """
        return pulumi.get(self, "masking_formats")


@pulumi.output_type
class GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str):
        """
        :param str description: The description of the masking format.
        :param str id: The OCID of the masking format.
        :param str name: The name of the masking format.
        """
        GetCompatibleFormatsForDataTypeFormatsForDataTypeMaskingFormatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the masking format.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the masking format.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the masking format.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeResult(dict):
    def __init__(__self__, *,
                 masking_formats: Sequence['outputs.GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatResult'],
                 sensitive_type_id: str):
        """
        :param Sequence['GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatArgs'] masking_formats: An array of the library masking formats compatible with the sensitive type.
        :param str sensitive_type_id: The OCID of the sensitive type.
        """
        GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            masking_formats=masking_formats,
            sensitive_type_id=sensitive_type_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             masking_formats: Optional[Sequence['outputs.GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatResult']] = None,
             sensitive_type_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if masking_formats is None and 'maskingFormats' in kwargs:
            masking_formats = kwargs['maskingFormats']
        if masking_formats is None:
            raise TypeError("Missing 'masking_formats' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")

        _setter("masking_formats", masking_formats)
        _setter("sensitive_type_id", sensitive_type_id)

    @property
    @pulumi.getter(name="maskingFormats")
    def masking_formats(self) -> Sequence['outputs.GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatResult']:
        """
        An array of the library masking formats compatible with the sensitive type.
        """
        return pulumi.get(self, "masking_formats")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        The OCID of the sensitive type.
        """
        return pulumi.get(self, "sensitive_type_id")


@pulumi.output_type
class GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str):
        """
        :param str description: The description of the masking format.
        :param str id: The OCID of the masking format.
        :param str name: The name of the masking format.
        """
        GetCompatibleFormatsForSensitiveTypeFormatsForSensitiveTypeMaskingFormatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the masking format.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the masking format.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the masking format.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataSafeConfigurationGlobalSettingResult(dict):
    def __init__(__self__, *,
                 is_paid_usage: bool,
                 offline_retention_period: int,
                 online_retention_period: int):
        """
        :param bool is_paid_usage: The paid usage option chosen by the customer admin.
        :param int offline_retention_period: The offline retention period in months.
        :param int online_retention_period: The online retention period in months.
        """
        GetDataSafeConfigurationGlobalSettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_paid_usage=is_paid_usage,
            offline_retention_period=offline_retention_period,
            online_retention_period=online_retention_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_paid_usage: Optional[bool] = None,
             offline_retention_period: Optional[int] = None,
             online_retention_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_paid_usage is None and 'isPaidUsage' in kwargs:
            is_paid_usage = kwargs['isPaidUsage']
        if is_paid_usage is None:
            raise TypeError("Missing 'is_paid_usage' argument")
        if offline_retention_period is None and 'offlineRetentionPeriod' in kwargs:
            offline_retention_period = kwargs['offlineRetentionPeriod']
        if offline_retention_period is None:
            raise TypeError("Missing 'offline_retention_period' argument")
        if online_retention_period is None and 'onlineRetentionPeriod' in kwargs:
            online_retention_period = kwargs['onlineRetentionPeriod']
        if online_retention_period is None:
            raise TypeError("Missing 'online_retention_period' argument")

        _setter("is_paid_usage", is_paid_usage)
        _setter("offline_retention_period", offline_retention_period)
        _setter("online_retention_period", online_retention_period)

    @property
    @pulumi.getter(name="isPaidUsage")
    def is_paid_usage(self) -> bool:
        """
        The paid usage option chosen by the customer admin.
        """
        return pulumi.get(self, "is_paid_usage")

    @property
    @pulumi.getter(name="offlineRetentionPeriod")
    def offline_retention_period(self) -> int:
        """
        The offline retention period in months.
        """
        return pulumi.get(self, "offline_retention_period")

    @property
    @pulumi.getter(name="onlineRetentionPeriod")
    def online_retention_period(self) -> int:
        """
        The online retention period in months.
        """
        return pulumi.get(self, "online_retention_period")


@pulumi.output_type
class GetDataSafePrivateEndpointsDataSafePrivateEndpointResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 endpoint_fqdn: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 nsg_ids: Sequence[str],
                 private_endpoint_id: str,
                 private_endpoint_ip: str,
                 state: str,
                 subnet_id: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 vcn_id: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the private endpoint.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param str endpoint_fqdn: The three-label fully qualified domain name (FQDN) of the private endpoint. The customer VCN's DNS records are updated with this FQDN.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the Data Safe private endpoint.
        :param Sequence[str] nsg_ids: The OCIDs of the network security groups that the private endpoint belongs to.
        :param str private_endpoint_id: The OCID of the underlying private endpoint.
        :param str private_endpoint_ip: The private IP address of the private endpoint.
        :param str state: A filter to return only resources that match the specified lifecycle state.
        :param str subnet_id: The OCID of the subnet.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the private endpoint was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str vcn_id: A filter to return only resources that match the specified VCN OCID.
        """
        GetDataSafePrivateEndpointsDataSafePrivateEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            endpoint_fqdn=endpoint_fqdn,
            freeform_tags=freeform_tags,
            id=id,
            nsg_ids=nsg_ids,
            private_endpoint_id=private_endpoint_id,
            private_endpoint_ip=private_endpoint_ip,
            state=state,
            subnet_id=subnet_id,
            system_tags=system_tags,
            time_created=time_created,
            vcn_id=vcn_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             endpoint_fqdn: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             nsg_ids: Optional[Sequence[str]] = None,
             private_endpoint_id: Optional[str] = None,
             private_endpoint_ip: Optional[str] = None,
             state: Optional[str] = None,
             subnet_id: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             vcn_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if endpoint_fqdn is None and 'endpointFqdn' in kwargs:
            endpoint_fqdn = kwargs['endpointFqdn']
        if endpoint_fqdn is None:
            raise TypeError("Missing 'endpoint_fqdn' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if nsg_ids is None and 'nsgIds' in kwargs:
            nsg_ids = kwargs['nsgIds']
        if nsg_ids is None:
            raise TypeError("Missing 'nsg_ids' argument")
        if private_endpoint_id is None and 'privateEndpointId' in kwargs:
            private_endpoint_id = kwargs['privateEndpointId']
        if private_endpoint_id is None:
            raise TypeError("Missing 'private_endpoint_id' argument")
        if private_endpoint_ip is None and 'privateEndpointIp' in kwargs:
            private_endpoint_ip = kwargs['privateEndpointIp']
        if private_endpoint_ip is None:
            raise TypeError("Missing 'private_endpoint_ip' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if vcn_id is None and 'vcnId' in kwargs:
            vcn_id = kwargs['vcnId']
        if vcn_id is None:
            raise TypeError("Missing 'vcn_id' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("endpoint_fqdn", endpoint_fqdn)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("nsg_ids", nsg_ids)
        _setter("private_endpoint_id", private_endpoint_id)
        _setter("private_endpoint_ip", private_endpoint_ip)
        _setter("state", state)
        _setter("subnet_id", subnet_id)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("vcn_id", vcn_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the private endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endpointFqdn")
    def endpoint_fqdn(self) -> str:
        """
        The three-label fully qualified domain name (FQDN) of the private endpoint. The customer VCN's DNS records are updated with this FQDN.
        """
        return pulumi.get(self, "endpoint_fqdn")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Data Safe private endpoint.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The OCIDs of the network security groups that the private endpoint belongs to.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> str:
        """
        The OCID of the underlying private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> str:
        """
        The private IP address of the private endpoint.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the private endpoint was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="vcnId")
    def vcn_id(self) -> str:
        """
        A filter to return only resources that match the specified VCN OCID.
        """
        return pulumi.get(self, "vcn_id")


@pulumi.output_type
class GetDataSafePrivateEndpointsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDataSafePrivateEndpointsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDiscoveryAnalyticItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetDiscoveryAnalyticItemDimensionResult'],
                 metric_name: str):
        """
        :param str count: The total count for the aggregation metric.
        :param Sequence['GetDiscoveryAnalyticItemDimensionArgs'] dimensions: The scope of analytics data.
        :param str metric_name: The name of the aggregation metric.
        """
        GetDiscoveryAnalyticItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
            metric_name=metric_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetDiscoveryAnalyticItemDimensionResult']] = None,
             metric_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)
        _setter("metric_name", metric_name)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        The total count for the aggregation metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetDiscoveryAnalyticItemDimensionResult']:
        """
        The scope of analytics data.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the aggregation metric.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class GetDiscoveryAnalyticItemDimensionResult(dict):
    def __init__(__self__, *,
                 sensitive_data_model_id: str,
                 target_id: str):
        """
        :param str sensitive_data_model_id: A filter to return only the resources that match the specified sensitive data model OCID.
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetDiscoveryAnalyticItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sensitive_data_model_id=sensitive_data_model_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sensitive_data_model_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if sensitive_data_model_id is None:
            raise TypeError("Missing 'sensitive_data_model_id' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("sensitive_data_model_id", sensitive_data_model_id)
        _setter("target_id", target_id)

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> str:
        """
        A filter to return only the resources that match the specified sensitive data model OCID.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemResult']):
        """
        :param Sequence['GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemArgs'] items: An array of discovery analytics summary objects.
        """
        GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemResult']:
        """
        An array of discovery analytics summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionResult'],
                 metric_name: str):
        """
        :param str count: The total count for the aggregation metric.
        :param Sequence['GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionArgs'] dimensions: The scope of analytics data.
        :param str metric_name: The name of the aggregation metric.
        """
        GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
            metric_name=metric_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionResult']] = None,
             metric_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)
        _setter("metric_name", metric_name)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        The total count for the aggregation metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionResult']:
        """
        The scope of analytics data.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the aggregation metric.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionResult(dict):
    def __init__(__self__, *,
                 sensitive_data_model_id: str,
                 target_id: str):
        """
        :param str sensitive_data_model_id: A filter to return only the resources that match the specified sensitive data model OCID.
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetDiscoveryAnalyticsDiscoveryAnalyticsCollectionItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sensitive_data_model_id=sensitive_data_model_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sensitive_data_model_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if sensitive_data_model_id is None:
            raise TypeError("Missing 'sensitive_data_model_id' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("sensitive_data_model_id", sensitive_data_model_id)
        _setter("target_id", target_id)

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> str:
        """
        A filter to return only the resources that match the specified sensitive data model OCID.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetDiscoveryAnalyticsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDiscoveryAnalyticsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDiscoveryJobsResultModifiedAttributeResult(dict):
    def __init__(__self__, *,
                 app_defined_child_column_keys: Sequence[str],
                 db_defined_child_column_keys: Sequence[str]):
        """
        :param Sequence[str] app_defined_child_column_keys: Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        :param Sequence[str] db_defined_child_column_keys: Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        GetDiscoveryJobsResultModifiedAttributeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_defined_child_column_keys=app_defined_child_column_keys,
            db_defined_child_column_keys=db_defined_child_column_keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_defined_child_column_keys: Optional[Sequence[str]] = None,
             db_defined_child_column_keys: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_defined_child_column_keys is None and 'appDefinedChildColumnKeys' in kwargs:
            app_defined_child_column_keys = kwargs['appDefinedChildColumnKeys']
        if app_defined_child_column_keys is None:
            raise TypeError("Missing 'app_defined_child_column_keys' argument")
        if db_defined_child_column_keys is None and 'dbDefinedChildColumnKeys' in kwargs:
            db_defined_child_column_keys = kwargs['dbDefinedChildColumnKeys']
        if db_defined_child_column_keys is None:
            raise TypeError("Missing 'db_defined_child_column_keys' argument")

        _setter("app_defined_child_column_keys", app_defined_child_column_keys)
        _setter("db_defined_child_column_keys", db_defined_child_column_keys)

    @property
    @pulumi.getter(name="appDefinedChildColumnKeys")
    def app_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        return pulumi.get(self, "app_defined_child_column_keys")

    @property
    @pulumi.getter(name="dbDefinedChildColumnKeys")
    def db_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        return pulumi.get(self, "db_defined_child_column_keys")


@pulumi.output_type
class GetDiscoveryJobsResultsDiscoveryJobResultCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemResult']):
        GetDiscoveryJobsResultsDiscoveryJobResultCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemResult(dict):
    def __init__(__self__, *,
                 app_defined_child_column_keys: Sequence[str],
                 app_name: str,
                 column_name: str,
                 data_type: str,
                 db_defined_child_column_keys: Sequence[str],
                 discovery_job_id: str,
                 discovery_type: str,
                 estimated_data_value_count: str,
                 is_result_applied: bool,
                 key: str,
                 modified_attributes: Sequence['outputs.GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeResult'],
                 object: str,
                 object_type: str,
                 parent_column_keys: Sequence[str],
                 planned_action: str,
                 relation_type: str,
                 sample_data_values: Sequence[str],
                 schema_name: str,
                 sensitive_columnkey: str,
                 sensitive_type_id: str):
        """
        :param Sequence[str] app_defined_child_column_keys: Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        :param str app_name: The name of the application. An application is an entity that is identified by a schema and stores sensitive information for that schema. Its value will be same as schemaName, if no value is passed.
        :param str column_name: A filter to return only a specific column based on column name.
        :param str data_type: The data type of the sensitive column.
        :param Sequence[str] db_defined_child_column_keys: Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        :param str discovery_job_id: The OCID of the discovery job.
        :param str discovery_type: A filter to return only the resources that match the specified discovery type.
        :param str estimated_data_value_count: The estimated number of data values the column has in the associated database.
        :param bool is_result_applied: A filter to return the discovery result resources based on the value of their isResultApplied attribute.
        :param str key: The unique key that identifies the discovery result.
        :param Sequence['GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeArgs'] modified_attributes: The attributes of a sensitive column that have been modified in the target database. It's populated only in the case of MODIFIED discovery results and shows the new values of the modified attributes.
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: The type of the database object that contains the sensitive column.
        :param Sequence[str] parent_column_keys: Unique keys identifying the columns that are parents of the sensitive column. At present, it tracks a single parent only.
        :param str planned_action: A filter to return only the resources that match the specified planned action.
        :param str relation_type: The type of referential relationship the sensitive column has with its parent. NONE indicates that the sensitive column does not have a parent. DB_DEFINED indicates that the relationship is defined in the database dictionary. APP_DEFINED indicates that the relationship is defined at the application level and not in the database dictionary.
        :param Sequence[str] sample_data_values: Original data values collected for the sensitive column from the associated database. Sample data helps review the column and ensure that it actually contains sensitive data. Note that sample data is retrieved by a data discovery job only if the isSampleDataCollectionEnabled attribute is set to true. At present, only one data value is collected per sensitive column.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sensitive_columnkey: The unique key that identifies the sensitive column represented by the discovery result.
        :param str sensitive_type_id: The OCID of the sensitive type associated with the sensitive column.
        """
        GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_defined_child_column_keys=app_defined_child_column_keys,
            app_name=app_name,
            column_name=column_name,
            data_type=data_type,
            db_defined_child_column_keys=db_defined_child_column_keys,
            discovery_job_id=discovery_job_id,
            discovery_type=discovery_type,
            estimated_data_value_count=estimated_data_value_count,
            is_result_applied=is_result_applied,
            key=key,
            modified_attributes=modified_attributes,
            object=object,
            object_type=object_type,
            parent_column_keys=parent_column_keys,
            planned_action=planned_action,
            relation_type=relation_type,
            sample_data_values=sample_data_values,
            schema_name=schema_name,
            sensitive_columnkey=sensitive_columnkey,
            sensitive_type_id=sensitive_type_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_defined_child_column_keys: Optional[Sequence[str]] = None,
             app_name: Optional[str] = None,
             column_name: Optional[str] = None,
             data_type: Optional[str] = None,
             db_defined_child_column_keys: Optional[Sequence[str]] = None,
             discovery_job_id: Optional[str] = None,
             discovery_type: Optional[str] = None,
             estimated_data_value_count: Optional[str] = None,
             is_result_applied: Optional[bool] = None,
             key: Optional[str] = None,
             modified_attributes: Optional[Sequence['outputs.GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeResult']] = None,
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             parent_column_keys: Optional[Sequence[str]] = None,
             planned_action: Optional[str] = None,
             relation_type: Optional[str] = None,
             sample_data_values: Optional[Sequence[str]] = None,
             schema_name: Optional[str] = None,
             sensitive_columnkey: Optional[str] = None,
             sensitive_type_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_defined_child_column_keys is None and 'appDefinedChildColumnKeys' in kwargs:
            app_defined_child_column_keys = kwargs['appDefinedChildColumnKeys']
        if app_defined_child_column_keys is None:
            raise TypeError("Missing 'app_defined_child_column_keys' argument")
        if app_name is None and 'appName' in kwargs:
            app_name = kwargs['appName']
        if app_name is None:
            raise TypeError("Missing 'app_name' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if db_defined_child_column_keys is None and 'dbDefinedChildColumnKeys' in kwargs:
            db_defined_child_column_keys = kwargs['dbDefinedChildColumnKeys']
        if db_defined_child_column_keys is None:
            raise TypeError("Missing 'db_defined_child_column_keys' argument")
        if discovery_job_id is None and 'discoveryJobId' in kwargs:
            discovery_job_id = kwargs['discoveryJobId']
        if discovery_job_id is None:
            raise TypeError("Missing 'discovery_job_id' argument")
        if discovery_type is None and 'discoveryType' in kwargs:
            discovery_type = kwargs['discoveryType']
        if discovery_type is None:
            raise TypeError("Missing 'discovery_type' argument")
        if estimated_data_value_count is None and 'estimatedDataValueCount' in kwargs:
            estimated_data_value_count = kwargs['estimatedDataValueCount']
        if estimated_data_value_count is None:
            raise TypeError("Missing 'estimated_data_value_count' argument")
        if is_result_applied is None and 'isResultApplied' in kwargs:
            is_result_applied = kwargs['isResultApplied']
        if is_result_applied is None:
            raise TypeError("Missing 'is_result_applied' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if modified_attributes is None and 'modifiedAttributes' in kwargs:
            modified_attributes = kwargs['modifiedAttributes']
        if modified_attributes is None:
            raise TypeError("Missing 'modified_attributes' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if parent_column_keys is None and 'parentColumnKeys' in kwargs:
            parent_column_keys = kwargs['parentColumnKeys']
        if parent_column_keys is None:
            raise TypeError("Missing 'parent_column_keys' argument")
        if planned_action is None and 'plannedAction' in kwargs:
            planned_action = kwargs['plannedAction']
        if planned_action is None:
            raise TypeError("Missing 'planned_action' argument")
        if relation_type is None and 'relationType' in kwargs:
            relation_type = kwargs['relationType']
        if relation_type is None:
            raise TypeError("Missing 'relation_type' argument")
        if sample_data_values is None and 'sampleDataValues' in kwargs:
            sample_data_values = kwargs['sampleDataValues']
        if sample_data_values is None:
            raise TypeError("Missing 'sample_data_values' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sensitive_columnkey is None and 'sensitiveColumnkey' in kwargs:
            sensitive_columnkey = kwargs['sensitiveColumnkey']
        if sensitive_columnkey is None:
            raise TypeError("Missing 'sensitive_columnkey' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")

        _setter("app_defined_child_column_keys", app_defined_child_column_keys)
        _setter("app_name", app_name)
        _setter("column_name", column_name)
        _setter("data_type", data_type)
        _setter("db_defined_child_column_keys", db_defined_child_column_keys)
        _setter("discovery_job_id", discovery_job_id)
        _setter("discovery_type", discovery_type)
        _setter("estimated_data_value_count", estimated_data_value_count)
        _setter("is_result_applied", is_result_applied)
        _setter("key", key)
        _setter("modified_attributes", modified_attributes)
        _setter("object", object)
        _setter("object_type", object_type)
        _setter("parent_column_keys", parent_column_keys)
        _setter("planned_action", planned_action)
        _setter("relation_type", relation_type)
        _setter("sample_data_values", sample_data_values)
        _setter("schema_name", schema_name)
        _setter("sensitive_columnkey", sensitive_columnkey)
        _setter("sensitive_type_id", sensitive_type_id)

    @property
    @pulumi.getter(name="appDefinedChildColumnKeys")
    def app_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        return pulumi.get(self, "app_defined_child_column_keys")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> str:
        """
        The name of the application. An application is an entity that is identified by a schema and stores sensitive information for that schema. Its value will be same as schemaName, if no value is passed.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        The data type of the sensitive column.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dbDefinedChildColumnKeys")
    def db_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        return pulumi.get(self, "db_defined_child_column_keys")

    @property
    @pulumi.getter(name="discoveryJobId")
    def discovery_job_id(self) -> str:
        """
        The OCID of the discovery job.
        """
        warnings.warn("""The 'oci_data_safe_discovery_jobs_result' resource has been deprecated. It is no longer supported.""", DeprecationWarning)
        pulumi.log.warn("""discovery_job_id is deprecated: The 'oci_data_safe_discovery_jobs_result' resource has been deprecated. It is no longer supported.""")

        return pulumi.get(self, "discovery_job_id")

    @property
    @pulumi.getter(name="discoveryType")
    def discovery_type(self) -> str:
        """
        A filter to return only the resources that match the specified discovery type.
        """
        warnings.warn("""The 'oci_data_safe_discovery_jobs_result' resource has been deprecated. It is no longer supported.""", DeprecationWarning)
        pulumi.log.warn("""discovery_type is deprecated: The 'oci_data_safe_discovery_jobs_result' resource has been deprecated. It is no longer supported.""")

        return pulumi.get(self, "discovery_type")

    @property
    @pulumi.getter(name="estimatedDataValueCount")
    def estimated_data_value_count(self) -> str:
        """
        The estimated number of data values the column has in the associated database.
        """
        return pulumi.get(self, "estimated_data_value_count")

    @property
    @pulumi.getter(name="isResultApplied")
    def is_result_applied(self) -> bool:
        """
        A filter to return the discovery result resources based on the value of their isResultApplied attribute.
        """
        return pulumi.get(self, "is_result_applied")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key that identifies the discovery result.
        """
        warnings.warn("""The 'oci_data_safe_discovery_jobs_result' resource has been deprecated. It is no longer supported.""", DeprecationWarning)
        pulumi.log.warn("""key is deprecated: The 'oci_data_safe_discovery_jobs_result' resource has been deprecated. It is no longer supported.""")

        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="modifiedAttributes")
    def modified_attributes(self) -> Sequence['outputs.GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeResult']:
        """
        The attributes of a sensitive column that have been modified in the target database. It's populated only in the case of MODIFIED discovery results and shows the new values of the modified attributes.
        """
        return pulumi.get(self, "modified_attributes")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        The type of the database object that contains the sensitive column.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="parentColumnKeys")
    def parent_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are parents of the sensitive column. At present, it tracks a single parent only.
        """
        return pulumi.get(self, "parent_column_keys")

    @property
    @pulumi.getter(name="plannedAction")
    def planned_action(self) -> str:
        """
        A filter to return only the resources that match the specified planned action.
        """
        return pulumi.get(self, "planned_action")

    @property
    @pulumi.getter(name="relationType")
    def relation_type(self) -> str:
        """
        The type of referential relationship the sensitive column has with its parent. NONE indicates that the sensitive column does not have a parent. DB_DEFINED indicates that the relationship is defined in the database dictionary. APP_DEFINED indicates that the relationship is defined at the application level and not in the database dictionary.
        """
        return pulumi.get(self, "relation_type")

    @property
    @pulumi.getter(name="sampleDataValues")
    def sample_data_values(self) -> Sequence[str]:
        """
        Original data values collected for the sensitive column from the associated database. Sample data helps review the column and ensure that it actually contains sensitive data. Note that sample data is retrieved by a data discovery job only if the isSampleDataCollectionEnabled attribute is set to true. At present, only one data value is collected per sensitive column.
        """
        return pulumi.get(self, "sample_data_values")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sensitiveColumnkey")
    def sensitive_columnkey(self) -> str:
        """
        The unique key that identifies the sensitive column represented by the discovery result.
        """
        return pulumi.get(self, "sensitive_columnkey")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        The OCID of the sensitive type associated with the sensitive column.
        """
        return pulumi.get(self, "sensitive_type_id")


@pulumi.output_type
class GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeResult(dict):
    def __init__(__self__, *,
                 app_defined_child_column_keys: Sequence[str],
                 db_defined_child_column_keys: Sequence[str]):
        """
        :param Sequence[str] app_defined_child_column_keys: Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        :param Sequence[str] db_defined_child_column_keys: Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        GetDiscoveryJobsResultsDiscoveryJobResultCollectionItemModifiedAttributeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_defined_child_column_keys=app_defined_child_column_keys,
            db_defined_child_column_keys=db_defined_child_column_keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_defined_child_column_keys: Optional[Sequence[str]] = None,
             db_defined_child_column_keys: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_defined_child_column_keys is None and 'appDefinedChildColumnKeys' in kwargs:
            app_defined_child_column_keys = kwargs['appDefinedChildColumnKeys']
        if app_defined_child_column_keys is None:
            raise TypeError("Missing 'app_defined_child_column_keys' argument")
        if db_defined_child_column_keys is None and 'dbDefinedChildColumnKeys' in kwargs:
            db_defined_child_column_keys = kwargs['dbDefinedChildColumnKeys']
        if db_defined_child_column_keys is None:
            raise TypeError("Missing 'db_defined_child_column_keys' argument")

        _setter("app_defined_child_column_keys", app_defined_child_column_keys)
        _setter("db_defined_child_column_keys", db_defined_child_column_keys)

    @property
    @pulumi.getter(name="appDefinedChildColumnKeys")
    def app_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        return pulumi.get(self, "app_defined_child_column_keys")

    @property
    @pulumi.getter(name="dbDefinedChildColumnKeys")
    def db_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        return pulumi.get(self, "db_defined_child_column_keys")


@pulumi.output_type
class GetDiscoveryJobsResultsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDiscoveryJobsResultsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLibraryMaskingFormatFormatEntryResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 description: str,
                 end_date: str,
                 end_length: int,
                 end_value: float,
                 fixed_number: float,
                 fixed_string: str,
                 grouping_columns: Sequence[str],
                 length: int,
                 library_masking_format_id: str,
                 post_processing_function: str,
                 random_lists: Sequence[str],
                 regular_expression: str,
                 replace_with: str,
                 schema_name: str,
                 sql_expression: str,
                 start_date: str,
                 start_length: int,
                 start_position: int,
                 start_value: float,
                 table_name: str,
                 type: str,
                 user_defined_function: str):
        """
        :param str column_name: The name of the substitution column.
        :param str description: The description of the format entry.
        :param str end_date: The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param int end_length: The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param float end_value: The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param float fixed_number: The constant number to be used for masking.
        :param str fixed_string: The constant string to be used for masking.
        :param Sequence[str] grouping_columns: One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param int length: The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param str library_masking_format_id: The OCID of the library masking format.
        :param str post_processing_function: The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param Sequence[str] random_lists: A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param str regular_expression: The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        :param str replace_with: The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        :param str schema_name: The name of the schema that contains the substitution column.
        :param str sql_expression: The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param str start_date: The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param int start_length: The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param int start_position: The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param float start_value: The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param str table_name: The name of the table that contains the substitution column.
        :param str type: The type of the format entry.
        :param str user_defined_function: The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        GetLibraryMaskingFormatFormatEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            description=description,
            end_date=end_date,
            end_length=end_length,
            end_value=end_value,
            fixed_number=fixed_number,
            fixed_string=fixed_string,
            grouping_columns=grouping_columns,
            length=length,
            library_masking_format_id=library_masking_format_id,
            post_processing_function=post_processing_function,
            random_lists=random_lists,
            regular_expression=regular_expression,
            replace_with=replace_with,
            schema_name=schema_name,
            sql_expression=sql_expression,
            start_date=start_date,
            start_length=start_length,
            start_position=start_position,
            start_value=start_value,
            table_name=table_name,
            type=type,
            user_defined_function=user_defined_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             description: Optional[str] = None,
             end_date: Optional[str] = None,
             end_length: Optional[int] = None,
             end_value: Optional[float] = None,
             fixed_number: Optional[float] = None,
             fixed_string: Optional[str] = None,
             grouping_columns: Optional[Sequence[str]] = None,
             length: Optional[int] = None,
             library_masking_format_id: Optional[str] = None,
             post_processing_function: Optional[str] = None,
             random_lists: Optional[Sequence[str]] = None,
             regular_expression: Optional[str] = None,
             replace_with: Optional[str] = None,
             schema_name: Optional[str] = None,
             sql_expression: Optional[str] = None,
             start_date: Optional[str] = None,
             start_length: Optional[int] = None,
             start_position: Optional[int] = None,
             start_value: Optional[float] = None,
             table_name: Optional[str] = None,
             type: Optional[str] = None,
             user_defined_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_date is None:
            raise TypeError("Missing 'end_date' argument")
        if end_length is None and 'endLength' in kwargs:
            end_length = kwargs['endLength']
        if end_length is None:
            raise TypeError("Missing 'end_length' argument")
        if end_value is None and 'endValue' in kwargs:
            end_value = kwargs['endValue']
        if end_value is None:
            raise TypeError("Missing 'end_value' argument")
        if fixed_number is None and 'fixedNumber' in kwargs:
            fixed_number = kwargs['fixedNumber']
        if fixed_number is None:
            raise TypeError("Missing 'fixed_number' argument")
        if fixed_string is None and 'fixedString' in kwargs:
            fixed_string = kwargs['fixedString']
        if fixed_string is None:
            raise TypeError("Missing 'fixed_string' argument")
        if grouping_columns is None and 'groupingColumns' in kwargs:
            grouping_columns = kwargs['groupingColumns']
        if grouping_columns is None:
            raise TypeError("Missing 'grouping_columns' argument")
        if length is None:
            raise TypeError("Missing 'length' argument")
        if library_masking_format_id is None and 'libraryMaskingFormatId' in kwargs:
            library_masking_format_id = kwargs['libraryMaskingFormatId']
        if library_masking_format_id is None:
            raise TypeError("Missing 'library_masking_format_id' argument")
        if post_processing_function is None and 'postProcessingFunction' in kwargs:
            post_processing_function = kwargs['postProcessingFunction']
        if post_processing_function is None:
            raise TypeError("Missing 'post_processing_function' argument")
        if random_lists is None and 'randomLists' in kwargs:
            random_lists = kwargs['randomLists']
        if random_lists is None:
            raise TypeError("Missing 'random_lists' argument")
        if regular_expression is None and 'regularExpression' in kwargs:
            regular_expression = kwargs['regularExpression']
        if regular_expression is None:
            raise TypeError("Missing 'regular_expression' argument")
        if replace_with is None and 'replaceWith' in kwargs:
            replace_with = kwargs['replaceWith']
        if replace_with is None:
            raise TypeError("Missing 'replace_with' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sql_expression is None and 'sqlExpression' in kwargs:
            sql_expression = kwargs['sqlExpression']
        if sql_expression is None:
            raise TypeError("Missing 'sql_expression' argument")
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_date is None:
            raise TypeError("Missing 'start_date' argument")
        if start_length is None and 'startLength' in kwargs:
            start_length = kwargs['startLength']
        if start_length is None:
            raise TypeError("Missing 'start_length' argument")
        if start_position is None and 'startPosition' in kwargs:
            start_position = kwargs['startPosition']
        if start_position is None:
            raise TypeError("Missing 'start_position' argument")
        if start_value is None and 'startValue' in kwargs:
            start_value = kwargs['startValue']
        if start_value is None:
            raise TypeError("Missing 'start_value' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_defined_function is None and 'userDefinedFunction' in kwargs:
            user_defined_function = kwargs['userDefinedFunction']
        if user_defined_function is None:
            raise TypeError("Missing 'user_defined_function' argument")

        _setter("column_name", column_name)
        _setter("description", description)
        _setter("end_date", end_date)
        _setter("end_length", end_length)
        _setter("end_value", end_value)
        _setter("fixed_number", fixed_number)
        _setter("fixed_string", fixed_string)
        _setter("grouping_columns", grouping_columns)
        _setter("length", length)
        _setter("library_masking_format_id", library_masking_format_id)
        _setter("post_processing_function", post_processing_function)
        _setter("random_lists", random_lists)
        _setter("regular_expression", regular_expression)
        _setter("replace_with", replace_with)
        _setter("schema_name", schema_name)
        _setter("sql_expression", sql_expression)
        _setter("start_date", start_date)
        _setter("start_length", start_length)
        _setter("start_position", start_position)
        _setter("start_value", start_value)
        _setter("table_name", table_name)
        _setter("type", type)
        _setter("user_defined_function", user_defined_function)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endLength")
    def end_length(self) -> int:
        """
        The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @property
    @pulumi.getter(name="endValue")
    def end_value(self) -> float:
        """
        The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> float:
        """
        The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> str:
        """
        The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Sequence[str]:
        """
        One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> str:
        """
        The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> str:
        """
        The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Sequence[str]:
        """
        A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> str:
        """
        The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> str:
        """
        The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        """
        return pulumi.get(self, "replace_with")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        The name of the schema that contains the substitution column.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> str:
        """
        The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startLength")
    def start_length(self) -> int:
        """
        The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> int:
        """
        The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> float:
        """
        The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the format entry.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> str:
        """
        The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")


@pulumi.output_type
class GetLibraryMaskingFormatsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetLibraryMaskingFormatsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLibraryMaskingFormatsLibraryMaskingFormatCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemResult']):
        GetLibraryMaskingFormatsLibraryMaskingFormatCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 format_entries: Sequence['outputs.GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryResult'],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 sensitive_type_ids: Sequence[str],
                 source: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the format entry.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Sequence['GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryArgs'] format_entries: An array of format entries. The combined output of all the format entries is used for masking.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the library masking format.
        :param Sequence[str] sensitive_type_ids: An array of OCIDs of the sensitive types compatible with the library masking format.
        :param str source: Specifies whether the library masking format is user-defined or predefined.
        :param str state: A filter to return only the resources that match the specified lifecycle states.
        :param str time_created: The date and time the library masking format was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        :param str time_updated: The date and time the library masking format was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            format_entries=format_entries,
            freeform_tags=freeform_tags,
            id=id,
            sensitive_type_ids=sensitive_type_ids,
            source=source,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             format_entries: Optional[Sequence['outputs.GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryResult']] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             sensitive_type_ids: Optional[Sequence[str]] = None,
             source: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if format_entries is None and 'formatEntries' in kwargs:
            format_entries = kwargs['formatEntries']
        if format_entries is None:
            raise TypeError("Missing 'format_entries' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if sensitive_type_ids is None and 'sensitiveTypeIds' in kwargs:
            sensitive_type_ids = kwargs['sensitiveTypeIds']
        if sensitive_type_ids is None:
            raise TypeError("Missing 'sensitive_type_ids' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("format_entries", format_entries)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("sensitive_type_ids", sensitive_type_ids)
        _setter("source", source)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="formatEntries")
    def format_entries(self) -> Sequence['outputs.GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryResult']:
        """
        An array of format entries. The combined output of all the format entries is used for masking.
        """
        return pulumi.get(self, "format_entries")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the library masking format.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sensitiveTypeIds")
    def sensitive_type_ids(self) -> Sequence[str]:
        """
        An array of OCIDs of the sensitive types compatible with the library masking format.
        """
        return pulumi.get(self, "sensitive_type_ids")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Specifies whether the library masking format is user-defined or predefined.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only the resources that match the specified lifecycle states.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the library masking format was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the library masking format was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 description: str,
                 end_date: str,
                 end_length: int,
                 end_value: float,
                 fixed_number: float,
                 fixed_string: str,
                 grouping_columns: Sequence[str],
                 length: int,
                 library_masking_format_id: str,
                 post_processing_function: str,
                 random_lists: Sequence[str],
                 regular_expression: str,
                 replace_with: str,
                 schema_name: str,
                 sql_expression: str,
                 start_date: str,
                 start_length: int,
                 start_position: int,
                 start_value: float,
                 table_name: str,
                 type: str,
                 user_defined_function: str):
        """
        :param str column_name: The name of the substitution column.
        :param str description: The description of the format entry.
        :param str end_date: The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param int end_length: The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param float end_value: The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param float fixed_number: The constant number to be used for masking.
        :param str fixed_string: The constant string to be used for masking.
        :param Sequence[str] grouping_columns: One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param int length: The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param str library_masking_format_id: A filter to return only the resources that match the specified library masking format OCID.
        :param str post_processing_function: The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param Sequence[str] random_lists: A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param str regular_expression: The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        :param str replace_with: The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        :param str schema_name: The name of the schema that contains the substitution column.
        :param str sql_expression: The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param str start_date: The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param int start_length: The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param int start_position: The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param float start_value: The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param str table_name: The name of the table that contains the substitution column.
        :param str type: The type of the format entry.
        :param str user_defined_function: The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        GetLibraryMaskingFormatsLibraryMaskingFormatCollectionItemFormatEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            description=description,
            end_date=end_date,
            end_length=end_length,
            end_value=end_value,
            fixed_number=fixed_number,
            fixed_string=fixed_string,
            grouping_columns=grouping_columns,
            length=length,
            library_masking_format_id=library_masking_format_id,
            post_processing_function=post_processing_function,
            random_lists=random_lists,
            regular_expression=regular_expression,
            replace_with=replace_with,
            schema_name=schema_name,
            sql_expression=sql_expression,
            start_date=start_date,
            start_length=start_length,
            start_position=start_position,
            start_value=start_value,
            table_name=table_name,
            type=type,
            user_defined_function=user_defined_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             description: Optional[str] = None,
             end_date: Optional[str] = None,
             end_length: Optional[int] = None,
             end_value: Optional[float] = None,
             fixed_number: Optional[float] = None,
             fixed_string: Optional[str] = None,
             grouping_columns: Optional[Sequence[str]] = None,
             length: Optional[int] = None,
             library_masking_format_id: Optional[str] = None,
             post_processing_function: Optional[str] = None,
             random_lists: Optional[Sequence[str]] = None,
             regular_expression: Optional[str] = None,
             replace_with: Optional[str] = None,
             schema_name: Optional[str] = None,
             sql_expression: Optional[str] = None,
             start_date: Optional[str] = None,
             start_length: Optional[int] = None,
             start_position: Optional[int] = None,
             start_value: Optional[float] = None,
             table_name: Optional[str] = None,
             type: Optional[str] = None,
             user_defined_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_date is None:
            raise TypeError("Missing 'end_date' argument")
        if end_length is None and 'endLength' in kwargs:
            end_length = kwargs['endLength']
        if end_length is None:
            raise TypeError("Missing 'end_length' argument")
        if end_value is None and 'endValue' in kwargs:
            end_value = kwargs['endValue']
        if end_value is None:
            raise TypeError("Missing 'end_value' argument")
        if fixed_number is None and 'fixedNumber' in kwargs:
            fixed_number = kwargs['fixedNumber']
        if fixed_number is None:
            raise TypeError("Missing 'fixed_number' argument")
        if fixed_string is None and 'fixedString' in kwargs:
            fixed_string = kwargs['fixedString']
        if fixed_string is None:
            raise TypeError("Missing 'fixed_string' argument")
        if grouping_columns is None and 'groupingColumns' in kwargs:
            grouping_columns = kwargs['groupingColumns']
        if grouping_columns is None:
            raise TypeError("Missing 'grouping_columns' argument")
        if length is None:
            raise TypeError("Missing 'length' argument")
        if library_masking_format_id is None and 'libraryMaskingFormatId' in kwargs:
            library_masking_format_id = kwargs['libraryMaskingFormatId']
        if library_masking_format_id is None:
            raise TypeError("Missing 'library_masking_format_id' argument")
        if post_processing_function is None and 'postProcessingFunction' in kwargs:
            post_processing_function = kwargs['postProcessingFunction']
        if post_processing_function is None:
            raise TypeError("Missing 'post_processing_function' argument")
        if random_lists is None and 'randomLists' in kwargs:
            random_lists = kwargs['randomLists']
        if random_lists is None:
            raise TypeError("Missing 'random_lists' argument")
        if regular_expression is None and 'regularExpression' in kwargs:
            regular_expression = kwargs['regularExpression']
        if regular_expression is None:
            raise TypeError("Missing 'regular_expression' argument")
        if replace_with is None and 'replaceWith' in kwargs:
            replace_with = kwargs['replaceWith']
        if replace_with is None:
            raise TypeError("Missing 'replace_with' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sql_expression is None and 'sqlExpression' in kwargs:
            sql_expression = kwargs['sqlExpression']
        if sql_expression is None:
            raise TypeError("Missing 'sql_expression' argument")
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_date is None:
            raise TypeError("Missing 'start_date' argument")
        if start_length is None and 'startLength' in kwargs:
            start_length = kwargs['startLength']
        if start_length is None:
            raise TypeError("Missing 'start_length' argument")
        if start_position is None and 'startPosition' in kwargs:
            start_position = kwargs['startPosition']
        if start_position is None:
            raise TypeError("Missing 'start_position' argument")
        if start_value is None and 'startValue' in kwargs:
            start_value = kwargs['startValue']
        if start_value is None:
            raise TypeError("Missing 'start_value' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_defined_function is None and 'userDefinedFunction' in kwargs:
            user_defined_function = kwargs['userDefinedFunction']
        if user_defined_function is None:
            raise TypeError("Missing 'user_defined_function' argument")

        _setter("column_name", column_name)
        _setter("description", description)
        _setter("end_date", end_date)
        _setter("end_length", end_length)
        _setter("end_value", end_value)
        _setter("fixed_number", fixed_number)
        _setter("fixed_string", fixed_string)
        _setter("grouping_columns", grouping_columns)
        _setter("length", length)
        _setter("library_masking_format_id", library_masking_format_id)
        _setter("post_processing_function", post_processing_function)
        _setter("random_lists", random_lists)
        _setter("regular_expression", regular_expression)
        _setter("replace_with", replace_with)
        _setter("schema_name", schema_name)
        _setter("sql_expression", sql_expression)
        _setter("start_date", start_date)
        _setter("start_length", start_length)
        _setter("start_position", start_position)
        _setter("start_value", start_value)
        _setter("table_name", table_name)
        _setter("type", type)
        _setter("user_defined_function", user_defined_function)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endLength")
    def end_length(self) -> int:
        """
        The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @property
    @pulumi.getter(name="endValue")
    def end_value(self) -> float:
        """
        The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> float:
        """
        The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> str:
        """
        The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Sequence[str]:
        """
        One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> str:
        """
        A filter to return only the resources that match the specified library masking format OCID.
        """
        return pulumi.get(self, "library_masking_format_id")

    @property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> str:
        """
        The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Sequence[str]:
        """
        A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> str:
        """
        The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> str:
        """
        The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        """
        return pulumi.get(self, "replace_with")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        The name of the schema that contains the substitution column.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> str:
        """
        The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startLength")
    def start_length(self) -> int:
        """
        The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> int:
        """
        The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> float:
        """
        The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the format entry.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> str:
        """
        The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")


@pulumi.output_type
class GetListUserGrantsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetListUserGrantsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetListUserGrantsGrantResult(dict):
    def __init__(__self__, *,
                 depth_level: int,
                 grant_name: str,
                 key: str,
                 privilege_category: str,
                 privilege_type: str):
        """
        :param int depth_level: A filter to return only items that match the specified user grant depth level.
        :param str grant_name: A filter to return only items that match the specified user grant name.
        :param str key: The unique key of a user grant.
        :param str privilege_category: A filter to return only items that match the specified user privilege category.
        :param str privilege_type: A filter to return only items that match the specified privilege grant type.
        """
        GetListUserGrantsGrantResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            depth_level=depth_level,
            grant_name=grant_name,
            key=key,
            privilege_category=privilege_category,
            privilege_type=privilege_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             depth_level: Optional[int] = None,
             grant_name: Optional[str] = None,
             key: Optional[str] = None,
             privilege_category: Optional[str] = None,
             privilege_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if depth_level is None and 'depthLevel' in kwargs:
            depth_level = kwargs['depthLevel']
        if depth_level is None:
            raise TypeError("Missing 'depth_level' argument")
        if grant_name is None and 'grantName' in kwargs:
            grant_name = kwargs['grantName']
        if grant_name is None:
            raise TypeError("Missing 'grant_name' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if privilege_category is None and 'privilegeCategory' in kwargs:
            privilege_category = kwargs['privilegeCategory']
        if privilege_category is None:
            raise TypeError("Missing 'privilege_category' argument")
        if privilege_type is None and 'privilegeType' in kwargs:
            privilege_type = kwargs['privilegeType']
        if privilege_type is None:
            raise TypeError("Missing 'privilege_type' argument")

        _setter("depth_level", depth_level)
        _setter("grant_name", grant_name)
        _setter("key", key)
        _setter("privilege_category", privilege_category)
        _setter("privilege_type", privilege_type)

    @property
    @pulumi.getter(name="depthLevel")
    def depth_level(self) -> int:
        """
        A filter to return only items that match the specified user grant depth level.
        """
        return pulumi.get(self, "depth_level")

    @property
    @pulumi.getter(name="grantName")
    def grant_name(self) -> str:
        """
        A filter to return only items that match the specified user grant name.
        """
        return pulumi.get(self, "grant_name")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key of a user grant.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="privilegeCategory")
    def privilege_category(self) -> str:
        """
        A filter to return only items that match the specified user privilege category.
        """
        return pulumi.get(self, "privilege_category")

    @property
    @pulumi.getter(name="privilegeType")
    def privilege_type(self) -> str:
        """
        A filter to return only items that match the specified privilege grant type.
        """
        return pulumi.get(self, "privilege_type")


@pulumi.output_type
class GetMaskingAnalyticItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetMaskingAnalyticItemDimensionResult'],
                 metric_name: str):
        """
        :param str count: The total count for the aggregation metric.
        :param Sequence['GetMaskingAnalyticItemDimensionArgs'] dimensions: The scope of analytics data.
        :param str metric_name: The name of the aggregation metric.
        """
        GetMaskingAnalyticItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
            metric_name=metric_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetMaskingAnalyticItemDimensionResult']] = None,
             metric_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)
        _setter("metric_name", metric_name)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        The total count for the aggregation metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetMaskingAnalyticItemDimensionResult']:
        """
        The scope of analytics data.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the aggregation metric.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class GetMaskingAnalyticItemDimensionResult(dict):
    def __init__(__self__, *,
                 policy_id: str,
                 target_id: str):
        """
        :param str policy_id: The OCID of the masking policy..
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetMaskingAnalyticItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_id=policy_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if policy_id is None:
            raise TypeError("Missing 'policy_id' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("policy_id", policy_id)
        _setter("target_id", target_id)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        The OCID of the masking policy..
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetMaskingAnalyticsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingAnalyticsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingAnalyticsMaskingAnalyticsCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingAnalyticsMaskingAnalyticsCollectionItemResult']):
        """
        :param Sequence['GetMaskingAnalyticsMaskingAnalyticsCollectionItemArgs'] items: An array of masking analytics summary objects.
        """
        GetMaskingAnalyticsMaskingAnalyticsCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingAnalyticsMaskingAnalyticsCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingAnalyticsMaskingAnalyticsCollectionItemResult']:
        """
        An array of masking analytics summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingAnalyticsMaskingAnalyticsCollectionItemResult(dict):
    def __init__(__self__, *,
                 count: str,
                 dimensions: Sequence['outputs.GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionResult'],
                 metric_name: str):
        """
        :param str count: The total count for the aggregation metric.
        :param Sequence['GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionArgs'] dimensions: The scope of analytics data.
        :param str metric_name: The name of the aggregation metric.
        """
        GetMaskingAnalyticsMaskingAnalyticsCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            dimensions=dimensions,
            metric_name=metric_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[str] = None,
             dimensions: Optional[Sequence['outputs.GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionResult']] = None,
             metric_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")

        _setter("count", count)
        _setter("dimensions", dimensions)
        _setter("metric_name", metric_name)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        The total count for the aggregation metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionResult']:
        """
        The scope of analytics data.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the aggregation metric.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionResult(dict):
    def __init__(__self__, *,
                 policy_id: str,
                 target_id: str):
        """
        :param str policy_id: The OCID of the masking policy..
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetMaskingAnalyticsMaskingAnalyticsCollectionItemDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_id=policy_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if policy_id is None:
            raise TypeError("Missing 'policy_id' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("policy_id", policy_id)
        _setter("target_id", target_id)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        The OCID of the masking policy..
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetMaskingPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingPoliciesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnMaskingFormatResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 description: str,
                 format_entries: Sequence['outputs.GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryResult']):
        """
        :param str condition: A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        :param str description: The description of the format entry.
        :param Sequence['GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryArgs'] format_entries: An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        GetMaskingPoliciesMaskingColumnMaskingFormatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            description=description,
            format_entries=format_entries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             description: Optional[str] = None,
             format_entries: Optional[Sequence['outputs.GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition is None:
            raise TypeError("Missing 'condition' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if format_entries is None and 'formatEntries' in kwargs:
            format_entries = kwargs['formatEntries']
        if format_entries is None:
            raise TypeError("Missing 'format_entries' argument")

        _setter("condition", condition)
        _setter("description", description)
        _setter("format_entries", format_entries)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="formatEntries")
    def format_entries(self) -> Sequence['outputs.GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryResult']:
        """
        An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        return pulumi.get(self, "format_entries")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 description: str,
                 end_date: str,
                 end_length: int,
                 end_value: float,
                 fixed_number: float,
                 fixed_string: str,
                 grouping_columns: Sequence[str],
                 length: int,
                 library_masking_format_id: str,
                 post_processing_function: str,
                 random_lists: Sequence[str],
                 regular_expression: str,
                 replace_with: str,
                 schema_name: str,
                 sql_expression: str,
                 start_date: str,
                 start_length: int,
                 start_position: int,
                 start_value: float,
                 table_name: str,
                 type: str,
                 user_defined_function: str):
        """
        :param str column_name: The name of the substitution column.
        :param str description: The description of the format entry.
        :param str end_date: The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param int end_length: The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param float end_value: The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param float fixed_number: The constant number to be used for masking.
        :param str fixed_string: The constant string to be used for masking.
        :param Sequence[str] grouping_columns: One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param int length: The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param str library_masking_format_id: The OCID of the library masking format.
        :param str post_processing_function: The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param Sequence[str] random_lists: A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param str regular_expression: The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        :param str replace_with: The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        :param str schema_name: The name of the schema that contains the database column.
        :param str sql_expression: The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param str start_date: The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param int start_length: The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param int start_position: The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param float start_value: The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param str table_name: The name of the table that contains the substitution column.
        :param str type: The type of the format entry.
        :param str user_defined_function: The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            description=description,
            end_date=end_date,
            end_length=end_length,
            end_value=end_value,
            fixed_number=fixed_number,
            fixed_string=fixed_string,
            grouping_columns=grouping_columns,
            length=length,
            library_masking_format_id=library_masking_format_id,
            post_processing_function=post_processing_function,
            random_lists=random_lists,
            regular_expression=regular_expression,
            replace_with=replace_with,
            schema_name=schema_name,
            sql_expression=sql_expression,
            start_date=start_date,
            start_length=start_length,
            start_position=start_position,
            start_value=start_value,
            table_name=table_name,
            type=type,
            user_defined_function=user_defined_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             description: Optional[str] = None,
             end_date: Optional[str] = None,
             end_length: Optional[int] = None,
             end_value: Optional[float] = None,
             fixed_number: Optional[float] = None,
             fixed_string: Optional[str] = None,
             grouping_columns: Optional[Sequence[str]] = None,
             length: Optional[int] = None,
             library_masking_format_id: Optional[str] = None,
             post_processing_function: Optional[str] = None,
             random_lists: Optional[Sequence[str]] = None,
             regular_expression: Optional[str] = None,
             replace_with: Optional[str] = None,
             schema_name: Optional[str] = None,
             sql_expression: Optional[str] = None,
             start_date: Optional[str] = None,
             start_length: Optional[int] = None,
             start_position: Optional[int] = None,
             start_value: Optional[float] = None,
             table_name: Optional[str] = None,
             type: Optional[str] = None,
             user_defined_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_date is None:
            raise TypeError("Missing 'end_date' argument")
        if end_length is None and 'endLength' in kwargs:
            end_length = kwargs['endLength']
        if end_length is None:
            raise TypeError("Missing 'end_length' argument")
        if end_value is None and 'endValue' in kwargs:
            end_value = kwargs['endValue']
        if end_value is None:
            raise TypeError("Missing 'end_value' argument")
        if fixed_number is None and 'fixedNumber' in kwargs:
            fixed_number = kwargs['fixedNumber']
        if fixed_number is None:
            raise TypeError("Missing 'fixed_number' argument")
        if fixed_string is None and 'fixedString' in kwargs:
            fixed_string = kwargs['fixedString']
        if fixed_string is None:
            raise TypeError("Missing 'fixed_string' argument")
        if grouping_columns is None and 'groupingColumns' in kwargs:
            grouping_columns = kwargs['groupingColumns']
        if grouping_columns is None:
            raise TypeError("Missing 'grouping_columns' argument")
        if length is None:
            raise TypeError("Missing 'length' argument")
        if library_masking_format_id is None and 'libraryMaskingFormatId' in kwargs:
            library_masking_format_id = kwargs['libraryMaskingFormatId']
        if library_masking_format_id is None:
            raise TypeError("Missing 'library_masking_format_id' argument")
        if post_processing_function is None and 'postProcessingFunction' in kwargs:
            post_processing_function = kwargs['postProcessingFunction']
        if post_processing_function is None:
            raise TypeError("Missing 'post_processing_function' argument")
        if random_lists is None and 'randomLists' in kwargs:
            random_lists = kwargs['randomLists']
        if random_lists is None:
            raise TypeError("Missing 'random_lists' argument")
        if regular_expression is None and 'regularExpression' in kwargs:
            regular_expression = kwargs['regularExpression']
        if regular_expression is None:
            raise TypeError("Missing 'regular_expression' argument")
        if replace_with is None and 'replaceWith' in kwargs:
            replace_with = kwargs['replaceWith']
        if replace_with is None:
            raise TypeError("Missing 'replace_with' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sql_expression is None and 'sqlExpression' in kwargs:
            sql_expression = kwargs['sqlExpression']
        if sql_expression is None:
            raise TypeError("Missing 'sql_expression' argument")
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_date is None:
            raise TypeError("Missing 'start_date' argument")
        if start_length is None and 'startLength' in kwargs:
            start_length = kwargs['startLength']
        if start_length is None:
            raise TypeError("Missing 'start_length' argument")
        if start_position is None and 'startPosition' in kwargs:
            start_position = kwargs['startPosition']
        if start_position is None:
            raise TypeError("Missing 'start_position' argument")
        if start_value is None and 'startValue' in kwargs:
            start_value = kwargs['startValue']
        if start_value is None:
            raise TypeError("Missing 'start_value' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_defined_function is None and 'userDefinedFunction' in kwargs:
            user_defined_function = kwargs['userDefinedFunction']
        if user_defined_function is None:
            raise TypeError("Missing 'user_defined_function' argument")

        _setter("column_name", column_name)
        _setter("description", description)
        _setter("end_date", end_date)
        _setter("end_length", end_length)
        _setter("end_value", end_value)
        _setter("fixed_number", fixed_number)
        _setter("fixed_string", fixed_string)
        _setter("grouping_columns", grouping_columns)
        _setter("length", length)
        _setter("library_masking_format_id", library_masking_format_id)
        _setter("post_processing_function", post_processing_function)
        _setter("random_lists", random_lists)
        _setter("regular_expression", regular_expression)
        _setter("replace_with", replace_with)
        _setter("schema_name", schema_name)
        _setter("sql_expression", sql_expression)
        _setter("start_date", start_date)
        _setter("start_length", start_length)
        _setter("start_position", start_position)
        _setter("start_value", start_value)
        _setter("table_name", table_name)
        _setter("type", type)
        _setter("user_defined_function", user_defined_function)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        The name of the substitution column.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endLength")
    def end_length(self) -> int:
        """
        The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @property
    @pulumi.getter(name="endValue")
    def end_value(self) -> float:
        """
        The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> float:
        """
        The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> str:
        """
        The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Sequence[str]:
        """
        One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> str:
        """
        The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> str:
        """
        The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Sequence[str]:
        """
        A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> str:
        """
        The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> str:
        """
        The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        """
        return pulumi.get(self, "replace_with")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        The name of the schema that contains the database column.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> str:
        """
        The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startLength")
    def start_length(self) -> int:
        """
        The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> int:
        """
        The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> float:
        """
        The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the format entry.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> str:
        """
        The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingPoliciesMaskingColumnsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemResult']):
        GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemResult(dict):
    def __init__(__self__, *,
                 child_columns: Sequence[str],
                 column_name: str,
                 data_type: str,
                 is_masking_enabled: bool,
                 key: str,
                 lifecycle_details: str,
                 masking_column_group: str,
                 masking_formats: Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatResult'],
                 masking_policy_id: str,
                 object: str,
                 object_type: str,
                 schema_name: str,
                 sensitive_type_id: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence[str] child_columns: An array of child columns that are in referential relationship with the masking column.
        :param str column_name: A filter to return only a specific column based on column name.
        :param str data_type: A filter to return only resources that match the specified data types.
        :param bool is_masking_enabled: A filter to return the masking column resources based on the value of their isMaskingEnabled attribute. A value of true returns only those columns for which masking is enabled. A value of false returns only those columns for which masking is disabled. Omitting this parameter returns all the masking columns in a masking policy.
        :param str key: The unique key that identifies the masking column. It's numeric and unique within a masking policy.
        :param str lifecycle_details: Details about the current state of the masking column.
        :param str masking_column_group: A filter to return only the resources that match the specified masking column group.
        :param Sequence['GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatArgs'] masking_formats: An array of masking formats assigned to the masking column.
        :param str masking_policy_id: The OCID of the masking policy.
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: A filter to return only items related to a specific object type.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sensitive_type_id: A filter to return only items related to a specific sensitive type OCID.
        :param str state: The current state of the masking column.
        :param str time_created: The date and time the masking column was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: The date and time the masking column was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            child_columns=child_columns,
            column_name=column_name,
            data_type=data_type,
            is_masking_enabled=is_masking_enabled,
            key=key,
            lifecycle_details=lifecycle_details,
            masking_column_group=masking_column_group,
            masking_formats=masking_formats,
            masking_policy_id=masking_policy_id,
            object=object,
            object_type=object_type,
            schema_name=schema_name,
            sensitive_type_id=sensitive_type_id,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             child_columns: Optional[Sequence[str]] = None,
             column_name: Optional[str] = None,
             data_type: Optional[str] = None,
             is_masking_enabled: Optional[bool] = None,
             key: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             masking_column_group: Optional[str] = None,
             masking_formats: Optional[Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatResult']] = None,
             masking_policy_id: Optional[str] = None,
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             schema_name: Optional[str] = None,
             sensitive_type_id: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if child_columns is None and 'childColumns' in kwargs:
            child_columns = kwargs['childColumns']
        if child_columns is None:
            raise TypeError("Missing 'child_columns' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if is_masking_enabled is None and 'isMaskingEnabled' in kwargs:
            is_masking_enabled = kwargs['isMaskingEnabled']
        if is_masking_enabled is None:
            raise TypeError("Missing 'is_masking_enabled' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if masking_column_group is None and 'maskingColumnGroup' in kwargs:
            masking_column_group = kwargs['maskingColumnGroup']
        if masking_column_group is None:
            raise TypeError("Missing 'masking_column_group' argument")
        if masking_formats is None and 'maskingFormats' in kwargs:
            masking_formats = kwargs['maskingFormats']
        if masking_formats is None:
            raise TypeError("Missing 'masking_formats' argument")
        if masking_policy_id is None and 'maskingPolicyId' in kwargs:
            masking_policy_id = kwargs['maskingPolicyId']
        if masking_policy_id is None:
            raise TypeError("Missing 'masking_policy_id' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("child_columns", child_columns)
        _setter("column_name", column_name)
        _setter("data_type", data_type)
        _setter("is_masking_enabled", is_masking_enabled)
        _setter("key", key)
        _setter("lifecycle_details", lifecycle_details)
        _setter("masking_column_group", masking_column_group)
        _setter("masking_formats", masking_formats)
        _setter("masking_policy_id", masking_policy_id)
        _setter("object", object)
        _setter("object_type", object_type)
        _setter("schema_name", schema_name)
        _setter("sensitive_type_id", sensitive_type_id)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="childColumns")
    def child_columns(self) -> Sequence[str]:
        """
        An array of child columns that are in referential relationship with the masking column.
        """
        return pulumi.get(self, "child_columns")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        A filter to return only resources that match the specified data types.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="isMaskingEnabled")
    def is_masking_enabled(self) -> bool:
        """
        A filter to return the masking column resources based on the value of their isMaskingEnabled attribute. A value of true returns only those columns for which masking is enabled. A value of false returns only those columns for which masking is disabled. Omitting this parameter returns all the masking columns in a masking policy.
        """
        return pulumi.get(self, "is_masking_enabled")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key that identifies the masking column. It's numeric and unique within a masking policy.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the masking column.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maskingColumnGroup")
    def masking_column_group(self) -> str:
        """
        A filter to return only the resources that match the specified masking column group.
        """
        return pulumi.get(self, "masking_column_group")

    @property
    @pulumi.getter(name="maskingFormats")
    def masking_formats(self) -> Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatResult']:
        """
        An array of masking formats assigned to the masking column.
        """
        return pulumi.get(self, "masking_formats")

    @property
    @pulumi.getter(name="maskingPolicyId")
    def masking_policy_id(self) -> str:
        """
        The OCID of the masking policy.
        """
        return pulumi.get(self, "masking_policy_id")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        A filter to return only items related to a specific object type.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        A filter to return only items related to a specific sensitive type OCID.
        """
        return pulumi.get(self, "sensitive_type_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the masking column.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the masking column was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the masking column was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 description: str,
                 format_entries: Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryResult']):
        """
        :param str condition: A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        :param str description: The description of the format entry.
        :param Sequence['GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryArgs'] format_entries: An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            description=description,
            format_entries=format_entries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             description: Optional[str] = None,
             format_entries: Optional[Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition is None:
            raise TypeError("Missing 'condition' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if format_entries is None and 'formatEntries' in kwargs:
            format_entries = kwargs['formatEntries']
        if format_entries is None:
            raise TypeError("Missing 'format_entries' argument")

        _setter("condition", condition)
        _setter("description", description)
        _setter("format_entries", format_entries)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  <a href="https://docs.oracle.com/en/cloud/paas/data-safe/udscs/conditional-masking.html">conditional masking</a>  so that you can mask the column data values differently using different masking  formats and the associated conditions.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="formatEntries")
    def format_entries(self) -> Sequence['outputs.GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryResult']:
        """
        An array of format entries. The combined output of all the format entries is  used for masking the column data values.
        """
        return pulumi.get(self, "format_entries")


@pulumi.output_type
class GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 description: str,
                 end_date: str,
                 end_length: int,
                 end_value: float,
                 fixed_number: float,
                 fixed_string: str,
                 grouping_columns: Sequence[str],
                 length: int,
                 library_masking_format_id: str,
                 post_processing_function: str,
                 random_lists: Sequence[str],
                 regular_expression: str,
                 replace_with: str,
                 schema_name: str,
                 sql_expression: str,
                 start_date: str,
                 start_length: int,
                 start_position: int,
                 start_value: float,
                 table_name: str,
                 type: str,
                 user_defined_function: str):
        """
        :param str column_name: A filter to return only a specific column based on column name.
        :param str description: The description of the format entry.
        :param str end_date: The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        :param int end_length: The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        :param float end_value: The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        :param float fixed_number: The constant number to be used for masking.
        :param str fixed_string: The constant string to be used for masking.
        :param Sequence[str] grouping_columns: One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        :param int length: The number of characters that should be there in the substring. It should be an integer and greater than zero.
        :param str library_masking_format_id: The OCID of the library masking format.
        :param str post_processing_function: The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        :param Sequence[str] random_lists: A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        :param str regular_expression: The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        :param str replace_with: The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sql_expression: The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        :param str start_date: The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        :param int start_length: The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        :param int start_position: The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        :param float start_value: The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        :param str table_name: The name of the table that contains the substitution column.
        :param str type: The type of the format entry.
        :param str user_defined_function: The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        GetMaskingPoliciesMaskingColumnsMaskingColumnCollectionItemMaskingFormatFormatEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            description=description,
            end_date=end_date,
            end_length=end_length,
            end_value=end_value,
            fixed_number=fixed_number,
            fixed_string=fixed_string,
            grouping_columns=grouping_columns,
            length=length,
            library_masking_format_id=library_masking_format_id,
            post_processing_function=post_processing_function,
            random_lists=random_lists,
            regular_expression=regular_expression,
            replace_with=replace_with,
            schema_name=schema_name,
            sql_expression=sql_expression,
            start_date=start_date,
            start_length=start_length,
            start_position=start_position,
            start_value=start_value,
            table_name=table_name,
            type=type,
            user_defined_function=user_defined_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             description: Optional[str] = None,
             end_date: Optional[str] = None,
             end_length: Optional[int] = None,
             end_value: Optional[float] = None,
             fixed_number: Optional[float] = None,
             fixed_string: Optional[str] = None,
             grouping_columns: Optional[Sequence[str]] = None,
             length: Optional[int] = None,
             library_masking_format_id: Optional[str] = None,
             post_processing_function: Optional[str] = None,
             random_lists: Optional[Sequence[str]] = None,
             regular_expression: Optional[str] = None,
             replace_with: Optional[str] = None,
             schema_name: Optional[str] = None,
             sql_expression: Optional[str] = None,
             start_date: Optional[str] = None,
             start_length: Optional[int] = None,
             start_position: Optional[int] = None,
             start_value: Optional[float] = None,
             table_name: Optional[str] = None,
             type: Optional[str] = None,
             user_defined_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_date is None:
            raise TypeError("Missing 'end_date' argument")
        if end_length is None and 'endLength' in kwargs:
            end_length = kwargs['endLength']
        if end_length is None:
            raise TypeError("Missing 'end_length' argument")
        if end_value is None and 'endValue' in kwargs:
            end_value = kwargs['endValue']
        if end_value is None:
            raise TypeError("Missing 'end_value' argument")
        if fixed_number is None and 'fixedNumber' in kwargs:
            fixed_number = kwargs['fixedNumber']
        if fixed_number is None:
            raise TypeError("Missing 'fixed_number' argument")
        if fixed_string is None and 'fixedString' in kwargs:
            fixed_string = kwargs['fixedString']
        if fixed_string is None:
            raise TypeError("Missing 'fixed_string' argument")
        if grouping_columns is None and 'groupingColumns' in kwargs:
            grouping_columns = kwargs['groupingColumns']
        if grouping_columns is None:
            raise TypeError("Missing 'grouping_columns' argument")
        if length is None:
            raise TypeError("Missing 'length' argument")
        if library_masking_format_id is None and 'libraryMaskingFormatId' in kwargs:
            library_masking_format_id = kwargs['libraryMaskingFormatId']
        if library_masking_format_id is None:
            raise TypeError("Missing 'library_masking_format_id' argument")
        if post_processing_function is None and 'postProcessingFunction' in kwargs:
            post_processing_function = kwargs['postProcessingFunction']
        if post_processing_function is None:
            raise TypeError("Missing 'post_processing_function' argument")
        if random_lists is None and 'randomLists' in kwargs:
            random_lists = kwargs['randomLists']
        if random_lists is None:
            raise TypeError("Missing 'random_lists' argument")
        if regular_expression is None and 'regularExpression' in kwargs:
            regular_expression = kwargs['regularExpression']
        if regular_expression is None:
            raise TypeError("Missing 'regular_expression' argument")
        if replace_with is None and 'replaceWith' in kwargs:
            replace_with = kwargs['replaceWith']
        if replace_with is None:
            raise TypeError("Missing 'replace_with' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sql_expression is None and 'sqlExpression' in kwargs:
            sql_expression = kwargs['sqlExpression']
        if sql_expression is None:
            raise TypeError("Missing 'sql_expression' argument")
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_date is None:
            raise TypeError("Missing 'start_date' argument")
        if start_length is None and 'startLength' in kwargs:
            start_length = kwargs['startLength']
        if start_length is None:
            raise TypeError("Missing 'start_length' argument")
        if start_position is None and 'startPosition' in kwargs:
            start_position = kwargs['startPosition']
        if start_position is None:
            raise TypeError("Missing 'start_position' argument")
        if start_value is None and 'startValue' in kwargs:
            start_value = kwargs['startValue']
        if start_value is None:
            raise TypeError("Missing 'start_value' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_defined_function is None and 'userDefinedFunction' in kwargs:
            user_defined_function = kwargs['userDefinedFunction']
        if user_defined_function is None:
            raise TypeError("Missing 'user_defined_function' argument")

        _setter("column_name", column_name)
        _setter("description", description)
        _setter("end_date", end_date)
        _setter("end_length", end_length)
        _setter("end_value", end_value)
        _setter("fixed_number", fixed_number)
        _setter("fixed_string", fixed_string)
        _setter("grouping_columns", grouping_columns)
        _setter("length", length)
        _setter("library_masking_format_id", library_masking_format_id)
        _setter("post_processing_function", post_processing_function)
        _setter("random_lists", random_lists)
        _setter("regular_expression", regular_expression)
        _setter("replace_with", replace_with)
        _setter("schema_name", schema_name)
        _setter("sql_expression", sql_expression)
        _setter("start_date", start_date)
        _setter("start_length", start_length)
        _setter("start_position", start_position)
        _setter("start_value", start_value)
        _setter("table_name", table_name)
        _setter("type", type)
        _setter("user_defined_function", user_defined_function)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the format entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endLength")
    def end_length(self) -> int:
        """
        The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
        """
        return pulumi.get(self, "end_length")

    @property
    @pulumi.getter(name="endValue")
    def end_value(self) -> float:
        """
        The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
        """
        return pulumi.get(self, "end_value")

    @property
    @pulumi.getter(name="fixedNumber")
    def fixed_number(self) -> float:
        """
        The constant number to be used for masking.
        """
        return pulumi.get(self, "fixed_number")

    @property
    @pulumi.getter(name="fixedString")
    def fixed_string(self) -> str:
        """
        The constant string to be used for masking.
        """
        return pulumi.get(self, "fixed_string")

    @property
    @pulumi.getter(name="groupingColumns")
    def grouping_columns(self) -> Sequence[str]:
        """
        One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
        """
        return pulumi.get(self, "grouping_columns")

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        The number of characters that should be there in the substring. It should be an integer and greater than zero.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="libraryMaskingFormatId")
    def library_masking_format_id(self) -> str:
        """
        The OCID of the library masking format.
        """
        return pulumi.get(self, "library_masking_format_id")

    @property
    @pulumi.getter(name="postProcessingFunction")
    def post_processing_function(self) -> str:
        """
        The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "post_processing_function")

    @property
    @pulumi.getter(name="randomLists")
    def random_lists(self) -> Sequence[str]:
        """
        A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
        """
        return pulumi.get(self, "random_lists")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> str:
        """
        The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> str:
        """
        The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
        """
        return pulumi.get(self, "replace_with")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> str:
        """
        The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
        """
        return pulumi.get(self, "sql_expression")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startLength")
    def start_length(self) -> int:
        """
        The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
        """
        return pulumi.get(self, "start_length")

    @property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> int:
        """
        The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
        """
        return pulumi.get(self, "start_position")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> float:
        """
        The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
        """
        return pulumi.get(self, "start_value")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the table that contains the substitution column.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the format entry.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userDefinedFunction")
    def user_defined_function(self) -> str:
        """
        The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
        """
        return pulumi.get(self, "user_defined_function")


@pulumi.output_type
class GetMaskingPoliciesMaskingPolicyCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingPoliciesMaskingPolicyCollectionItemResult']):
        GetMaskingPoliciesMaskingPolicyCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingPoliciesMaskingPolicyCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingPoliciesMaskingPolicyCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingPoliciesMaskingPolicyCollectionItemResult(dict):
    def __init__(__self__, *,
                 add_masking_columns_from_sdm_trigger: int,
                 column_sources: Sequence['outputs.GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceResult'],
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_drop_temp_tables_enabled: bool,
                 is_redo_logging_enabled: bool,
                 is_refresh_stats_enabled: bool,
                 parallel_degree: str,
                 post_masking_script: str,
                 pre_masking_script: str,
                 recompile: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence['GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceArgs'] column_sources: The source of masking columns.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the masking policy.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the masking policy.
        :param bool is_drop_temp_tables_enabled: Indicates if the temporary tables created during a masking operation should be dropped after masking. It's enabled by default. Set this attribute to false to preserve the temporary tables. Masking creates temporary tables that map the original sensitive  data values to mask values. By default, these temporary tables are dropped after masking. But, in some cases, you may want  to preserve this information to track how masking changed your data. Note that doing so compromises security. These tables  must be dropped before the database is available for unprivileged users.
        :param bool is_redo_logging_enabled: Indicates if redo logging is enabled during a masking operation. It's disabled by default. Set this attribute to true to enable redo logging. By default, masking disables redo logging and flashback logging to purge any original unmasked  data from logs. However, in certain circumstances when you only want to test masking, rollback changes, and retry masking, you could enable logging and use a flashback database to retrieve the original unmasked data after it has been masked.
        :param bool is_refresh_stats_enabled: Indicates if statistics gathering is enabled. It's enabled by default. Set this attribute to false to disable statistics gathering. The masking process gathers statistics on masked database tables after masking completes.
        :param str parallel_degree: Specifies options to enable parallel execution when running data masking. Allowed values are 'NONE' (no parallelism), 'DEFAULT' (the Oracle Database computes the optimum degree of parallelism) or an integer value to be used as the degree of parallelism. Parallel execution helps effectively use multiple CPUs and improve masking performance. Refer to the Oracle Database parallel execution framework when choosing an explicit degree of parallelism.
        :param str post_masking_script: A post-masking script, which can contain SQL and PL/SQL statements. It's executed after the core masking script generated using the masking policy. It's usually used to perform additional transformation or cleanup work after masking.
        :param str pre_masking_script: A pre-masking script, which can contain SQL and PL/SQL statements. It's executed before  the core masking script generated using the masking policy. It's usually used to perform any preparation or prerequisite work before masking data.
        :param str recompile: Specifies how to recompile invalid objects post data masking. Allowed values are 'SERIAL' (recompile in serial),  'PARALLEL' (recompile in parallel), 'NONE' (do not recompile). If it's set to PARALLEL, the value of parallelDegree attribute is used. Note that few objects may remain invalid even after recompiling once and you may have to further recompile manually using UTL_RECOMP package.
        :param str state: A filter to return only the resources that match the specified lifecycle states.
        :param str time_created: The date and time the masking policy was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: The date and time the masking policy was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        GetMaskingPoliciesMaskingPolicyCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add_masking_columns_from_sdm_trigger=add_masking_columns_from_sdm_trigger,
            column_sources=column_sources,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_drop_temp_tables_enabled=is_drop_temp_tables_enabled,
            is_redo_logging_enabled=is_redo_logging_enabled,
            is_refresh_stats_enabled=is_refresh_stats_enabled,
            parallel_degree=parallel_degree,
            post_masking_script=post_masking_script,
            pre_masking_script=pre_masking_script,
            recompile=recompile,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add_masking_columns_from_sdm_trigger: Optional[int] = None,
             column_sources: Optional[Sequence['outputs.GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceResult']] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_drop_temp_tables_enabled: Optional[bool] = None,
             is_redo_logging_enabled: Optional[bool] = None,
             is_refresh_stats_enabled: Optional[bool] = None,
             parallel_degree: Optional[str] = None,
             post_masking_script: Optional[str] = None,
             pre_masking_script: Optional[str] = None,
             recompile: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if add_masking_columns_from_sdm_trigger is None and 'addMaskingColumnsFromSdmTrigger' in kwargs:
            add_masking_columns_from_sdm_trigger = kwargs['addMaskingColumnsFromSdmTrigger']
        if add_masking_columns_from_sdm_trigger is None:
            raise TypeError("Missing 'add_masking_columns_from_sdm_trigger' argument")
        if column_sources is None and 'columnSources' in kwargs:
            column_sources = kwargs['columnSources']
        if column_sources is None:
            raise TypeError("Missing 'column_sources' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_drop_temp_tables_enabled is None and 'isDropTempTablesEnabled' in kwargs:
            is_drop_temp_tables_enabled = kwargs['isDropTempTablesEnabled']
        if is_drop_temp_tables_enabled is None:
            raise TypeError("Missing 'is_drop_temp_tables_enabled' argument")
        if is_redo_logging_enabled is None and 'isRedoLoggingEnabled' in kwargs:
            is_redo_logging_enabled = kwargs['isRedoLoggingEnabled']
        if is_redo_logging_enabled is None:
            raise TypeError("Missing 'is_redo_logging_enabled' argument")
        if is_refresh_stats_enabled is None and 'isRefreshStatsEnabled' in kwargs:
            is_refresh_stats_enabled = kwargs['isRefreshStatsEnabled']
        if is_refresh_stats_enabled is None:
            raise TypeError("Missing 'is_refresh_stats_enabled' argument")
        if parallel_degree is None and 'parallelDegree' in kwargs:
            parallel_degree = kwargs['parallelDegree']
        if parallel_degree is None:
            raise TypeError("Missing 'parallel_degree' argument")
        if post_masking_script is None and 'postMaskingScript' in kwargs:
            post_masking_script = kwargs['postMaskingScript']
        if post_masking_script is None:
            raise TypeError("Missing 'post_masking_script' argument")
        if pre_masking_script is None and 'preMaskingScript' in kwargs:
            pre_masking_script = kwargs['preMaskingScript']
        if pre_masking_script is None:
            raise TypeError("Missing 'pre_masking_script' argument")
        if recompile is None:
            raise TypeError("Missing 'recompile' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("add_masking_columns_from_sdm_trigger", add_masking_columns_from_sdm_trigger)
        _setter("column_sources", column_sources)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_drop_temp_tables_enabled", is_drop_temp_tables_enabled)
        _setter("is_redo_logging_enabled", is_redo_logging_enabled)
        _setter("is_refresh_stats_enabled", is_refresh_stats_enabled)
        _setter("parallel_degree", parallel_degree)
        _setter("post_masking_script", post_masking_script)
        _setter("pre_masking_script", pre_masking_script)
        _setter("recompile", recompile)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="addMaskingColumnsFromSdmTrigger")
    def add_masking_columns_from_sdm_trigger(self) -> int:
        return pulumi.get(self, "add_masking_columns_from_sdm_trigger")

    @property
    @pulumi.getter(name="columnSources")
    def column_sources(self) -> Sequence['outputs.GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceResult']:
        """
        The source of masking columns.
        """
        return pulumi.get(self, "column_sources")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the masking policy.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the masking policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDropTempTablesEnabled")
    def is_drop_temp_tables_enabled(self) -> bool:
        """
        Indicates if the temporary tables created during a masking operation should be dropped after masking. It's enabled by default. Set this attribute to false to preserve the temporary tables. Masking creates temporary tables that map the original sensitive  data values to mask values. By default, these temporary tables are dropped after masking. But, in some cases, you may want  to preserve this information to track how masking changed your data. Note that doing so compromises security. These tables  must be dropped before the database is available for unprivileged users.
        """
        return pulumi.get(self, "is_drop_temp_tables_enabled")

    @property
    @pulumi.getter(name="isRedoLoggingEnabled")
    def is_redo_logging_enabled(self) -> bool:
        """
        Indicates if redo logging is enabled during a masking operation. It's disabled by default. Set this attribute to true to enable redo logging. By default, masking disables redo logging and flashback logging to purge any original unmasked  data from logs. However, in certain circumstances when you only want to test masking, rollback changes, and retry masking, you could enable logging and use a flashback database to retrieve the original unmasked data after it has been masked.
        """
        return pulumi.get(self, "is_redo_logging_enabled")

    @property
    @pulumi.getter(name="isRefreshStatsEnabled")
    def is_refresh_stats_enabled(self) -> bool:
        """
        Indicates if statistics gathering is enabled. It's enabled by default. Set this attribute to false to disable statistics gathering. The masking process gathers statistics on masked database tables after masking completes.
        """
        return pulumi.get(self, "is_refresh_stats_enabled")

    @property
    @pulumi.getter(name="parallelDegree")
    def parallel_degree(self) -> str:
        """
        Specifies options to enable parallel execution when running data masking. Allowed values are 'NONE' (no parallelism), 'DEFAULT' (the Oracle Database computes the optimum degree of parallelism) or an integer value to be used as the degree of parallelism. Parallel execution helps effectively use multiple CPUs and improve masking performance. Refer to the Oracle Database parallel execution framework when choosing an explicit degree of parallelism.
        """
        return pulumi.get(self, "parallel_degree")

    @property
    @pulumi.getter(name="postMaskingScript")
    def post_masking_script(self) -> str:
        """
        A post-masking script, which can contain SQL and PL/SQL statements. It's executed after the core masking script generated using the masking policy. It's usually used to perform additional transformation or cleanup work after masking.
        """
        return pulumi.get(self, "post_masking_script")

    @property
    @pulumi.getter(name="preMaskingScript")
    def pre_masking_script(self) -> str:
        """
        A pre-masking script, which can contain SQL and PL/SQL statements. It's executed before  the core masking script generated using the masking policy. It's usually used to perform any preparation or prerequisite work before masking data.
        """
        return pulumi.get(self, "pre_masking_script")

    @property
    @pulumi.getter
    def recompile(self) -> str:
        """
        Specifies how to recompile invalid objects post data masking. Allowed values are 'SERIAL' (recompile in serial),  'PARALLEL' (recompile in parallel), 'NONE' (do not recompile). If it's set to PARALLEL, the value of parallelDegree attribute is used. Note that few objects may remain invalid even after recompiling once and you may have to further recompile manually using UTL_RECOMP package.
        """
        return pulumi.get(self, "recompile")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only the resources that match the specified lifecycle states.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the masking policy was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the masking policy was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceResult(dict):
    def __init__(__self__, *,
                 column_source: str,
                 sensitive_data_model_id: str,
                 target_id: str):
        """
        :param str column_source: The source of masking columns.
        :param str sensitive_data_model_id: A filter to return only the resources that match the specified sensitive data model OCID.
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetMaskingPoliciesMaskingPolicyCollectionItemColumnSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_source=column_source,
            sensitive_data_model_id=sensitive_data_model_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_source: Optional[str] = None,
             sensitive_data_model_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_source is None and 'columnSource' in kwargs:
            column_source = kwargs['columnSource']
        if column_source is None:
            raise TypeError("Missing 'column_source' argument")
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if sensitive_data_model_id is None:
            raise TypeError("Missing 'sensitive_data_model_id' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("column_source", column_source)
        _setter("sensitive_data_model_id", sensitive_data_model_id)
        _setter("target_id", target_id)

    @property
    @pulumi.getter(name="columnSource")
    def column_source(self) -> str:
        """
        The source of masking columns.
        """
        return pulumi.get(self, "column_source")

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> str:
        """
        A filter to return only the resources that match the specified sensitive data model OCID.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetMaskingPolicyColumnSourceResult(dict):
    def __init__(__self__, *,
                 column_source: str,
                 sensitive_data_model_id: str,
                 target_id: str):
        """
        :param str column_source: The source of masking columns.
        :param str sensitive_data_model_id: The OCID of the sensitive data model that's used as the source of masking columns.
        :param str target_id: The OCID of the target database that's used as the source of masking columns.
        """
        GetMaskingPolicyColumnSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_source=column_source,
            sensitive_data_model_id=sensitive_data_model_id,
            target_id=target_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_source: Optional[str] = None,
             sensitive_data_model_id: Optional[str] = None,
             target_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_source is None and 'columnSource' in kwargs:
            column_source = kwargs['columnSource']
        if column_source is None:
            raise TypeError("Missing 'column_source' argument")
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if sensitive_data_model_id is None:
            raise TypeError("Missing 'sensitive_data_model_id' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")

        _setter("column_source", column_source)
        _setter("sensitive_data_model_id", sensitive_data_model_id)
        _setter("target_id", target_id)

    @property
    @pulumi.getter(name="columnSource")
    def column_source(self) -> str:
        """
        The source of masking columns.
        """
        return pulumi.get(self, "column_source")

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> str:
        """
        The OCID of the sensitive data model that's used as the source of masking columns.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The OCID of the target database that's used as the source of masking columns.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class GetMaskingPolicyMaskingObjectsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingPolicyMaskingObjectsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingPolicyMaskingObjectsMaskingObjectCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemResult']):
        """
        :param Sequence['GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemArgs'] items: An array of masking object summary objects.
        """
        GetMaskingPolicyMaskingObjectsMaskingObjectCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemResult']:
        """
        An array of masking object summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemResult(dict):
    def __init__(__self__, *,
                 object: str,
                 object_type: str,
                 schema_name: str):
        """
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: A filter to return only items related to a specific object type.
        :param str schema_name: A filter to return only items related to specific schema name.
        """
        GetMaskingPolicyMaskingObjectsMaskingObjectCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            object_type=object_type,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")

        _setter("object", object)
        _setter("object_type", object_type)
        _setter("schema_name", schema_name)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        A filter to return only items related to a specific object type.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetMaskingPolicyMaskingSchemasFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingPolicyMaskingSchemasFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemResult']):
        """
        :param Sequence['GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemArgs'] items: An array of masking schema summary objects.
        """
        GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemResult']:
        """
        An array of masking schema summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemResult(dict):
    def __init__(__self__, *,
                 schema_name: str):
        """
        :param str schema_name: A filter to return only items related to specific schema name.
        """
        GetMaskingPolicyMaskingSchemasMaskingSchemaCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")

        _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetMaskingReportMaskedColumnsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingReportMaskedColumnsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingReportMaskedColumnsMaskedColumnCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingReportMaskedColumnsMaskedColumnCollectionItemResult']):
        """
        :param Sequence['GetMaskingReportMaskedColumnsMaskedColumnCollectionItemArgs'] items: An array of masking column summary objects.
        """
        GetMaskingReportMaskedColumnsMaskedColumnCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingReportMaskedColumnsMaskedColumnCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingReportMaskedColumnsMaskedColumnCollectionItemResult']:
        """
        An array of masking column summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingReportMaskedColumnsMaskedColumnCollectionItemResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 key: str,
                 masking_column_group: str,
                 masking_format_used: str,
                 object: str,
                 object_type: str,
                 parent_column_key: str,
                 schema_name: str,
                 sensitive_type_id: str,
                 total_masked_values: str):
        """
        :param str column_name: A filter to return only a specific column based on column name.
        :param str key: The unique key that identifies the masked column. It's numeric and unique within a masking policy.
        :param str masking_column_group: A filter to return only the resources that match the specified masking column group.
        :param str masking_format_used: The masking format used for masking the column.
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: A filter to return only items related to a specific object type.
        :param str parent_column_key: The unique key that identifies the parent column of the masked column.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sensitive_type_id: A filter to return only items related to a specific sensitive type OCID.
        :param str total_masked_values: The total number of values masked in the column.
        """
        GetMaskingReportMaskedColumnsMaskedColumnCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            key=key,
            masking_column_group=masking_column_group,
            masking_format_used=masking_format_used,
            object=object,
            object_type=object_type,
            parent_column_key=parent_column_key,
            schema_name=schema_name,
            sensitive_type_id=sensitive_type_id,
            total_masked_values=total_masked_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             key: Optional[str] = None,
             masking_column_group: Optional[str] = None,
             masking_format_used: Optional[str] = None,
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             parent_column_key: Optional[str] = None,
             schema_name: Optional[str] = None,
             sensitive_type_id: Optional[str] = None,
             total_masked_values: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if masking_column_group is None and 'maskingColumnGroup' in kwargs:
            masking_column_group = kwargs['maskingColumnGroup']
        if masking_column_group is None:
            raise TypeError("Missing 'masking_column_group' argument")
        if masking_format_used is None and 'maskingFormatUsed' in kwargs:
            masking_format_used = kwargs['maskingFormatUsed']
        if masking_format_used is None:
            raise TypeError("Missing 'masking_format_used' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if parent_column_key is None and 'parentColumnKey' in kwargs:
            parent_column_key = kwargs['parentColumnKey']
        if parent_column_key is None:
            raise TypeError("Missing 'parent_column_key' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")
        if total_masked_values is None and 'totalMaskedValues' in kwargs:
            total_masked_values = kwargs['totalMaskedValues']
        if total_masked_values is None:
            raise TypeError("Missing 'total_masked_values' argument")

        _setter("column_name", column_name)
        _setter("key", key)
        _setter("masking_column_group", masking_column_group)
        _setter("masking_format_used", masking_format_used)
        _setter("object", object)
        _setter("object_type", object_type)
        _setter("parent_column_key", parent_column_key)
        _setter("schema_name", schema_name)
        _setter("sensitive_type_id", sensitive_type_id)
        _setter("total_masked_values", total_masked_values)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key that identifies the masked column. It's numeric and unique within a masking policy.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="maskingColumnGroup")
    def masking_column_group(self) -> str:
        """
        A filter to return only the resources that match the specified masking column group.
        """
        return pulumi.get(self, "masking_column_group")

    @property
    @pulumi.getter(name="maskingFormatUsed")
    def masking_format_used(self) -> str:
        """
        The masking format used for masking the column.
        """
        return pulumi.get(self, "masking_format_used")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        A filter to return only items related to a specific object type.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="parentColumnKey")
    def parent_column_key(self) -> str:
        """
        The unique key that identifies the parent column of the masked column.
        """
        return pulumi.get(self, "parent_column_key")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        A filter to return only items related to a specific sensitive type OCID.
        """
        return pulumi.get(self, "sensitive_type_id")

    @property
    @pulumi.getter(name="totalMaskedValues")
    def total_masked_values(self) -> str:
        """
        The total number of values masked in the column.
        """
        return pulumi.get(self, "total_masked_values")


@pulumi.output_type
class GetMaskingReportsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaskingReportsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaskingReportsMaskedColumnItemResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 key: str,
                 masking_column_group: str,
                 masking_format_used: str,
                 object: str,
                 object_type: str,
                 parent_column_key: str,
                 schema_name: str,
                 sensitive_type_id: str,
                 total_masked_values: str):
        """
        :param str column_name: A filter to return only a specific column based on column name.
        :param str key: The unique key that identifies the masked column. It's numeric and unique within a masking policy.
        :param str masking_column_group: A filter to return only the resources that match the specified masking column group.
        :param str masking_format_used: The masking format used for masking the column.
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: A filter to return only items related to a specific object type.
        :param str parent_column_key: The unique key that identifies the parent column of the masked column.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sensitive_type_id: A filter to return only items related to a specific sensitive type OCID.
        :param str total_masked_values: The total number of values masked in the column.
        """
        GetMaskingReportsMaskedColumnItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            key=key,
            masking_column_group=masking_column_group,
            masking_format_used=masking_format_used,
            object=object,
            object_type=object_type,
            parent_column_key=parent_column_key,
            schema_name=schema_name,
            sensitive_type_id=sensitive_type_id,
            total_masked_values=total_masked_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             key: Optional[str] = None,
             masking_column_group: Optional[str] = None,
             masking_format_used: Optional[str] = None,
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             parent_column_key: Optional[str] = None,
             schema_name: Optional[str] = None,
             sensitive_type_id: Optional[str] = None,
             total_masked_values: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if masking_column_group is None and 'maskingColumnGroup' in kwargs:
            masking_column_group = kwargs['maskingColumnGroup']
        if masking_column_group is None:
            raise TypeError("Missing 'masking_column_group' argument")
        if masking_format_used is None and 'maskingFormatUsed' in kwargs:
            masking_format_used = kwargs['maskingFormatUsed']
        if masking_format_used is None:
            raise TypeError("Missing 'masking_format_used' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if parent_column_key is None and 'parentColumnKey' in kwargs:
            parent_column_key = kwargs['parentColumnKey']
        if parent_column_key is None:
            raise TypeError("Missing 'parent_column_key' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")
        if total_masked_values is None and 'totalMaskedValues' in kwargs:
            total_masked_values = kwargs['totalMaskedValues']
        if total_masked_values is None:
            raise TypeError("Missing 'total_masked_values' argument")

        _setter("column_name", column_name)
        _setter("key", key)
        _setter("masking_column_group", masking_column_group)
        _setter("masking_format_used", masking_format_used)
        _setter("object", object)
        _setter("object_type", object_type)
        _setter("parent_column_key", parent_column_key)
        _setter("schema_name", schema_name)
        _setter("sensitive_type_id", sensitive_type_id)
        _setter("total_masked_values", total_masked_values)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key that identifies the masked column. It's numeric and unique within a masking policy.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="maskingColumnGroup")
    def masking_column_group(self) -> str:
        """
        A filter to return only the resources that match the specified masking column group.
        """
        return pulumi.get(self, "masking_column_group")

    @property
    @pulumi.getter(name="maskingFormatUsed")
    def masking_format_used(self) -> str:
        """
        The masking format used for masking the column.
        """
        return pulumi.get(self, "masking_format_used")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        A filter to return only items related to a specific object type.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="parentColumnKey")
    def parent_column_key(self) -> str:
        """
        The unique key that identifies the parent column of the masked column.
        """
        return pulumi.get(self, "parent_column_key")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        A filter to return only items related to a specific sensitive type OCID.
        """
        return pulumi.get(self, "sensitive_type_id")

    @property
    @pulumi.getter(name="totalMaskedValues")
    def total_masked_values(self) -> str:
        """
        The total number of values masked in the column.
        """
        return pulumi.get(self, "total_masked_values")


@pulumi.output_type
class GetMaskingReportsMaskingReportCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetMaskingReportsMaskingReportCollectionItemResult']):
        GetMaskingReportsMaskingReportCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetMaskingReportsMaskingReportCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetMaskingReportsMaskingReportCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetMaskingReportsMaskingReportCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 id: str,
                 is_drop_temp_tables_enabled: bool,
                 is_redo_logging_enabled: bool,
                 is_refresh_stats_enabled: bool,
                 masking_policy_id: str,
                 masking_work_request_id: str,
                 parallel_degree: str,
                 recompile: str,
                 state: str,
                 target_id: str,
                 time_created: str,
                 time_masking_finished: str,
                 time_masking_started: str,
                 total_masked_columns: str,
                 total_masked_objects: str,
                 total_masked_schemas: str,
                 total_masked_sensitive_types: str,
                 total_masked_values: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param str id: The OCID of the masking report.
        :param bool is_drop_temp_tables_enabled: Indicates if the temporary tables created during the masking operation were dropped after masking.
        :param bool is_redo_logging_enabled: Indicates if redo logging was enabled during the masking operation.
        :param bool is_refresh_stats_enabled: Indicates if statistics gathering was enabled during the masking operation.
        :param str masking_policy_id: A filter to return only the resources that match the specified masking policy OCID.
        :param str masking_work_request_id: The OCID of the masking work request that resulted in this masking report.
        :param str parallel_degree: Indicates if parallel execution was enabled during the masking operation.
        :param str recompile: Indicates how invalid objects were recompiled post the masking operation.
        :param str state: The current state of the masking report.
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: The date and time the masking report was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_masking_finished: The date and time data masking finished, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        :param str time_masking_started: The date and time data masking started, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        :param str total_masked_columns: The total number of masked columns.
        :param str total_masked_objects: The total number of unique objects (tables and editioning views) that contain the masked columns.
        :param str total_masked_schemas: The total number of unique schemas that contain the masked columns.
        :param str total_masked_sensitive_types: The total number of unique sensitive types associated with the masked columns.
        :param str total_masked_values: The total number of masked values.
        """
        GetMaskingReportsMaskingReportCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            id=id,
            is_drop_temp_tables_enabled=is_drop_temp_tables_enabled,
            is_redo_logging_enabled=is_redo_logging_enabled,
            is_refresh_stats_enabled=is_refresh_stats_enabled,
            masking_policy_id=masking_policy_id,
            masking_work_request_id=masking_work_request_id,
            parallel_degree=parallel_degree,
            recompile=recompile,
            state=state,
            target_id=target_id,
            time_created=time_created,
            time_masking_finished=time_masking_finished,
            time_masking_started=time_masking_started,
            total_masked_columns=total_masked_columns,
            total_masked_objects=total_masked_objects,
            total_masked_schemas=total_masked_schemas,
            total_masked_sensitive_types=total_masked_sensitive_types,
            total_masked_values=total_masked_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             id: Optional[str] = None,
             is_drop_temp_tables_enabled: Optional[bool] = None,
             is_redo_logging_enabled: Optional[bool] = None,
             is_refresh_stats_enabled: Optional[bool] = None,
             masking_policy_id: Optional[str] = None,
             masking_work_request_id: Optional[str] = None,
             parallel_degree: Optional[str] = None,
             recompile: Optional[str] = None,
             state: Optional[str] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_masking_finished: Optional[str] = None,
             time_masking_started: Optional[str] = None,
             total_masked_columns: Optional[str] = None,
             total_masked_objects: Optional[str] = None,
             total_masked_schemas: Optional[str] = None,
             total_masked_sensitive_types: Optional[str] = None,
             total_masked_values: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_drop_temp_tables_enabled is None and 'isDropTempTablesEnabled' in kwargs:
            is_drop_temp_tables_enabled = kwargs['isDropTempTablesEnabled']
        if is_drop_temp_tables_enabled is None:
            raise TypeError("Missing 'is_drop_temp_tables_enabled' argument")
        if is_redo_logging_enabled is None and 'isRedoLoggingEnabled' in kwargs:
            is_redo_logging_enabled = kwargs['isRedoLoggingEnabled']
        if is_redo_logging_enabled is None:
            raise TypeError("Missing 'is_redo_logging_enabled' argument")
        if is_refresh_stats_enabled is None and 'isRefreshStatsEnabled' in kwargs:
            is_refresh_stats_enabled = kwargs['isRefreshStatsEnabled']
        if is_refresh_stats_enabled is None:
            raise TypeError("Missing 'is_refresh_stats_enabled' argument")
        if masking_policy_id is None and 'maskingPolicyId' in kwargs:
            masking_policy_id = kwargs['maskingPolicyId']
        if masking_policy_id is None:
            raise TypeError("Missing 'masking_policy_id' argument")
        if masking_work_request_id is None and 'maskingWorkRequestId' in kwargs:
            masking_work_request_id = kwargs['maskingWorkRequestId']
        if masking_work_request_id is None:
            raise TypeError("Missing 'masking_work_request_id' argument")
        if parallel_degree is None and 'parallelDegree' in kwargs:
            parallel_degree = kwargs['parallelDegree']
        if parallel_degree is None:
            raise TypeError("Missing 'parallel_degree' argument")
        if recompile is None:
            raise TypeError("Missing 'recompile' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_masking_finished is None and 'timeMaskingFinished' in kwargs:
            time_masking_finished = kwargs['timeMaskingFinished']
        if time_masking_finished is None:
            raise TypeError("Missing 'time_masking_finished' argument")
        if time_masking_started is None and 'timeMaskingStarted' in kwargs:
            time_masking_started = kwargs['timeMaskingStarted']
        if time_masking_started is None:
            raise TypeError("Missing 'time_masking_started' argument")
        if total_masked_columns is None and 'totalMaskedColumns' in kwargs:
            total_masked_columns = kwargs['totalMaskedColumns']
        if total_masked_columns is None:
            raise TypeError("Missing 'total_masked_columns' argument")
        if total_masked_objects is None and 'totalMaskedObjects' in kwargs:
            total_masked_objects = kwargs['totalMaskedObjects']
        if total_masked_objects is None:
            raise TypeError("Missing 'total_masked_objects' argument")
        if total_masked_schemas is None and 'totalMaskedSchemas' in kwargs:
            total_masked_schemas = kwargs['totalMaskedSchemas']
        if total_masked_schemas is None:
            raise TypeError("Missing 'total_masked_schemas' argument")
        if total_masked_sensitive_types is None and 'totalMaskedSensitiveTypes' in kwargs:
            total_masked_sensitive_types = kwargs['totalMaskedSensitiveTypes']
        if total_masked_sensitive_types is None:
            raise TypeError("Missing 'total_masked_sensitive_types' argument")
        if total_masked_values is None and 'totalMaskedValues' in kwargs:
            total_masked_values = kwargs['totalMaskedValues']
        if total_masked_values is None:
            raise TypeError("Missing 'total_masked_values' argument")

        _setter("compartment_id", compartment_id)
        _setter("id", id)
        _setter("is_drop_temp_tables_enabled", is_drop_temp_tables_enabled)
        _setter("is_redo_logging_enabled", is_redo_logging_enabled)
        _setter("is_refresh_stats_enabled", is_refresh_stats_enabled)
        _setter("masking_policy_id", masking_policy_id)
        _setter("masking_work_request_id", masking_work_request_id)
        _setter("parallel_degree", parallel_degree)
        _setter("recompile", recompile)
        _setter("state", state)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_masking_finished", time_masking_finished)
        _setter("time_masking_started", time_masking_started)
        _setter("total_masked_columns", total_masked_columns)
        _setter("total_masked_objects", total_masked_objects)
        _setter("total_masked_schemas", total_masked_schemas)
        _setter("total_masked_sensitive_types", total_masked_sensitive_types)
        _setter("total_masked_values", total_masked_values)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the masking report.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDropTempTablesEnabled")
    def is_drop_temp_tables_enabled(self) -> bool:
        """
        Indicates if the temporary tables created during the masking operation were dropped after masking.
        """
        return pulumi.get(self, "is_drop_temp_tables_enabled")

    @property
    @pulumi.getter(name="isRedoLoggingEnabled")
    def is_redo_logging_enabled(self) -> bool:
        """
        Indicates if redo logging was enabled during the masking operation.
        """
        return pulumi.get(self, "is_redo_logging_enabled")

    @property
    @pulumi.getter(name="isRefreshStatsEnabled")
    def is_refresh_stats_enabled(self) -> bool:
        """
        Indicates if statistics gathering was enabled during the masking operation.
        """
        return pulumi.get(self, "is_refresh_stats_enabled")

    @property
    @pulumi.getter(name="maskingPolicyId")
    def masking_policy_id(self) -> str:
        """
        A filter to return only the resources that match the specified masking policy OCID.
        """
        return pulumi.get(self, "masking_policy_id")

    @property
    @pulumi.getter(name="maskingWorkRequestId")
    def masking_work_request_id(self) -> str:
        """
        The OCID of the masking work request that resulted in this masking report.
        """
        return pulumi.get(self, "masking_work_request_id")

    @property
    @pulumi.getter(name="parallelDegree")
    def parallel_degree(self) -> str:
        """
        Indicates if parallel execution was enabled during the masking operation.
        """
        return pulumi.get(self, "parallel_degree")

    @property
    @pulumi.getter
    def recompile(self) -> str:
        """
        Indicates how invalid objects were recompiled post the masking operation.
        """
        return pulumi.get(self, "recompile")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the masking report.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the masking report was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeMaskingFinished")
    def time_masking_finished(self) -> str:
        """
        The date and time data masking finished, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        return pulumi.get(self, "time_masking_finished")

    @property
    @pulumi.getter(name="timeMaskingStarted")
    def time_masking_started(self) -> str:
        """
        The date and time data masking started, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339)
        """
        return pulumi.get(self, "time_masking_started")

    @property
    @pulumi.getter(name="totalMaskedColumns")
    def total_masked_columns(self) -> str:
        """
        The total number of masked columns.
        """
        return pulumi.get(self, "total_masked_columns")

    @property
    @pulumi.getter(name="totalMaskedObjects")
    def total_masked_objects(self) -> str:
        """
        The total number of unique objects (tables and editioning views) that contain the masked columns.
        """
        return pulumi.get(self, "total_masked_objects")

    @property
    @pulumi.getter(name="totalMaskedSchemas")
    def total_masked_schemas(self) -> str:
        """
        The total number of unique schemas that contain the masked columns.
        """
        return pulumi.get(self, "total_masked_schemas")

    @property
    @pulumi.getter(name="totalMaskedSensitiveTypes")
    def total_masked_sensitive_types(self) -> str:
        """
        The total number of unique sensitive types associated with the masked columns.
        """
        return pulumi.get(self, "total_masked_sensitive_types")

    @property
    @pulumi.getter(name="totalMaskedValues")
    def total_masked_values(self) -> str:
        """
        The total number of masked values.
        """
        return pulumi.get(self, "total_masked_values")


@pulumi.output_type
class GetOnpremConnectorsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetOnpremConnectorsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetOnpremConnectorsOnPremConnectorResult(dict):
    def __init__(__self__, *,
                 available_version: str,
                 compartment_id: str,
                 created_version: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str):
        """
        :param str available_version: Latest available version of the on-premises connector.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param str created_version: Created version of the on-premises connector.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the on-premises connector.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the on-premises connector.
        :param str lifecycle_details: Details about the current state of the on-premises connector.
        :param str state: The current state of the on-premises connector.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the on-premises connector was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetOnpremConnectorsOnPremConnectorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_version=available_version,
            compartment_id=compartment_id,
            created_version=created_version,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_version: Optional[str] = None,
             compartment_id: Optional[str] = None,
             created_version: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if available_version is None and 'availableVersion' in kwargs:
            available_version = kwargs['availableVersion']
        if available_version is None:
            raise TypeError("Missing 'available_version' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if created_version is None and 'createdVersion' in kwargs:
            created_version = kwargs['createdVersion']
        if created_version is None:
            raise TypeError("Missing 'created_version' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")

        _setter("available_version", available_version)
        _setter("compartment_id", compartment_id)
        _setter("created_version", created_version)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)

    @property
    @pulumi.getter(name="availableVersion")
    def available_version(self) -> str:
        """
        Latest available version of the on-premises connector.
        """
        return pulumi.get(self, "available_version")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="createdVersion")
    def created_version(self) -> str:
        """
        Created version of the on-premises connector.
        """
        return pulumi.get(self, "created_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the on-premises connector.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the on-premises connector.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the on-premises connector.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the on-premises connector.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the on-premises connector was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetReportDefinitionColumnFilterResult(dict):
    def __init__(__self__, *,
                 expressions: Sequence[str],
                 field_name: str,
                 is_enabled: bool,
                 is_hidden: bool,
                 operator: str):
        """
        :param Sequence[str] expressions: An array of expressions based on the operator type. A filter may have one or more expressions.
        :param str field_name: Name of the column that must be sorted.
        :param bool is_enabled: Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        :param bool is_hidden: Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str operator: Specifies the type of operator that must be applied for example in, eq etc.
        """
        GetReportDefinitionColumnFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expressions=expressions,
            field_name=field_name,
            is_enabled=is_enabled,
            is_hidden=is_hidden,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expressions: Optional[Sequence[str]] = None,
             field_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             is_hidden: Optional[bool] = None,
             operator: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expressions is None:
            raise TypeError("Missing 'expressions' argument")
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")
        if operator is None:
            raise TypeError("Missing 'operator' argument")

        _setter("expressions", expressions)
        _setter("field_name", field_name)
        _setter("is_enabled", is_enabled)
        _setter("is_hidden", is_hidden)
        _setter("operator", operator)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence[str]:
        """
        An array of expressions based on the operator type. A filter may have one or more expressions.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Specifies the type of operator that must be applied for example in, eq etc.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class GetReportDefinitionColumnInfoResult(dict):
    def __init__(__self__, *,
                 data_type: str,
                 display_name: str,
                 display_order: int,
                 field_name: str,
                 is_hidden: bool):
        """
        :param str data_type: Specifies the data type of the column.
        :param str display_name: Name of the report definition.
        :param int display_order: Specifies the order in which the summary must be displayed.
        :param str field_name: Name of the column that must be sorted.
        :param bool is_hidden: Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        GetReportDefinitionColumnInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            display_name=display_name,
            display_order=display_order,
            field_name=field_name,
            is_hidden=is_hidden,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             display_name: Optional[str] = None,
             display_order: Optional[int] = None,
             field_name: Optional[str] = None,
             is_hidden: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")

        _setter("data_type", data_type)
        _setter("display_name", display_name)
        _setter("display_order", display_order)
        _setter("field_name", field_name)
        _setter("is_hidden", is_hidden)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Specifies the data type of the column.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Name of the report definition.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")


@pulumi.output_type
class GetReportDefinitionColumnSortingResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 is_ascending: bool,
                 sorting_order: int):
        """
        :param str field_name: Name of the column that must be sorted.
        :param bool is_ascending: Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        :param int sorting_order: Indicates the order at which column must be sorted.
        """
        GetReportDefinitionColumnSortingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            is_ascending=is_ascending,
            sorting_order=sorting_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: Optional[str] = None,
             is_ascending: Optional[bool] = None,
             sorting_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_ascending is None and 'isAscending' in kwargs:
            is_ascending = kwargs['isAscending']
        if is_ascending is None:
            raise TypeError("Missing 'is_ascending' argument")
        if sorting_order is None and 'sortingOrder' in kwargs:
            sorting_order = kwargs['sortingOrder']
        if sorting_order is None:
            raise TypeError("Missing 'sorting_order' argument")

        _setter("field_name", field_name)
        _setter("is_ascending", is_ascending)
        _setter("sorting_order", sorting_order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isAscending")
    def is_ascending(self) -> bool:
        """
        Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_ascending")

    @property
    @pulumi.getter(name="sortingOrder")
    def sorting_order(self) -> int:
        """
        Indicates the order at which column must be sorted.
        """
        return pulumi.get(self, "sorting_order")


@pulumi.output_type
class GetReportDefinitionSummaryResult(dict):
    def __init__(__self__, *,
                 count_of: str,
                 display_order: int,
                 group_by_field_name: str,
                 is_hidden: bool,
                 name: str,
                 scim_filter: str):
        """
        :param str count_of: Name of the key or count of object.
        :param int display_order: Specifies the order in which the summary must be displayed.
        :param str group_by_field_name: A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        :param bool is_hidden: Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str name: Name of the report summary.
        :param str scim_filter: Additional scim filters used to get the specific summary.
        """
        GetReportDefinitionSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count_of=count_of,
            display_order=display_order,
            group_by_field_name=group_by_field_name,
            is_hidden=is_hidden,
            name=name,
            scim_filter=scim_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count_of: Optional[str] = None,
             display_order: Optional[int] = None,
             group_by_field_name: Optional[str] = None,
             is_hidden: Optional[bool] = None,
             name: Optional[str] = None,
             scim_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count_of is None and 'countOf' in kwargs:
            count_of = kwargs['countOf']
        if count_of is None:
            raise TypeError("Missing 'count_of' argument")
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if group_by_field_name is None and 'groupByFieldName' in kwargs:
            group_by_field_name = kwargs['groupByFieldName']
        if group_by_field_name is None:
            raise TypeError("Missing 'group_by_field_name' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if scim_filter is None and 'scimFilter' in kwargs:
            scim_filter = kwargs['scimFilter']
        if scim_filter is None:
            raise TypeError("Missing 'scim_filter' argument")

        _setter("count_of", count_of)
        _setter("display_order", display_order)
        _setter("group_by_field_name", group_by_field_name)
        _setter("is_hidden", is_hidden)
        _setter("name", name)
        _setter("scim_filter", scim_filter)

    @property
    @pulumi.getter(name="countOf")
    def count_of(self) -> str:
        """
        Name of the key or count of object.
        """
        return pulumi.get(self, "count_of")

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter(name="groupByFieldName")
    def group_by_field_name(self) -> str:
        """
        A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        """
        return pulumi.get(self, "group_by_field_name")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the report summary.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scimFilter")
    def scim_filter(self) -> str:
        """
        Additional scim filters used to get the specific summary.
        """
        return pulumi.get(self, "scim_filter")


@pulumi.output_type
class GetReportDefinitionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the report summary.
        """
        GetReportDefinitionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the report summary.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetReportDefinitionsReportDefinitionCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemResult']):
        GetReportDefinitionsReportDefinitionCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetReportDefinitionsReportDefinitionCollectionItemResult(dict):
    def __init__(__self__, *,
                 category: str,
                 column_filters: Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnFilterResult'],
                 column_infos: Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnInfoResult'],
                 column_sortings: Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnSortingResult'],
                 compartment_id: str,
                 compliance_standards: Sequence[str],
                 data_source: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 display_order: int,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_seeded: bool,
                 parent_id: str,
                 record_time_span: str,
                 schedule: str,
                 scheduled_report_compartment_id: str,
                 scheduled_report_mime_type: str,
                 scheduled_report_name: str,
                 scheduled_report_row_limit: int,
                 scim_filter: str,
                 state: str,
                 summaries: Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemSummaryResult'],
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str category: An optional filter to return only resources that match the specified category.
        :param Sequence['GetReportDefinitionsReportDefinitionCollectionItemColumnFilterArgs'] column_filters: An array of columnFilter objects. A columnFilter object stores all information about a column filter including field name, an operator, one or more expressions, if the filter is enabled, or if the filter is hidden.
        :param Sequence['GetReportDefinitionsReportDefinitionCollectionItemColumnInfoArgs'] column_infos: An array of column objects in the order (left to right) displayed in the report. A column object stores all information about a column, including the name displayed on the UI, corresponding field name in the data source, data type of the column, and column visibility (if the column is visible to the user).
        :param Sequence['GetReportDefinitionsReportDefinitionCollectionItemColumnSortingArgs'] column_sortings: An array of column sorting objects. Each column sorting object stores the column name to be sorted and if the sorting is in ascending order; sorting is done by the first column in the array, then by the second column in the array, etc.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Sequence[str] compliance_standards: The list of the data protection regulations/standards used in the report that will help demonstrate compliance.
        :param str data_source: Specifies the name of a resource that provides data for the report. For example  alerts, events.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: A description of the report definition.
        :param str display_name: The name of the report definition to query.
        :param int display_order: Specifies the order in which the summary must be displayed.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the report definition.
        :param bool is_seeded: A boolean flag indicating to list seeded report definitions. Set this parameter to get list of seeded report definitions.
        :param str parent_id: The OCID of the parent report definition. In the case of seeded report definition, this is same as definition OCID.
        :param str record_time_span: The time span for the records in the report to be scheduled. <period-value><period> Allowed period strings - "H","D","M","Y" Each of the above fields potentially introduce constraints. A workRequest is created only when period-value satisfies all the constraints. Constraints introduced: 1. period = H (The allowed range for period-value is [1, 23]) 2. period = D (The allowed range for period-value is [1, 30]) 3. period = M (The allowed range for period-value is [1, 11]) 4. period = Y (The minimum period-value is 1)
        :param str schedule: The schedule to generate the report periodically in the specified format: <version-string>;<version-specific-schedule>
        :param str scheduled_report_compartment_id: The OCID of the compartment in which the scheduled resource should be created.
        :param str scheduled_report_mime_type: Specifies the format of the report ( either XLS or PDF )
        :param str scheduled_report_name: The name of the report to be scheduled.
        :param int scheduled_report_row_limit: Specifies the limit on the number of rows in the report.
        :param str scim_filter: Additional scim filters used to get the specific summary.
        :param str state: An optional filter to return only resources that match the specified lifecycle state.
        :param Sequence['GetReportDefinitionsReportDefinitionCollectionItemSummaryArgs'] summaries: An array of report summary objects in the order (left to right)  displayed in the report.  A  report summary object stores all information about summary of report to be displayed, including the name displayed on UI, the display order, corresponding group by and count of values, summary visibility (if the summary is visible to user).
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: Specifies the data and time the report definition was created.
        :param str time_updated: The date and time the report definition was update.
        """
        GetReportDefinitionsReportDefinitionCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            column_filters=column_filters,
            column_infos=column_infos,
            column_sortings=column_sortings,
            compartment_id=compartment_id,
            compliance_standards=compliance_standards,
            data_source=data_source,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            display_order=display_order,
            freeform_tags=freeform_tags,
            id=id,
            is_seeded=is_seeded,
            parent_id=parent_id,
            record_time_span=record_time_span,
            schedule=schedule,
            scheduled_report_compartment_id=scheduled_report_compartment_id,
            scheduled_report_mime_type=scheduled_report_mime_type,
            scheduled_report_name=scheduled_report_name,
            scheduled_report_row_limit=scheduled_report_row_limit,
            scim_filter=scim_filter,
            state=state,
            summaries=summaries,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             column_filters: Optional[Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnFilterResult']] = None,
             column_infos: Optional[Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnInfoResult']] = None,
             column_sortings: Optional[Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnSortingResult']] = None,
             compartment_id: Optional[str] = None,
             compliance_standards: Optional[Sequence[str]] = None,
             data_source: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             display_order: Optional[int] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_seeded: Optional[bool] = None,
             parent_id: Optional[str] = None,
             record_time_span: Optional[str] = None,
             schedule: Optional[str] = None,
             scheduled_report_compartment_id: Optional[str] = None,
             scheduled_report_mime_type: Optional[str] = None,
             scheduled_report_name: Optional[str] = None,
             scheduled_report_row_limit: Optional[int] = None,
             scim_filter: Optional[str] = None,
             state: Optional[str] = None,
             summaries: Optional[Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemSummaryResult']] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if column_filters is None and 'columnFilters' in kwargs:
            column_filters = kwargs['columnFilters']
        if column_filters is None:
            raise TypeError("Missing 'column_filters' argument")
        if column_infos is None and 'columnInfos' in kwargs:
            column_infos = kwargs['columnInfos']
        if column_infos is None:
            raise TypeError("Missing 'column_infos' argument")
        if column_sortings is None and 'columnSortings' in kwargs:
            column_sortings = kwargs['columnSortings']
        if column_sortings is None:
            raise TypeError("Missing 'column_sortings' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if compliance_standards is None and 'complianceStandards' in kwargs:
            compliance_standards = kwargs['complianceStandards']
        if compliance_standards is None:
            raise TypeError("Missing 'compliance_standards' argument")
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if data_source is None:
            raise TypeError("Missing 'data_source' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_seeded is None and 'isSeeded' in kwargs:
            is_seeded = kwargs['isSeeded']
        if is_seeded is None:
            raise TypeError("Missing 'is_seeded' argument")
        if parent_id is None and 'parentId' in kwargs:
            parent_id = kwargs['parentId']
        if parent_id is None:
            raise TypeError("Missing 'parent_id' argument")
        if record_time_span is None and 'recordTimeSpan' in kwargs:
            record_time_span = kwargs['recordTimeSpan']
        if record_time_span is None:
            raise TypeError("Missing 'record_time_span' argument")
        if schedule is None:
            raise TypeError("Missing 'schedule' argument")
        if scheduled_report_compartment_id is None and 'scheduledReportCompartmentId' in kwargs:
            scheduled_report_compartment_id = kwargs['scheduledReportCompartmentId']
        if scheduled_report_compartment_id is None:
            raise TypeError("Missing 'scheduled_report_compartment_id' argument")
        if scheduled_report_mime_type is None and 'scheduledReportMimeType' in kwargs:
            scheduled_report_mime_type = kwargs['scheduledReportMimeType']
        if scheduled_report_mime_type is None:
            raise TypeError("Missing 'scheduled_report_mime_type' argument")
        if scheduled_report_name is None and 'scheduledReportName' in kwargs:
            scheduled_report_name = kwargs['scheduledReportName']
        if scheduled_report_name is None:
            raise TypeError("Missing 'scheduled_report_name' argument")
        if scheduled_report_row_limit is None and 'scheduledReportRowLimit' in kwargs:
            scheduled_report_row_limit = kwargs['scheduledReportRowLimit']
        if scheduled_report_row_limit is None:
            raise TypeError("Missing 'scheduled_report_row_limit' argument")
        if scim_filter is None and 'scimFilter' in kwargs:
            scim_filter = kwargs['scimFilter']
        if scim_filter is None:
            raise TypeError("Missing 'scim_filter' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if summaries is None:
            raise TypeError("Missing 'summaries' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("category", category)
        _setter("column_filters", column_filters)
        _setter("column_infos", column_infos)
        _setter("column_sortings", column_sortings)
        _setter("compartment_id", compartment_id)
        _setter("compliance_standards", compliance_standards)
        _setter("data_source", data_source)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("display_order", display_order)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_seeded", is_seeded)
        _setter("parent_id", parent_id)
        _setter("record_time_span", record_time_span)
        _setter("schedule", schedule)
        _setter("scheduled_report_compartment_id", scheduled_report_compartment_id)
        _setter("scheduled_report_mime_type", scheduled_report_mime_type)
        _setter("scheduled_report_name", scheduled_report_name)
        _setter("scheduled_report_row_limit", scheduled_report_row_limit)
        _setter("scim_filter", scim_filter)
        _setter("state", state)
        _setter("summaries", summaries)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        An optional filter to return only resources that match the specified category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="columnFilters")
    def column_filters(self) -> Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnFilterResult']:
        """
        An array of columnFilter objects. A columnFilter object stores all information about a column filter including field name, an operator, one or more expressions, if the filter is enabled, or if the filter is hidden.
        """
        return pulumi.get(self, "column_filters")

    @property
    @pulumi.getter(name="columnInfos")
    def column_infos(self) -> Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnInfoResult']:
        """
        An array of column objects in the order (left to right) displayed in the report. A column object stores all information about a column, including the name displayed on the UI, corresponding field name in the data source, data type of the column, and column visibility (if the column is visible to the user).
        """
        return pulumi.get(self, "column_infos")

    @property
    @pulumi.getter(name="columnSortings")
    def column_sortings(self) -> Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemColumnSortingResult']:
        """
        An array of column sorting objects. Each column sorting object stores the column name to be sorted and if the sorting is in ascending order; sorting is done by the first column in the array, then by the second column in the array, etc.
        """
        return pulumi.get(self, "column_sortings")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="complianceStandards")
    def compliance_standards(self) -> Sequence[str]:
        """
        The list of the data protection regulations/standards used in the report that will help demonstrate compliance.
        """
        return pulumi.get(self, "compliance_standards")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        Specifies the name of a resource that provides data for the report. For example  alerts, events.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the report definition.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The name of the report definition to query.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the report definition.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSeeded")
    def is_seeded(self) -> bool:
        """
        A boolean flag indicating to list seeded report definitions. Set this parameter to get list of seeded report definitions.
        """
        return pulumi.get(self, "is_seeded")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> str:
        """
        The OCID of the parent report definition. In the case of seeded report definition, this is same as definition OCID.
        """
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="recordTimeSpan")
    def record_time_span(self) -> str:
        """
        The time span for the records in the report to be scheduled. <period-value><period> Allowed period strings - "H","D","M","Y" Each of the above fields potentially introduce constraints. A workRequest is created only when period-value satisfies all the constraints. Constraints introduced: 1. period = H (The allowed range for period-value is [1, 23]) 2. period = D (The allowed range for period-value is [1, 30]) 3. period = M (The allowed range for period-value is [1, 11]) 4. period = Y (The minimum period-value is 1)
        """
        return pulumi.get(self, "record_time_span")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        The schedule to generate the report periodically in the specified format: <version-string>;<version-specific-schedule>
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="scheduledReportCompartmentId")
    def scheduled_report_compartment_id(self) -> str:
        """
        The OCID of the compartment in which the scheduled resource should be created.
        """
        return pulumi.get(self, "scheduled_report_compartment_id")

    @property
    @pulumi.getter(name="scheduledReportMimeType")
    def scheduled_report_mime_type(self) -> str:
        """
        Specifies the format of the report ( either XLS or PDF )
        """
        return pulumi.get(self, "scheduled_report_mime_type")

    @property
    @pulumi.getter(name="scheduledReportName")
    def scheduled_report_name(self) -> str:
        """
        The name of the report to be scheduled.
        """
        return pulumi.get(self, "scheduled_report_name")

    @property
    @pulumi.getter(name="scheduledReportRowLimit")
    def scheduled_report_row_limit(self) -> int:
        """
        Specifies the limit on the number of rows in the report.
        """
        return pulumi.get(self, "scheduled_report_row_limit")

    @property
    @pulumi.getter(name="scimFilter")
    def scim_filter(self) -> str:
        """
        Additional scim filters used to get the specific summary.
        """
        return pulumi.get(self, "scim_filter")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        An optional filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def summaries(self) -> Sequence['outputs.GetReportDefinitionsReportDefinitionCollectionItemSummaryResult']:
        """
        An array of report summary objects in the order (left to right)  displayed in the report.  A  report summary object stores all information about summary of report to be displayed, including the name displayed on UI, the display order, corresponding group by and count of values, summary visibility (if the summary is visible to user).
        """
        return pulumi.get(self, "summaries")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Specifies the data and time the report definition was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the report definition was update.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetReportDefinitionsReportDefinitionCollectionItemColumnFilterResult(dict):
    def __init__(__self__, *,
                 expressions: Sequence[str],
                 field_name: str,
                 is_enabled: bool,
                 is_hidden: bool,
                 operator: str):
        """
        :param Sequence[str] expressions: An array of expressions based on the operator type. A filter may have one or more expressions.
        :param str field_name: Name of the column that must be sorted.
        :param bool is_enabled: Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        :param bool is_hidden: Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str operator: Specifies the type of operator that must be applied for example in, eq etc.
        """
        GetReportDefinitionsReportDefinitionCollectionItemColumnFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expressions=expressions,
            field_name=field_name,
            is_enabled=is_enabled,
            is_hidden=is_hidden,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expressions: Optional[Sequence[str]] = None,
             field_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             is_hidden: Optional[bool] = None,
             operator: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expressions is None:
            raise TypeError("Missing 'expressions' argument")
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")
        if operator is None:
            raise TypeError("Missing 'operator' argument")

        _setter("expressions", expressions)
        _setter("field_name", field_name)
        _setter("is_enabled", is_enabled)
        _setter("is_hidden", is_hidden)
        _setter("operator", operator)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence[str]:
        """
        An array of expressions based on the operator type. A filter may have one or more expressions.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Indicates whether the filter is enabled. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Specifies the type of operator that must be applied for example in, eq etc.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class GetReportDefinitionsReportDefinitionCollectionItemColumnInfoResult(dict):
    def __init__(__self__, *,
                 data_type: str,
                 display_name: str,
                 display_order: int,
                 field_name: str,
                 is_hidden: bool):
        """
        :param str data_type: Specifies the data type of the column.
        :param str display_name: The name of the report definition to query.
        :param int display_order: Specifies the order in which the summary must be displayed.
        :param str field_name: Name of the column that must be sorted.
        :param bool is_hidden: Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        GetReportDefinitionsReportDefinitionCollectionItemColumnInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            display_name=display_name,
            display_order=display_order,
            field_name=field_name,
            is_hidden=is_hidden,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             display_name: Optional[str] = None,
             display_order: Optional[int] = None,
             field_name: Optional[str] = None,
             is_hidden: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")

        _setter("data_type", data_type)
        _setter("display_name", display_name)
        _setter("display_order", display_order)
        _setter("field_name", field_name)
        _setter("is_hidden", is_hidden)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Specifies the data type of the column.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The name of the report definition to query.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")


@pulumi.output_type
class GetReportDefinitionsReportDefinitionCollectionItemColumnSortingResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 is_ascending: bool,
                 sorting_order: int):
        """
        :param str field_name: Name of the column that must be sorted.
        :param bool is_ascending: Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        :param int sorting_order: Indicates the order at which column must be sorted.
        """
        GetReportDefinitionsReportDefinitionCollectionItemColumnSortingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            is_ascending=is_ascending,
            sorting_order=sorting_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: Optional[str] = None,
             is_ascending: Optional[bool] = None,
             sorting_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_name is None and 'fieldName' in kwargs:
            field_name = kwargs['fieldName']
        if field_name is None:
            raise TypeError("Missing 'field_name' argument")
        if is_ascending is None and 'isAscending' in kwargs:
            is_ascending = kwargs['isAscending']
        if is_ascending is None:
            raise TypeError("Missing 'is_ascending' argument")
        if sorting_order is None and 'sortingOrder' in kwargs:
            sorting_order = kwargs['sortingOrder']
        if sorting_order is None:
            raise TypeError("Missing 'sorting_order' argument")

        _setter("field_name", field_name)
        _setter("is_ascending", is_ascending)
        _setter("sorting_order", sorting_order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the column that must be sorted.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="isAscending")
    def is_ascending(self) -> bool:
        """
        Indicates if the column must be sorted in ascending order. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_ascending")

    @property
    @pulumi.getter(name="sortingOrder")
    def sorting_order(self) -> int:
        """
        Indicates the order at which column must be sorted.
        """
        return pulumi.get(self, "sorting_order")


@pulumi.output_type
class GetReportDefinitionsReportDefinitionCollectionItemSummaryResult(dict):
    def __init__(__self__, *,
                 count_of: str,
                 display_order: int,
                 group_by_field_name: str,
                 is_hidden: bool,
                 name: str,
                 scim_filter: str):
        """
        :param str count_of: Name of the key or count of object.
        :param int display_order: Specifies the order in which the summary must be displayed.
        :param str group_by_field_name: A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        :param bool is_hidden: Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        :param str name: Name of the report summary.
        :param str scim_filter: Additional scim filters used to get the specific summary.
        """
        GetReportDefinitionsReportDefinitionCollectionItemSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count_of=count_of,
            display_order=display_order,
            group_by_field_name=group_by_field_name,
            is_hidden=is_hidden,
            name=name,
            scim_filter=scim_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count_of: Optional[str] = None,
             display_order: Optional[int] = None,
             group_by_field_name: Optional[str] = None,
             is_hidden: Optional[bool] = None,
             name: Optional[str] = None,
             scim_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count_of is None and 'countOf' in kwargs:
            count_of = kwargs['countOf']
        if count_of is None:
            raise TypeError("Missing 'count_of' argument")
        if display_order is None and 'displayOrder' in kwargs:
            display_order = kwargs['displayOrder']
        if display_order is None:
            raise TypeError("Missing 'display_order' argument")
        if group_by_field_name is None and 'groupByFieldName' in kwargs:
            group_by_field_name = kwargs['groupByFieldName']
        if group_by_field_name is None:
            raise TypeError("Missing 'group_by_field_name' argument")
        if is_hidden is None and 'isHidden' in kwargs:
            is_hidden = kwargs['isHidden']
        if is_hidden is None:
            raise TypeError("Missing 'is_hidden' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if scim_filter is None and 'scimFilter' in kwargs:
            scim_filter = kwargs['scimFilter']
        if scim_filter is None:
            raise TypeError("Missing 'scim_filter' argument")

        _setter("count_of", count_of)
        _setter("display_order", display_order)
        _setter("group_by_field_name", group_by_field_name)
        _setter("is_hidden", is_hidden)
        _setter("name", name)
        _setter("scim_filter", scim_filter)

    @property
    @pulumi.getter(name="countOf")
    def count_of(self) -> str:
        """
        Name of the key or count of object.
        """
        return pulumi.get(self, "count_of")

    @property
    @pulumi.getter(name="displayOrder")
    def display_order(self) -> int:
        """
        Specifies the order in which the summary must be displayed.
        """
        return pulumi.get(self, "display_order")

    @property
    @pulumi.getter(name="groupByFieldName")
    def group_by_field_name(self) -> str:
        """
        A comma-delimited string that specifies the names of the fields by which the records must be aggregated to get the summary.
        """
        return pulumi.get(self, "group_by_field_name")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> bool:
        """
        Indicates if the summary is hidden. Values can either be 'true' or 'false'.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the report summary.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scimFilter")
    def scim_filter(self) -> str:
        """
        Additional scim filters used to get the specific summary.
        """
        return pulumi.get(self, "scim_filter")


@pulumi.output_type
class GetReportsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetReportsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetReportsReportCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetReportsReportCollectionItemResult']):
        GetReportsReportCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetReportsReportCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetReportsReportCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetReportsReportCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 mime_type: str,
                 report_definition_id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_generated: str,
                 type: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: Specifies a description of the report.
        :param str display_name: The name of the report definition to query.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the report.
        :param str mime_type: Specifies the format of report to be excel or pdf
        :param str report_definition_id: The ID of the report definition to filter the list of reports
        :param str state: An optional filter to return only resources that match the specified lifecycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_generated: Specifies the date and time the report was generated.
        :param str type: An optional filter to return only resources that match the specified type.
        """
        GetReportsReportCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            mime_type=mime_type,
            report_definition_id=report_definition_id,
            state=state,
            system_tags=system_tags,
            time_generated=time_generated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             mime_type: Optional[str] = None,
             report_definition_id: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_generated: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if mime_type is None and 'mimeType' in kwargs:
            mime_type = kwargs['mimeType']
        if mime_type is None:
            raise TypeError("Missing 'mime_type' argument")
        if report_definition_id is None and 'reportDefinitionId' in kwargs:
            report_definition_id = kwargs['reportDefinitionId']
        if report_definition_id is None:
            raise TypeError("Missing 'report_definition_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_generated is None and 'timeGenerated' in kwargs:
            time_generated = kwargs['timeGenerated']
        if time_generated is None:
            raise TypeError("Missing 'time_generated' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("mime_type", mime_type)
        _setter("report_definition_id", report_definition_id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_generated", time_generated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Specifies a description of the report.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The name of the report definition to query.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the report.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> str:
        """
        Specifies the format of report to be excel or pdf
        """
        return pulumi.get(self, "mime_type")

    @property
    @pulumi.getter(name="reportDefinitionId")
    def report_definition_id(self) -> str:
        """
        The ID of the report definition to filter the list of reports
        """
        return pulumi.get(self, "report_definition_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        An optional filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> str:
        """
        Specifies the date and time the report was generated.
        """
        return pulumi.get(self, "time_generated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        An optional filter to return only resources that match the specified type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSdmMaskingPolicyDifferenceDifferenceColumnsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionItemResult']):
        GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionItemResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 difference_type: str,
                 key: str,
                 masking_columnkey: str,
                 object: str,
                 planned_action: str,
                 schema_name: str,
                 sensitive_columnkey: str,
                 sensitive_type_id: str,
                 sync_status: str,
                 time_last_synced: str):
        """
        :param str column_name: A filter to return only a specific column based on column name.
        :param str difference_type: A filter to return only the SDM masking policy difference columns that match the specified difference type
        :param str key: The unique key that identifies the SDM masking policy difference column.
        :param str masking_columnkey: The unique key that identifies the masking column represented by the SDM masking policy difference column.
        :param str object: A filter to return only items related to a specific object name.
        :param str planned_action: A filter to return only the SDM masking policy difference columns that match the specified planned action.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sensitive_columnkey: The unique key that identifies the sensitive column represented by the SDM masking policy difference column.
        :param str sensitive_type_id: The OCID of the sensitive type associated with the difference column.
        :param str sync_status: A filter to return the SDM masking policy difference columns based on the value of their syncStatus attribute.
        :param str time_last_synced: The date and time the SDM masking policy difference column was last synced, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetSdmMaskingPolicyDifferenceDifferenceColumnsSdmMaskingPolicyDifferenceColumnCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            difference_type=difference_type,
            key=key,
            masking_columnkey=masking_columnkey,
            object=object,
            planned_action=planned_action,
            schema_name=schema_name,
            sensitive_columnkey=sensitive_columnkey,
            sensitive_type_id=sensitive_type_id,
            sync_status=sync_status,
            time_last_synced=time_last_synced,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             difference_type: Optional[str] = None,
             key: Optional[str] = None,
             masking_columnkey: Optional[str] = None,
             object: Optional[str] = None,
             planned_action: Optional[str] = None,
             schema_name: Optional[str] = None,
             sensitive_columnkey: Optional[str] = None,
             sensitive_type_id: Optional[str] = None,
             sync_status: Optional[str] = None,
             time_last_synced: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if difference_type is None and 'differenceType' in kwargs:
            difference_type = kwargs['differenceType']
        if difference_type is None:
            raise TypeError("Missing 'difference_type' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if masking_columnkey is None and 'maskingColumnkey' in kwargs:
            masking_columnkey = kwargs['maskingColumnkey']
        if masking_columnkey is None:
            raise TypeError("Missing 'masking_columnkey' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if planned_action is None and 'plannedAction' in kwargs:
            planned_action = kwargs['plannedAction']
        if planned_action is None:
            raise TypeError("Missing 'planned_action' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sensitive_columnkey is None and 'sensitiveColumnkey' in kwargs:
            sensitive_columnkey = kwargs['sensitiveColumnkey']
        if sensitive_columnkey is None:
            raise TypeError("Missing 'sensitive_columnkey' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")
        if sync_status is None and 'syncStatus' in kwargs:
            sync_status = kwargs['syncStatus']
        if sync_status is None:
            raise TypeError("Missing 'sync_status' argument")
        if time_last_synced is None and 'timeLastSynced' in kwargs:
            time_last_synced = kwargs['timeLastSynced']
        if time_last_synced is None:
            raise TypeError("Missing 'time_last_synced' argument")

        _setter("column_name", column_name)
        _setter("difference_type", difference_type)
        _setter("key", key)
        _setter("masking_columnkey", masking_columnkey)
        _setter("object", object)
        _setter("planned_action", planned_action)
        _setter("schema_name", schema_name)
        _setter("sensitive_columnkey", sensitive_columnkey)
        _setter("sensitive_type_id", sensitive_type_id)
        _setter("sync_status", sync_status)
        _setter("time_last_synced", time_last_synced)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="differenceType")
    def difference_type(self) -> str:
        """
        A filter to return only the SDM masking policy difference columns that match the specified difference type
        """
        return pulumi.get(self, "difference_type")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key that identifies the SDM masking policy difference column.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="maskingColumnkey")
    def masking_columnkey(self) -> str:
        """
        The unique key that identifies the masking column represented by the SDM masking policy difference column.
        """
        return pulumi.get(self, "masking_columnkey")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="plannedAction")
    def planned_action(self) -> str:
        """
        A filter to return only the SDM masking policy difference columns that match the specified planned action.
        """
        return pulumi.get(self, "planned_action")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sensitiveColumnkey")
    def sensitive_columnkey(self) -> str:
        """
        The unique key that identifies the sensitive column represented by the SDM masking policy difference column.
        """
        return pulumi.get(self, "sensitive_columnkey")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        The OCID of the sensitive type associated with the difference column.
        """
        return pulumi.get(self, "sensitive_type_id")

    @property
    @pulumi.getter(name="syncStatus")
    def sync_status(self) -> str:
        """
        A filter to return the SDM masking policy difference columns based on the value of their syncStatus attribute.
        """
        return pulumi.get(self, "sync_status")

    @property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> str:
        """
        The date and time the SDM masking policy difference column was last synced, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_last_synced")


@pulumi.output_type
class GetSdmMaskingPolicyDifferencesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSdmMaskingPolicyDifferencesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionItemResult']):
        GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 difference_type: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 masking_policy_id: str,
                 sensitive_data_model_id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_creation_started: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str difference_type: The type of the SDM masking policy difference. It defines the difference scope. NEW identifies new sensitive columns in the sensitive data model that are not in the masking policy. DELETED identifies columns that are present in the masking policy but have been deleted from the sensitive data model. MODIFIED identifies columns that are present in the sensitive data model as well as the masking policy but some of their attributes have been modified. ALL covers all the above three scenarios and reports new, deleted and modified columns.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the SDM masking policy difference.
        :param str masking_policy_id: A filter to return only the resources that match the specified masking policy OCID.
        :param str sensitive_data_model_id: A filter to return only the resources that match the specified sensitive data model OCID.
        :param str state: A filter to return only the resources that match the specified lifecycle states.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the SDM masking policy difference was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_creation_started: The date and time the SDM masking policy difference creation started, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetSdmMaskingPolicyDifferencesSdmMaskingPolicyDifferenceCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            difference_type=difference_type,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            masking_policy_id=masking_policy_id,
            sensitive_data_model_id=sensitive_data_model_id,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_creation_started=time_creation_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             difference_type: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             masking_policy_id: Optional[str] = None,
             sensitive_data_model_id: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_creation_started: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if difference_type is None and 'differenceType' in kwargs:
            difference_type = kwargs['differenceType']
        if difference_type is None:
            raise TypeError("Missing 'difference_type' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if masking_policy_id is None and 'maskingPolicyId' in kwargs:
            masking_policy_id = kwargs['maskingPolicyId']
        if masking_policy_id is None:
            raise TypeError("Missing 'masking_policy_id' argument")
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if sensitive_data_model_id is None:
            raise TypeError("Missing 'sensitive_data_model_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_creation_started is None and 'timeCreationStarted' in kwargs:
            time_creation_started = kwargs['timeCreationStarted']
        if time_creation_started is None:
            raise TypeError("Missing 'time_creation_started' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("difference_type", difference_type)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("masking_policy_id", masking_policy_id)
        _setter("sensitive_data_model_id", sensitive_data_model_id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_creation_started", time_creation_started)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="differenceType")
    def difference_type(self) -> str:
        """
        The type of the SDM masking policy difference. It defines the difference scope. NEW identifies new sensitive columns in the sensitive data model that are not in the masking policy. DELETED identifies columns that are present in the masking policy but have been deleted from the sensitive data model. MODIFIED identifies columns that are present in the sensitive data model as well as the masking policy but some of their attributes have been modified. ALL covers all the above three scenarios and reports new, deleted and modified columns.
        """
        return pulumi.get(self, "difference_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the SDM masking policy difference.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maskingPolicyId")
    def masking_policy_id(self) -> str:
        """
        A filter to return only the resources that match the specified masking policy OCID.
        """
        return pulumi.get(self, "masking_policy_id")

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> str:
        """
        A filter to return only the resources that match the specified sensitive data model OCID.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only the resources that match the specified lifecycle states.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the SDM masking policy difference was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeCreationStarted")
    def time_creation_started(self) -> str:
        """
        The date and time the SDM masking policy difference creation started, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_creation_started")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetResult(dict):
    def __init__(__self__, *,
                 auditings: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingResult'],
                 authorization_controls: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlResult'],
                 baseline_target_id: str,
                 current_target_id: str,
                 data_encryptions: Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionResult'],
                 db_configurations: Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationResult'],
                 fine_grained_access_controls: Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlResult'],
                 privileges_and_roles: Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleResult'],
                 user_accounts: Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountResult']):
        """
        :param Sequence['GetSecurityAssessmentComparisonTargetAuditingArgs'] auditings: A comparison between findings belonging to Auditing category.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuthorizationControlArgs'] authorization_controls: A comparison between findings belonging to Authorization Control category.
        :param str baseline_target_id: The OCID of the target that is used as a baseline in this comparison.
        :param str current_target_id: The OCID of the target to be compared against the baseline target.
        :param Sequence['GetSecurityAssessmentComparisonTargetDataEncryptionArgs'] data_encryptions: Comparison between findings belonging to Data Encryption category.
        :param Sequence['GetSecurityAssessmentComparisonTargetDbConfigurationArgs'] db_configurations: Comparison between findings belonging to Database Configuration category.
        :param Sequence['GetSecurityAssessmentComparisonTargetFineGrainedAccessControlArgs'] fine_grained_access_controls: Comparison between findings belonging to Fine-Grained Access Control category.
        :param Sequence['GetSecurityAssessmentComparisonTargetPrivilegesAndRoleArgs'] privileges_and_roles: Comparison between findings belonging to Privileges and Roles category.
        :param Sequence['GetSecurityAssessmentComparisonTargetUserAccountArgs'] user_accounts: Comparison between findings belonging to User Accounts category.
        """
        GetSecurityAssessmentComparisonTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditings=auditings,
            authorization_controls=authorization_controls,
            baseline_target_id=baseline_target_id,
            current_target_id=current_target_id,
            data_encryptions=data_encryptions,
            db_configurations=db_configurations,
            fine_grained_access_controls=fine_grained_access_controls,
            privileges_and_roles=privileges_and_roles,
            user_accounts=user_accounts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditings: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingResult']] = None,
             authorization_controls: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlResult']] = None,
             baseline_target_id: Optional[str] = None,
             current_target_id: Optional[str] = None,
             data_encryptions: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionResult']] = None,
             db_configurations: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationResult']] = None,
             fine_grained_access_controls: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlResult']] = None,
             privileges_and_roles: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleResult']] = None,
             user_accounts: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditings is None:
            raise TypeError("Missing 'auditings' argument")
        if authorization_controls is None and 'authorizationControls' in kwargs:
            authorization_controls = kwargs['authorizationControls']
        if authorization_controls is None:
            raise TypeError("Missing 'authorization_controls' argument")
        if baseline_target_id is None and 'baselineTargetId' in kwargs:
            baseline_target_id = kwargs['baselineTargetId']
        if baseline_target_id is None:
            raise TypeError("Missing 'baseline_target_id' argument")
        if current_target_id is None and 'currentTargetId' in kwargs:
            current_target_id = kwargs['currentTargetId']
        if current_target_id is None:
            raise TypeError("Missing 'current_target_id' argument")
        if data_encryptions is None and 'dataEncryptions' in kwargs:
            data_encryptions = kwargs['dataEncryptions']
        if data_encryptions is None:
            raise TypeError("Missing 'data_encryptions' argument")
        if db_configurations is None and 'dbConfigurations' in kwargs:
            db_configurations = kwargs['dbConfigurations']
        if db_configurations is None:
            raise TypeError("Missing 'db_configurations' argument")
        if fine_grained_access_controls is None and 'fineGrainedAccessControls' in kwargs:
            fine_grained_access_controls = kwargs['fineGrainedAccessControls']
        if fine_grained_access_controls is None:
            raise TypeError("Missing 'fine_grained_access_controls' argument")
        if privileges_and_roles is None and 'privilegesAndRoles' in kwargs:
            privileges_and_roles = kwargs['privilegesAndRoles']
        if privileges_and_roles is None:
            raise TypeError("Missing 'privileges_and_roles' argument")
        if user_accounts is None and 'userAccounts' in kwargs:
            user_accounts = kwargs['userAccounts']
        if user_accounts is None:
            raise TypeError("Missing 'user_accounts' argument")

        _setter("auditings", auditings)
        _setter("authorization_controls", authorization_controls)
        _setter("baseline_target_id", baseline_target_id)
        _setter("current_target_id", current_target_id)
        _setter("data_encryptions", data_encryptions)
        _setter("db_configurations", db_configurations)
        _setter("fine_grained_access_controls", fine_grained_access_controls)
        _setter("privileges_and_roles", privileges_and_roles)
        _setter("user_accounts", user_accounts)

    @property
    @pulumi.getter
    def auditings(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingResult']:
        """
        A comparison between findings belonging to Auditing category.
        """
        return pulumi.get(self, "auditings")

    @property
    @pulumi.getter(name="authorizationControls")
    def authorization_controls(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlResult']:
        """
        A comparison between findings belonging to Authorization Control category.
        """
        return pulumi.get(self, "authorization_controls")

    @property
    @pulumi.getter(name="baselineTargetId")
    def baseline_target_id(self) -> str:
        """
        The OCID of the target that is used as a baseline in this comparison.
        """
        return pulumi.get(self, "baseline_target_id")

    @property
    @pulumi.getter(name="currentTargetId")
    def current_target_id(self) -> str:
        """
        The OCID of the target to be compared against the baseline target.
        """
        return pulumi.get(self, "current_target_id")

    @property
    @pulumi.getter(name="dataEncryptions")
    def data_encryptions(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionResult']:
        """
        Comparison between findings belonging to Data Encryption category.
        """
        return pulumi.get(self, "data_encryptions")

    @property
    @pulumi.getter(name="dbConfigurations")
    def db_configurations(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationResult']:
        """
        Comparison between findings belonging to Database Configuration category.
        """
        return pulumi.get(self, "db_configurations")

    @property
    @pulumi.getter(name="fineGrainedAccessControls")
    def fine_grained_access_controls(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlResult']:
        """
        Comparison between findings belonging to Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_controls")

    @property
    @pulumi.getter(name="privilegesAndRoles")
    def privileges_and_roles(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleResult']:
        """
        Comparison between findings belonging to Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles")

    @property
    @pulumi.getter(name="userAccounts")
    def user_accounts(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountResult']:
        """
        Comparison between findings belonging to User Accounts category.
        """
        return pulumi.get(self, "user_accounts")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuditingResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuditingBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuditingCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetAuditingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuditingBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetAuditingBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetAuditingBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuditingCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetAuditingCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetAuditingCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuthorizationControlResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetAuthorizationControlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetAuthorizationControlBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetAuthorizationControlCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDataEncryptionResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetDataEncryptionBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetDataEncryptionCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetDataEncryptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDataEncryptionBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetDataEncryptionBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetDataEncryptionBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDataEncryptionCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetDataEncryptionCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetDataEncryptionCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDbConfigurationResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetDbConfigurationBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetDbConfigurationCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetDbConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDbConfigurationBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetDbConfigurationBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetDbConfigurationBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDbConfigurationCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetDbConfigurationCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetDbConfigurationCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetFineGrainedAccessControlResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetFineGrainedAccessControlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetFineGrainedAccessControlBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetFineGrainedAccessControlCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetPrivilegesAndRoleResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetPrivilegesAndRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetPrivilegesAndRoleBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetPrivilegesAndRoleCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetUserAccountResult(dict):
    def __init__(__self__, *,
                 added_items: Sequence[str],
                 baselines: Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountBaselineResult'],
                 currents: Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountCurrentResult'],
                 modified_items: Sequence[str],
                 removed_items: Sequence[str],
                 severity: str):
        """
        :param Sequence[str] added_items: This array identifies the items that are present in the current assessment, but are missing from the baseline.
        :param Sequence['GetSecurityAssessmentComparisonTargetUserAccountBaselineArgs'] baselines: The particular finding reported by the security assessment.
        :param Sequence['GetSecurityAssessmentComparisonTargetUserAccountCurrentArgs'] currents: The particular finding reported by the security assessment.
        :param Sequence[str] modified_items: This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        :param Sequence[str] removed_items: This array identifies the items that are present in the baseline, but are missing from the current assessment.
        :param str severity: The severity of this diff.
        """
        GetSecurityAssessmentComparisonTargetUserAccountResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_items=added_items,
            baselines=baselines,
            currents=currents,
            modified_items=modified_items,
            removed_items=removed_items,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_items: Optional[Sequence[str]] = None,
             baselines: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountCurrentResult']] = None,
             modified_items: Optional[Sequence[str]] = None,
             removed_items: Optional[Sequence[str]] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if added_items is None and 'addedItems' in kwargs:
            added_items = kwargs['addedItems']
        if added_items is None:
            raise TypeError("Missing 'added_items' argument")
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if modified_items is None and 'modifiedItems' in kwargs:
            modified_items = kwargs['modifiedItems']
        if modified_items is None:
            raise TypeError("Missing 'modified_items' argument")
        if removed_items is None and 'removedItems' in kwargs:
            removed_items = kwargs['removedItems']
        if removed_items is None:
            raise TypeError("Missing 'removed_items' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("added_items", added_items)
        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("modified_items", modified_items)
        _setter("removed_items", removed_items)
        _setter("severity", severity)

    @property
    @pulumi.getter(name="addedItems")
    def added_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the current assessment, but are missing from the baseline.
        """
        return pulumi.get(self, "added_items")

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountBaselineResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountCurrentResult']:
        """
        The particular finding reported by the security assessment.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter(name="modifiedItems")
    def modified_items(self) -> Sequence[str]:
        """
        This array contains the items that are present in both the current assessment and the baseline, but are different in the two assessments.
        """
        return pulumi.get(self, "modified_items")

    @property
    @pulumi.getter(name="removedItems")
    def removed_items(self) -> Sequence[str]:
        """
        This array identifies the items that are present in the baseline, but are missing from the current assessment.
        """
        return pulumi.get(self, "removed_items")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetUserAccountBaselineResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetUserAccountBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetUserAccountBaselineReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetUserAccountCurrentResult(dict):
    def __init__(__self__, *,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 title: str):
        """
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: A unique identifier for the finding. This is common for the finding across targets.
        :param Sequence['GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceArgs'] references: Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: The severity of this diff.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentComparisonTargetUserAccountCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("title", title)

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique identifier for the finding. This is common for the finding across targets.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceResult']:
        """
        Provides information on whether the finding is related to a CIS Oracle Database Benchmark recommendation, STIG rule, or related to a GDPR Article/Recital.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity of this diff.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentComparisonTargetUserAccountCurrentReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentFindingFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityAssessmentFindingFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSecurityAssessmentFindingFindingResult(dict):
    def __init__(__self__, *,
                 assessment_id: str,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentFindingFindingReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 target_id: str,
                 title: str):
        GetSecurityAssessmentFindingFindingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assessment_id=assessment_id,
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            target_id=target_id,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assessment_id: Optional[str] = None,
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentFindingFindingReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             target_id: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assessment_id is None and 'assessmentId' in kwargs:
            assessment_id = kwargs['assessmentId']
        if assessment_id is None:
            raise TypeError("Missing 'assessment_id' argument")
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("assessment_id", assessment_id)
        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("target_id", target_id)
        _setter("title", title)

    @property
    @pulumi.getter(name="assessmentId")
    def assessment_id(self) -> str:
        return pulumi.get(self, "assessment_id")

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentFindingFindingReferenceResult']:
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentFindingFindingReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        GetSecurityAssessmentFindingFindingReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentFindingsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityAssessmentFindingsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSecurityAssessmentFindingsFindingResult(dict):
    def __init__(__self__, *,
                 assessment_id: str,
                 details: Sequence[str],
                 key: str,
                 references: Sequence['outputs.GetSecurityAssessmentFindingsFindingReferenceResult'],
                 remarks: str,
                 severity: str,
                 summary: str,
                 target_id: str,
                 title: str):
        """
        :param str assessment_id: The OCID of the assessment that generated this finding.
        :param Sequence[str] details: The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        :param str key: The unique finding key. This is a system-generated identifier. To get the finding key for a finding, use ListFindings.
        :param Sequence['GetSecurityAssessmentFindingsFindingReferenceArgs'] references: An optional filter to return only findings containing the specified reference.
        :param str remarks: The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        :param str severity: A filter to return only findings of a particular risk level.
        :param str summary: The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        :param str target_id: The OCID of the target database.
        :param str title: The short title for the finding.
        """
        GetSecurityAssessmentFindingsFindingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assessment_id=assessment_id,
            details=details,
            key=key,
            references=references,
            remarks=remarks,
            severity=severity,
            summary=summary,
            target_id=target_id,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assessment_id: Optional[str] = None,
             details: Optional[Sequence[str]] = None,
             key: Optional[str] = None,
             references: Optional[Sequence['outputs.GetSecurityAssessmentFindingsFindingReferenceResult']] = None,
             remarks: Optional[str] = None,
             severity: Optional[str] = None,
             summary: Optional[str] = None,
             target_id: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assessment_id is None and 'assessmentId' in kwargs:
            assessment_id = kwargs['assessmentId']
        if assessment_id is None:
            raise TypeError("Missing 'assessment_id' argument")
        if details is None:
            raise TypeError("Missing 'details' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if references is None:
            raise TypeError("Missing 'references' argument")
        if remarks is None:
            raise TypeError("Missing 'remarks' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("assessment_id", assessment_id)
        _setter("details", details)
        _setter("key", key)
        _setter("references", references)
        _setter("remarks", remarks)
        _setter("severity", severity)
        _setter("summary", summary)
        _setter("target_id", target_id)
        _setter("title", title)

    @property
    @pulumi.getter(name="assessmentId")
    def assessment_id(self) -> str:
        """
        The OCID of the assessment that generated this finding.
        """
        return pulumi.get(self, "assessment_id")

    @property
    @pulumi.getter
    def details(self) -> Sequence[str]:
        """
        The details of the finding. Provides detailed information to explain the finding summary, typically results from the assessed database, followed by any recommendations for changes.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique finding key. This is a system-generated identifier. To get the finding key for a finding, use ListFindings.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def references(self) -> Sequence['outputs.GetSecurityAssessmentFindingsFindingReferenceResult']:
        """
        An optional filter to return only findings containing the specified reference.
        """
        return pulumi.get(self, "references")

    @property
    @pulumi.getter
    def remarks(self) -> str:
        """
        The explanation of the issue in this finding. It explains the reason for the rule and, if a risk is reported, it may also explain the recommended actions for remediation.
        """
        return pulumi.get(self, "remarks")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        A filter to return only findings of a particular risk level.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The brief summary of the finding. When the finding is informational, the summary typically reports only the number of data elements that were examined.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The OCID of the target database.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short title for the finding.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSecurityAssessmentFindingsFindingReferenceResult(dict):
    def __init__(__self__, *,
                 cis: str,
                 gdpr: str,
                 stig: str):
        """
        :param str cis: Relevant section from CIS.
        :param str gdpr: Relevant section from GDPR.
        :param str stig: Relevant section from STIG.
        """
        GetSecurityAssessmentFindingsFindingReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cis=cis,
            gdpr=gdpr,
            stig=stig,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cis: Optional[str] = None,
             gdpr: Optional[str] = None,
             stig: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cis is None:
            raise TypeError("Missing 'cis' argument")
        if gdpr is None:
            raise TypeError("Missing 'gdpr' argument")
        if stig is None:
            raise TypeError("Missing 'stig' argument")

        _setter("cis", cis)
        _setter("gdpr", gdpr)
        _setter("stig", stig)

    @property
    @pulumi.getter
    def cis(self) -> str:
        """
        Relevant section from CIS.
        """
        return pulumi.get(self, "cis")

    @property
    @pulumi.getter
    def gdpr(self) -> str:
        """
        Relevant section from GDPR.
        """
        return pulumi.get(self, "gdpr")

    @property
    @pulumi.getter
    def stig(self) -> str:
        """
        Relevant section from STIG.
        """
        return pulumi.get(self, "stig")


@pulumi.output_type
class GetSecurityAssessmentStatisticResult(dict):
    def __init__(__self__, *,
                 advisories: Sequence['outputs.GetSecurityAssessmentStatisticAdvisoryResult'],
                 evaluates: Sequence['outputs.GetSecurityAssessmentStatisticEvaluateResult'],
                 high_risks: Sequence['outputs.GetSecurityAssessmentStatisticHighRiskResult'],
                 low_risks: Sequence['outputs.GetSecurityAssessmentStatisticLowRiskResult'],
                 medium_risks: Sequence['outputs.GetSecurityAssessmentStatisticMediumRiskResult'],
                 passes: Sequence['outputs.GetSecurityAssessmentStatisticPassResult'],
                 targets_count: int):
        """
        :param Sequence['GetSecurityAssessmentStatisticAdvisoryArgs'] advisories: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentStatisticEvaluateArgs'] evaluates: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentStatisticHighRiskArgs'] high_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentStatisticLowRiskArgs'] low_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentStatisticMediumRiskArgs'] medium_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentStatisticPassArgs'] passes: Statistics showing the number of findings with a particular risk level for each category.
        :param int targets_count: The total number of targets in this security assessment.
        """
        GetSecurityAssessmentStatisticResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advisories=advisories,
            evaluates=evaluates,
            high_risks=high_risks,
            low_risks=low_risks,
            medium_risks=medium_risks,
            passes=passes,
            targets_count=targets_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advisories: Optional[Sequence['outputs.GetSecurityAssessmentStatisticAdvisoryResult']] = None,
             evaluates: Optional[Sequence['outputs.GetSecurityAssessmentStatisticEvaluateResult']] = None,
             high_risks: Optional[Sequence['outputs.GetSecurityAssessmentStatisticHighRiskResult']] = None,
             low_risks: Optional[Sequence['outputs.GetSecurityAssessmentStatisticLowRiskResult']] = None,
             medium_risks: Optional[Sequence['outputs.GetSecurityAssessmentStatisticMediumRiskResult']] = None,
             passes: Optional[Sequence['outputs.GetSecurityAssessmentStatisticPassResult']] = None,
             targets_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if advisories is None:
            raise TypeError("Missing 'advisories' argument")
        if evaluates is None:
            raise TypeError("Missing 'evaluates' argument")
        if high_risks is None and 'highRisks' in kwargs:
            high_risks = kwargs['highRisks']
        if high_risks is None:
            raise TypeError("Missing 'high_risks' argument")
        if low_risks is None and 'lowRisks' in kwargs:
            low_risks = kwargs['lowRisks']
        if low_risks is None:
            raise TypeError("Missing 'low_risks' argument")
        if medium_risks is None and 'mediumRisks' in kwargs:
            medium_risks = kwargs['mediumRisks']
        if medium_risks is None:
            raise TypeError("Missing 'medium_risks' argument")
        if passes is None:
            raise TypeError("Missing 'passes' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")

        _setter("advisories", advisories)
        _setter("evaluates", evaluates)
        _setter("high_risks", high_risks)
        _setter("low_risks", low_risks)
        _setter("medium_risks", medium_risks)
        _setter("passes", passes)
        _setter("targets_count", targets_count)

    @property
    @pulumi.getter
    def advisories(self) -> Sequence['outputs.GetSecurityAssessmentStatisticAdvisoryResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "advisories")

    @property
    @pulumi.getter
    def evaluates(self) -> Sequence['outputs.GetSecurityAssessmentStatisticEvaluateResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "evaluates")

    @property
    @pulumi.getter(name="highRisks")
    def high_risks(self) -> Sequence['outputs.GetSecurityAssessmentStatisticHighRiskResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "high_risks")

    @property
    @pulumi.getter(name="lowRisks")
    def low_risks(self) -> Sequence['outputs.GetSecurityAssessmentStatisticLowRiskResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "low_risks")

    @property
    @pulumi.getter(name="mediumRisks")
    def medium_risks(self) -> Sequence['outputs.GetSecurityAssessmentStatisticMediumRiskResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "medium_risks")

    @property
    @pulumi.getter
    def passes(self) -> Sequence['outputs.GetSecurityAssessmentStatisticPassResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "passes")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")


@pulumi.output_type
class GetSecurityAssessmentStatisticAdvisoryResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentStatisticAdvisoryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentStatisticEvaluateResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentStatisticEvaluateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentStatisticHighRiskResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentStatisticHighRiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentStatisticLowRiskResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentStatisticLowRiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentStatisticMediumRiskResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentStatisticMediumRiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentStatisticPassResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentStatisticPassResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityAssessmentsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 ignored_assessment_ids: Sequence[str],
                 ignored_targets: Sequence[str],
                 is_baseline: bool,
                 is_deviated_from_baseline: bool,
                 last_compared_baseline_id: str,
                 lifecycle_details: str,
                 link: str,
                 schedule: str,
                 schedule_security_assessment_id: str,
                 state: str,
                 statistics: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticResult'],
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 target_ids: Sequence[str],
                 target_version: str,
                 time_created: str,
                 time_last_assessed: str,
                 time_updated: str,
                 triggered_by: str,
                 type: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the security assessment.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the security assessment.
        :param Sequence[str] ignored_assessment_ids: List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        :param Sequence[str] ignored_targets: List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        :param bool is_baseline: A filter to return only security assessments that are set as baseline.
        :param bool is_deviated_from_baseline: Indicates whether or not the security assessment deviates from the baseline.
        :param str last_compared_baseline_id: The OCID of the baseline against which the latest security assessment was compared.
        :param str lifecycle_details: Details about the current state of the security assessment.
        :param str link: The summary of findings for the security assessment.
        :param str schedule: Schedule of the assessment that runs periodically in the specified format: - <version-string>;<version-specific-schedule>
        :param str schedule_security_assessment_id: The OCID of the security assessment that is responsible for creating this scheduled save assessment.
        :param str state: A filter to return only resources that match the specified lifecycle state.
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticArgs'] statistics: Statistics showing the number of findings for each category grouped by risk levels for all the targets in the specified security assessment.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param Sequence[str] target_ids: Array of database target OCIDs.
        :param str target_version: The version of the target database.
        :param str time_created: The date and time when the security assessment was created. Conforms to the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_last_assessed: The date and time when the security assessment was last run. Conforms to the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: The date and time when the security assessment was last updated. Conforms to the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str triggered_by: A filter to return only security asessments that were created by either user or system.
        :param str type: A filter to return only items that match the specified security assessment type.
        """
        GetSecurityAssessmentsSecurityAssessmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            ignored_assessment_ids=ignored_assessment_ids,
            ignored_targets=ignored_targets,
            is_baseline=is_baseline,
            is_deviated_from_baseline=is_deviated_from_baseline,
            last_compared_baseline_id=last_compared_baseline_id,
            lifecycle_details=lifecycle_details,
            link=link,
            schedule=schedule,
            schedule_security_assessment_id=schedule_security_assessment_id,
            state=state,
            statistics=statistics,
            system_tags=system_tags,
            target_id=target_id,
            target_ids=target_ids,
            target_version=target_version,
            time_created=time_created,
            time_last_assessed=time_last_assessed,
            time_updated=time_updated,
            triggered_by=triggered_by,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             ignored_assessment_ids: Optional[Sequence[str]] = None,
             ignored_targets: Optional[Sequence[str]] = None,
             is_baseline: Optional[bool] = None,
             is_deviated_from_baseline: Optional[bool] = None,
             last_compared_baseline_id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             link: Optional[str] = None,
             schedule: Optional[str] = None,
             schedule_security_assessment_id: Optional[str] = None,
             state: Optional[str] = None,
             statistics: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticResult']] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             target_ids: Optional[Sequence[str]] = None,
             target_version: Optional[str] = None,
             time_created: Optional[str] = None,
             time_last_assessed: Optional[str] = None,
             time_updated: Optional[str] = None,
             triggered_by: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ignored_assessment_ids is None and 'ignoredAssessmentIds' in kwargs:
            ignored_assessment_ids = kwargs['ignoredAssessmentIds']
        if ignored_assessment_ids is None:
            raise TypeError("Missing 'ignored_assessment_ids' argument")
        if ignored_targets is None and 'ignoredTargets' in kwargs:
            ignored_targets = kwargs['ignoredTargets']
        if ignored_targets is None:
            raise TypeError("Missing 'ignored_targets' argument")
        if is_baseline is None and 'isBaseline' in kwargs:
            is_baseline = kwargs['isBaseline']
        if is_baseline is None:
            raise TypeError("Missing 'is_baseline' argument")
        if is_deviated_from_baseline is None and 'isDeviatedFromBaseline' in kwargs:
            is_deviated_from_baseline = kwargs['isDeviatedFromBaseline']
        if is_deviated_from_baseline is None:
            raise TypeError("Missing 'is_deviated_from_baseline' argument")
        if last_compared_baseline_id is None and 'lastComparedBaselineId' in kwargs:
            last_compared_baseline_id = kwargs['lastComparedBaselineId']
        if last_compared_baseline_id is None:
            raise TypeError("Missing 'last_compared_baseline_id' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if link is None:
            raise TypeError("Missing 'link' argument")
        if schedule is None:
            raise TypeError("Missing 'schedule' argument")
        if schedule_security_assessment_id is None and 'scheduleSecurityAssessmentId' in kwargs:
            schedule_security_assessment_id = kwargs['scheduleSecurityAssessmentId']
        if schedule_security_assessment_id is None:
            raise TypeError("Missing 'schedule_security_assessment_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if target_ids is None and 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if target_ids is None:
            raise TypeError("Missing 'target_ids' argument")
        if target_version is None and 'targetVersion' in kwargs:
            target_version = kwargs['targetVersion']
        if target_version is None:
            raise TypeError("Missing 'target_version' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_last_assessed is None and 'timeLastAssessed' in kwargs:
            time_last_assessed = kwargs['timeLastAssessed']
        if time_last_assessed is None:
            raise TypeError("Missing 'time_last_assessed' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if triggered_by is None and 'triggeredBy' in kwargs:
            triggered_by = kwargs['triggeredBy']
        if triggered_by is None:
            raise TypeError("Missing 'triggered_by' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("ignored_assessment_ids", ignored_assessment_ids)
        _setter("ignored_targets", ignored_targets)
        _setter("is_baseline", is_baseline)
        _setter("is_deviated_from_baseline", is_deviated_from_baseline)
        _setter("last_compared_baseline_id", last_compared_baseline_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("link", link)
        _setter("schedule", schedule)
        _setter("schedule_security_assessment_id", schedule_security_assessment_id)
        _setter("state", state)
        _setter("statistics", statistics)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("target_ids", target_ids)
        _setter("target_version", target_version)
        _setter("time_created", time_created)
        _setter("time_last_assessed", time_last_assessed)
        _setter("time_updated", time_updated)
        _setter("triggered_by", triggered_by)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the security assessment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the security assessment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoredAssessmentIds")
    def ignored_assessment_ids(self) -> Sequence[str]:
        """
        List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        """
        return pulumi.get(self, "ignored_assessment_ids")

    @property
    @pulumi.getter(name="ignoredTargets")
    def ignored_targets(self) -> Sequence[str]:
        """
        List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        """
        return pulumi.get(self, "ignored_targets")

    @property
    @pulumi.getter(name="isBaseline")
    def is_baseline(self) -> bool:
        """
        A filter to return only security assessments that are set as baseline.
        """
        return pulumi.get(self, "is_baseline")

    @property
    @pulumi.getter(name="isDeviatedFromBaseline")
    def is_deviated_from_baseline(self) -> bool:
        """
        Indicates whether or not the security assessment deviates from the baseline.
        """
        return pulumi.get(self, "is_deviated_from_baseline")

    @property
    @pulumi.getter(name="lastComparedBaselineId")
    def last_compared_baseline_id(self) -> str:
        """
        The OCID of the baseline against which the latest security assessment was compared.
        """
        return pulumi.get(self, "last_compared_baseline_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the security assessment.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def link(self) -> str:
        """
        The summary of findings for the security assessment.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Schedule of the assessment that runs periodically in the specified format: - <version-string>;<version-specific-schedule>
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="scheduleSecurityAssessmentId")
    def schedule_security_assessment_id(self) -> str:
        """
        The OCID of the security assessment that is responsible for creating this scheduled save assessment.
        """
        return pulumi.get(self, "schedule_security_assessment_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def statistics(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticResult']:
        """
        Statistics showing the number of findings for each category grouped by risk levels for all the targets in the specified security assessment.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        Array of database target OCIDs.
        """
        return pulumi.get(self, "target_ids")

    @property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> str:
        """
        The version of the target database.
        """
        return pulumi.get(self, "target_version")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time when the security assessment was created. Conforms to the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastAssessed")
    def time_last_assessed(self) -> str:
        """
        The date and time when the security assessment was last run. Conforms to the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_last_assessed")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time when the security assessment was last updated. Conforms to the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="triggeredBy")
    def triggered_by(self) -> str:
        """
        A filter to return only security asessments that were created by either user or system.
        """
        return pulumi.get(self, "triggered_by")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A filter to return only items that match the specified security assessment type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticResult(dict):
    def __init__(__self__, *,
                 advisories: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryResult'],
                 evaluates: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateResult'],
                 high_risks: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskResult'],
                 low_risks: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskResult'],
                 medium_risks: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskResult'],
                 passes: Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticPassResult'],
                 targets_count: int):
        """
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryArgs'] advisories: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateArgs'] evaluates: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskArgs'] high_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskArgs'] low_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskArgs'] medium_risks: Statistics showing the number of findings with a particular risk level for each category.
        :param Sequence['GetSecurityAssessmentsSecurityAssessmentStatisticPassArgs'] passes: Statistics showing the number of findings with a particular risk level for each category.
        :param int targets_count: The total number of targets in this security assessment.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advisories=advisories,
            evaluates=evaluates,
            high_risks=high_risks,
            low_risks=low_risks,
            medium_risks=medium_risks,
            passes=passes,
            targets_count=targets_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advisories: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryResult']] = None,
             evaluates: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateResult']] = None,
             high_risks: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskResult']] = None,
             low_risks: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskResult']] = None,
             medium_risks: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskResult']] = None,
             passes: Optional[Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticPassResult']] = None,
             targets_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if advisories is None:
            raise TypeError("Missing 'advisories' argument")
        if evaluates is None:
            raise TypeError("Missing 'evaluates' argument")
        if high_risks is None and 'highRisks' in kwargs:
            high_risks = kwargs['highRisks']
        if high_risks is None:
            raise TypeError("Missing 'high_risks' argument")
        if low_risks is None and 'lowRisks' in kwargs:
            low_risks = kwargs['lowRisks']
        if low_risks is None:
            raise TypeError("Missing 'low_risks' argument")
        if medium_risks is None and 'mediumRisks' in kwargs:
            medium_risks = kwargs['mediumRisks']
        if medium_risks is None:
            raise TypeError("Missing 'medium_risks' argument")
        if passes is None:
            raise TypeError("Missing 'passes' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")

        _setter("advisories", advisories)
        _setter("evaluates", evaluates)
        _setter("high_risks", high_risks)
        _setter("low_risks", low_risks)
        _setter("medium_risks", medium_risks)
        _setter("passes", passes)
        _setter("targets_count", targets_count)

    @property
    @pulumi.getter
    def advisories(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "advisories")

    @property
    @pulumi.getter
    def evaluates(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "evaluates")

    @property
    @pulumi.getter(name="highRisks")
    def high_risks(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "high_risks")

    @property
    @pulumi.getter(name="lowRisks")
    def low_risks(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "low_risks")

    @property
    @pulumi.getter(name="mediumRisks")
    def medium_risks(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "medium_risks")

    @property
    @pulumi.getter
    def passes(self) -> Sequence['outputs.GetSecurityAssessmentsSecurityAssessmentStatisticPassResult']:
        """
        Statistics showing the number of findings with a particular risk level for each category.
        """
        return pulumi.get(self, "passes")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticAdvisoryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticEvaluateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticHighRiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticLowRiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticMediumRiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSecurityAssessmentsSecurityAssessmentStatisticPassResult(dict):
    def __init__(__self__, *,
                 auditing_findings_count: int,
                 authorization_control_findings_count: int,
                 data_encryption_findings_count: int,
                 db_configuration_findings_count: int,
                 fine_grained_access_control_findings_count: int,
                 privileges_and_roles_findings_count: int,
                 targets_count: int,
                 user_accounts_findings_count: int):
        """
        :param int auditing_findings_count: The number of findings in the Auditing category.
        :param int authorization_control_findings_count: The number of findings in the Authorization Control category.
        :param int data_encryption_findings_count: The number of findings in the Data Encryption category.
        :param int db_configuration_findings_count: The number of findings in the Database Configuration category.
        :param int fine_grained_access_control_findings_count: The number of findings in the Fine-Grained Access Control category.
        :param int privileges_and_roles_findings_count: The number of findings in the Privileges and Roles category.
        :param int targets_count: The total number of targets in this security assessment.
        :param int user_accounts_findings_count: The number of findings in the User Accounts category.
        """
        GetSecurityAssessmentsSecurityAssessmentStatisticPassResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auditing_findings_count=auditing_findings_count,
            authorization_control_findings_count=authorization_control_findings_count,
            data_encryption_findings_count=data_encryption_findings_count,
            db_configuration_findings_count=db_configuration_findings_count,
            fine_grained_access_control_findings_count=fine_grained_access_control_findings_count,
            privileges_and_roles_findings_count=privileges_and_roles_findings_count,
            targets_count=targets_count,
            user_accounts_findings_count=user_accounts_findings_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auditing_findings_count: Optional[int] = None,
             authorization_control_findings_count: Optional[int] = None,
             data_encryption_findings_count: Optional[int] = None,
             db_configuration_findings_count: Optional[int] = None,
             fine_grained_access_control_findings_count: Optional[int] = None,
             privileges_and_roles_findings_count: Optional[int] = None,
             targets_count: Optional[int] = None,
             user_accounts_findings_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auditing_findings_count is None and 'auditingFindingsCount' in kwargs:
            auditing_findings_count = kwargs['auditingFindingsCount']
        if auditing_findings_count is None:
            raise TypeError("Missing 'auditing_findings_count' argument")
        if authorization_control_findings_count is None and 'authorizationControlFindingsCount' in kwargs:
            authorization_control_findings_count = kwargs['authorizationControlFindingsCount']
        if authorization_control_findings_count is None:
            raise TypeError("Missing 'authorization_control_findings_count' argument")
        if data_encryption_findings_count is None and 'dataEncryptionFindingsCount' in kwargs:
            data_encryption_findings_count = kwargs['dataEncryptionFindingsCount']
        if data_encryption_findings_count is None:
            raise TypeError("Missing 'data_encryption_findings_count' argument")
        if db_configuration_findings_count is None and 'dbConfigurationFindingsCount' in kwargs:
            db_configuration_findings_count = kwargs['dbConfigurationFindingsCount']
        if db_configuration_findings_count is None:
            raise TypeError("Missing 'db_configuration_findings_count' argument")
        if fine_grained_access_control_findings_count is None and 'fineGrainedAccessControlFindingsCount' in kwargs:
            fine_grained_access_control_findings_count = kwargs['fineGrainedAccessControlFindingsCount']
        if fine_grained_access_control_findings_count is None:
            raise TypeError("Missing 'fine_grained_access_control_findings_count' argument")
        if privileges_and_roles_findings_count is None and 'privilegesAndRolesFindingsCount' in kwargs:
            privileges_and_roles_findings_count = kwargs['privilegesAndRolesFindingsCount']
        if privileges_and_roles_findings_count is None:
            raise TypeError("Missing 'privileges_and_roles_findings_count' argument")
        if targets_count is None and 'targetsCount' in kwargs:
            targets_count = kwargs['targetsCount']
        if targets_count is None:
            raise TypeError("Missing 'targets_count' argument")
        if user_accounts_findings_count is None and 'userAccountsFindingsCount' in kwargs:
            user_accounts_findings_count = kwargs['userAccountsFindingsCount']
        if user_accounts_findings_count is None:
            raise TypeError("Missing 'user_accounts_findings_count' argument")

        _setter("auditing_findings_count", auditing_findings_count)
        _setter("authorization_control_findings_count", authorization_control_findings_count)
        _setter("data_encryption_findings_count", data_encryption_findings_count)
        _setter("db_configuration_findings_count", db_configuration_findings_count)
        _setter("fine_grained_access_control_findings_count", fine_grained_access_control_findings_count)
        _setter("privileges_and_roles_findings_count", privileges_and_roles_findings_count)
        _setter("targets_count", targets_count)
        _setter("user_accounts_findings_count", user_accounts_findings_count)

    @property
    @pulumi.getter(name="auditingFindingsCount")
    def auditing_findings_count(self) -> int:
        """
        The number of findings in the Auditing category.
        """
        return pulumi.get(self, "auditing_findings_count")

    @property
    @pulumi.getter(name="authorizationControlFindingsCount")
    def authorization_control_findings_count(self) -> int:
        """
        The number of findings in the Authorization Control category.
        """
        return pulumi.get(self, "authorization_control_findings_count")

    @property
    @pulumi.getter(name="dataEncryptionFindingsCount")
    def data_encryption_findings_count(self) -> int:
        """
        The number of findings in the Data Encryption category.
        """
        return pulumi.get(self, "data_encryption_findings_count")

    @property
    @pulumi.getter(name="dbConfigurationFindingsCount")
    def db_configuration_findings_count(self) -> int:
        """
        The number of findings in the Database Configuration category.
        """
        return pulumi.get(self, "db_configuration_findings_count")

    @property
    @pulumi.getter(name="fineGrainedAccessControlFindingsCount")
    def fine_grained_access_control_findings_count(self) -> int:
        """
        The number of findings in the Fine-Grained Access Control category.
        """
        return pulumi.get(self, "fine_grained_access_control_findings_count")

    @property
    @pulumi.getter(name="privilegesAndRolesFindingsCount")
    def privileges_and_roles_findings_count(self) -> int:
        """
        The number of findings in the Privileges and Roles category.
        """
        return pulumi.get(self, "privileges_and_roles_findings_count")

    @property
    @pulumi.getter(name="targetsCount")
    def targets_count(self) -> int:
        """
        The total number of targets in this security assessment.
        """
        return pulumi.get(self, "targets_count")

    @property
    @pulumi.getter(name="userAccountsFindingsCount")
    def user_accounts_findings_count(self) -> int:
        """
        The number of findings in the User Accounts category.
        """
        return pulumi.get(self, "user_accounts_findings_count")


@pulumi.output_type
class GetSensitiveDataModelSensitiveObjectsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSensitiveDataModelSensitiveObjectsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemResult']):
        """
        :param Sequence['GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemArgs'] items: An array of sensitive object summary objects.
        """
        GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemResult']:
        """
        An array of sensitive object summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemResult(dict):
    def __init__(__self__, *,
                 object: str,
                 object_type: str,
                 schema_name: str):
        """
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: A filter to return only items related to a specific object type.
        :param str schema_name: A filter to return only items related to specific schema name.
        """
        GetSensitiveDataModelSensitiveObjectsSensitiveObjectCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object=object,
            object_type=object_type,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")

        _setter("object", object)
        _setter("object_type", object_type)
        _setter("schema_name", schema_name)

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        A filter to return only items related to a specific object type.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetSensitiveDataModelSensitiveSchemasFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSensitiveDataModelSensitiveSchemasFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemResult']):
        """
        :param Sequence['GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemArgs'] items: An array of sensitive schema summary objects.
        """
        GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemResult']:
        """
        An array of sensitive schema summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemResult(dict):
    def __init__(__self__, *,
                 schema_name: str):
        """
        :param str schema_name: A filter to return only items related to specific schema name.
        """
        GetSensitiveDataModelSensitiveSchemasSensitiveSchemaCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")

        _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetSensitiveDataModelsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSensitiveDataModelsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSensitiveDataModelsSensitiveColumnsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSensitiveDataModelsSensitiveColumnsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionItemResult']):
        GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionItemResult(dict):
    def __init__(__self__, *,
                 app_defined_child_column_keys: Sequence[str],
                 app_name: str,
                 column_groups: Sequence[str],
                 column_name: str,
                 data_type: str,
                 db_defined_child_column_keys: Sequence[str],
                 estimated_data_value_count: str,
                 key: str,
                 lifecycle_details: str,
                 object: str,
                 object_type: str,
                 parent_column_keys: Sequence[str],
                 relation_type: str,
                 sample_data_values: Sequence[str],
                 schema_name: str,
                 sensitive_data_model_id: str,
                 sensitive_type_id: str,
                 source: str,
                 state: str,
                 status: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence[str] app_defined_child_column_keys: Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        :param str app_name: The name of the application associated with the sensitive column. It's useful when the application name is different from the schema name. Otherwise, it can be ignored.
        :param Sequence[str] column_groups: The composite key groups to which the sensitive column belongs. If the column is part of a composite key, it's assigned a column group. It helps identify and manage referential relationships that involve composite keys.
        :param str column_name: A filter to return only a specific column based on column name.
        :param str data_type: A filter to return only the resources that match the specified data types.
        :param Sequence[str] db_defined_child_column_keys: Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        :param str estimated_data_value_count: The estimated number of data values the column has in the associated database.
        :param str key: The unique key that identifies the sensitive column. It's numeric and unique within a sensitive data model.
        :param str lifecycle_details: Details about the current state of the sensitive column.
        :param str object: A filter to return only items related to a specific object name.
        :param str object_type: A filter to return only items related to a specific object type.
        :param Sequence[str] parent_column_keys: Unique keys identifying the columns that are parents of the sensitive column. At present, it tracks a single parent only.
        :param str relation_type: A filter to return sensitive columns based on their relationship with their parent columns. If set to NONE, it returns the sensitive columns that do not have any parent. The response includes the parent columns as well as the independent columns that are not in any relationship. If set to APP_DEFINED, it returns all the child columns that have application-level (non-dictionary) relationship with their parents. If set to DB_DEFINED, it returns all the child columns that have database-level (dictionary-defined) relationship with their parents.
        :param Sequence[str] sample_data_values: Original data values collected for the sensitive column from the associated database. Sample data helps review the column and ensure that it actually contains sensitive data. Note that sample data is retrieved by a data discovery job only if the isSampleDataCollectionEnabled attribute is set to true. At present, only one data value is collected per sensitive column.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str sensitive_data_model_id: The OCID of the sensitive data model.
        :param str sensitive_type_id: A filter to return only the sensitive columns that are associated with one of the sensitive types identified by the specified OCIDs.
        :param str source: The source of the sensitive column. DISCOVERY indicates that the column was added to the sensitive data model using a data discovery job. MANUAL indicates that the column was added manually.
        :param str state: The current state of the sensitive column.
        :param str status: A filter to return only the sensitive columns that match the specified status.
        :param str time_created: The date and time, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339), the sensitive column was created in the sensitive data model.
        :param str time_updated: The date and time, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339), the sensitive column was last updated in the sensitive data model.
        """
        GetSensitiveDataModelsSensitiveColumnsSensitiveColumnCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_defined_child_column_keys=app_defined_child_column_keys,
            app_name=app_name,
            column_groups=column_groups,
            column_name=column_name,
            data_type=data_type,
            db_defined_child_column_keys=db_defined_child_column_keys,
            estimated_data_value_count=estimated_data_value_count,
            key=key,
            lifecycle_details=lifecycle_details,
            object=object,
            object_type=object_type,
            parent_column_keys=parent_column_keys,
            relation_type=relation_type,
            sample_data_values=sample_data_values,
            schema_name=schema_name,
            sensitive_data_model_id=sensitive_data_model_id,
            sensitive_type_id=sensitive_type_id,
            source=source,
            state=state,
            status=status,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_defined_child_column_keys: Optional[Sequence[str]] = None,
             app_name: Optional[str] = None,
             column_groups: Optional[Sequence[str]] = None,
             column_name: Optional[str] = None,
             data_type: Optional[str] = None,
             db_defined_child_column_keys: Optional[Sequence[str]] = None,
             estimated_data_value_count: Optional[str] = None,
             key: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             object: Optional[str] = None,
             object_type: Optional[str] = None,
             parent_column_keys: Optional[Sequence[str]] = None,
             relation_type: Optional[str] = None,
             sample_data_values: Optional[Sequence[str]] = None,
             schema_name: Optional[str] = None,
             sensitive_data_model_id: Optional[str] = None,
             sensitive_type_id: Optional[str] = None,
             source: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_defined_child_column_keys is None and 'appDefinedChildColumnKeys' in kwargs:
            app_defined_child_column_keys = kwargs['appDefinedChildColumnKeys']
        if app_defined_child_column_keys is None:
            raise TypeError("Missing 'app_defined_child_column_keys' argument")
        if app_name is None and 'appName' in kwargs:
            app_name = kwargs['appName']
        if app_name is None:
            raise TypeError("Missing 'app_name' argument")
        if column_groups is None and 'columnGroups' in kwargs:
            column_groups = kwargs['columnGroups']
        if column_groups is None:
            raise TypeError("Missing 'column_groups' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if db_defined_child_column_keys is None and 'dbDefinedChildColumnKeys' in kwargs:
            db_defined_child_column_keys = kwargs['dbDefinedChildColumnKeys']
        if db_defined_child_column_keys is None:
            raise TypeError("Missing 'db_defined_child_column_keys' argument")
        if estimated_data_value_count is None and 'estimatedDataValueCount' in kwargs:
            estimated_data_value_count = kwargs['estimatedDataValueCount']
        if estimated_data_value_count is None:
            raise TypeError("Missing 'estimated_data_value_count' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if object is None:
            raise TypeError("Missing 'object' argument")
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if object_type is None:
            raise TypeError("Missing 'object_type' argument")
        if parent_column_keys is None and 'parentColumnKeys' in kwargs:
            parent_column_keys = kwargs['parentColumnKeys']
        if parent_column_keys is None:
            raise TypeError("Missing 'parent_column_keys' argument")
        if relation_type is None and 'relationType' in kwargs:
            relation_type = kwargs['relationType']
        if relation_type is None:
            raise TypeError("Missing 'relation_type' argument")
        if sample_data_values is None and 'sampleDataValues' in kwargs:
            sample_data_values = kwargs['sampleDataValues']
        if sample_data_values is None:
            raise TypeError("Missing 'sample_data_values' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if sensitive_data_model_id is None and 'sensitiveDataModelId' in kwargs:
            sensitive_data_model_id = kwargs['sensitiveDataModelId']
        if sensitive_data_model_id is None:
            raise TypeError("Missing 'sensitive_data_model_id' argument")
        if sensitive_type_id is None and 'sensitiveTypeId' in kwargs:
            sensitive_type_id = kwargs['sensitiveTypeId']
        if sensitive_type_id is None:
            raise TypeError("Missing 'sensitive_type_id' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("app_defined_child_column_keys", app_defined_child_column_keys)
        _setter("app_name", app_name)
        _setter("column_groups", column_groups)
        _setter("column_name", column_name)
        _setter("data_type", data_type)
        _setter("db_defined_child_column_keys", db_defined_child_column_keys)
        _setter("estimated_data_value_count", estimated_data_value_count)
        _setter("key", key)
        _setter("lifecycle_details", lifecycle_details)
        _setter("object", object)
        _setter("object_type", object_type)
        _setter("parent_column_keys", parent_column_keys)
        _setter("relation_type", relation_type)
        _setter("sample_data_values", sample_data_values)
        _setter("schema_name", schema_name)
        _setter("sensitive_data_model_id", sensitive_data_model_id)
        _setter("sensitive_type_id", sensitive_type_id)
        _setter("source", source)
        _setter("state", state)
        _setter("status", status)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="appDefinedChildColumnKeys")
    def app_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are application-level (non-dictionary) children of the sensitive column.
        """
        return pulumi.get(self, "app_defined_child_column_keys")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> str:
        """
        The name of the application associated with the sensitive column. It's useful when the application name is different from the schema name. Otherwise, it can be ignored.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="columnGroups")
    def column_groups(self) -> Sequence[str]:
        """
        The composite key groups to which the sensitive column belongs. If the column is part of a composite key, it's assigned a column group. It helps identify and manage referential relationships that involve composite keys.
        """
        return pulumi.get(self, "column_groups")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        A filter to return only the resources that match the specified data types.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dbDefinedChildColumnKeys")
    def db_defined_child_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are database-level (dictionary-defined) children of the sensitive column.
        """
        return pulumi.get(self, "db_defined_child_column_keys")

    @property
    @pulumi.getter(name="estimatedDataValueCount")
    def estimated_data_value_count(self) -> str:
        """
        The estimated number of data values the column has in the associated database.
        """
        return pulumi.get(self, "estimated_data_value_count")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key that identifies the sensitive column. It's numeric and unique within a sensitive data model.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the sensitive column.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        A filter to return only items related to a specific object name.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> str:
        """
        A filter to return only items related to a specific object type.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="parentColumnKeys")
    def parent_column_keys(self) -> Sequence[str]:
        """
        Unique keys identifying the columns that are parents of the sensitive column. At present, it tracks a single parent only.
        """
        return pulumi.get(self, "parent_column_keys")

    @property
    @pulumi.getter(name="relationType")
    def relation_type(self) -> str:
        """
        A filter to return sensitive columns based on their relationship with their parent columns. If set to NONE, it returns the sensitive columns that do not have any parent. The response includes the parent columns as well as the independent columns that are not in any relationship. If set to APP_DEFINED, it returns all the child columns that have application-level (non-dictionary) relationship with their parents. If set to DB_DEFINED, it returns all the child columns that have database-level (dictionary-defined) relationship with their parents.
        """
        return pulumi.get(self, "relation_type")

    @property
    @pulumi.getter(name="sampleDataValues")
    def sample_data_values(self) -> Sequence[str]:
        """
        Original data values collected for the sensitive column from the associated database. Sample data helps review the column and ensure that it actually contains sensitive data. Note that sample data is retrieved by a data discovery job only if the isSampleDataCollectionEnabled attribute is set to true. At present, only one data value is collected per sensitive column.
        """
        return pulumi.get(self, "sample_data_values")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sensitiveDataModelId")
    def sensitive_data_model_id(self) -> str:
        """
        The OCID of the sensitive data model.
        """
        return pulumi.get(self, "sensitive_data_model_id")

    @property
    @pulumi.getter(name="sensitiveTypeId")
    def sensitive_type_id(self) -> str:
        """
        A filter to return only the sensitive columns that are associated with one of the sensitive types identified by the specified OCIDs.
        """
        return pulumi.get(self, "sensitive_type_id")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the sensitive column. DISCOVERY indicates that the column was added to the sensitive data model using a data discovery job. MANUAL indicates that the column was added manually.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the sensitive column.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        A filter to return only the sensitive columns that match the specified status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339), the sensitive column was created in the sensitive data model.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339), the sensitive column was last updated in the sensitive data model.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetSensitiveDataModelsSensitiveDataModelCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSensitiveDataModelsSensitiveDataModelCollectionItemResult']):
        GetSensitiveDataModelsSensitiveDataModelCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSensitiveDataModelsSensitiveDataModelCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSensitiveDataModelsSensitiveDataModelCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSensitiveDataModelsSensitiveDataModelCollectionItemResult(dict):
    def __init__(__self__, *,
                 app_suite_name: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_app_defined_relation_discovery_enabled: bool,
                 is_include_all_schemas: bool,
                 is_include_all_sensitive_types: bool,
                 is_sample_data_collection_enabled: bool,
                 schemas_for_discoveries: Sequence[str],
                 sensitive_type_ids_for_discoveries: Sequence[str],
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str app_suite_name: The application suite name identifying a collection of applications. The default value is GENERIC. It's useful only if maintaining a sensitive data model for a suite of applications.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the sensitive data model.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the sensitive data model.
        :param bool is_app_defined_relation_discovery_enabled: Indicates if data discovery jobs should identify potential application-level (non-dictionary) referential relationships between columns. Note that data discovery automatically identifies and adds database-level (dictionary-defined) relationships. This option helps identify application-level relationships that are not defined in the database dictionary, which in turn, helps identify additional sensitive columns and preserve referential integrity during data masking. It's disabled by default and should be used only if there is a need to identify application-level relationships.
        :param bool is_include_all_schemas: Indicates if all the schemas in the associated target database should be scanned by data discovery jobs. If it's set to true, the schemasForDiscovery attribute is ignored and all schemas are used for data discovery.
        :param bool is_include_all_sensitive_types: Indicates if all the existing sensitive types should be used by data discovery jobs.If it's set to true, the sensitiveTypeIdsForDiscovery attribute is ignored and all sensitive types are used for data discovery.
        :param bool is_sample_data_collection_enabled: Indicates if data discovery jobs should collect and store sample data values for the discovered columns. Sample data helps review the discovered columns and ensure that they actually contain sensitive data. As it collects original data from the target database, it's disabled by default and should be used only if it's acceptable to store sample data in Data Safe's repository in Oracle Cloud. Note that sample data values are not collected for columns with the following data types: LONG, LOB, RAW, XMLTYPE and BFILE.
        :param Sequence[str] schemas_for_discoveries: The schemas to be scanned by data discovery jobs.
        :param Sequence[str] sensitive_type_ids_for_discoveries: The OCIDs of the sensitive types to be used by data discovery jobs.
        :param str state: A filter to return only the resources that match the specified lifecycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: The date and time the sensitive data model was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: The date and time the sensitive data model was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetSensitiveDataModelsSensitiveDataModelCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_suite_name=app_suite_name,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_app_defined_relation_discovery_enabled=is_app_defined_relation_discovery_enabled,
            is_include_all_schemas=is_include_all_schemas,
            is_include_all_sensitive_types=is_include_all_sensitive_types,
            is_sample_data_collection_enabled=is_sample_data_collection_enabled,
            schemas_for_discoveries=schemas_for_discoveries,
            sensitive_type_ids_for_discoveries=sensitive_type_ids_for_discoveries,
            state=state,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_suite_name: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_app_defined_relation_discovery_enabled: Optional[bool] = None,
             is_include_all_schemas: Optional[bool] = None,
             is_include_all_sensitive_types: Optional[bool] = None,
             is_sample_data_collection_enabled: Optional[bool] = None,
             schemas_for_discoveries: Optional[Sequence[str]] = None,
             sensitive_type_ids_for_discoveries: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_suite_name is None and 'appSuiteName' in kwargs:
            app_suite_name = kwargs['appSuiteName']
        if app_suite_name is None:
            raise TypeError("Missing 'app_suite_name' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_app_defined_relation_discovery_enabled is None and 'isAppDefinedRelationDiscoveryEnabled' in kwargs:
            is_app_defined_relation_discovery_enabled = kwargs['isAppDefinedRelationDiscoveryEnabled']
        if is_app_defined_relation_discovery_enabled is None:
            raise TypeError("Missing 'is_app_defined_relation_discovery_enabled' argument")
        if is_include_all_schemas is None and 'isIncludeAllSchemas' in kwargs:
            is_include_all_schemas = kwargs['isIncludeAllSchemas']
        if is_include_all_schemas is None:
            raise TypeError("Missing 'is_include_all_schemas' argument")
        if is_include_all_sensitive_types is None and 'isIncludeAllSensitiveTypes' in kwargs:
            is_include_all_sensitive_types = kwargs['isIncludeAllSensitiveTypes']
        if is_include_all_sensitive_types is None:
            raise TypeError("Missing 'is_include_all_sensitive_types' argument")
        if is_sample_data_collection_enabled is None and 'isSampleDataCollectionEnabled' in kwargs:
            is_sample_data_collection_enabled = kwargs['isSampleDataCollectionEnabled']
        if is_sample_data_collection_enabled is None:
            raise TypeError("Missing 'is_sample_data_collection_enabled' argument")
        if schemas_for_discoveries is None and 'schemasForDiscoveries' in kwargs:
            schemas_for_discoveries = kwargs['schemasForDiscoveries']
        if schemas_for_discoveries is None:
            raise TypeError("Missing 'schemas_for_discoveries' argument")
        if sensitive_type_ids_for_discoveries is None and 'sensitiveTypeIdsForDiscoveries' in kwargs:
            sensitive_type_ids_for_discoveries = kwargs['sensitiveTypeIdsForDiscoveries']
        if sensitive_type_ids_for_discoveries is None:
            raise TypeError("Missing 'sensitive_type_ids_for_discoveries' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("app_suite_name", app_suite_name)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_app_defined_relation_discovery_enabled", is_app_defined_relation_discovery_enabled)
        _setter("is_include_all_schemas", is_include_all_schemas)
        _setter("is_include_all_sensitive_types", is_include_all_sensitive_types)
        _setter("is_sample_data_collection_enabled", is_sample_data_collection_enabled)
        _setter("schemas_for_discoveries", schemas_for_discoveries)
        _setter("sensitive_type_ids_for_discoveries", sensitive_type_ids_for_discoveries)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="appSuiteName")
    def app_suite_name(self) -> str:
        """
        The application suite name identifying a collection of applications. The default value is GENERIC. It's useful only if maintaining a sensitive data model for a suite of applications.
        """
        return pulumi.get(self, "app_suite_name")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the sensitive data model.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the sensitive data model.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAppDefinedRelationDiscoveryEnabled")
    def is_app_defined_relation_discovery_enabled(self) -> bool:
        """
        Indicates if data discovery jobs should identify potential application-level (non-dictionary) referential relationships between columns. Note that data discovery automatically identifies and adds database-level (dictionary-defined) relationships. This option helps identify application-level relationships that are not defined in the database dictionary, which in turn, helps identify additional sensitive columns and preserve referential integrity during data masking. It's disabled by default and should be used only if there is a need to identify application-level relationships.
        """
        return pulumi.get(self, "is_app_defined_relation_discovery_enabled")

    @property
    @pulumi.getter(name="isIncludeAllSchemas")
    def is_include_all_schemas(self) -> bool:
        """
        Indicates if all the schemas in the associated target database should be scanned by data discovery jobs. If it's set to true, the schemasForDiscovery attribute is ignored and all schemas are used for data discovery.
        """
        return pulumi.get(self, "is_include_all_schemas")

    @property
    @pulumi.getter(name="isIncludeAllSensitiveTypes")
    def is_include_all_sensitive_types(self) -> bool:
        """
        Indicates if all the existing sensitive types should be used by data discovery jobs.If it's set to true, the sensitiveTypeIdsForDiscovery attribute is ignored and all sensitive types are used for data discovery.
        """
        return pulumi.get(self, "is_include_all_sensitive_types")

    @property
    @pulumi.getter(name="isSampleDataCollectionEnabled")
    def is_sample_data_collection_enabled(self) -> bool:
        """
        Indicates if data discovery jobs should collect and store sample data values for the discovered columns. Sample data helps review the discovered columns and ensure that they actually contain sensitive data. As it collects original data from the target database, it's disabled by default and should be used only if it's acceptable to store sample data in Data Safe's repository in Oracle Cloud. Note that sample data values are not collected for columns with the following data types: LONG, LOB, RAW, XMLTYPE and BFILE.
        """
        return pulumi.get(self, "is_sample_data_collection_enabled")

    @property
    @pulumi.getter(name="schemasForDiscoveries")
    def schemas_for_discoveries(self) -> Sequence[str]:
        """
        The schemas to be scanned by data discovery jobs.
        """
        return pulumi.get(self, "schemas_for_discoveries")

    @property
    @pulumi.getter(name="sensitiveTypeIdsForDiscoveries")
    def sensitive_type_ids_for_discoveries(self) -> Sequence[str]:
        """
        The OCIDs of the sensitive types to be used by data discovery jobs.
        """
        return pulumi.get(self, "sensitive_type_ids_for_discoveries")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only the resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the sensitive data model was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the sensitive data model was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetSensitiveTypesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSensitiveTypesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSensitiveTypesSensitiveTypeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSensitiveTypesSensitiveTypeCollectionItemResult']):
        GetSensitiveTypesSensitiveTypeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetSensitiveTypesSensitiveTypeCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSensitiveTypesSensitiveTypeCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSensitiveTypesSensitiveTypeCollectionItemResult(dict):
    def __init__(__self__, *,
                 comment_pattern: str,
                 compartment_id: str,
                 data_pattern: str,
                 default_masking_format_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 entity_type: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 name_pattern: str,
                 parent_category_id: str,
                 search_type: str,
                 short_name: str,
                 source: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str comment_pattern: A regular expression to be used by data discovery for matching column comments.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param str data_pattern: A regular expression to be used by data discovery for matching column data values.
        :param str default_masking_format_id: A filter to return only the sensitive types that have the default masking format identified by the specified OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the sensitive type.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param str entity_type: A filter to return the sensitive type resources based on the value of their entityType attribute.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the sensitive type.
        :param str name_pattern: A regular expression to be used by data discovery for matching column names.
        :param str parent_category_id: A filter to return only the sensitive types that are children of the sensitive category identified by the specified OCID.
        :param str search_type: The search type indicating how the column name, comment and data patterns should be used by data discovery. [Learn more](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/sensitive-types.html#GUID-1D1AD98E-B93F-4FF2-80AE-CB7D8A14F6CC).
        :param str short_name: The short name of the sensitive type.
        :param str source: Specifies whether the sensitive type is user-defined or predefined.
        :param str state: A filter to return only the resources that match the specified lifecycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the sensitive type was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: The date and time the sensitive type was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetSensitiveTypesSensitiveTypeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment_pattern=comment_pattern,
            compartment_id=compartment_id,
            data_pattern=data_pattern,
            default_masking_format_id=default_masking_format_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            entity_type=entity_type,
            freeform_tags=freeform_tags,
            id=id,
            name_pattern=name_pattern,
            parent_category_id=parent_category_id,
            search_type=search_type,
            short_name=short_name,
            source=source,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment_pattern: Optional[str] = None,
             compartment_id: Optional[str] = None,
             data_pattern: Optional[str] = None,
             default_masking_format_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             entity_type: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             name_pattern: Optional[str] = None,
             parent_category_id: Optional[str] = None,
             search_type: Optional[str] = None,
             short_name: Optional[str] = None,
             source: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comment_pattern is None and 'commentPattern' in kwargs:
            comment_pattern = kwargs['commentPattern']
        if comment_pattern is None:
            raise TypeError("Missing 'comment_pattern' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if data_pattern is None and 'dataPattern' in kwargs:
            data_pattern = kwargs['dataPattern']
        if data_pattern is None:
            raise TypeError("Missing 'data_pattern' argument")
        if default_masking_format_id is None and 'defaultMaskingFormatId' in kwargs:
            default_masking_format_id = kwargs['defaultMaskingFormatId']
        if default_masking_format_id is None:
            raise TypeError("Missing 'default_masking_format_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if entity_type is None and 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if entity_type is None:
            raise TypeError("Missing 'entity_type' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name_pattern is None and 'namePattern' in kwargs:
            name_pattern = kwargs['namePattern']
        if name_pattern is None:
            raise TypeError("Missing 'name_pattern' argument")
        if parent_category_id is None and 'parentCategoryId' in kwargs:
            parent_category_id = kwargs['parentCategoryId']
        if parent_category_id is None:
            raise TypeError("Missing 'parent_category_id' argument")
        if search_type is None and 'searchType' in kwargs:
            search_type = kwargs['searchType']
        if search_type is None:
            raise TypeError("Missing 'search_type' argument")
        if short_name is None and 'shortName' in kwargs:
            short_name = kwargs['shortName']
        if short_name is None:
            raise TypeError("Missing 'short_name' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("comment_pattern", comment_pattern)
        _setter("compartment_id", compartment_id)
        _setter("data_pattern", data_pattern)
        _setter("default_masking_format_id", default_masking_format_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("name_pattern", name_pattern)
        _setter("parent_category_id", parent_category_id)
        _setter("search_type", search_type)
        _setter("short_name", short_name)
        _setter("source", source)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="commentPattern")
    def comment_pattern(self) -> str:
        """
        A regular expression to be used by data discovery for matching column comments.
        """
        return pulumi.get(self, "comment_pattern")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="dataPattern")
    def data_pattern(self) -> str:
        """
        A regular expression to be used by data discovery for matching column data values.
        """
        return pulumi.get(self, "data_pattern")

    @property
    @pulumi.getter(name="defaultMaskingFormatId")
    def default_masking_format_id(self) -> str:
        """
        A filter to return only the sensitive types that have the default masking format identified by the specified OCID.
        """
        return pulumi.get(self, "default_masking_format_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the sensitive type.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        A filter to return the sensitive type resources based on the value of their entityType attribute.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the sensitive type.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="namePattern")
    def name_pattern(self) -> str:
        """
        A regular expression to be used by data discovery for matching column names.
        """
        return pulumi.get(self, "name_pattern")

    @property
    @pulumi.getter(name="parentCategoryId")
    def parent_category_id(self) -> str:
        """
        A filter to return only the sensitive types that are children of the sensitive category identified by the specified OCID.
        """
        return pulumi.get(self, "parent_category_id")

    @property
    @pulumi.getter(name="searchType")
    def search_type(self) -> str:
        """
        The search type indicating how the column name, comment and data patterns should be used by data discovery. [Learn more](https://docs.oracle.com/en/cloud/paas/data-safe/udscs/sensitive-types.html#GUID-1D1AD98E-B93F-4FF2-80AE-CB7D8A14F6CC).
        """
        return pulumi.get(self, "search_type")

    @property
    @pulumi.getter(name="shortName")
    def short_name(self) -> str:
        """
        The short name of the sensitive type.
        """
        return pulumi.get(self, "short_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Specifies whether the sensitive type is user-defined or predefined.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only the resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the sensitive type was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the sensitive type was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetTargetAlertPolicyAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetAlertPolicyAssociationsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionItemResult']):
        GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_enabled: bool,
                 policy_id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: Describes the target-alert policy association.
        :param str display_name: The display name of the target-alert policy association.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the target-alert policy association.
        :param bool is_enabled: Indicates if the target-alert policy association is enabled or disabled.
        :param str policy_id: The OCID of the alert policy.
        :param str state: An optional filter to return only alert policies that have the given life-cycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_created: Creation date and time of the alert policy, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: Last date and time the alert policy was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        GetTargetAlertPolicyAssociationsTargetAlertPolicyAssociationCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_enabled=is_enabled,
            policy_id=policy_id,
            state=state,
            system_tags=system_tags,
            target_id=target_id,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             policy_id: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if policy_id is None:
            raise TypeError("Missing 'policy_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_enabled", is_enabled)
        _setter("policy_id", policy_id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Describes the target-alert policy association.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the target-alert policy association.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the target-alert policy association.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Indicates if the target-alert policy association is enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        The OCID of the alert policy.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        An optional filter to return only alert policies that have the given life-cycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Creation date and time of the alert policy, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        Last date and time the alert policy was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetTargetDatabaseConnectionOptionResult(dict):
    def __init__(__self__, *,
                 connection_type: str,
                 datasafe_private_endpoint_id: str,
                 on_prem_connector_id: str):
        """
        :param str connection_type: The connection type used to connect to the database. Allowed values:
               * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
               * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        :param str datasafe_private_endpoint_id: The OCID of the Data Safe private endpoint.
        :param str on_prem_connector_id: The OCID of the on-premises connector.
        """
        GetTargetDatabaseConnectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_type=connection_type,
            datasafe_private_endpoint_id=datasafe_private_endpoint_id,
            on_prem_connector_id=on_prem_connector_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_type: Optional[str] = None,
             datasafe_private_endpoint_id: Optional[str] = None,
             on_prem_connector_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_type is None and 'connectionType' in kwargs:
            connection_type = kwargs['connectionType']
        if connection_type is None:
            raise TypeError("Missing 'connection_type' argument")
        if datasafe_private_endpoint_id is None and 'datasafePrivateEndpointId' in kwargs:
            datasafe_private_endpoint_id = kwargs['datasafePrivateEndpointId']
        if datasafe_private_endpoint_id is None:
            raise TypeError("Missing 'datasafe_private_endpoint_id' argument")
        if on_prem_connector_id is None and 'onPremConnectorId' in kwargs:
            on_prem_connector_id = kwargs['onPremConnectorId']
        if on_prem_connector_id is None:
            raise TypeError("Missing 'on_prem_connector_id' argument")

        _setter("connection_type", connection_type)
        _setter("datasafe_private_endpoint_id", datasafe_private_endpoint_id)
        _setter("on_prem_connector_id", on_prem_connector_id)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        The connection type used to connect to the database. Allowed values:
        * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
        * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="datasafePrivateEndpointId")
    def datasafe_private_endpoint_id(self) -> str:
        """
        The OCID of the Data Safe private endpoint.
        """
        return pulumi.get(self, "datasafe_private_endpoint_id")

    @property
    @pulumi.getter(name="onPremConnectorId")
    def on_prem_connector_id(self) -> str:
        """
        The OCID of the on-premises connector.
        """
        return pulumi.get(self, "on_prem_connector_id")


@pulumi.output_type
class GetTargetDatabaseCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 user_name: str):
        """
        :param str password: The password of the database user.
        :param str user_name: The database user name.
        """
        GetTargetDatabaseCredentialResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']
        if user_name is None:
            raise TypeError("Missing 'user_name' argument")

        _setter("password", password)
        _setter("user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the database user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        The database user name.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetTargetDatabaseDatabaseDetailResult(dict):
    def __init__(__self__, *,
                 autonomous_database_id: str,
                 database_type: str,
                 db_system_id: str,
                 infrastructure_type: str,
                 instance_id: str,
                 ip_addresses: Sequence[str],
                 listener_port: int,
                 service_name: str,
                 vm_cluster_id: str):
        """
        :param str autonomous_database_id: The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param str database_type: The database type.
        :param str db_system_id: The OCID of the cloud database registered as a target database in Data Safe.
        :param str infrastructure_type: The infrastructure type the database is running on.
        :param str instance_id: The OCID of the compute instance on which the database is running.
        :param Sequence[str] ip_addresses: The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param int listener_port: The port number of the database listener.
        :param str service_name: The service name of the database registered as target database.
        :param str vm_cluster_id: The OCID of the VM cluster in which the database is running.
        """
        GetTargetDatabaseDatabaseDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_database_id=autonomous_database_id,
            database_type=database_type,
            db_system_id=db_system_id,
            infrastructure_type=infrastructure_type,
            instance_id=instance_id,
            ip_addresses=ip_addresses,
            listener_port=listener_port,
            service_name=service_name,
            vm_cluster_id=vm_cluster_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_database_id: Optional[str] = None,
             database_type: Optional[str] = None,
             db_system_id: Optional[str] = None,
             infrastructure_type: Optional[str] = None,
             instance_id: Optional[str] = None,
             ip_addresses: Optional[Sequence[str]] = None,
             listener_port: Optional[int] = None,
             service_name: Optional[str] = None,
             vm_cluster_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if autonomous_database_id is None and 'autonomousDatabaseId' in kwargs:
            autonomous_database_id = kwargs['autonomousDatabaseId']
        if autonomous_database_id is None:
            raise TypeError("Missing 'autonomous_database_id' argument")
        if database_type is None and 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if database_type is None:
            raise TypeError("Missing 'database_type' argument")
        if db_system_id is None and 'dbSystemId' in kwargs:
            db_system_id = kwargs['dbSystemId']
        if db_system_id is None:
            raise TypeError("Missing 'db_system_id' argument")
        if infrastructure_type is None and 'infrastructureType' in kwargs:
            infrastructure_type = kwargs['infrastructureType']
        if infrastructure_type is None:
            raise TypeError("Missing 'infrastructure_type' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if ip_addresses is None and 'ipAddresses' in kwargs:
            ip_addresses = kwargs['ipAddresses']
        if ip_addresses is None:
            raise TypeError("Missing 'ip_addresses' argument")
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if listener_port is None:
            raise TypeError("Missing 'listener_port' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")
        if vm_cluster_id is None and 'vmClusterId' in kwargs:
            vm_cluster_id = kwargs['vmClusterId']
        if vm_cluster_id is None:
            raise TypeError("Missing 'vm_cluster_id' argument")

        _setter("autonomous_database_id", autonomous_database_id)
        _setter("database_type", database_type)
        _setter("db_system_id", db_system_id)
        _setter("infrastructure_type", infrastructure_type)
        _setter("instance_id", instance_id)
        _setter("ip_addresses", ip_addresses)
        _setter("listener_port", listener_port)
        _setter("service_name", service_name)
        _setter("vm_cluster_id", vm_cluster_id)

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> str:
        """
        The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        The database type.
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> str:
        """
        The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        """
        The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> str:
        """
        The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class GetTargetDatabaseRoleFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetDatabaseRoleFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetDatabaseRoleRoleResult(dict):
    def __init__(__self__, *,
                 authentication_type: str,
                 is_common: bool,
                 is_implicit: bool,
                 is_inherited: bool,
                 is_oracle_maintained: bool,
                 is_password_required: bool,
                 role_name: str):
        GetTargetDatabaseRoleRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_type=authentication_type,
            is_common=is_common,
            is_implicit=is_implicit,
            is_inherited=is_inherited,
            is_oracle_maintained=is_oracle_maintained,
            is_password_required=is_password_required,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_type: Optional[str] = None,
             is_common: Optional[bool] = None,
             is_implicit: Optional[bool] = None,
             is_inherited: Optional[bool] = None,
             is_oracle_maintained: Optional[bool] = None,
             is_password_required: Optional[bool] = None,
             role_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if is_common is None and 'isCommon' in kwargs:
            is_common = kwargs['isCommon']
        if is_common is None:
            raise TypeError("Missing 'is_common' argument")
        if is_implicit is None and 'isImplicit' in kwargs:
            is_implicit = kwargs['isImplicit']
        if is_implicit is None:
            raise TypeError("Missing 'is_implicit' argument")
        if is_inherited is None and 'isInherited' in kwargs:
            is_inherited = kwargs['isInherited']
        if is_inherited is None:
            raise TypeError("Missing 'is_inherited' argument")
        if is_oracle_maintained is None and 'isOracleMaintained' in kwargs:
            is_oracle_maintained = kwargs['isOracleMaintained']
        if is_oracle_maintained is None:
            raise TypeError("Missing 'is_oracle_maintained' argument")
        if is_password_required is None and 'isPasswordRequired' in kwargs:
            is_password_required = kwargs['isPasswordRequired']
        if is_password_required is None:
            raise TypeError("Missing 'is_password_required' argument")
        if role_name is None and 'roleName' in kwargs:
            role_name = kwargs['roleName']
        if role_name is None:
            raise TypeError("Missing 'role_name' argument")

        _setter("authentication_type", authentication_type)
        _setter("is_common", is_common)
        _setter("is_implicit", is_implicit)
        _setter("is_inherited", is_inherited)
        _setter("is_oracle_maintained", is_oracle_maintained)
        _setter("is_password_required", is_password_required)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="isCommon")
    def is_common(self) -> bool:
        return pulumi.get(self, "is_common")

    @property
    @pulumi.getter(name="isImplicit")
    def is_implicit(self) -> bool:
        return pulumi.get(self, "is_implicit")

    @property
    @pulumi.getter(name="isInherited")
    def is_inherited(self) -> bool:
        return pulumi.get(self, "is_inherited")

    @property
    @pulumi.getter(name="isOracleMaintained")
    def is_oracle_maintained(self) -> bool:
        return pulumi.get(self, "is_oracle_maintained")

    @property
    @pulumi.getter(name="isPasswordRequired")
    def is_password_required(self) -> bool:
        return pulumi.get(self, "is_password_required")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetTargetDatabaseRolesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetDatabaseRolesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetDatabaseRolesRoleResult(dict):
    def __init__(__self__, *,
                 authentication_type: str,
                 is_common: bool,
                 is_implicit: bool,
                 is_inherited: bool,
                 is_oracle_maintained: bool,
                 is_password_required: bool,
                 role_name: str):
        """
        :param str authentication_type: A filter to return roles based on authentication type.
        :param bool is_common: Is the role common.
        :param bool is_implicit: Is the role implicit.
        :param bool is_inherited: Is the role inherited.
        :param bool is_oracle_maintained: A filter to return roles based on whether they are maintained by oracle or not.
        :param bool is_password_required: Is password required.
        :param str role_name: A filter to return only a specific role based on role name.
        """
        GetTargetDatabaseRolesRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_type=authentication_type,
            is_common=is_common,
            is_implicit=is_implicit,
            is_inherited=is_inherited,
            is_oracle_maintained=is_oracle_maintained,
            is_password_required=is_password_required,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_type: Optional[str] = None,
             is_common: Optional[bool] = None,
             is_implicit: Optional[bool] = None,
             is_inherited: Optional[bool] = None,
             is_oracle_maintained: Optional[bool] = None,
             is_password_required: Optional[bool] = None,
             role_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if is_common is None and 'isCommon' in kwargs:
            is_common = kwargs['isCommon']
        if is_common is None:
            raise TypeError("Missing 'is_common' argument")
        if is_implicit is None and 'isImplicit' in kwargs:
            is_implicit = kwargs['isImplicit']
        if is_implicit is None:
            raise TypeError("Missing 'is_implicit' argument")
        if is_inherited is None and 'isInherited' in kwargs:
            is_inherited = kwargs['isInherited']
        if is_inherited is None:
            raise TypeError("Missing 'is_inherited' argument")
        if is_oracle_maintained is None and 'isOracleMaintained' in kwargs:
            is_oracle_maintained = kwargs['isOracleMaintained']
        if is_oracle_maintained is None:
            raise TypeError("Missing 'is_oracle_maintained' argument")
        if is_password_required is None and 'isPasswordRequired' in kwargs:
            is_password_required = kwargs['isPasswordRequired']
        if is_password_required is None:
            raise TypeError("Missing 'is_password_required' argument")
        if role_name is None and 'roleName' in kwargs:
            role_name = kwargs['roleName']
        if role_name is None:
            raise TypeError("Missing 'role_name' argument")

        _setter("authentication_type", authentication_type)
        _setter("is_common", is_common)
        _setter("is_implicit", is_implicit)
        _setter("is_inherited", is_inherited)
        _setter("is_oracle_maintained", is_oracle_maintained)
        _setter("is_password_required", is_password_required)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        A filter to return roles based on authentication type.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="isCommon")
    def is_common(self) -> bool:
        """
        Is the role common.
        """
        return pulumi.get(self, "is_common")

    @property
    @pulumi.getter(name="isImplicit")
    def is_implicit(self) -> bool:
        """
        Is the role implicit.
        """
        return pulumi.get(self, "is_implicit")

    @property
    @pulumi.getter(name="isInherited")
    def is_inherited(self) -> bool:
        """
        Is the role inherited.
        """
        return pulumi.get(self, "is_inherited")

    @property
    @pulumi.getter(name="isOracleMaintained")
    def is_oracle_maintained(self) -> bool:
        """
        A filter to return roles based on whether they are maintained by oracle or not.
        """
        return pulumi.get(self, "is_oracle_maintained")

    @property
    @pulumi.getter(name="isPasswordRequired")
    def is_password_required(self) -> bool:
        """
        Is password required.
        """
        return pulumi.get(self, "is_password_required")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        A filter to return only a specific role based on role name.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetTargetDatabaseTlsConfigResult(dict):
    def __init__(__self__, *,
                 certificate_store_type: str,
                 key_store_content: str,
                 status: str,
                 store_password: str,
                 trust_store_content: str):
        """
        :param str certificate_store_type: The format of the certificate store.
        :param str key_store_content: Base64 encoded string of key store file content.
        :param str status: Status to represent whether the database connection is TLS enabled or not.
        :param str store_password: The password to read the trust store and key store files, if they are password protected.
        :param str trust_store_content: Base64 encoded string of trust store file content.
        """
        GetTargetDatabaseTlsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_store_type=certificate_store_type,
            key_store_content=key_store_content,
            status=status,
            store_password=store_password,
            trust_store_content=trust_store_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_store_type: Optional[str] = None,
             key_store_content: Optional[str] = None,
             status: Optional[str] = None,
             store_password: Optional[str] = None,
             trust_store_content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_store_type is None and 'certificateStoreType' in kwargs:
            certificate_store_type = kwargs['certificateStoreType']
        if certificate_store_type is None:
            raise TypeError("Missing 'certificate_store_type' argument")
        if key_store_content is None and 'keyStoreContent' in kwargs:
            key_store_content = kwargs['keyStoreContent']
        if key_store_content is None:
            raise TypeError("Missing 'key_store_content' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if store_password is None and 'storePassword' in kwargs:
            store_password = kwargs['storePassword']
        if store_password is None:
            raise TypeError("Missing 'store_password' argument")
        if trust_store_content is None and 'trustStoreContent' in kwargs:
            trust_store_content = kwargs['trustStoreContent']
        if trust_store_content is None:
            raise TypeError("Missing 'trust_store_content' argument")

        _setter("certificate_store_type", certificate_store_type)
        _setter("key_store_content", key_store_content)
        _setter("status", status)
        _setter("store_password", store_password)
        _setter("trust_store_content", trust_store_content)

    @property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> str:
        """
        The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> str:
        """
        Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> str:
        """
        The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> str:
        """
        Base64 encoded string of trust store file content.
        """
        return pulumi.get(self, "trust_store_content")


@pulumi.output_type
class GetTargetDatabasesColumnsColumnResult(dict):
    def __init__(__self__, *,
                 character_length: int,
                 column_name: str,
                 data_type: str,
                 length: str,
                 precision: int,
                 scale: int,
                 schema_name: str,
                 table_name: str):
        """
        :param int character_length: Character length.
        :param str column_name: A filter to return only a specific column based on column name.
        :param str data_type: Data type of the column.
        :param str length: Length of the data represented by the column.
        :param int precision: Precision of the column.
        :param int scale: Scale of the column.
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str table_name: A filter to return only items related to specific table name.
        """
        GetTargetDatabasesColumnsColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            character_length=character_length,
            column_name=column_name,
            data_type=data_type,
            length=length,
            precision=precision,
            scale=scale,
            schema_name=schema_name,
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             character_length: Optional[int] = None,
             column_name: Optional[str] = None,
             data_type: Optional[str] = None,
             length: Optional[str] = None,
             precision: Optional[int] = None,
             scale: Optional[int] = None,
             schema_name: Optional[str] = None,
             table_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if character_length is None and 'characterLength' in kwargs:
            character_length = kwargs['characterLength']
        if character_length is None:
            raise TypeError("Missing 'character_length' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if length is None:
            raise TypeError("Missing 'length' argument")
        if precision is None:
            raise TypeError("Missing 'precision' argument")
        if scale is None:
            raise TypeError("Missing 'scale' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("character_length", character_length)
        _setter("column_name", column_name)
        _setter("data_type", data_type)
        _setter("length", length)
        _setter("precision", precision)
        _setter("scale", scale)
        _setter("schema_name", schema_name)
        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="characterLength")
    def character_length(self) -> int:
        """
        Character length.
        """
        return pulumi.get(self, "character_length")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        A filter to return only a specific column based on column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Data type of the column.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def length(self) -> str:
        """
        Length of the data represented by the column.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def precision(self) -> int:
        """
        Precision of the column.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scale(self) -> int:
        """
        Scale of the column.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        A filter to return only items related to specific table name.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class GetTargetDatabasesColumnsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetDatabasesColumnsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetDatabasesSchemasFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetDatabasesSchemasFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetDatabasesSchemasSchemaResult(dict):
    def __init__(__self__, *,
                 is_oracle_maintained: bool,
                 schema_name: str):
        """
        :param bool is_oracle_maintained: A filter to return only items related to specific type of schema.
        :param str schema_name: A filter to return only items related to specific schema name.
        """
        GetTargetDatabasesSchemasSchemaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_oracle_maintained=is_oracle_maintained,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_oracle_maintained: Optional[bool] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_oracle_maintained is None and 'isOracleMaintained' in kwargs:
            is_oracle_maintained = kwargs['isOracleMaintained']
        if is_oracle_maintained is None:
            raise TypeError("Missing 'is_oracle_maintained' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")

        _setter("is_oracle_maintained", is_oracle_maintained)
        _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="isOracleMaintained")
    def is_oracle_maintained(self) -> bool:
        """
        A filter to return only items related to specific type of schema.
        """
        return pulumi.get(self, "is_oracle_maintained")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetTargetDatabasesTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTargetDatabasesTablesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTargetDatabasesTablesTableResult(dict):
    def __init__(__self__, *,
                 schema_name: str,
                 table_name: str):
        """
        :param str schema_name: A filter to return only items related to specific schema name.
        :param str table_name: A filter to return only items related to specific table name.
        """
        GetTargetDatabasesTablesTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_name=schema_name,
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_name: Optional[str] = None,
             table_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("schema_name", schema_name)
        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        A filter to return only items related to specific schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        A filter to return only items related to specific table name.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class GetTargetDatabasesTargetDatabaseResult(dict):
    def __init__(__self__, *,
                 associated_resource_ids: Sequence[str],
                 compartment_id: str,
                 connection_options: Sequence['outputs.GetTargetDatabasesTargetDatabaseConnectionOptionResult'],
                 credentials: Sequence['outputs.GetTargetDatabasesTargetDatabaseCredentialResult'],
                 database_details: Sequence['outputs.GetTargetDatabasesTargetDatabaseDatabaseDetailResult'],
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str,
                 tls_configs: Sequence['outputs.GetTargetDatabasesTargetDatabaseTlsConfigResult']):
        """
        :param Sequence[str] associated_resource_ids: The OCIDs of associated resources like database, Data Safe private endpoint etc.
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Sequence['GetTargetDatabasesTargetDatabaseConnectionOptionArgs'] connection_options: Types of connection supported by Data Safe.
        :param Sequence['GetTargetDatabasesTargetDatabaseCredentialArgs'] credentials: The database credentials required for Data Safe to connect to the database.
        :param Sequence['GetTargetDatabasesTargetDatabaseDatabaseDetailArgs'] database_details: Details of the database for the registration in Data Safe.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the target database in Data Safe.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the Data Safe target database.
        :param str lifecycle_details: Details about the current state of the target database in Data Safe.
        :param str state: A filter to return only target databases that match the specified lifecycle state.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the database was registered in Data Safe and created as a target database in Data Safe.
        :param str time_updated: The date and time of the target database update in Data Safe.
        :param Sequence['GetTargetDatabasesTargetDatabaseTlsConfigArgs'] tls_configs: The details required to establish a TLS enabled connection.
        """
        GetTargetDatabasesTargetDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associated_resource_ids=associated_resource_ids,
            compartment_id=compartment_id,
            connection_options=connection_options,
            credentials=credentials,
            database_details=database_details,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
            tls_configs=tls_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associated_resource_ids: Optional[Sequence[str]] = None,
             compartment_id: Optional[str] = None,
             connection_options: Optional[Sequence['outputs.GetTargetDatabasesTargetDatabaseConnectionOptionResult']] = None,
             credentials: Optional[Sequence['outputs.GetTargetDatabasesTargetDatabaseCredentialResult']] = None,
             database_details: Optional[Sequence['outputs.GetTargetDatabasesTargetDatabaseDatabaseDetailResult']] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             tls_configs: Optional[Sequence['outputs.GetTargetDatabasesTargetDatabaseTlsConfigResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if associated_resource_ids is None and 'associatedResourceIds' in kwargs:
            associated_resource_ids = kwargs['associatedResourceIds']
        if associated_resource_ids is None:
            raise TypeError("Missing 'associated_resource_ids' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if connection_options is None and 'connectionOptions' in kwargs:
            connection_options = kwargs['connectionOptions']
        if connection_options is None:
            raise TypeError("Missing 'connection_options' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if database_details is None and 'databaseDetails' in kwargs:
            database_details = kwargs['databaseDetails']
        if database_details is None:
            raise TypeError("Missing 'database_details' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if tls_configs is None and 'tlsConfigs' in kwargs:
            tls_configs = kwargs['tlsConfigs']
        if tls_configs is None:
            raise TypeError("Missing 'tls_configs' argument")

        _setter("associated_resource_ids", associated_resource_ids)
        _setter("compartment_id", compartment_id)
        _setter("connection_options", connection_options)
        _setter("credentials", credentials)
        _setter("database_details", database_details)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("tls_configs", tls_configs)

    @property
    @pulumi.getter(name="associatedResourceIds")
    def associated_resource_ids(self) -> Sequence[str]:
        """
        The OCIDs of associated resources like database, Data Safe private endpoint etc.
        """
        return pulumi.get(self, "associated_resource_ids")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Sequence['outputs.GetTargetDatabasesTargetDatabaseConnectionOptionResult']:
        """
        Types of connection supported by Data Safe.
        """
        return pulumi.get(self, "connection_options")

    @property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.GetTargetDatabasesTargetDatabaseCredentialResult']:
        """
        The database credentials required for Data Safe to connect to the database.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="databaseDetails")
    def database_details(self) -> Sequence['outputs.GetTargetDatabasesTargetDatabaseDatabaseDetailResult']:
        """
        Details of the database for the registration in Data Safe.
        """
        return pulumi.get(self, "database_details")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the target database in Data Safe.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Data Safe target database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the target database in Data Safe.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only target databases that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the database was registered in Data Safe and created as a target database in Data Safe.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time of the target database update in Data Safe.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Sequence['outputs.GetTargetDatabasesTargetDatabaseTlsConfigResult']:
        """
        The details required to establish a TLS enabled connection.
        """
        return pulumi.get(self, "tls_configs")


@pulumi.output_type
class GetTargetDatabasesTargetDatabaseConnectionOptionResult(dict):
    def __init__(__self__, *,
                 connection_type: str,
                 datasafe_private_endpoint_id: str,
                 on_prem_connector_id: str):
        """
        :param str connection_type: The connection type used to connect to the database. Allowed values:
               * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
               * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        :param str datasafe_private_endpoint_id: The OCID of the Data Safe private endpoint.
        :param str on_prem_connector_id: The OCID of the on-premises connector.
        """
        GetTargetDatabasesTargetDatabaseConnectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_type=connection_type,
            datasafe_private_endpoint_id=datasafe_private_endpoint_id,
            on_prem_connector_id=on_prem_connector_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_type: Optional[str] = None,
             datasafe_private_endpoint_id: Optional[str] = None,
             on_prem_connector_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_type is None and 'connectionType' in kwargs:
            connection_type = kwargs['connectionType']
        if connection_type is None:
            raise TypeError("Missing 'connection_type' argument")
        if datasafe_private_endpoint_id is None and 'datasafePrivateEndpointId' in kwargs:
            datasafe_private_endpoint_id = kwargs['datasafePrivateEndpointId']
        if datasafe_private_endpoint_id is None:
            raise TypeError("Missing 'datasafe_private_endpoint_id' argument")
        if on_prem_connector_id is None and 'onPremConnectorId' in kwargs:
            on_prem_connector_id = kwargs['onPremConnectorId']
        if on_prem_connector_id is None:
            raise TypeError("Missing 'on_prem_connector_id' argument")

        _setter("connection_type", connection_type)
        _setter("datasafe_private_endpoint_id", datasafe_private_endpoint_id)
        _setter("on_prem_connector_id", on_prem_connector_id)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        The connection type used to connect to the database. Allowed values:
        * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
        * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="datasafePrivateEndpointId")
    def datasafe_private_endpoint_id(self) -> str:
        """
        The OCID of the Data Safe private endpoint.
        """
        return pulumi.get(self, "datasafe_private_endpoint_id")

    @property
    @pulumi.getter(name="onPremConnectorId")
    def on_prem_connector_id(self) -> str:
        """
        The OCID of the on-premises connector.
        """
        return pulumi.get(self, "on_prem_connector_id")


@pulumi.output_type
class GetTargetDatabasesTargetDatabaseCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 user_name: str):
        """
        :param str password: The password of the database user.
        :param str user_name: The database user name.
        """
        GetTargetDatabasesTargetDatabaseCredentialResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']
        if user_name is None:
            raise TypeError("Missing 'user_name' argument")

        _setter("password", password)
        _setter("user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the database user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        The database user name.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetTargetDatabasesTargetDatabaseDatabaseDetailResult(dict):
    def __init__(__self__, *,
                 autonomous_database_id: str,
                 database_type: str,
                 db_system_id: str,
                 infrastructure_type: str,
                 instance_id: str,
                 ip_addresses: Sequence[str],
                 listener_port: int,
                 service_name: str,
                 vm_cluster_id: str):
        """
        :param str autonomous_database_id: The OCID of the Autonomous Database registered as a target database in Data Safe.
        :param str database_type: A filter to return only target databases that match the specified database type.
        :param str db_system_id: The OCID of the cloud database registered as a target database in Data Safe.
        :param str infrastructure_type: A filter to return only target databases that match the specified infrastructure type.
        :param str instance_id: The OCID of the compute instance on which the database is running.
        :param Sequence[str] ip_addresses: The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        :param int listener_port: The port number of the database listener.
        :param str service_name: The service name of the database registered as target database.
        :param str vm_cluster_id: The OCID of the VM cluster in which the database is running.
        """
        GetTargetDatabasesTargetDatabaseDatabaseDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_database_id=autonomous_database_id,
            database_type=database_type,
            db_system_id=db_system_id,
            infrastructure_type=infrastructure_type,
            instance_id=instance_id,
            ip_addresses=ip_addresses,
            listener_port=listener_port,
            service_name=service_name,
            vm_cluster_id=vm_cluster_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_database_id: Optional[str] = None,
             database_type: Optional[str] = None,
             db_system_id: Optional[str] = None,
             infrastructure_type: Optional[str] = None,
             instance_id: Optional[str] = None,
             ip_addresses: Optional[Sequence[str]] = None,
             listener_port: Optional[int] = None,
             service_name: Optional[str] = None,
             vm_cluster_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if autonomous_database_id is None and 'autonomousDatabaseId' in kwargs:
            autonomous_database_id = kwargs['autonomousDatabaseId']
        if autonomous_database_id is None:
            raise TypeError("Missing 'autonomous_database_id' argument")
        if database_type is None and 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if database_type is None:
            raise TypeError("Missing 'database_type' argument")
        if db_system_id is None and 'dbSystemId' in kwargs:
            db_system_id = kwargs['dbSystemId']
        if db_system_id is None:
            raise TypeError("Missing 'db_system_id' argument")
        if infrastructure_type is None and 'infrastructureType' in kwargs:
            infrastructure_type = kwargs['infrastructureType']
        if infrastructure_type is None:
            raise TypeError("Missing 'infrastructure_type' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if ip_addresses is None and 'ipAddresses' in kwargs:
            ip_addresses = kwargs['ipAddresses']
        if ip_addresses is None:
            raise TypeError("Missing 'ip_addresses' argument")
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if listener_port is None:
            raise TypeError("Missing 'listener_port' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")
        if vm_cluster_id is None and 'vmClusterId' in kwargs:
            vm_cluster_id = kwargs['vmClusterId']
        if vm_cluster_id is None:
            raise TypeError("Missing 'vm_cluster_id' argument")

        _setter("autonomous_database_id", autonomous_database_id)
        _setter("database_type", database_type)
        _setter("db_system_id", db_system_id)
        _setter("infrastructure_type", infrastructure_type)
        _setter("instance_id", instance_id)
        _setter("ip_addresses", ip_addresses)
        _setter("listener_port", listener_port)
        _setter("service_name", service_name)
        _setter("vm_cluster_id", vm_cluster_id)

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> str:
        """
        The OCID of the Autonomous Database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        A filter to return only target databases that match the specified database type.
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The OCID of the cloud database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> str:
        """
        A filter to return only target databases that match the specified infrastructure type.
        """
        return pulumi.get(self, "infrastructure_type")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        The list of database host IP Addresses. Fully qualified domain names can be used if connectionType is 'ONPREM_CONNECTOR'.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        """
        The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> str:
        """
        The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class GetTargetDatabasesTargetDatabaseTlsConfigResult(dict):
    def __init__(__self__, *,
                 certificate_store_type: str,
                 key_store_content: str,
                 status: str,
                 store_password: str,
                 trust_store_content: str):
        """
        :param str certificate_store_type: The format of the certificate store.
        :param str key_store_content: Base64 encoded string of key store file content.
        :param str status: Status to represent whether the database connection is TLS enabled or not.
        :param str store_password: The password to read the trust store and key store files, if they are password protected.
        :param str trust_store_content: Base64 encoded string of trust store file content.
        """
        GetTargetDatabasesTargetDatabaseTlsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_store_type=certificate_store_type,
            key_store_content=key_store_content,
            status=status,
            store_password=store_password,
            trust_store_content=trust_store_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_store_type: Optional[str] = None,
             key_store_content: Optional[str] = None,
             status: Optional[str] = None,
             store_password: Optional[str] = None,
             trust_store_content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_store_type is None and 'certificateStoreType' in kwargs:
            certificate_store_type = kwargs['certificateStoreType']
        if certificate_store_type is None:
            raise TypeError("Missing 'certificate_store_type' argument")
        if key_store_content is None and 'keyStoreContent' in kwargs:
            key_store_content = kwargs['keyStoreContent']
        if key_store_content is None:
            raise TypeError("Missing 'key_store_content' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if store_password is None and 'storePassword' in kwargs:
            store_password = kwargs['storePassword']
        if store_password is None:
            raise TypeError("Missing 'store_password' argument")
        if trust_store_content is None and 'trustStoreContent' in kwargs:
            trust_store_content = kwargs['trustStoreContent']
        if trust_store_content is None:
            raise TypeError("Missing 'trust_store_content' argument")

        _setter("certificate_store_type", certificate_store_type)
        _setter("key_store_content", key_store_content)
        _setter("status", status)
        _setter("store_password", store_password)
        _setter("trust_store_content", trust_store_content)

    @property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> str:
        """
        The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> str:
        """
        Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> str:
        """
        The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> str:
        """
        Base64 encoded string of trust store file content.
        """
        return pulumi.get(self, "trust_store_content")


@pulumi.output_type
class GetUserAssessmentComparisonSummaryResult(dict):
    def __init__(__self__, *,
                 baselines: Sequence['outputs.GetUserAssessmentComparisonSummaryBaselineResult'],
                 currents: Sequence['outputs.GetUserAssessmentComparisonSummaryCurrentResult'],
                 status: str):
        GetUserAssessmentComparisonSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baselines=baselines,
            currents=currents,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baselines: Optional[Sequence['outputs.GetUserAssessmentComparisonSummaryBaselineResult']] = None,
             currents: Optional[Sequence['outputs.GetUserAssessmentComparisonSummaryCurrentResult']] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if baselines is None:
            raise TypeError("Missing 'baselines' argument")
        if currents is None:
            raise TypeError("Missing 'currents' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("baselines", baselines)
        _setter("currents", currents)
        _setter("status", status)

    @property
    @pulumi.getter
    def baselines(self) -> Sequence['outputs.GetUserAssessmentComparisonSummaryBaselineResult']:
        return pulumi.get(self, "baselines")

    @property
    @pulumi.getter
    def currents(self) -> Sequence['outputs.GetUserAssessmentComparisonSummaryCurrentResult']:
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetUserAssessmentComparisonSummaryBaselineResult(dict):
    def __init__(__self__, *,
                 target_id: str,
                 user_assessment_id: str):
        """
        :param str user_assessment_id: The OCID of the user assessment.
        """
        GetUserAssessmentComparisonSummaryBaselineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_id=target_id,
            user_assessment_id=user_assessment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']
        if user_assessment_id is None:
            raise TypeError("Missing 'user_assessment_id' argument")

        _setter("target_id", target_id)
        _setter("user_assessment_id", user_assessment_id)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> str:
        """
        The OCID of the user assessment.
        """
        return pulumi.get(self, "user_assessment_id")


@pulumi.output_type
class GetUserAssessmentComparisonSummaryCurrentResult(dict):
    def __init__(__self__, *,
                 target_id: str,
                 user_assessment_id: str):
        """
        :param str user_assessment_id: The OCID of the user assessment.
        """
        GetUserAssessmentComparisonSummaryCurrentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_id=target_id,
            user_assessment_id=user_assessment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']
        if user_assessment_id is None:
            raise TypeError("Missing 'user_assessment_id' argument")

        _setter("target_id", target_id)
        _setter("user_assessment_id", user_assessment_id)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> str:
        """
        The OCID of the user assessment.
        """
        return pulumi.get(self, "user_assessment_id")


@pulumi.output_type
class GetUserAssessmentIgnoredTargetResult(dict):
    def __init__(__self__, *,
                 lifecycle_state: str,
                 target_id: str,
                 user_assessment_id: str):
        """
        :param str user_assessment_id: The OCID of the user assessment.
        """
        GetUserAssessmentIgnoredTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lifecycle_state=lifecycle_state,
            target_id=target_id,
            user_assessment_id=user_assessment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lifecycle_state: Optional[str] = None,
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lifecycle_state is None and 'lifecycleState' in kwargs:
            lifecycle_state = kwargs['lifecycleState']
        if lifecycle_state is None:
            raise TypeError("Missing 'lifecycle_state' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']
        if user_assessment_id is None:
            raise TypeError("Missing 'user_assessment_id' argument")

        _setter("lifecycle_state", lifecycle_state)
        _setter("target_id", target_id)
        _setter("user_assessment_id", user_assessment_id)

    @property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> str:
        return pulumi.get(self, "lifecycle_state")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> str:
        """
        The OCID of the user assessment.
        """
        return pulumi.get(self, "user_assessment_id")


@pulumi.output_type
class GetUserAssessmentProfileAnalyticsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetUserAssessmentProfileAnalyticsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetUserAssessmentProfileAnalyticsProfileAggregationResult(dict):
    def __init__(__self__, *,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 items: Sequence[Any]):
        """
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param Sequence[Any] items: The array of profile aggregation data.
        """
        GetUserAssessmentProfileAnalyticsProfileAggregationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             defined_tags: Optional[Mapping[str, Any]] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             items: Optional[Sequence[Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("items", items)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def items(self) -> Sequence[Any]:
        """
        The array of profile aggregation data.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetUserAssessmentProfilesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetUserAssessmentProfilesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetUserAssessmentProfilesProfileResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 composite_limit: str,
                 connect_time: str,
                 cpu_per_call: str,
                 cpu_per_session: str,
                 defined_tags: Mapping[str, Any],
                 failed_login_attempts: str,
                 freeform_tags: Mapping[str, Any],
                 idle_time: str,
                 inactive_account_time: str,
                 is_user_created: bool,
                 logical_reads_per_call: str,
                 logical_reads_per_session: str,
                 password_grace_time: str,
                 password_life_time: str,
                 password_lock_time: str,
                 password_reuse_max: str,
                 password_reuse_time: str,
                 password_rollover_time: str,
                 password_verification_function: str,
                 password_verification_function_details: str,
                 private_sga: str,
                 profile_name: str,
                 sessions_per_user: str,
                 target_id: str,
                 user_assessment_id: str,
                 user_count: int):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param str composite_limit: Specify the total resource cost for a session, expressed in service units. Oracle Database calculates the total service units as a weighted sum of CPU_PER_SESSION, CONNECT_TIME, LOGICAL_READS_PER_SESSION, and PRIVATE_SGA.
        :param str connect_time: Specify the total elapsed time limit for a session, expressed in minutes.
        :param str cpu_per_call: Specify the CPU time limit for a call (a parse, execute, or fetch), expressed in hundredths of seconds.
        :param str cpu_per_session: Specify the CPU time limit for a session, expressed in hundredth of seconds.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str failed_login_attempts: Maximum times the user is allowed in fail login before the user account is locked.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str idle_time: Specify the permitted periods of continuous inactive time during a  session, expressed in minutes.
        :param str inactive_account_time: The permitted periods of continuous inactive time during a session, expressed in minutes. Long-running queries and other operations are not subjected to this limit.
        :param bool is_user_created: An optional filter to return the user created profiles.
        :param str logical_reads_per_call: Specify the permitted the number of data blocks read for a call to process a SQL statement (a parse, execute, or fetch).
        :param str logical_reads_per_session: Specify the permitted number of data blocks read in a session, including blocks read from memory and disk.
        :param str password_grace_time: Number of grace days for user to change password.
        :param str password_life_time: Number of days the password is valid before expiry.
        :param str password_lock_time: Number of days the user account remains locked after failed login.
        :param str password_reuse_max: Number of day after the user can use the already used password.
        :param str password_reuse_time: Number of days before which a password cannot be reused.
        :param str password_rollover_time: Number of days the password rollover is allowed. Minimum value can be 1/24 day (1 hour) to 60 days.
        :param str password_verification_function: An optional filter to filter the profiles based on password verification function.
        :param str password_verification_function_details: Details about the PL/SQL that can be used for password verification.
        :param str private_sga: Specify the amount of private space a session can allocate in the shared pool of the system global area (SGA), expressed in bytes.
        :param str profile_name: A filter to return only items that match the specified profile name.
        :param str sessions_per_user: Specify the number of concurrent sessions to which you want to limit the user.
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str user_assessment_id: The OCID of the user assessment.
        :param int user_count: The number of users having a given profile.
        """
        GetUserAssessmentProfilesProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            composite_limit=composite_limit,
            connect_time=connect_time,
            cpu_per_call=cpu_per_call,
            cpu_per_session=cpu_per_session,
            defined_tags=defined_tags,
            failed_login_attempts=failed_login_attempts,
            freeform_tags=freeform_tags,
            idle_time=idle_time,
            inactive_account_time=inactive_account_time,
            is_user_created=is_user_created,
            logical_reads_per_call=logical_reads_per_call,
            logical_reads_per_session=logical_reads_per_session,
            password_grace_time=password_grace_time,
            password_life_time=password_life_time,
            password_lock_time=password_lock_time,
            password_reuse_max=password_reuse_max,
            password_reuse_time=password_reuse_time,
            password_rollover_time=password_rollover_time,
            password_verification_function=password_verification_function,
            password_verification_function_details=password_verification_function_details,
            private_sga=private_sga,
            profile_name=profile_name,
            sessions_per_user=sessions_per_user,
            target_id=target_id,
            user_assessment_id=user_assessment_id,
            user_count=user_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             composite_limit: Optional[str] = None,
             connect_time: Optional[str] = None,
             cpu_per_call: Optional[str] = None,
             cpu_per_session: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             failed_login_attempts: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             idle_time: Optional[str] = None,
             inactive_account_time: Optional[str] = None,
             is_user_created: Optional[bool] = None,
             logical_reads_per_call: Optional[str] = None,
             logical_reads_per_session: Optional[str] = None,
             password_grace_time: Optional[str] = None,
             password_life_time: Optional[str] = None,
             password_lock_time: Optional[str] = None,
             password_reuse_max: Optional[str] = None,
             password_reuse_time: Optional[str] = None,
             password_rollover_time: Optional[str] = None,
             password_verification_function: Optional[str] = None,
             password_verification_function_details: Optional[str] = None,
             private_sga: Optional[str] = None,
             profile_name: Optional[str] = None,
             sessions_per_user: Optional[str] = None,
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             user_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if composite_limit is None and 'compositeLimit' in kwargs:
            composite_limit = kwargs['compositeLimit']
        if composite_limit is None:
            raise TypeError("Missing 'composite_limit' argument")
        if connect_time is None and 'connectTime' in kwargs:
            connect_time = kwargs['connectTime']
        if connect_time is None:
            raise TypeError("Missing 'connect_time' argument")
        if cpu_per_call is None and 'cpuPerCall' in kwargs:
            cpu_per_call = kwargs['cpuPerCall']
        if cpu_per_call is None:
            raise TypeError("Missing 'cpu_per_call' argument")
        if cpu_per_session is None and 'cpuPerSession' in kwargs:
            cpu_per_session = kwargs['cpuPerSession']
        if cpu_per_session is None:
            raise TypeError("Missing 'cpu_per_session' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if failed_login_attempts is None and 'failedLoginAttempts' in kwargs:
            failed_login_attempts = kwargs['failedLoginAttempts']
        if failed_login_attempts is None:
            raise TypeError("Missing 'failed_login_attempts' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if idle_time is None and 'idleTime' in kwargs:
            idle_time = kwargs['idleTime']
        if idle_time is None:
            raise TypeError("Missing 'idle_time' argument")
        if inactive_account_time is None and 'inactiveAccountTime' in kwargs:
            inactive_account_time = kwargs['inactiveAccountTime']
        if inactive_account_time is None:
            raise TypeError("Missing 'inactive_account_time' argument")
        if is_user_created is None and 'isUserCreated' in kwargs:
            is_user_created = kwargs['isUserCreated']
        if is_user_created is None:
            raise TypeError("Missing 'is_user_created' argument")
        if logical_reads_per_call is None and 'logicalReadsPerCall' in kwargs:
            logical_reads_per_call = kwargs['logicalReadsPerCall']
        if logical_reads_per_call is None:
            raise TypeError("Missing 'logical_reads_per_call' argument")
        if logical_reads_per_session is None and 'logicalReadsPerSession' in kwargs:
            logical_reads_per_session = kwargs['logicalReadsPerSession']
        if logical_reads_per_session is None:
            raise TypeError("Missing 'logical_reads_per_session' argument")
        if password_grace_time is None and 'passwordGraceTime' in kwargs:
            password_grace_time = kwargs['passwordGraceTime']
        if password_grace_time is None:
            raise TypeError("Missing 'password_grace_time' argument")
        if password_life_time is None and 'passwordLifeTime' in kwargs:
            password_life_time = kwargs['passwordLifeTime']
        if password_life_time is None:
            raise TypeError("Missing 'password_life_time' argument")
        if password_lock_time is None and 'passwordLockTime' in kwargs:
            password_lock_time = kwargs['passwordLockTime']
        if password_lock_time is None:
            raise TypeError("Missing 'password_lock_time' argument")
        if password_reuse_max is None and 'passwordReuseMax' in kwargs:
            password_reuse_max = kwargs['passwordReuseMax']
        if password_reuse_max is None:
            raise TypeError("Missing 'password_reuse_max' argument")
        if password_reuse_time is None and 'passwordReuseTime' in kwargs:
            password_reuse_time = kwargs['passwordReuseTime']
        if password_reuse_time is None:
            raise TypeError("Missing 'password_reuse_time' argument")
        if password_rollover_time is None and 'passwordRolloverTime' in kwargs:
            password_rollover_time = kwargs['passwordRolloverTime']
        if password_rollover_time is None:
            raise TypeError("Missing 'password_rollover_time' argument")
        if password_verification_function is None and 'passwordVerificationFunction' in kwargs:
            password_verification_function = kwargs['passwordVerificationFunction']
        if password_verification_function is None:
            raise TypeError("Missing 'password_verification_function' argument")
        if password_verification_function_details is None and 'passwordVerificationFunctionDetails' in kwargs:
            password_verification_function_details = kwargs['passwordVerificationFunctionDetails']
        if password_verification_function_details is None:
            raise TypeError("Missing 'password_verification_function_details' argument")
        if private_sga is None and 'privateSga' in kwargs:
            private_sga = kwargs['privateSga']
        if private_sga is None:
            raise TypeError("Missing 'private_sga' argument")
        if profile_name is None and 'profileName' in kwargs:
            profile_name = kwargs['profileName']
        if profile_name is None:
            raise TypeError("Missing 'profile_name' argument")
        if sessions_per_user is None and 'sessionsPerUser' in kwargs:
            sessions_per_user = kwargs['sessionsPerUser']
        if sessions_per_user is None:
            raise TypeError("Missing 'sessions_per_user' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']
        if user_assessment_id is None:
            raise TypeError("Missing 'user_assessment_id' argument")
        if user_count is None and 'userCount' in kwargs:
            user_count = kwargs['userCount']
        if user_count is None:
            raise TypeError("Missing 'user_count' argument")

        _setter("compartment_id", compartment_id)
        _setter("composite_limit", composite_limit)
        _setter("connect_time", connect_time)
        _setter("cpu_per_call", cpu_per_call)
        _setter("cpu_per_session", cpu_per_session)
        _setter("defined_tags", defined_tags)
        _setter("failed_login_attempts", failed_login_attempts)
        _setter("freeform_tags", freeform_tags)
        _setter("idle_time", idle_time)
        _setter("inactive_account_time", inactive_account_time)
        _setter("is_user_created", is_user_created)
        _setter("logical_reads_per_call", logical_reads_per_call)
        _setter("logical_reads_per_session", logical_reads_per_session)
        _setter("password_grace_time", password_grace_time)
        _setter("password_life_time", password_life_time)
        _setter("password_lock_time", password_lock_time)
        _setter("password_reuse_max", password_reuse_max)
        _setter("password_reuse_time", password_reuse_time)
        _setter("password_rollover_time", password_rollover_time)
        _setter("password_verification_function", password_verification_function)
        _setter("password_verification_function_details", password_verification_function_details)
        _setter("private_sga", private_sga)
        _setter("profile_name", profile_name)
        _setter("sessions_per_user", sessions_per_user)
        _setter("target_id", target_id)
        _setter("user_assessment_id", user_assessment_id)
        _setter("user_count", user_count)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="compositeLimit")
    def composite_limit(self) -> str:
        """
        Specify the total resource cost for a session, expressed in service units. Oracle Database calculates the total service units as a weighted sum of CPU_PER_SESSION, CONNECT_TIME, LOGICAL_READS_PER_SESSION, and PRIVATE_SGA.
        """
        return pulumi.get(self, "composite_limit")

    @property
    @pulumi.getter(name="connectTime")
    def connect_time(self) -> str:
        """
        Specify the total elapsed time limit for a session, expressed in minutes.
        """
        return pulumi.get(self, "connect_time")

    @property
    @pulumi.getter(name="cpuPerCall")
    def cpu_per_call(self) -> str:
        """
        Specify the CPU time limit for a call (a parse, execute, or fetch), expressed in hundredths of seconds.
        """
        return pulumi.get(self, "cpu_per_call")

    @property
    @pulumi.getter(name="cpuPerSession")
    def cpu_per_session(self) -> str:
        """
        Specify the CPU time limit for a session, expressed in hundredth of seconds.
        """
        return pulumi.get(self, "cpu_per_session")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="failedLoginAttempts")
    def failed_login_attempts(self) -> str:
        """
        Maximum times the user is allowed in fail login before the user account is locked.
        """
        return pulumi.get(self, "failed_login_attempts")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="idleTime")
    def idle_time(self) -> str:
        """
        Specify the permitted periods of continuous inactive time during a  session, expressed in minutes.
        """
        return pulumi.get(self, "idle_time")

    @property
    @pulumi.getter(name="inactiveAccountTime")
    def inactive_account_time(self) -> str:
        """
        The permitted periods of continuous inactive time during a session, expressed in minutes. Long-running queries and other operations are not subjected to this limit.
        """
        return pulumi.get(self, "inactive_account_time")

    @property
    @pulumi.getter(name="isUserCreated")
    def is_user_created(self) -> bool:
        """
        An optional filter to return the user created profiles.
        """
        return pulumi.get(self, "is_user_created")

    @property
    @pulumi.getter(name="logicalReadsPerCall")
    def logical_reads_per_call(self) -> str:
        """
        Specify the permitted the number of data blocks read for a call to process a SQL statement (a parse, execute, or fetch).
        """
        return pulumi.get(self, "logical_reads_per_call")

    @property
    @pulumi.getter(name="logicalReadsPerSession")
    def logical_reads_per_session(self) -> str:
        """
        Specify the permitted number of data blocks read in a session, including blocks read from memory and disk.
        """
        return pulumi.get(self, "logical_reads_per_session")

    @property
    @pulumi.getter(name="passwordGraceTime")
    def password_grace_time(self) -> str:
        """
        Number of grace days for user to change password.
        """
        return pulumi.get(self, "password_grace_time")

    @property
    @pulumi.getter(name="passwordLifeTime")
    def password_life_time(self) -> str:
        """
        Number of days the password is valid before expiry.
        """
        return pulumi.get(self, "password_life_time")

    @property
    @pulumi.getter(name="passwordLockTime")
    def password_lock_time(self) -> str:
        """
        Number of days the user account remains locked after failed login.
        """
        return pulumi.get(self, "password_lock_time")

    @property
    @pulumi.getter(name="passwordReuseMax")
    def password_reuse_max(self) -> str:
        """
        Number of day after the user can use the already used password.
        """
        return pulumi.get(self, "password_reuse_max")

    @property
    @pulumi.getter(name="passwordReuseTime")
    def password_reuse_time(self) -> str:
        """
        Number of days before which a password cannot be reused.
        """
        return pulumi.get(self, "password_reuse_time")

    @property
    @pulumi.getter(name="passwordRolloverTime")
    def password_rollover_time(self) -> str:
        """
        Number of days the password rollover is allowed. Minimum value can be 1/24 day (1 hour) to 60 days.
        """
        return pulumi.get(self, "password_rollover_time")

    @property
    @pulumi.getter(name="passwordVerificationFunction")
    def password_verification_function(self) -> str:
        """
        An optional filter to filter the profiles based on password verification function.
        """
        return pulumi.get(self, "password_verification_function")

    @property
    @pulumi.getter(name="passwordVerificationFunctionDetails")
    def password_verification_function_details(self) -> str:
        """
        Details about the PL/SQL that can be used for password verification.
        """
        return pulumi.get(self, "password_verification_function_details")

    @property
    @pulumi.getter(name="privateSga")
    def private_sga(self) -> str:
        """
        Specify the amount of private space a session can allocate in the shared pool of the system global area (SGA), expressed in bytes.
        """
        return pulumi.get(self, "private_sga")

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> str:
        """
        A filter to return only items that match the specified profile name.
        """
        return pulumi.get(self, "profile_name")

    @property
    @pulumi.getter(name="sessionsPerUser")
    def sessions_per_user(self) -> str:
        """
        Specify the number of concurrent sessions to which you want to limit the user.
        """
        return pulumi.get(self, "sessions_per_user")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> str:
        """
        The OCID of the user assessment.
        """
        return pulumi.get(self, "user_assessment_id")

    @property
    @pulumi.getter(name="userCount")
    def user_count(self) -> int:
        """
        The number of users having a given profile.
        """
        return pulumi.get(self, "user_count")


@pulumi.output_type
class GetUserAssessmentUserAnalyticsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetUserAssessmentUserAnalyticsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetUserAssessmentUserAnalyticsUserAggregationResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetUserAssessmentUserAnalyticsUserAggregationItemResult']):
        """
        :param Sequence['GetUserAssessmentUserAnalyticsUserAggregationItemArgs'] items: The array of user aggregation data.
        """
        GetUserAssessmentUserAnalyticsUserAggregationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetUserAssessmentUserAnalyticsUserAggregationItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetUserAssessmentUserAnalyticsUserAggregationItemResult']:
        """
        The array of user aggregation data.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetUserAssessmentUserAnalyticsUserAggregationItemResult(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class GetUserAssessmentUsersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetUserAssessmentUsersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetUserAssessmentUsersUserResult(dict):
    def __init__(__self__, *,
                 account_status: str,
                 admin_roles: Sequence[str],
                 authentication_type: str,
                 key: str,
                 target_id: str,
                 time_last_login: str,
                 time_password_changed: str,
                 time_user_created: str,
                 user_category: str,
                 user_name: str,
                 user_profile: str,
                 user_types: Sequence[str]):
        """
        :param str account_status: A filter to return only items that match the specified account status.
        :param Sequence[str] admin_roles: The admin roles granted to the user.
        :param str authentication_type: A filter to return only items that match the specified authentication type.
        :param str key: The unique user key. This is a system-generated identifier. Use ListUsers to get the user key for a user.
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param str time_last_login: The date and time when the user last logged in, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_password_changed: The date and time when the user password was last changed, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_user_created: The date and time when the user was created in the database, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str user_category: A filter to return only items that match the specified user category.
        :param str user_name: A filter to return only items that match the specified user name.
        :param str user_profile: A filter to return only items that match the specified user profile.
        :param Sequence[str] user_types: The user type, which can be a combination of the following:
        """
        GetUserAssessmentUsersUserResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_status=account_status,
            admin_roles=admin_roles,
            authentication_type=authentication_type,
            key=key,
            target_id=target_id,
            time_last_login=time_last_login,
            time_password_changed=time_password_changed,
            time_user_created=time_user_created,
            user_category=user_category,
            user_name=user_name,
            user_profile=user_profile,
            user_types=user_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_status: Optional[str] = None,
             admin_roles: Optional[Sequence[str]] = None,
             authentication_type: Optional[str] = None,
             key: Optional[str] = None,
             target_id: Optional[str] = None,
             time_last_login: Optional[str] = None,
             time_password_changed: Optional[str] = None,
             time_user_created: Optional[str] = None,
             user_category: Optional[str] = None,
             user_name: Optional[str] = None,
             user_profile: Optional[str] = None,
             user_types: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_status is None and 'accountStatus' in kwargs:
            account_status = kwargs['accountStatus']
        if account_status is None:
            raise TypeError("Missing 'account_status' argument")
        if admin_roles is None and 'adminRoles' in kwargs:
            admin_roles = kwargs['adminRoles']
        if admin_roles is None:
            raise TypeError("Missing 'admin_roles' argument")
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if time_last_login is None and 'timeLastLogin' in kwargs:
            time_last_login = kwargs['timeLastLogin']
        if time_last_login is None:
            raise TypeError("Missing 'time_last_login' argument")
        if time_password_changed is None and 'timePasswordChanged' in kwargs:
            time_password_changed = kwargs['timePasswordChanged']
        if time_password_changed is None:
            raise TypeError("Missing 'time_password_changed' argument")
        if time_user_created is None and 'timeUserCreated' in kwargs:
            time_user_created = kwargs['timeUserCreated']
        if time_user_created is None:
            raise TypeError("Missing 'time_user_created' argument")
        if user_category is None and 'userCategory' in kwargs:
            user_category = kwargs['userCategory']
        if user_category is None:
            raise TypeError("Missing 'user_category' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']
        if user_name is None:
            raise TypeError("Missing 'user_name' argument")
        if user_profile is None and 'userProfile' in kwargs:
            user_profile = kwargs['userProfile']
        if user_profile is None:
            raise TypeError("Missing 'user_profile' argument")
        if user_types is None and 'userTypes' in kwargs:
            user_types = kwargs['userTypes']
        if user_types is None:
            raise TypeError("Missing 'user_types' argument")

        _setter("account_status", account_status)
        _setter("admin_roles", admin_roles)
        _setter("authentication_type", authentication_type)
        _setter("key", key)
        _setter("target_id", target_id)
        _setter("time_last_login", time_last_login)
        _setter("time_password_changed", time_password_changed)
        _setter("time_user_created", time_user_created)
        _setter("user_category", user_category)
        _setter("user_name", user_name)
        _setter("user_profile", user_profile)
        _setter("user_types", user_types)

    @property
    @pulumi.getter(name="accountStatus")
    def account_status(self) -> str:
        """
        A filter to return only items that match the specified account status.
        """
        return pulumi.get(self, "account_status")

    @property
    @pulumi.getter(name="adminRoles")
    def admin_roles(self) -> Sequence[str]:
        """
        The admin roles granted to the user.
        """
        return pulumi.get(self, "admin_roles")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        A filter to return only items that match the specified authentication type.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique user key. This is a system-generated identifier. Use ListUsers to get the user key for a user.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="timeLastLogin")
    def time_last_login(self) -> str:
        """
        The date and time when the user last logged in, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_last_login")

    @property
    @pulumi.getter(name="timePasswordChanged")
    def time_password_changed(self) -> str:
        """
        The date and time when the user password was last changed, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_password_changed")

    @property
    @pulumi.getter(name="timeUserCreated")
    def time_user_created(self) -> str:
        """
        The date and time when the user was created in the database, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_user_created")

    @property
    @pulumi.getter(name="userCategory")
    def user_category(self) -> str:
        """
        A filter to return only items that match the specified user category.
        """
        return pulumi.get(self, "user_category")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        A filter to return only items that match the specified user name.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userProfile")
    def user_profile(self) -> str:
        """
        A filter to return only items that match the specified user profile.
        """
        return pulumi.get(self, "user_profile")

    @property
    @pulumi.getter(name="userTypes")
    def user_types(self) -> Sequence[str]:
        """
        The user type, which can be a combination of the following:
        """
        return pulumi.get(self, "user_types")


@pulumi.output_type
class GetUserAssessmentsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetUserAssessmentsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetUserAssessmentsIgnoredTargetResult(dict):
    def __init__(__self__, *,
                 lifecycle_state: str,
                 target_id: str,
                 user_assessment_id: str):
        """
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetUserAssessmentsIgnoredTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lifecycle_state=lifecycle_state,
            target_id=target_id,
            user_assessment_id=user_assessment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lifecycle_state: Optional[str] = None,
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lifecycle_state is None and 'lifecycleState' in kwargs:
            lifecycle_state = kwargs['lifecycleState']
        if lifecycle_state is None:
            raise TypeError("Missing 'lifecycle_state' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']
        if user_assessment_id is None:
            raise TypeError("Missing 'user_assessment_id' argument")

        _setter("lifecycle_state", lifecycle_state)
        _setter("target_id", target_id)
        _setter("user_assessment_id", user_assessment_id)

    @property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> str:
        return pulumi.get(self, "lifecycle_state")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> str:
        return pulumi.get(self, "user_assessment_id")


@pulumi.output_type
class GetUserAssessmentsUserAssessmentResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 ignored_assessment_ids: Sequence[str],
                 ignored_targets: Sequence['outputs.GetUserAssessmentsUserAssessmentIgnoredTargetResult'],
                 is_baseline: bool,
                 is_deviated_from_baseline: bool,
                 last_compared_baseline_id: str,
                 lifecycle_details: str,
                 schedule: str,
                 schedule_assessment_id: str,
                 state: str,
                 statistics: str,
                 system_tags: Mapping[str, Any],
                 target_id: str,
                 target_ids: Sequence[str],
                 time_created: str,
                 time_last_assessed: str,
                 time_updated: str,
                 triggered_by: str,
                 type: str):
        """
        :param str compartment_id: A filter to return only resources that match the specified compartment OCID.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        :param str description: The description of the user assessment.
        :param str display_name: A filter to return only resources that match the specified display name.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the user assessment.
        :param Sequence[str] ignored_assessment_ids: List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        :param Sequence['GetUserAssessmentsUserAssessmentIgnoredTargetArgs'] ignored_targets: List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        :param bool is_baseline: A filter to return only user assessments that are set as baseline.
        :param bool is_deviated_from_baseline: Indicates if the user assessment deviates from the baseline.
        :param str last_compared_baseline_id: The OCID of the last user assessment baseline against which the latest assessment was compared.
        :param str lifecycle_details: Details about the current state of the user assessment.
        :param str schedule: Schedule of the assessment that runs periodically in this specified format: <version-string>;<version-specific-schedule>
        :param str schedule_assessment_id: The OCID of the user assessment that is responsible for creating this scheduled save assessment.
        :param str state: The current state of the user assessment.
        :param str statistics: Map that contains maps of values. Example: `{"Operations": {"CostCenter": "42"}}`
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str target_id: A filter to return only items related to a specific target OCID.
        :param Sequence[str] target_ids: Array of database target OCIDs.
        :param str time_created: The date and time when the user assessment was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_last_assessed: The date and time the user assessment was last run, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str time_updated: The last date and time when the user assessment was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param str triggered_by: A filter to return user assessments that were created by either the system or by a user only.
        :param str type: A filter to return only items that match the specified assessment type.
        """
        GetUserAssessmentsUserAssessmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            ignored_assessment_ids=ignored_assessment_ids,
            ignored_targets=ignored_targets,
            is_baseline=is_baseline,
            is_deviated_from_baseline=is_deviated_from_baseline,
            last_compared_baseline_id=last_compared_baseline_id,
            lifecycle_details=lifecycle_details,
            schedule=schedule,
            schedule_assessment_id=schedule_assessment_id,
            state=state,
            statistics=statistics,
            system_tags=system_tags,
            target_id=target_id,
            target_ids=target_ids,
            time_created=time_created,
            time_last_assessed=time_last_assessed,
            time_updated=time_updated,
            triggered_by=triggered_by,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             ignored_assessment_ids: Optional[Sequence[str]] = None,
             ignored_targets: Optional[Sequence['outputs.GetUserAssessmentsUserAssessmentIgnoredTargetResult']] = None,
             is_baseline: Optional[bool] = None,
             is_deviated_from_baseline: Optional[bool] = None,
             last_compared_baseline_id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             schedule: Optional[str] = None,
             schedule_assessment_id: Optional[str] = None,
             state: Optional[str] = None,
             statistics: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             target_id: Optional[str] = None,
             target_ids: Optional[Sequence[str]] = None,
             time_created: Optional[str] = None,
             time_last_assessed: Optional[str] = None,
             time_updated: Optional[str] = None,
             triggered_by: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ignored_assessment_ids is None and 'ignoredAssessmentIds' in kwargs:
            ignored_assessment_ids = kwargs['ignoredAssessmentIds']
        if ignored_assessment_ids is None:
            raise TypeError("Missing 'ignored_assessment_ids' argument")
        if ignored_targets is None and 'ignoredTargets' in kwargs:
            ignored_targets = kwargs['ignoredTargets']
        if ignored_targets is None:
            raise TypeError("Missing 'ignored_targets' argument")
        if is_baseline is None and 'isBaseline' in kwargs:
            is_baseline = kwargs['isBaseline']
        if is_baseline is None:
            raise TypeError("Missing 'is_baseline' argument")
        if is_deviated_from_baseline is None and 'isDeviatedFromBaseline' in kwargs:
            is_deviated_from_baseline = kwargs['isDeviatedFromBaseline']
        if is_deviated_from_baseline is None:
            raise TypeError("Missing 'is_deviated_from_baseline' argument")
        if last_compared_baseline_id is None and 'lastComparedBaselineId' in kwargs:
            last_compared_baseline_id = kwargs['lastComparedBaselineId']
        if last_compared_baseline_id is None:
            raise TypeError("Missing 'last_compared_baseline_id' argument")
        if lifecycle_details is None and 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if lifecycle_details is None:
            raise TypeError("Missing 'lifecycle_details' argument")
        if schedule is None:
            raise TypeError("Missing 'schedule' argument")
        if schedule_assessment_id is None and 'scheduleAssessmentId' in kwargs:
            schedule_assessment_id = kwargs['scheduleAssessmentId']
        if schedule_assessment_id is None:
            raise TypeError("Missing 'schedule_assessment_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if target_ids is None and 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if target_ids is None:
            raise TypeError("Missing 'target_ids' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_last_assessed is None and 'timeLastAssessed' in kwargs:
            time_last_assessed = kwargs['timeLastAssessed']
        if time_last_assessed is None:
            raise TypeError("Missing 'time_last_assessed' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if triggered_by is None and 'triggeredBy' in kwargs:
            triggered_by = kwargs['triggeredBy']
        if triggered_by is None:
            raise TypeError("Missing 'triggered_by' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("ignored_assessment_ids", ignored_assessment_ids)
        _setter("ignored_targets", ignored_targets)
        _setter("is_baseline", is_baseline)
        _setter("is_deviated_from_baseline", is_deviated_from_baseline)
        _setter("last_compared_baseline_id", last_compared_baseline_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("schedule", schedule)
        _setter("schedule_assessment_id", schedule_assessment_id)
        _setter("state", state)
        _setter("statistics", statistics)
        _setter("system_tags", system_tags)
        _setter("target_id", target_id)
        _setter("target_ids", target_ids)
        _setter("time_created", time_created)
        _setter("time_last_assessed", time_last_assessed)
        _setter("time_updated", time_updated)
        _setter("triggered_by", triggered_by)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that match the specified compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the user assessment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the specified display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm)  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the user assessment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoredAssessmentIds")
    def ignored_assessment_ids(self) -> Sequence[str]:
        """
        List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        """
        return pulumi.get(self, "ignored_assessment_ids")

    @property
    @pulumi.getter(name="ignoredTargets")
    def ignored_targets(self) -> Sequence['outputs.GetUserAssessmentsUserAssessmentIgnoredTargetResult']:
        """
        List containing maps as values. Example: `{"Operations": [ {"CostCenter": "42"} ] }`
        """
        return pulumi.get(self, "ignored_targets")

    @property
    @pulumi.getter(name="isBaseline")
    def is_baseline(self) -> bool:
        """
        A filter to return only user assessments that are set as baseline.
        """
        return pulumi.get(self, "is_baseline")

    @property
    @pulumi.getter(name="isDeviatedFromBaseline")
    def is_deviated_from_baseline(self) -> bool:
        """
        Indicates if the user assessment deviates from the baseline.
        """
        return pulumi.get(self, "is_deviated_from_baseline")

    @property
    @pulumi.getter(name="lastComparedBaselineId")
    def last_compared_baseline_id(self) -> str:
        """
        The OCID of the last user assessment baseline against which the latest assessment was compared.
        """
        return pulumi.get(self, "last_compared_baseline_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Details about the current state of the user assessment.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Schedule of the assessment that runs periodically in this specified format: <version-string>;<version-specific-schedule>
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="scheduleAssessmentId")
    def schedule_assessment_id(self) -> str:
        """
        The OCID of the user assessment that is responsible for creating this scheduled save assessment.
        """
        return pulumi.get(self, "schedule_assessment_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the user assessment.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        Map that contains maps of values. Example: `{"Operations": {"CostCenter": "42"}}`
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        Array of database target OCIDs.
        """
        return pulumi.get(self, "target_ids")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time when the user assessment was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastAssessed")
    def time_last_assessed(self) -> str:
        """
        The date and time the user assessment was last run, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_last_assessed")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The last date and time when the user assessment was updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="triggeredBy")
    def triggered_by(self) -> str:
        """
        A filter to return user assessments that were created by either the system or by a user only.
        """
        return pulumi.get(self, "triggered_by")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A filter to return only items that match the specified assessment type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetUserAssessmentsUserAssessmentIgnoredTargetResult(dict):
    def __init__(__self__, *,
                 lifecycle_state: str,
                 target_id: str,
                 user_assessment_id: str):
        """
        :param str target_id: A filter to return only items related to a specific target OCID.
        """
        GetUserAssessmentsUserAssessmentIgnoredTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lifecycle_state=lifecycle_state,
            target_id=target_id,
            user_assessment_id=user_assessment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lifecycle_state: Optional[str] = None,
             target_id: Optional[str] = None,
             user_assessment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lifecycle_state is None and 'lifecycleState' in kwargs:
            lifecycle_state = kwargs['lifecycleState']
        if lifecycle_state is None:
            raise TypeError("Missing 'lifecycle_state' argument")
        if target_id is None and 'targetId' in kwargs:
            target_id = kwargs['targetId']
        if target_id is None:
            raise TypeError("Missing 'target_id' argument")
        if user_assessment_id is None and 'userAssessmentId' in kwargs:
            user_assessment_id = kwargs['userAssessmentId']
        if user_assessment_id is None:
            raise TypeError("Missing 'user_assessment_id' argument")

        _setter("lifecycle_state", lifecycle_state)
        _setter("target_id", target_id)
        _setter("user_assessment_id", user_assessment_id)

    @property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> str:
        return pulumi.get(self, "lifecycle_state")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        A filter to return only items related to a specific target OCID.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter(name="userAssessmentId")
    def user_assessment_id(self) -> str:
        return pulumi.get(self, "user_assessment_id")


