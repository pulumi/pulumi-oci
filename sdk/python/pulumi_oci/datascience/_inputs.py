# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'JobJobConfigurationDetailsArgs',
    'JobJobConfigurationDetailsArgsDict',
    'JobJobConfigurationDetailsStartupProbeDetailsArgs',
    'JobJobConfigurationDetailsStartupProbeDetailsArgsDict',
    'JobJobEnvironmentConfigurationDetailsArgs',
    'JobJobEnvironmentConfigurationDetailsArgsDict',
    'JobJobInfrastructureConfigurationDetailsArgs',
    'JobJobInfrastructureConfigurationDetailsArgsDict',
    'JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs',
    'JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict',
    'JobJobLogConfigurationDetailsArgs',
    'JobJobLogConfigurationDetailsArgsDict',
    'JobJobNodeConfigurationDetailsArgs',
    'JobJobNodeConfigurationDetailsArgsDict',
    'JobJobNodeConfigurationDetailsJobNetworkConfigurationArgs',
    'JobJobNodeConfigurationDetailsJobNetworkConfigurationArgsDict',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgs',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgsDict',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs',
    'JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict',
    'JobJobStorageMountConfigurationDetailsListArgs',
    'JobJobStorageMountConfigurationDetailsListArgsDict',
    'JobRunJobConfigurationOverrideDetailsArgs',
    'JobRunJobConfigurationOverrideDetailsArgsDict',
    'JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgs',
    'JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgsDict',
    'JobRunJobEnvironmentConfigurationOverrideDetailsArgs',
    'JobRunJobEnvironmentConfigurationOverrideDetailsArgsDict',
    'JobRunJobInfrastructureConfigurationDetailArgs',
    'JobRunJobInfrastructureConfigurationDetailArgsDict',
    'JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgs',
    'JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgsDict',
    'JobRunJobInfrastructureConfigurationOverrideDetailsArgs',
    'JobRunJobInfrastructureConfigurationOverrideDetailsArgsDict',
    'JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgs',
    'JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgsDict',
    'JobRunJobLogConfigurationOverrideDetailsArgs',
    'JobRunJobLogConfigurationOverrideDetailsArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsArgs',
    'JobRunJobNodeConfigurationOverrideDetailsArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs',
    'JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict',
    'JobRunJobStorageMountConfigurationDetailsListArgs',
    'JobRunJobStorageMountConfigurationDetailsListArgsDict',
    'JobRunLogDetailArgs',
    'JobRunLogDetailArgsDict',
    'JobRunNodeGroupDetailsListArgs',
    'JobRunNodeGroupDetailsListArgsDict',
    'MlApplicationImplementationApplicationComponentArgs',
    'MlApplicationImplementationApplicationComponentArgsDict',
    'MlApplicationImplementationConfigurationSchemaArgs',
    'MlApplicationImplementationConfigurationSchemaArgsDict',
    'MlApplicationImplementationLoggingArgs',
    'MlApplicationImplementationLoggingArgsDict',
    'MlApplicationImplementationLoggingAggregatedInstanceViewLogArgs',
    'MlApplicationImplementationLoggingAggregatedInstanceViewLogArgsDict',
    'MlApplicationImplementationLoggingImplementationLogArgs',
    'MlApplicationImplementationLoggingImplementationLogArgsDict',
    'MlApplicationImplementationLoggingTriggerLogArgs',
    'MlApplicationImplementationLoggingTriggerLogArgsDict',
    'MlApplicationImplementationMlApplicationPackageArgumentArgs',
    'MlApplicationImplementationMlApplicationPackageArgumentArgsDict',
    'MlApplicationImplementationMlApplicationPackageArgumentArgumentArgs',
    'MlApplicationImplementationMlApplicationPackageArgumentArgumentArgsDict',
    'MlApplicationInstanceAuthConfigurationArgs',
    'MlApplicationInstanceAuthConfigurationArgsDict',
    'MlApplicationInstanceConfigurationArgs',
    'MlApplicationInstanceConfigurationArgsDict',
    'MlApplicationInstancePredictionEndpointDetailArgs',
    'MlApplicationInstancePredictionEndpointDetailArgsDict',
    'MlApplicationInstancePredictionEndpointDetailPredictionUriArgs',
    'MlApplicationInstancePredictionEndpointDetailPredictionUriArgsDict',
    'ModelBackupOperationDetailArgs',
    'ModelBackupOperationDetailArgsDict',
    'ModelBackupSettingArgs',
    'ModelBackupSettingArgsDict',
    'ModelCustomMetadataListArgs',
    'ModelCustomMetadataListArgsDict',
    'ModelDefinedMetadataListArgs',
    'ModelDefinedMetadataListArgsDict',
    'ModelDeploymentCategoryLogDetailsArgs',
    'ModelDeploymentCategoryLogDetailsArgsDict',
    'ModelDeploymentCategoryLogDetailsAccessArgs',
    'ModelDeploymentCategoryLogDetailsAccessArgsDict',
    'ModelDeploymentCategoryLogDetailsPredictArgs',
    'ModelDeploymentCategoryLogDetailsPredictArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgs',
    'ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgsDict',
    'ModelDeploymentModelDeploymentSystemDataArgs',
    'ModelDeploymentModelDeploymentSystemDataArgsDict',
    'ModelGroupMemberModelEntriesArgs',
    'ModelGroupMemberModelEntriesArgsDict',
    'ModelGroupMemberModelEntriesMemberModelDetailArgs',
    'ModelGroupMemberModelEntriesMemberModelDetailArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsArgs',
    'ModelGroupModelGroupCloneSourceDetailsArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgs',
    'ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgs',
    'ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgs',
    'ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgs',
    'ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgs',
    'ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgsDict',
    'ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgs',
    'ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgsDict',
    'ModelGroupModelGroupDetailsArgs',
    'ModelGroupModelGroupDetailsArgsDict',
    'ModelGroupModelGroupDetailsCustomMetadataListArgs',
    'ModelGroupModelGroupDetailsCustomMetadataListArgsDict',
    'ModelRetentionOperationDetailArgs',
    'ModelRetentionOperationDetailArgsDict',
    'ModelRetentionSettingArgs',
    'ModelRetentionSettingArgsDict',
    'NotebookSessionNotebookSessionConfigDetailsArgs',
    'NotebookSessionNotebookSessionConfigDetailsArgsDict',
    'NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgs',
    'NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgsDict',
    'NotebookSessionNotebookSessionConfigurationDetailsArgs',
    'NotebookSessionNotebookSessionConfigurationDetailsArgsDict',
    'NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs',
    'NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgsDict',
    'NotebookSessionNotebookSessionRuntimeConfigDetailsArgs',
    'NotebookSessionNotebookSessionRuntimeConfigDetailsArgsDict',
    'NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgs',
    'NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgsDict',
    'NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgs',
    'NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgsDict',
    'NotebookSessionNotebookSessionStorageMountConfigurationDetailsListArgs',
    'NotebookSessionNotebookSessionStorageMountConfigurationDetailsListArgsDict',
    'PipelineConfigurationDetailsArgs',
    'PipelineConfigurationDetailsArgsDict',
    'PipelineInfrastructureConfigurationDetailsArgs',
    'PipelineInfrastructureConfigurationDetailsArgsDict',
    'PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgs',
    'PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict',
    'PipelineLogConfigurationDetailsArgs',
    'PipelineLogConfigurationDetailsArgsDict',
    'PipelineRunConfigurationDetailArgs',
    'PipelineRunConfigurationDetailArgsDict',
    'PipelineRunConfigurationOverrideDetailsArgs',
    'PipelineRunConfigurationOverrideDetailsArgsDict',
    'PipelineRunInfrastructureConfigurationOverrideDetailsArgs',
    'PipelineRunInfrastructureConfigurationOverrideDetailsArgsDict',
    'PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgs',
    'PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgsDict',
    'PipelineRunLogConfigurationOverrideDetailsArgs',
    'PipelineRunLogConfigurationOverrideDetailsArgsDict',
    'PipelineRunLogDetailArgs',
    'PipelineRunLogDetailArgsDict',
    'PipelineRunStepOverrideDetailArgs',
    'PipelineRunStepOverrideDetailArgsDict',
    'PipelineRunStepOverrideDetailStepConfigurationDetailsArgs',
    'PipelineRunStepOverrideDetailStepConfigurationDetailsArgsDict',
    'PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgs',
    'PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgsDict',
    'PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgs',
    'PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgsDict',
    'PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs',
    'PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict',
    'PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs',
    'PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict',
    'PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgs',
    'PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgsDict',
    'PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs',
    'PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict',
    'PipelineRunStepRunArgs',
    'PipelineRunStepRunArgsDict',
    'PipelineStepArtifactArgs',
    'PipelineStepArtifactArgsDict',
    'PipelineStepDetailArgs',
    'PipelineStepDetailArgsDict',
    'PipelineStepDetailStepConfigurationDetailsArgs',
    'PipelineStepDetailStepConfigurationDetailsArgsDict',
    'PipelineStepDetailStepContainerConfigurationDetailsArgs',
    'PipelineStepDetailStepContainerConfigurationDetailsArgsDict',
    'PipelineStepDetailStepDataflowConfigurationDetailsArgs',
    'PipelineStepDetailStepDataflowConfigurationDetailsArgsDict',
    'PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs',
    'PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict',
    'PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs',
    'PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict',
    'PipelineStepDetailStepInfrastructureConfigurationDetailsArgs',
    'PipelineStepDetailStepInfrastructureConfigurationDetailsArgsDict',
    'PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs',
    'PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict',
    'PipelineStepDetailStepStorageMountConfigurationDetailsListArgs',
    'PipelineStepDetailStepStorageMountConfigurationDetailsListArgsDict',
    'PipelineStorageMountConfigurationDetailsListArgs',
    'PipelineStorageMountConfigurationDetailsListArgsDict',
    'ScheduleActionArgs',
    'ScheduleActionArgsDict',
    'ScheduleActionActionDetailsArgs',
    'ScheduleActionActionDetailsArgsDict',
    'ScheduleActionActionDetailsCreateJobRunDetailsArgs',
    'ScheduleActionActionDetailsCreateJobRunDetailsArgsDict',
    'ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgs',
    'ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgsDict',
    'ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgs',
    'ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgsDict',
    'ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgs',
    'ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgsDict',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsArgs',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsArgsDict',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgs',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgsDict',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgs',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgsDict',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgs',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgsDict',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgs',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgsDict',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgs',
    'ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgsDict',
    'ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgs',
    'ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgsDict',
    'ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgs',
    'ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgsDict',
    'ScheduleLogDetailsArgs',
    'ScheduleLogDetailsArgsDict',
    'ScheduleTriggerArgs',
    'ScheduleTriggerArgsDict',
    'GetContainersFilterArgs',
    'GetContainersFilterArgsDict',
    'GetFastLaunchJobConfigsFilterArgs',
    'GetFastLaunchJobConfigsFilterArgsDict',
    'GetJobRunsFilterArgs',
    'GetJobRunsFilterArgsDict',
    'GetJobShapesFilterArgs',
    'GetJobShapesFilterArgsDict',
    'GetJobsFilterArgs',
    'GetJobsFilterArgsDict',
    'GetMlApplicationImplementationsFilterArgs',
    'GetMlApplicationImplementationsFilterArgsDict',
    'GetMlApplicationInstancesFilterArgs',
    'GetMlApplicationInstancesFilterArgsDict',
    'GetMlApplicationsFilterArgs',
    'GetMlApplicationsFilterArgsDict',
    'GetModelDeploymentModelStatesFilterArgs',
    'GetModelDeploymentModelStatesFilterArgsDict',
    'GetModelDeploymentShapesFilterArgs',
    'GetModelDeploymentShapesFilterArgsDict',
    'GetModelDeploymentsFilterArgs',
    'GetModelDeploymentsFilterArgsDict',
    'GetModelGroupModelsFilterArgs',
    'GetModelGroupModelsFilterArgsDict',
    'GetModelGroupVersionHistoriesFilterArgs',
    'GetModelGroupVersionHistoriesFilterArgsDict',
    'GetModelGroupsFilterArgs',
    'GetModelGroupsFilterArgsDict',
    'GetModelVersionSetsFilterArgs',
    'GetModelVersionSetsFilterArgsDict',
    'GetModelsFilterArgs',
    'GetModelsFilterArgsDict',
    'GetNotebookSessionShapesFilterArgs',
    'GetNotebookSessionShapesFilterArgsDict',
    'GetNotebookSessionsFilterArgs',
    'GetNotebookSessionsFilterArgsDict',
    'GetPipelineRunsFilterArgs',
    'GetPipelineRunsFilterArgsDict',
    'GetPipelinesFilterArgs',
    'GetPipelinesFilterArgsDict',
    'GetPrivateEndpointsFilterArgs',
    'GetPrivateEndpointsFilterArgsDict',
    'GetProjectsFilterArgs',
    'GetProjectsFilterArgsDict',
    'GetSchedulesFilterArgs',
    'GetSchedulesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class JobJobConfigurationDetailsArgsDict(TypedDict):
        job_type: pulumi.Input[_builtins.str]
        """
        The type of job.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arguments to pass to the job.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for the job.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        startup_probe_details: NotRequired[pulumi.Input['JobJobConfigurationDetailsStartupProbeDetailsArgsDict']]
        """
        The probe indicates whether the application within the job run has started.
        """
elif False:
    JobJobConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_probe_details: Optional[pulumi.Input['JobJobConfigurationDetailsStartupProbeDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] job_type: The type of job.
        :param pulumi.Input[_builtins.str] command_line_arguments: The arguments to pass to the job.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for the job.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the job. Timer starts when the job becomes active.
        :param pulumi.Input['JobJobConfigurationDetailsStartupProbeDetailsArgs'] startup_probe_details: The probe indicates whether the application within the job run has started.
        """
        pulumi.set(__self__, "job_type", job_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if startup_probe_details is not None:
            pulumi.set(__self__, "startup_probe_details", startup_probe_details)

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of job.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arguments to pass to the job.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for the job.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="startupProbeDetails")
    def startup_probe_details(self) -> Optional[pulumi.Input['JobJobConfigurationDetailsStartupProbeDetailsArgs']]:
        """
        The probe indicates whether the application within the job run has started.
        """
        return pulumi.get(self, "startup_probe_details")

    @startup_probe_details.setter
    def startup_probe_details(self, value: Optional[pulumi.Input['JobJobConfigurationDetailsStartupProbeDetailsArgs']]):
        pulumi.set(self, "startup_probe_details", value)


if not MYPY:
    class JobJobConfigurationDetailsStartupProbeDetailsArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The commands to run in the target job run to perform the startup probe
        """
        job_probe_check_type: pulumi.Input[_builtins.str]
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many times the job will try before giving up when a probe fails.
        """
        initial_delay_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        period_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds how often the job run should perform a startup probe
        """
elif False:
    JobJobConfigurationDetailsStartupProbeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobConfigurationDetailsStartupProbeDetailsArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 job_probe_check_type: pulumi.Input[_builtins.str],
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The commands to run in the target job run to perform the startup probe
        :param pulumi.Input[_builtins.str] job_probe_check_type: The probe check type to perform the startup probe and specifies the type of health check for a job.
        :param pulumi.Input[_builtins.int] failure_threshold: How many times the job will try before giving up when a probe fails.
        :param pulumi.Input[_builtins.int] initial_delay_in_seconds: Number of seconds after the job run has started before a startup probe is initiated.
        :param pulumi.Input[_builtins.int] period_in_seconds: Number of seconds how often the job run should perform a startup probe
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "job_probe_check_type", job_probe_check_type)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_in_seconds is not None:
            pulumi.set(__self__, "initial_delay_in_seconds", initial_delay_in_seconds)
        if period_in_seconds is not None:
            pulumi.set(__self__, "period_in_seconds", period_in_seconds)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The commands to run in the target job run to perform the startup probe
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="jobProbeCheckType")
    def job_probe_check_type(self) -> pulumi.Input[_builtins.str]:
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        return pulumi.get(self, "job_probe_check_type")

    @job_probe_check_type.setter
    def job_probe_check_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_probe_check_type", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many times the job will try before giving up when a probe fails.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelayInSeconds")
    def initial_delay_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        return pulumi.get(self, "initial_delay_in_seconds")

    @initial_delay_in_seconds.setter
    def initial_delay_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodInSeconds")
    def period_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds how often the job run should perform a startup probe
        """
        return pulumi.get(self, "period_in_seconds")

    @period_in_seconds.setter
    def period_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_in_seconds", value)


if not MYPY:
    class JobJobEnvironmentConfigurationDetailsArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        job_environment_type: pulumi.Input[_builtins.str]
        """
        The environment configuration type used for job runtime.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the container image signature
        """
elif False:
    JobJobEnvironmentConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobEnvironmentConfigurationDetailsArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 job_environment_type: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        :param pulumi.Input[_builtins.str] job_environment_type: The environment configuration type used for job runtime.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: OCID of the container image signature
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "job_environment_type", job_environment_type)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentType")
    def job_environment_type(self) -> pulumi.Input[_builtins.str]:
        """
        The environment configuration type used for job runtime.
        """
        return pulumi.get(self, "job_environment_type")

    @job_environment_type.setter
    def job_environment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_environment_type", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class JobJobInfrastructureConfigurationDetailsArgsDict(TypedDict):
        job_infrastructure_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The infrastructure type used for job run.
        """
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The size of the block storage volume to attach to the instance running the job
        """
        job_shape_config_details: NotRequired[pulumi.Input['JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        shape_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name that corresponds to the JobShapeSummary to use for the job node
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The subnet to create a secondary vnic in to attach to the instance running the job
        """
elif False:
    JobJobInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_infrastructure_type: pulumi.Input[_builtins.str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 job_shape_config_details: Optional[pulumi.Input['JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']] = None,
                 shape_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_infrastructure_type: (Updatable) The infrastructure type used for job run.
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: (Updatable) The size of the block storage volume to attach to the instance running the job
        :param pulumi.Input['JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs'] job_shape_config_details: (Updatable) Details for the job run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] shape_name: (Updatable) The name that corresponds to the JobShapeSummary to use for the job node
        :param pulumi.Input[_builtins.str] subnet_id: (Updatable) The subnet to create a secondary vnic in to attach to the instance running the job
        """
        pulumi.set(__self__, "job_infrastructure_type", job_infrastructure_type)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if job_shape_config_details is not None:
            pulumi.set(__self__, "job_shape_config_details", job_shape_config_details)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureType")
    def job_infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The infrastructure type used for job run.
        """
        return pulumi.get(self, "job_infrastructure_type")

    @job_infrastructure_type.setter
    def job_infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The size of the block storage volume to attach to the instance running the job
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="jobShapeConfigDetails")
    def job_shape_config_details(self) -> Optional[pulumi.Input['JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "job_shape_config_details")

    @job_shape_config_details.setter
    def job_shape_config_details(self, value: Optional[pulumi.Input['JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']]):
        pulumi.set(self, "job_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name that corresponds to the JobShapeSummary to use for the job node
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The subnet to create a secondary vnic in to attach to the instance running the job
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The total amount of memory available to the job run instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The total number of OCPUs available to the job run instance.
        """
elif False:
    JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) The total amount of memory available to the job run instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) The total number of OCPUs available to the job run instance.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The total amount of memory available to the job run instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The total number of OCPUs available to the job run instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class JobJobLogConfigurationDetailsArgsDict(TypedDict):
        enable_auto_log_creation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If automatic on-behalf-of log object creation is enabled for job runs.
        """
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If customer logging is enabled for job runs.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log group id for where log objects are for job runs.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log id the job run will push logs too.
        """
elif False:
    JobJobLogConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobLogConfigurationDetailsArgs:
    def __init__(__self__, *,
                 enable_auto_log_creation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_auto_log_creation: If automatic on-behalf-of log object creation is enabled for job runs.
        :param pulumi.Input[_builtins.bool] enable_logging: If customer logging is enabled for job runs.
        :param pulumi.Input[_builtins.str] log_group_id: The log group id for where log objects are for job runs.
        :param pulumi.Input[_builtins.str] log_id: The log id the job run will push logs too.
        """
        if enable_auto_log_creation is not None:
            pulumi.set(__self__, "enable_auto_log_creation", enable_auto_log_creation)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableAutoLogCreation")
    def enable_auto_log_creation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If automatic on-behalf-of log object creation is enabled for job runs.
        """
        return pulumi.get(self, "enable_auto_log_creation")

    @enable_auto_log_creation.setter
    def enable_auto_log_creation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_log_creation", value)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If customer logging is enabled for job runs.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log group id for where log objects are for job runs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log id the job run will push logs too.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsArgsDict(TypedDict):
        job_node_type: pulumi.Input[_builtins.str]
        """
        The node type used for job run.
        """
        job_network_configuration: NotRequired[pulumi.Input['JobJobNodeConfigurationDetailsJobNetworkConfigurationArgsDict']]
        """
        The job network configuration details
        """
        job_node_group_configuration_details_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgsDict']]]]
        """
        List of JobNodeGroupConfigurationDetails
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the job run. Timer starts when the job run is in progress.
        """
        startup_order: NotRequired[pulumi.Input[_builtins.str]]
        """
        The execution order of node groups
        """
elif False:
    JobJobNodeConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_node_type: pulumi.Input[_builtins.str],
                 job_network_configuration: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNetworkConfigurationArgs']] = None,
                 job_node_group_configuration_details_lists: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgs']]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_order: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_node_type: The node type used for job run.
        :param pulumi.Input['JobJobNodeConfigurationDetailsJobNetworkConfigurationArgs'] job_network_configuration: The job network configuration details
        :param pulumi.Input[Sequence[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgs']]] job_node_group_configuration_details_lists: List of JobNodeGroupConfigurationDetails
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the job run. Timer starts when the job run is in progress.
        :param pulumi.Input[_builtins.str] startup_order: The execution order of node groups
        """
        pulumi.set(__self__, "job_node_type", job_node_type)
        if job_network_configuration is not None:
            pulumi.set(__self__, "job_network_configuration", job_network_configuration)
        if job_node_group_configuration_details_lists is not None:
            pulumi.set(__self__, "job_node_group_configuration_details_lists", job_node_group_configuration_details_lists)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if startup_order is not None:
            pulumi.set(__self__, "startup_order", startup_order)

    @_builtins.property
    @pulumi.getter(name="jobNodeType")
    def job_node_type(self) -> pulumi.Input[_builtins.str]:
        """
        The node type used for job run.
        """
        return pulumi.get(self, "job_node_type")

    @job_node_type.setter
    def job_node_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_node_type", value)

    @_builtins.property
    @pulumi.getter(name="jobNetworkConfiguration")
    def job_network_configuration(self) -> Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNetworkConfigurationArgs']]:
        """
        The job network configuration details
        """
        return pulumi.get(self, "job_network_configuration")

    @job_network_configuration.setter
    def job_network_configuration(self, value: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNetworkConfigurationArgs']]):
        pulumi.set(self, "job_network_configuration", value)

    @_builtins.property
    @pulumi.getter(name="jobNodeGroupConfigurationDetailsLists")
    def job_node_group_configuration_details_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgs']]]]:
        """
        List of JobNodeGroupConfigurationDetails
        """
        return pulumi.get(self, "job_node_group_configuration_details_lists")

    @job_node_group_configuration_details_lists.setter
    def job_node_group_configuration_details_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgs']]]]):
        pulumi.set(self, "job_node_group_configuration_details_lists", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the job run. Timer starts when the job run is in progress.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="startupOrder")
    def startup_order(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The execution order of node groups
        """
        return pulumi.get(self, "startup_order")

    @startup_order.setter
    def startup_order(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "startup_order", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNetworkConfigurationArgsDict(TypedDict):
        job_network_type: pulumi.Input[_builtins.str]
        """
        job network type
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom subnet id
        """
elif False:
    JobJobNodeConfigurationDetailsJobNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNetworkConfigurationArgs:
    def __init__(__self__, *,
                 job_network_type: pulumi.Input[_builtins.str],
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_network_type: job network type
        :param pulumi.Input[_builtins.str] subnet_id: The custom subnet id
        """
        pulumi.set(__self__, "job_network_type", job_network_type)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="jobNetworkType")
    def job_network_type(self) -> pulumi.Input[_builtins.str]:
        """
        job network type
        """
        return pulumi.get(self, "job_network_type")

    @job_network_type.setter
    def job_network_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_network_type", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom subnet id
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        node group name.
        """
        job_configuration_details: NotRequired[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict']]
        """
        The job configuration details
        """
        job_environment_configuration_details: NotRequired[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict']]
        """
        Environment configuration to capture job runtime dependencies.
        """
        job_infrastructure_configuration_details: NotRequired[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict']]
        """
        The job infrastructure configuration details (shape, block storage, etc.)
        """
        minimum_success_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum threshold of successful replicas for node group to be successful. All replicas need to succeed if this is not specified.
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of nodes.
        """
elif False:
    JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 job_configuration_details: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs']] = None,
                 job_environment_configuration_details: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs']] = None,
                 job_infrastructure_configuration_details: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs']] = None,
                 minimum_success_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: node group name.
        :param pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs'] job_configuration_details: The job configuration details
        :param pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs'] job_environment_configuration_details: Environment configuration to capture job runtime dependencies.
        :param pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs'] job_infrastructure_configuration_details: The job infrastructure configuration details (shape, block storage, etc.)
        :param pulumi.Input[_builtins.int] minimum_success_replicas: The minimum threshold of successful replicas for node group to be successful. All replicas need to succeed if this is not specified.
        :param pulumi.Input[_builtins.int] replicas: The number of nodes.
        """
        pulumi.set(__self__, "name", name)
        if job_configuration_details is not None:
            pulumi.set(__self__, "job_configuration_details", job_configuration_details)
        if job_environment_configuration_details is not None:
            pulumi.set(__self__, "job_environment_configuration_details", job_environment_configuration_details)
        if job_infrastructure_configuration_details is not None:
            pulumi.set(__self__, "job_infrastructure_configuration_details", job_infrastructure_configuration_details)
        if minimum_success_replicas is not None:
            pulumi.set(__self__, "minimum_success_replicas", minimum_success_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        node group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="jobConfigurationDetails")
    def job_configuration_details(self) -> Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs']]:
        """
        The job configuration details
        """
        return pulumi.get(self, "job_configuration_details")

    @job_configuration_details.setter
    def job_configuration_details(self, value: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs']]):
        pulumi.set(self, "job_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentConfigurationDetails")
    def job_environment_configuration_details(self) -> Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs']]:
        """
        Environment configuration to capture job runtime dependencies.
        """
        return pulumi.get(self, "job_environment_configuration_details")

    @job_environment_configuration_details.setter
    def job_environment_configuration_details(self, value: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs']]):
        pulumi.set(self, "job_environment_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureConfigurationDetails")
    def job_infrastructure_configuration_details(self) -> Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs']]:
        """
        The job infrastructure configuration details (shape, block storage, etc.)
        """
        return pulumi.get(self, "job_infrastructure_configuration_details")

    @job_infrastructure_configuration_details.setter
    def job_infrastructure_configuration_details(self, value: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs']]):
        pulumi.set(self, "job_infrastructure_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessReplicas")
    def minimum_success_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum threshold of successful replicas for node group to be successful. All replicas need to succeed if this is not specified.
        """
        return pulumi.get(self, "minimum_success_replicas")

    @minimum_success_replicas.setter
    def minimum_success_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_success_replicas", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of nodes.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict(TypedDict):
        job_type: pulumi.Input[_builtins.str]
        """
        The type of job.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arguments to pass to the job.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for the job.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        startup_probe_details: NotRequired[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict']]
        """
        The probe indicates whether the application within the job run has started.
        """
elif False:
    JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_probe_details: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] job_type: The type of job.
        :param pulumi.Input[_builtins.str] command_line_arguments: The arguments to pass to the job.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for the job.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the job. Timer starts when the job becomes active.
        :param pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs'] startup_probe_details: The probe indicates whether the application within the job run has started.
        """
        pulumi.set(__self__, "job_type", job_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if startup_probe_details is not None:
            pulumi.set(__self__, "startup_probe_details", startup_probe_details)

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of job.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arguments to pass to the job.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for the job.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="startupProbeDetails")
    def startup_probe_details(self) -> Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs']]:
        """
        The probe indicates whether the application within the job run has started.
        """
        return pulumi.get(self, "startup_probe_details")

    @startup_probe_details.setter
    def startup_probe_details(self, value: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs']]):
        pulumi.set(self, "startup_probe_details", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The commands to run in the target job run to perform the startup probe
        """
        job_probe_check_type: pulumi.Input[_builtins.str]
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many times the job will try before giving up when a probe fails.
        """
        initial_delay_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        period_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds how often the job run should perform a startup probe
        """
elif False:
    JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 job_probe_check_type: pulumi.Input[_builtins.str],
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The commands to run in the target job run to perform the startup probe
        :param pulumi.Input[_builtins.str] job_probe_check_type: The probe check type to perform the startup probe and specifies the type of health check for a job.
        :param pulumi.Input[_builtins.int] failure_threshold: How many times the job will try before giving up when a probe fails.
        :param pulumi.Input[_builtins.int] initial_delay_in_seconds: Number of seconds after the job run has started before a startup probe is initiated.
        :param pulumi.Input[_builtins.int] period_in_seconds: Number of seconds how often the job run should perform a startup probe
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "job_probe_check_type", job_probe_check_type)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_in_seconds is not None:
            pulumi.set(__self__, "initial_delay_in_seconds", initial_delay_in_seconds)
        if period_in_seconds is not None:
            pulumi.set(__self__, "period_in_seconds", period_in_seconds)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The commands to run in the target job run to perform the startup probe
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="jobProbeCheckType")
    def job_probe_check_type(self) -> pulumi.Input[_builtins.str]:
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        return pulumi.get(self, "job_probe_check_type")

    @job_probe_check_type.setter
    def job_probe_check_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_probe_check_type", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many times the job will try before giving up when a probe fails.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelayInSeconds")
    def initial_delay_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        return pulumi.get(self, "initial_delay_in_seconds")

    @initial_delay_in_seconds.setter
    def initial_delay_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodInSeconds")
    def period_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds how often the job run should perform a startup probe
        """
        return pulumi.get(self, "period_in_seconds")

    @period_in_seconds.setter
    def period_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_in_seconds", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        job_environment_type: pulumi.Input[_builtins.str]
        """
        The environment configuration type used for job runtime.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the container image signature
        """
elif False:
    JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 job_environment_type: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        :param pulumi.Input[_builtins.str] job_environment_type: The environment configuration type used for job runtime.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: OCID of the container image signature
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "job_environment_type", job_environment_type)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentType")
    def job_environment_type(self) -> pulumi.Input[_builtins.str]:
        """
        The environment configuration type used for job runtime.
        """
        return pulumi.get(self, "job_environment_type")

    @job_environment_type.setter
    def job_environment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_environment_type", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict(TypedDict):
        job_infrastructure_type: pulumi.Input[_builtins.str]
        """
        The infrastructure type used for job run.
        """
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the block storage volume to attach to the instance running the job
        """
        job_shape_config_details: NotRequired[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict']]
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        shape_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
elif False:
    JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_infrastructure_type: pulumi.Input[_builtins.str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 job_shape_config_details: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']] = None,
                 shape_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_infrastructure_type: The infrastructure type used for job run.
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: The size of the block storage volume to attach to the instance running the job
        :param pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs'] job_shape_config_details: Details for the job run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] shape_name: The name that corresponds to the JobShapeSummary to use for the job node
        :param pulumi.Input[_builtins.str] subnet_id: The subnet to create a secondary vnic in to attach to the instance running the job
        """
        pulumi.set(__self__, "job_infrastructure_type", job_infrastructure_type)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if job_shape_config_details is not None:
            pulumi.set(__self__, "job_shape_config_details", job_shape_config_details)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureType")
    def job_infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        The infrastructure type used for job run.
        """
        return pulumi.get(self, "job_infrastructure_type")

    @job_infrastructure_type.setter
    def job_infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the block storage volume to attach to the instance running the job
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="jobShapeConfigDetails")
    def job_shape_config_details(self) -> Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']]:
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "job_shape_config_details")

    @job_shape_config_details.setter
    def job_shape_config_details(self, value: Optional[pulumi.Input['JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']]):
        pulumi.set(self, "job_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict(TypedDict):
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total number of OCPUs available to the job run instance.
        """
elif False:
    JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobNodeConfigurationDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] memory_in_gbs: The total amount of memory available to the job run instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: The total number of OCPUs available to the job run instance.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total number of OCPUs available to the job run instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class JobJobStorageMountConfigurationDetailsListArgsDict(TypedDict):
        destination_directory_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The local directory name to be mounted
        """
        storage_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of storage.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage bucket
        """
        destination_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        export_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the export
        """
        mount_target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the mount target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage namespace
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Prefix in the bucket to mount
        """
elif False:
    JobJobStorageMountConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobStorageMountConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 destination_directory_name: pulumi.Input[_builtins.str],
                 storage_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_path: Optional[pulumi.Input[_builtins.str]] = None,
                 export_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_directory_name: (Updatable) The local directory name to be mounted
        :param pulumi.Input[_builtins.str] storage_type: (Updatable) The type of storage.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The object storage bucket
        :param pulumi.Input[_builtins.str] destination_path: (Updatable) The local path of the mounted directory, excluding directory name.
        :param pulumi.Input[_builtins.str] export_id: (Updatable) OCID of the export
        :param pulumi.Input[_builtins.str] mount_target_id: (Updatable) OCID of the mount target
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The object storage namespace
        :param pulumi.Input[_builtins.str] prefix: (Updatable) Prefix in the bucket to mount
        """
        pulumi.set(__self__, "destination_directory_name", destination_directory_name)
        pulumi.set(__self__, "storage_type", storage_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if mount_target_id is not None:
            pulumi.set(__self__, "mount_target_id", mount_target_id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="destinationDirectoryName")
    def destination_directory_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The local directory name to be mounted
        """
        return pulumi.get(self, "destination_directory_name")

    @destination_directory_name.setter
    def destination_directory_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_directory_name", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_path", value)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the export
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_id", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the mount target
        """
        return pulumi.get(self, "mount_target_id")

    @mount_target_id.setter
    def mount_target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_target_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Prefix in the bucket to mount
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class JobRunJobConfigurationOverrideDetailsArgsDict(TypedDict):
        job_type: pulumi.Input[_builtins.str]
        """
        The type of job.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arguments to pass to the job.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for the job.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        startup_probe_details: NotRequired[pulumi.Input['JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgsDict']]
        """
        The probe indicates whether the application within the job run has started.
        """
elif False:
    JobRunJobConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 job_type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_probe_details: Optional[pulumi.Input['JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] job_type: The type of job.
        :param pulumi.Input[_builtins.str] command_line_arguments: The arguments to pass to the job.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for the job.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the job. Timer starts when the job becomes active.
        :param pulumi.Input['JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgs'] startup_probe_details: The probe indicates whether the application within the job run has started.
        """
        pulumi.set(__self__, "job_type", job_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if startup_probe_details is not None:
            pulumi.set(__self__, "startup_probe_details", startup_probe_details)

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of job.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arguments to pass to the job.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for the job.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="startupProbeDetails")
    def startup_probe_details(self) -> Optional[pulumi.Input['JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgs']]:
        """
        The probe indicates whether the application within the job run has started.
        """
        return pulumi.get(self, "startup_probe_details")

    @startup_probe_details.setter
    def startup_probe_details(self, value: Optional[pulumi.Input['JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgs']]):
        pulumi.set(self, "startup_probe_details", value)


if not MYPY:
    class JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The commands to run in the target job run to perform the startup probe
        """
        job_probe_check_type: pulumi.Input[_builtins.str]
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many times the job will try before giving up when a probe fails.
        """
        initial_delay_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        period_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds how often the job run should perform a startup probe
        """
elif False:
    JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobConfigurationOverrideDetailsStartupProbeDetailsArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 job_probe_check_type: pulumi.Input[_builtins.str],
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The commands to run in the target job run to perform the startup probe
        :param pulumi.Input[_builtins.str] job_probe_check_type: The probe check type to perform the startup probe and specifies the type of health check for a job.
        :param pulumi.Input[_builtins.int] failure_threshold: How many times the job will try before giving up when a probe fails.
        :param pulumi.Input[_builtins.int] initial_delay_in_seconds: Number of seconds after the job run has started before a startup probe is initiated.
        :param pulumi.Input[_builtins.int] period_in_seconds: Number of seconds how often the job run should perform a startup probe
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "job_probe_check_type", job_probe_check_type)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_in_seconds is not None:
            pulumi.set(__self__, "initial_delay_in_seconds", initial_delay_in_seconds)
        if period_in_seconds is not None:
            pulumi.set(__self__, "period_in_seconds", period_in_seconds)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The commands to run in the target job run to perform the startup probe
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="jobProbeCheckType")
    def job_probe_check_type(self) -> pulumi.Input[_builtins.str]:
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        return pulumi.get(self, "job_probe_check_type")

    @job_probe_check_type.setter
    def job_probe_check_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_probe_check_type", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many times the job will try before giving up when a probe fails.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelayInSeconds")
    def initial_delay_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        return pulumi.get(self, "initial_delay_in_seconds")

    @initial_delay_in_seconds.setter
    def initial_delay_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodInSeconds")
    def period_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds how often the job run should perform a startup probe
        """
        return pulumi.get(self, "period_in_seconds")

    @period_in_seconds.setter
    def period_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_in_seconds", value)


if not MYPY:
    class JobRunJobEnvironmentConfigurationOverrideDetailsArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        job_environment_type: pulumi.Input[_builtins.str]
        """
        The environment configuration type used for job runtime.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the container image signature
        """
elif False:
    JobRunJobEnvironmentConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobEnvironmentConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 job_environment_type: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        :param pulumi.Input[_builtins.str] job_environment_type: The environment configuration type used for job runtime.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: OCID of the container image signature
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "job_environment_type", job_environment_type)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentType")
    def job_environment_type(self) -> pulumi.Input[_builtins.str]:
        """
        The environment configuration type used for job runtime.
        """
        return pulumi.get(self, "job_environment_type")

    @job_environment_type.setter
    def job_environment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_environment_type", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class JobRunJobInfrastructureConfigurationDetailArgsDict(TypedDict):
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the block storage volume to attach to the instance running the job
        """
        job_infrastructure_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The infrastructure type used for job run.
        """
        job_shape_config_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgsDict']]]]
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        shape_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
elif False:
    JobRunJobInfrastructureConfigurationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobInfrastructureConfigurationDetailArgs:
    def __init__(__self__, *,
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 job_infrastructure_type: Optional[pulumi.Input[_builtins.str]] = None,
                 job_shape_config_details: Optional[pulumi.Input[Sequence[pulumi.Input['JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgs']]]] = None,
                 shape_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: The size of the block storage volume to attach to the instance running the job
        :param pulumi.Input[_builtins.str] job_infrastructure_type: The infrastructure type used for job run.
        :param pulumi.Input[Sequence[pulumi.Input['JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgs']]] job_shape_config_details: Details for the job run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] shape_name: The name that corresponds to the JobShapeSummary to use for the job node
        :param pulumi.Input[_builtins.str] subnet_id: The subnet to create a secondary vnic in to attach to the instance running the job
        """
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if job_infrastructure_type is not None:
            pulumi.set(__self__, "job_infrastructure_type", job_infrastructure_type)
        if job_shape_config_details is not None:
            pulumi.set(__self__, "job_shape_config_details", job_shape_config_details)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the block storage volume to attach to the instance running the job
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureType")
    def job_infrastructure_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The infrastructure type used for job run.
        """
        return pulumi.get(self, "job_infrastructure_type")

    @job_infrastructure_type.setter
    def job_infrastructure_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="jobShapeConfigDetails")
    def job_shape_config_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgs']]]]:
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "job_shape_config_details")

    @job_shape_config_details.setter
    def job_shape_config_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgs']]]]):
        pulumi.set(self, "job_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total number of OCPUs available to the job run instance.
        """
elif False:
    JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobInfrastructureConfigurationDetailJobShapeConfigDetailArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: The total amount of memory available to the job run instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: The total number of OCPUs available to the job run instance.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total number of OCPUs available to the job run instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class JobRunJobInfrastructureConfigurationOverrideDetailsArgsDict(TypedDict):
        job_infrastructure_type: pulumi.Input[_builtins.str]
        """
        The infrastructure type used for job run.
        """
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the block storage volume to attach to the instance running the job
        """
        job_shape_config_details: NotRequired[pulumi.Input['JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgsDict']]
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        shape_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
elif False:
    JobRunJobInfrastructureConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobInfrastructureConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 job_infrastructure_type: pulumi.Input[_builtins.str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 job_shape_config_details: Optional[pulumi.Input['JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgs']] = None,
                 shape_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_infrastructure_type: The infrastructure type used for job run.
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: The size of the block storage volume to attach to the instance running the job
        :param pulumi.Input['JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgs'] job_shape_config_details: Details for the job run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] shape_name: The name that corresponds to the JobShapeSummary to use for the job node
        :param pulumi.Input[_builtins.str] subnet_id: The subnet to create a secondary vnic in to attach to the instance running the job
        """
        pulumi.set(__self__, "job_infrastructure_type", job_infrastructure_type)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if job_shape_config_details is not None:
            pulumi.set(__self__, "job_shape_config_details", job_shape_config_details)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureType")
    def job_infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        The infrastructure type used for job run.
        """
        return pulumi.get(self, "job_infrastructure_type")

    @job_infrastructure_type.setter
    def job_infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the block storage volume to attach to the instance running the job
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="jobShapeConfigDetails")
    def job_shape_config_details(self) -> Optional[pulumi.Input['JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgs']]:
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "job_shape_config_details")

    @job_shape_config_details.setter
    def job_shape_config_details(self, value: Optional[pulumi.Input['JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgs']]):
        pulumi.set(self, "job_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgsDict(TypedDict):
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total number of OCPUs available to the job run instance.
        """
elif False:
    JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobInfrastructureConfigurationOverrideDetailsJobShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] memory_in_gbs: The total amount of memory available to the job run instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: The total number of OCPUs available to the job run instance.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total number of OCPUs available to the job run instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class JobRunJobLogConfigurationOverrideDetailsArgsDict(TypedDict):
        enable_auto_log_creation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If automatic on-behalf-of log object creation is enabled for job runs.
        """
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If customer logging is enabled for job runs.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log group id for where log objects are for job runs.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log id the job run will push logs too.
        """
elif False:
    JobRunJobLogConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobLogConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 enable_auto_log_creation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_auto_log_creation: If automatic on-behalf-of log object creation is enabled for job runs.
        :param pulumi.Input[_builtins.bool] enable_logging: If customer logging is enabled for job runs.
        :param pulumi.Input[_builtins.str] log_group_id: The log group id for where log objects are for job runs.
        :param pulumi.Input[_builtins.str] log_id: The log id the job run will push logs too.
        """
        if enable_auto_log_creation is not None:
            pulumi.set(__self__, "enable_auto_log_creation", enable_auto_log_creation)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableAutoLogCreation")
    def enable_auto_log_creation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If automatic on-behalf-of log object creation is enabled for job runs.
        """
        return pulumi.get(self, "enable_auto_log_creation")

    @enable_auto_log_creation.setter
    def enable_auto_log_creation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_log_creation", value)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If customer logging is enabled for job runs.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log group id for where log objects are for job runs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log id the job run will push logs too.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsArgsDict(TypedDict):
        job_node_type: pulumi.Input[_builtins.str]
        """
        The node type used for job run.
        """
        job_network_configuration: NotRequired[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgsDict']]
        """
        The job network configuration details
        """
        job_node_group_configuration_details_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgsDict']]]]
        """
        List of JobNodeGroupConfigurationDetails
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the job run. Timer starts when the job run is in progress.
        """
        startup_order: NotRequired[pulumi.Input[_builtins.str]]
        """
        The execution order of node groups
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 job_node_type: pulumi.Input[_builtins.str],
                 job_network_configuration: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgs']] = None,
                 job_node_group_configuration_details_lists: Optional[pulumi.Input[Sequence[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgs']]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_order: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_node_type: The node type used for job run.
        :param pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgs'] job_network_configuration: The job network configuration details
        :param pulumi.Input[Sequence[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgs']]] job_node_group_configuration_details_lists: List of JobNodeGroupConfigurationDetails
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the job run. Timer starts when the job run is in progress.
        :param pulumi.Input[_builtins.str] startup_order: The execution order of node groups
        """
        pulumi.set(__self__, "job_node_type", job_node_type)
        if job_network_configuration is not None:
            pulumi.set(__self__, "job_network_configuration", job_network_configuration)
        if job_node_group_configuration_details_lists is not None:
            pulumi.set(__self__, "job_node_group_configuration_details_lists", job_node_group_configuration_details_lists)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if startup_order is not None:
            pulumi.set(__self__, "startup_order", startup_order)

    @_builtins.property
    @pulumi.getter(name="jobNodeType")
    def job_node_type(self) -> pulumi.Input[_builtins.str]:
        """
        The node type used for job run.
        """
        return pulumi.get(self, "job_node_type")

    @job_node_type.setter
    def job_node_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_node_type", value)

    @_builtins.property
    @pulumi.getter(name="jobNetworkConfiguration")
    def job_network_configuration(self) -> Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgs']]:
        """
        The job network configuration details
        """
        return pulumi.get(self, "job_network_configuration")

    @job_network_configuration.setter
    def job_network_configuration(self, value: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgs']]):
        pulumi.set(self, "job_network_configuration", value)

    @_builtins.property
    @pulumi.getter(name="jobNodeGroupConfigurationDetailsLists")
    def job_node_group_configuration_details_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgs']]]]:
        """
        List of JobNodeGroupConfigurationDetails
        """
        return pulumi.get(self, "job_node_group_configuration_details_lists")

    @job_node_group_configuration_details_lists.setter
    def job_node_group_configuration_details_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgs']]]]):
        pulumi.set(self, "job_node_group_configuration_details_lists", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the job run. Timer starts when the job run is in progress.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="startupOrder")
    def startup_order(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The execution order of node groups
        """
        return pulumi.get(self, "startup_order")

    @startup_order.setter
    def startup_order(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "startup_order", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgsDict(TypedDict):
        job_network_type: pulumi.Input[_builtins.str]
        """
        job network type
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom subnet id
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNetworkConfigurationArgs:
    def __init__(__self__, *,
                 job_network_type: pulumi.Input[_builtins.str],
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_network_type: job network type
        :param pulumi.Input[_builtins.str] subnet_id: The custom subnet id
        """
        pulumi.set(__self__, "job_network_type", job_network_type)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="jobNetworkType")
    def job_network_type(self) -> pulumi.Input[_builtins.str]:
        """
        job network type
        """
        return pulumi.get(self, "job_network_type")

    @job_network_type.setter
    def job_network_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_network_type", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom subnet id
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        node group name.
        """
        job_configuration_details: NotRequired[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict']]
        """
        The job configuration details
        """
        job_environment_configuration_details: NotRequired[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict']]
        """
        Environment configuration to capture job runtime dependencies.
        """
        job_infrastructure_configuration_details: NotRequired[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict']]
        """
        The job infrastructure configuration details (shape, block storage, etc.)
        """
        minimum_success_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum threshold of successful replicas for node group to be successful. All replicas need to succeed if this is not specified.
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of nodes.
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 job_configuration_details: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs']] = None,
                 job_environment_configuration_details: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs']] = None,
                 job_infrastructure_configuration_details: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs']] = None,
                 minimum_success_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: node group name.
        :param pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs'] job_configuration_details: The job configuration details
        :param pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs'] job_environment_configuration_details: Environment configuration to capture job runtime dependencies.
        :param pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs'] job_infrastructure_configuration_details: The job infrastructure configuration details (shape, block storage, etc.)
        :param pulumi.Input[_builtins.int] minimum_success_replicas: The minimum threshold of successful replicas for node group to be successful. All replicas need to succeed if this is not specified.
        :param pulumi.Input[_builtins.int] replicas: The number of nodes.
        """
        pulumi.set(__self__, "name", name)
        if job_configuration_details is not None:
            pulumi.set(__self__, "job_configuration_details", job_configuration_details)
        if job_environment_configuration_details is not None:
            pulumi.set(__self__, "job_environment_configuration_details", job_environment_configuration_details)
        if job_infrastructure_configuration_details is not None:
            pulumi.set(__self__, "job_infrastructure_configuration_details", job_infrastructure_configuration_details)
        if minimum_success_replicas is not None:
            pulumi.set(__self__, "minimum_success_replicas", minimum_success_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        node group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="jobConfigurationDetails")
    def job_configuration_details(self) -> Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs']]:
        """
        The job configuration details
        """
        return pulumi.get(self, "job_configuration_details")

    @job_configuration_details.setter
    def job_configuration_details(self, value: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs']]):
        pulumi.set(self, "job_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentConfigurationDetails")
    def job_environment_configuration_details(self) -> Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs']]:
        """
        Environment configuration to capture job runtime dependencies.
        """
        return pulumi.get(self, "job_environment_configuration_details")

    @job_environment_configuration_details.setter
    def job_environment_configuration_details(self, value: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs']]):
        pulumi.set(self, "job_environment_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureConfigurationDetails")
    def job_infrastructure_configuration_details(self) -> Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs']]:
        """
        The job infrastructure configuration details (shape, block storage, etc.)
        """
        return pulumi.get(self, "job_infrastructure_configuration_details")

    @job_infrastructure_configuration_details.setter
    def job_infrastructure_configuration_details(self, value: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs']]):
        pulumi.set(self, "job_infrastructure_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessReplicas")
    def minimum_success_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum threshold of successful replicas for node group to be successful. All replicas need to succeed if this is not specified.
        """
        return pulumi.get(self, "minimum_success_replicas")

    @minimum_success_replicas.setter
    def minimum_success_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_success_replicas", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of nodes.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict(TypedDict):
        job_type: pulumi.Input[_builtins.str]
        """
        The type of job.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arguments to pass to the job.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for the job.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        startup_probe_details: NotRequired[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict']]
        """
        The probe indicates whether the application within the job run has started.
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_probe_details: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] job_type: The type of job.
        :param pulumi.Input[_builtins.str] command_line_arguments: The arguments to pass to the job.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for the job.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the job. Timer starts when the job becomes active.
        :param pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs'] startup_probe_details: The probe indicates whether the application within the job run has started.
        """
        pulumi.set(__self__, "job_type", job_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if startup_probe_details is not None:
            pulumi.set(__self__, "startup_probe_details", startup_probe_details)

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of job.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arguments to pass to the job.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for the job.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="startupProbeDetails")
    def startup_probe_details(self) -> Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs']]:
        """
        The probe indicates whether the application within the job run has started.
        """
        return pulumi.get(self, "startup_probe_details")

    @startup_probe_details.setter
    def startup_probe_details(self, value: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs']]):
        pulumi.set(self, "startup_probe_details", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The commands to run in the target job run to perform the startup probe
        """
        job_probe_check_type: pulumi.Input[_builtins.str]
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many times the job will try before giving up when a probe fails.
        """
        initial_delay_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        period_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds how often the job run should perform a startup probe
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobConfigurationDetailsStartupProbeDetailsArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 job_probe_check_type: pulumi.Input[_builtins.str],
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_delay_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The commands to run in the target job run to perform the startup probe
        :param pulumi.Input[_builtins.str] job_probe_check_type: The probe check type to perform the startup probe and specifies the type of health check for a job.
        :param pulumi.Input[_builtins.int] failure_threshold: How many times the job will try before giving up when a probe fails.
        :param pulumi.Input[_builtins.int] initial_delay_in_seconds: Number of seconds after the job run has started before a startup probe is initiated.
        :param pulumi.Input[_builtins.int] period_in_seconds: Number of seconds how often the job run should perform a startup probe
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "job_probe_check_type", job_probe_check_type)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_in_seconds is not None:
            pulumi.set(__self__, "initial_delay_in_seconds", initial_delay_in_seconds)
        if period_in_seconds is not None:
            pulumi.set(__self__, "period_in_seconds", period_in_seconds)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The commands to run in the target job run to perform the startup probe
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="jobProbeCheckType")
    def job_probe_check_type(self) -> pulumi.Input[_builtins.str]:
        """
        The probe check type to perform the startup probe and specifies the type of health check for a job.
        """
        return pulumi.get(self, "job_probe_check_type")

    @job_probe_check_type.setter
    def job_probe_check_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_probe_check_type", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many times the job will try before giving up when a probe fails.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelayInSeconds")
    def initial_delay_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds after the job run has started before a startup probe is initiated.
        """
        return pulumi.get(self, "initial_delay_in_seconds")

    @initial_delay_in_seconds.setter
    def initial_delay_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodInSeconds")
    def period_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds how often the job run should perform a startup probe
        """
        return pulumi.get(self, "period_in_seconds")

    @period_in_seconds.setter
    def period_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_in_seconds", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        job_environment_type: pulumi.Input[_builtins.str]
        """
        The environment configuration type used for job runtime.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the container image signature
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobEnvironmentConfigurationDetailsArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 job_environment_type: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        :param pulumi.Input[_builtins.str] job_environment_type: The environment configuration type used for job runtime.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: OCID of the container image signature
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "job_environment_type", job_environment_type)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentType")
    def job_environment_type(self) -> pulumi.Input[_builtins.str]:
        """
        The environment configuration type used for job runtime.
        """
        return pulumi.get(self, "job_environment_type")

    @job_environment_type.setter
    def job_environment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_environment_type", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict(TypedDict):
        job_infrastructure_type: pulumi.Input[_builtins.str]
        """
        The infrastructure type used for job run.
        """
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the block storage volume to attach to the instance running the job
        """
        job_shape_config_details: NotRequired[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict']]
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        shape_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 job_infrastructure_type: pulumi.Input[_builtins.str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 job_shape_config_details: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']] = None,
                 shape_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_infrastructure_type: The infrastructure type used for job run.
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: The size of the block storage volume to attach to the instance running the job
        :param pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs'] job_shape_config_details: Details for the job run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] shape_name: The name that corresponds to the JobShapeSummary to use for the job node
        :param pulumi.Input[_builtins.str] subnet_id: The subnet to create a secondary vnic in to attach to the instance running the job
        """
        pulumi.set(__self__, "job_infrastructure_type", job_infrastructure_type)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if job_shape_config_details is not None:
            pulumi.set(__self__, "job_shape_config_details", job_shape_config_details)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="jobInfrastructureType")
    def job_infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        """
        The infrastructure type used for job run.
        """
        return pulumi.get(self, "job_infrastructure_type")

    @job_infrastructure_type.setter
    def job_infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the block storage volume to attach to the instance running the job
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="jobShapeConfigDetails")
    def job_shape_config_details(self) -> Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']]:
        """
        Details for the job run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "job_shape_config_details")

    @job_shape_config_details.setter
    def job_shape_config_details(self, value: Optional[pulumi.Input['JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs']]):
        pulumi.set(self, "job_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name that corresponds to the JobShapeSummary to use for the job node
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet to create a secondary vnic in to attach to the instance running the job
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict(TypedDict):
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total number of OCPUs available to the job run instance.
        """
elif False:
    JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobNodeConfigurationOverrideDetailsJobNodeGroupConfigurationDetailsListJobInfrastructureConfigurationDetailsJobShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] memory_in_gbs: The total amount of memory available to the job run instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: The total number of OCPUs available to the job run instance.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total amount of memory available to the job run instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total number of OCPUs available to the job run instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class JobRunJobStorageMountConfigurationDetailsListArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object storage bucket
        """
        destination_directory_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The local directory name to be mounted
        """
        destination_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The local path of the mounted directory, excluding directory name.
        """
        export_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the export
        """
        mount_target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the mount target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object storage namespace
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix in the bucket to mount
        """
        storage_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of storage.
        """
elif False:
    JobRunJobStorageMountConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobStorageMountConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_directory_name: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_path: Optional[pulumi.Input[_builtins.str]] = None,
                 export_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The object storage bucket
        :param pulumi.Input[_builtins.str] destination_directory_name: The local directory name to be mounted
        :param pulumi.Input[_builtins.str] destination_path: The local path of the mounted directory, excluding directory name.
        :param pulumi.Input[_builtins.str] export_id: OCID of the export
        :param pulumi.Input[_builtins.str] mount_target_id: OCID of the mount target
        :param pulumi.Input[_builtins.str] namespace: The object storage namespace
        :param pulumi.Input[_builtins.str] prefix: Prefix in the bucket to mount
        :param pulumi.Input[_builtins.str] storage_type: The type of storage.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if destination_directory_name is not None:
            pulumi.set(__self__, "destination_directory_name", destination_directory_name)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if mount_target_id is not None:
            pulumi.set(__self__, "mount_target_id", mount_target_id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object storage bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="destinationDirectoryName")
    def destination_directory_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The local directory name to be mounted
        """
        return pulumi.get(self, "destination_directory_name")

    @destination_directory_name.setter
    def destination_directory_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_directory_name", value)

    @_builtins.property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The local path of the mounted directory, excluding directory name.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_path", value)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the export
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_id", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the mount target
        """
        return pulumi.get(self, "mount_target_id")

    @mount_target_id.setter
    def mount_target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_target_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object storage namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix in the bucket to mount
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class JobRunLogDetailArgsDict(TypedDict):
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log group id for where log objects will be for job runs.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log id of the log object the job run logs will be shipped to.
        """
elif False:
    JobRunLogDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunLogDetailArgs:
    def __init__(__self__, *,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_group_id: The log group id for where log objects will be for job runs.
        :param pulumi.Input[_builtins.str] log_id: The log id of the log object the job run logs will be shipped to.
        """
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log group id for where log objects will be for job runs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log id of the log object the job run logs will be shipped to.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class JobRunNodeGroupDetailsListArgsDict(TypedDict):
        lifecycle_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state details of the node group.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        node group name.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the job run.
        """
elif False:
    JobRunNodeGroupDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunNodeGroupDetailsListArgs:
    def __init__(__self__, *,
                 lifecycle_details: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] lifecycle_details: The state details of the node group.
        :param pulumi.Input[_builtins.str] name: node group name.
        :param pulumi.Input[_builtins.str] state: The state of the job run.
        """
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state details of the node group.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifecycle_details", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        node group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the job run.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MlApplicationImplementationApplicationComponentArgsDict(TypedDict):
        application_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of Data Flow Application
        """
        component_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of application component
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the MlApplicationImplementation. Unique identifier that is immutable after creation.
        """
        job_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of Data Science Job
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of Data Science Model
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        ML Application Implementation name which is unique for given ML Application.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pipeline_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of Data Science Pipeline
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the resource
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        type of the argument
        """
elif False:
    MlApplicationImplementationApplicationComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationApplicationComponentArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[_builtins.str]] = None,
                 component_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 job_id: Optional[pulumi.Input[_builtins.str]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 pipeline_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] application_id: OCID of Data Flow Application
        :param pulumi.Input[_builtins.str] component_name: Name of application component
        :param pulumi.Input[_builtins.str] id: The OCID of the MlApplicationImplementation. Unique identifier that is immutable after creation.
        :param pulumi.Input[_builtins.str] job_id: OCID of Data Science Job
        :param pulumi.Input[_builtins.str] model_id: OCID of Data Science Model
        :param pulumi.Input[_builtins.str] name: ML Application Implementation name which is unique for given ML Application.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] pipeline_id: OCID of Data Science Pipeline
        :param pulumi.Input[_builtins.str] resource_type: Type of the resource
        :param pulumi.Input[_builtins.str] type: type of the argument
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if component_name is not None:
            pulumi.set(__self__, "component_name", component_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of Data Flow Application
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_id", value)

    @_builtins.property
    @pulumi.getter(name="componentName")
    def component_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of application component
        """
        return pulumi.get(self, "component_name")

    @component_name.setter
    def component_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "component_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the MlApplicationImplementation. Unique identifier that is immutable after creation.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of Data Science Job
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_id", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of Data Science Model
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ML Application Implementation name which is unique for given ML Application.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of Data Science Pipeline
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the resource
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type of the argument
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MlApplicationImplementationConfigurationSchemaArgsDict(TypedDict):
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default value for the optional configuration property (it must not be specified for mandatory configuration properties)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        short description of the argument
        """
        is_mandatory: NotRequired[pulumi.Input[_builtins.bool]]
        """
        argument is mandatory or not
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of key (parameter name)
        """
        sample_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sample property value (it must match validationRegexp if it is specified)
        """
        validation_regexp: NotRequired[pulumi.Input[_builtins.str]]
        """
        A regular expression will be used for the validation of property value.
        """
        value_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of value
        """
elif False:
    MlApplicationImplementationConfigurationSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationConfigurationSchemaArgs:
    def __init__(__self__, *,
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 is_mandatory: Optional[pulumi.Input[_builtins.bool]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sample_value: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_regexp: Optional[pulumi.Input[_builtins.str]] = None,
                 value_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] default_value: The default value for the optional configuration property (it must not be specified for mandatory configuration properties)
        :param pulumi.Input[_builtins.str] description: short description of the argument
        :param pulumi.Input[_builtins.bool] is_mandatory: argument is mandatory or not
        :param pulumi.Input[_builtins.str] key_name: Name of key (parameter name)
        :param pulumi.Input[_builtins.str] sample_value: Sample property value (it must match validationRegexp if it is specified)
        :param pulumi.Input[_builtins.str] validation_regexp: A regular expression will be used for the validation of property value.
        :param pulumi.Input[_builtins.str] value_type: Type of value
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_mandatory is not None:
            pulumi.set(__self__, "is_mandatory", is_mandatory)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if sample_value is not None:
            pulumi.set(__self__, "sample_value", sample_value)
        if validation_regexp is not None:
            pulumi.set(__self__, "validation_regexp", validation_regexp)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default value for the optional configuration property (it must not be specified for mandatory configuration properties)
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        short description of the argument
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="isMandatory")
    def is_mandatory(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        argument is mandatory or not
        """
        return pulumi.get(self, "is_mandatory")

    @is_mandatory.setter
    def is_mandatory(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mandatory", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of key (parameter name)
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="sampleValue")
    def sample_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sample property value (it must match validationRegexp if it is specified)
        """
        return pulumi.get(self, "sample_value")

    @sample_value.setter
    def sample_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sample_value", value)

    @_builtins.property
    @pulumi.getter(name="validationRegexp")
    def validation_regexp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A regular expression will be used for the validation of property value.
        """
        return pulumi.get(self, "validation_regexp")

    @validation_regexp.setter
    def validation_regexp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_regexp", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of value
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class MlApplicationImplementationLoggingArgsDict(TypedDict):
        aggregated_instance_view_log: NotRequired[pulumi.Input['MlApplicationImplementationLoggingAggregatedInstanceViewLogArgsDict']]
        """
        (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
        implementation_log: NotRequired[pulumi.Input['MlApplicationImplementationLoggingImplementationLogArgsDict']]
        """
        (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
        trigger_log: NotRequired[pulumi.Input['MlApplicationImplementationLoggingTriggerLogArgsDict']]
        """
        (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
elif False:
    MlApplicationImplementationLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationLoggingArgs:
    def __init__(__self__, *,
                 aggregated_instance_view_log: Optional[pulumi.Input['MlApplicationImplementationLoggingAggregatedInstanceViewLogArgs']] = None,
                 implementation_log: Optional[pulumi.Input['MlApplicationImplementationLoggingImplementationLogArgs']] = None,
                 trigger_log: Optional[pulumi.Input['MlApplicationImplementationLoggingTriggerLogArgs']] = None):
        """
        :param pulumi.Input['MlApplicationImplementationLoggingAggregatedInstanceViewLogArgs'] aggregated_instance_view_log: (Updatable) Log configuration details for particular areas of ML Application Implementation.
        :param pulumi.Input['MlApplicationImplementationLoggingImplementationLogArgs'] implementation_log: (Updatable) Log configuration details for particular areas of ML Application Implementation.
        :param pulumi.Input['MlApplicationImplementationLoggingTriggerLogArgs'] trigger_log: (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
        if aggregated_instance_view_log is not None:
            pulumi.set(__self__, "aggregated_instance_view_log", aggregated_instance_view_log)
        if implementation_log is not None:
            pulumi.set(__self__, "implementation_log", implementation_log)
        if trigger_log is not None:
            pulumi.set(__self__, "trigger_log", trigger_log)

    @_builtins.property
    @pulumi.getter(name="aggregatedInstanceViewLog")
    def aggregated_instance_view_log(self) -> Optional[pulumi.Input['MlApplicationImplementationLoggingAggregatedInstanceViewLogArgs']]:
        """
        (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
        return pulumi.get(self, "aggregated_instance_view_log")

    @aggregated_instance_view_log.setter
    def aggregated_instance_view_log(self, value: Optional[pulumi.Input['MlApplicationImplementationLoggingAggregatedInstanceViewLogArgs']]):
        pulumi.set(self, "aggregated_instance_view_log", value)

    @_builtins.property
    @pulumi.getter(name="implementationLog")
    def implementation_log(self) -> Optional[pulumi.Input['MlApplicationImplementationLoggingImplementationLogArgs']]:
        """
        (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
        return pulumi.get(self, "implementation_log")

    @implementation_log.setter
    def implementation_log(self, value: Optional[pulumi.Input['MlApplicationImplementationLoggingImplementationLogArgs']]):
        pulumi.set(self, "implementation_log", value)

    @_builtins.property
    @pulumi.getter(name="triggerLog")
    def trigger_log(self) -> Optional[pulumi.Input['MlApplicationImplementationLoggingTriggerLogArgs']]:
        """
        (Updatable) Log configuration details for particular areas of ML Application Implementation.
        """
        return pulumi.get(self, "trigger_log")

    @trigger_log.setter
    def trigger_log(self, value: Optional[pulumi.Input['MlApplicationImplementationLoggingTriggerLogArgs']]):
        pulumi.set(self, "trigger_log", value)


if not MYPY:
    class MlApplicationImplementationLoggingAggregatedInstanceViewLogArgsDict(TypedDict):
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If logging is enabled.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
elif False:
    MlApplicationImplementationLoggingAggregatedInstanceViewLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationLoggingAggregatedInstanceViewLogArgs:
    def __init__(__self__, *,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_logging: (Updatable) If logging is enabled.
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If logging is enabled.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class MlApplicationImplementationLoggingImplementationLogArgsDict(TypedDict):
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If logging is enabled.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
elif False:
    MlApplicationImplementationLoggingImplementationLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationLoggingImplementationLogArgs:
    def __init__(__self__, *,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_logging: (Updatable) If logging is enabled.
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If logging is enabled.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class MlApplicationImplementationLoggingTriggerLogArgsDict(TypedDict):
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If logging is enabled.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
elif False:
    MlApplicationImplementationLoggingTriggerLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationLoggingTriggerLogArgs:
    def __init__(__self__, *,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_logging: (Updatable) If logging is enabled.
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If logging is enabled.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class MlApplicationImplementationMlApplicationPackageArgumentArgsDict(TypedDict):
        arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input['MlApplicationImplementationMlApplicationPackageArgumentArgumentArgsDict']]]]
        """
        Array of the ML Application package arguments
        """
elif False:
    MlApplicationImplementationMlApplicationPackageArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationMlApplicationPackageArgumentArgs:
    def __init__(__self__, *,
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input['MlApplicationImplementationMlApplicationPackageArgumentArgumentArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MlApplicationImplementationMlApplicationPackageArgumentArgumentArgs']]] arguments: Array of the ML Application package arguments
        """
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MlApplicationImplementationMlApplicationPackageArgumentArgumentArgs']]]]:
        """
        Array of the ML Application package arguments
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MlApplicationImplementationMlApplicationPackageArgumentArgumentArgs']]]]):
        pulumi.set(self, "arguments", value)


if not MYPY:
    class MlApplicationImplementationMlApplicationPackageArgumentArgumentArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        short description of the argument
        """
        is_mandatory: NotRequired[pulumi.Input[_builtins.bool]]
        """
        argument is mandatory or not
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        ML Application Implementation name which is unique for given ML Application.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        type of the argument
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Argument value
        """
elif False:
    MlApplicationImplementationMlApplicationPackageArgumentArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationImplementationMlApplicationPackageArgumentArgumentArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 is_mandatory: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: short description of the argument
        :param pulumi.Input[_builtins.bool] is_mandatory: argument is mandatory or not
        :param pulumi.Input[_builtins.str] name: ML Application Implementation name which is unique for given ML Application.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] type: type of the argument
        :param pulumi.Input[_builtins.str] value: Argument value
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_mandatory is not None:
            pulumi.set(__self__, "is_mandatory", is_mandatory)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        short description of the argument
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="isMandatory")
    def is_mandatory(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        argument is mandatory or not
        """
        return pulumi.get(self, "is_mandatory")

    @is_mandatory.setter
    def is_mandatory(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mandatory", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ML Application Implementation name which is unique for given ML Application.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type of the argument
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Argument value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MlApplicationInstanceAuthConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of AuthN/Z
        """
        application_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the IDCS application
        """
        domain_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity Domain OCID
        """
elif False:
    MlApplicationInstanceAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationInstanceAuthConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 application_name: Optional[pulumi.Input[_builtins.str]] = None,
                 domain_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of AuthN/Z
        :param pulumi.Input[_builtins.str] application_name: Name of the IDCS application
        :param pulumi.Input[_builtins.str] domain_id: Identity Domain OCID
        """
        pulumi.set(__self__, "type", type)
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of AuthN/Z
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the IDCS application
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_name", value)

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity Domain OCID
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_id", value)


if not MYPY:
    class MlApplicationInstanceConfigurationArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        (Updatable) Key of configuration property
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Value of configuration property
        """
elif False:
    MlApplicationInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationInstanceConfigurationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) Key of configuration property
        :param pulumi.Input[_builtins.str] value: (Updatable) Value of configuration property
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Key of configuration property
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Value of configuration property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MlApplicationInstancePredictionEndpointDetailArgsDict(TypedDict):
        base_prediction_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base URI of prediction router.
        """
        prediction_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input['MlApplicationInstancePredictionEndpointDetailPredictionUriArgsDict']]]]
        """
        Array of all prediction URIs per use-case.
        """
elif False:
    MlApplicationInstancePredictionEndpointDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationInstancePredictionEndpointDetailArgs:
    def __init__(__self__, *,
                 base_prediction_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 prediction_uris: Optional[pulumi.Input[Sequence[pulumi.Input['MlApplicationInstancePredictionEndpointDetailPredictionUriArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] base_prediction_uri: Base URI of prediction router.
        :param pulumi.Input[Sequence[pulumi.Input['MlApplicationInstancePredictionEndpointDetailPredictionUriArgs']]] prediction_uris: Array of all prediction URIs per use-case.
        """
        if base_prediction_uri is not None:
            pulumi.set(__self__, "base_prediction_uri", base_prediction_uri)
        if prediction_uris is not None:
            pulumi.set(__self__, "prediction_uris", prediction_uris)

    @_builtins.property
    @pulumi.getter(name="basePredictionUri")
    def base_prediction_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base URI of prediction router.
        """
        return pulumi.get(self, "base_prediction_uri")

    @base_prediction_uri.setter
    def base_prediction_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_prediction_uri", value)

    @_builtins.property
    @pulumi.getter(name="predictionUris")
    def prediction_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MlApplicationInstancePredictionEndpointDetailPredictionUriArgs']]]]:
        """
        Array of all prediction URIs per use-case.
        """
        return pulumi.get(self, "prediction_uris")

    @prediction_uris.setter
    def prediction_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MlApplicationInstancePredictionEndpointDetailPredictionUriArgs']]]]):
        pulumi.set(self, "prediction_uris", value)


if not MYPY:
    class MlApplicationInstancePredictionEndpointDetailPredictionUriArgsDict(TypedDict):
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prediction URI.
        """
        use_case: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prediction use-case.
        """
elif False:
    MlApplicationInstancePredictionEndpointDetailPredictionUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlApplicationInstancePredictionEndpointDetailPredictionUriArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[_builtins.str]] = None,
                 use_case: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: Prediction URI.
        :param pulumi.Input[_builtins.str] use_case: Prediction use-case.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if use_case is not None:
            pulumi.set(__self__, "use_case", use_case)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prediction URI.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="useCase")
    def use_case(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prediction use-case.
        """
        return pulumi.get(self, "use_case")

    @use_case.setter
    def use_case(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "use_case", value)


if not MYPY:
    class ModelBackupOperationDetailArgsDict(TypedDict):
        backup_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup status of the model.
        """
        backup_state_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup execution status details of the model.
        """
        time_last_backup: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last backup execution time of the model.
        """
elif False:
    ModelBackupOperationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBackupOperationDetailArgs:
    def __init__(__self__, *,
                 backup_state: Optional[pulumi.Input[_builtins.str]] = None,
                 backup_state_details: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_backup: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] backup_state: The backup status of the model.
        :param pulumi.Input[_builtins.str] backup_state_details: The backup execution status details of the model.
        :param pulumi.Input[_builtins.str] time_last_backup: The last backup execution time of the model.
        """
        if backup_state is not None:
            pulumi.set(__self__, "backup_state", backup_state)
        if backup_state_details is not None:
            pulumi.set(__self__, "backup_state_details", backup_state_details)
        if time_last_backup is not None:
            pulumi.set(__self__, "time_last_backup", time_last_backup)

    @_builtins.property
    @pulumi.getter(name="backupState")
    def backup_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup status of the model.
        """
        return pulumi.get(self, "backup_state")

    @backup_state.setter
    def backup_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_state", value)

    @_builtins.property
    @pulumi.getter(name="backupStateDetails")
    def backup_state_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup execution status details of the model.
        """
        return pulumi.get(self, "backup_state_details")

    @backup_state_details.setter
    def backup_state_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_state_details", value)

    @_builtins.property
    @pulumi.getter(name="timeLastBackup")
    def time_last_backup(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last backup execution time of the model.
        """
        return pulumi.get(self, "time_last_backup")

    @time_last_backup.setter
    def time_last_backup(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_backup", value)


if not MYPY:
    class ModelBackupSettingArgsDict(TypedDict):
        backup_region: pulumi.Input[_builtins.str]
        """
        (Updatable) Oracle Cloud Infrastructure backup region for the model.
        """
        is_backup_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) Boolean flag representing whether backup needs to be enabled/disabled for the model.
        """
        customer_notification_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Customer notification on backup success/failure events.
        """
elif False:
    ModelBackupSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBackupSettingArgs:
    def __init__(__self__, *,
                 backup_region: pulumi.Input[_builtins.str],
                 is_backup_enabled: pulumi.Input[_builtins.bool],
                 customer_notification_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] backup_region: (Updatable) Oracle Cloud Infrastructure backup region for the model.
        :param pulumi.Input[_builtins.bool] is_backup_enabled: (Updatable) Boolean flag representing whether backup needs to be enabled/disabled for the model.
        :param pulumi.Input[_builtins.str] customer_notification_type: (Updatable) Customer notification on backup success/failure events.
        """
        pulumi.set(__self__, "backup_region", backup_region)
        pulumi.set(__self__, "is_backup_enabled", is_backup_enabled)
        if customer_notification_type is not None:
            pulumi.set(__self__, "customer_notification_type", customer_notification_type)

    @_builtins.property
    @pulumi.getter(name="backupRegion")
    def backup_region(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Oracle Cloud Infrastructure backup region for the model.
        """
        return pulumi.get(self, "backup_region")

    @backup_region.setter
    def backup_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "backup_region", value)

    @_builtins.property
    @pulumi.getter(name="isBackupEnabled")
    def is_backup_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Boolean flag representing whether backup needs to be enabled/disabled for the model.
        """
        return pulumi.get(self, "is_backup_enabled")

    @is_backup_enabled.setter
    def is_backup_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_backup_enabled", value)

    @_builtins.property
    @pulumi.getter(name="customerNotificationType")
    def customer_notification_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Customer notification on backup success/failure events.
        """
        return pulumi.get(self, "customer_notification_type")

    @customer_notification_type.setter
    def customer_notification_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_notification_type", value)


if not MYPY:
    class ModelCustomMetadataListArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,Reports,Readme,other".
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Description of model metadata
        """
        has_artifact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is there any artifact present for the metadata.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Key of the model Metadata. The key can either be user defined or Oracle Cloud Infrastructure defined. List of Oracle Cloud Infrastructure defined keys:
        * useCaseType
        * libraryName
        * libraryVersion
        * estimatorClass
        * hyperParameters
        * testArtifactresults
        * fineTuningConfiguration
        * deploymentConfiguration
        * readme
        * license
        * evaluationConfiguration
        """
        keywords: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) list of keywords for searching
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Allowed values for useCaseType: binary_classification, regression, multinomial_classification, clustering, recommender, dimensionality_reduction/representation, time_series_forecasting, anomaly_detection, topic_modeling, ner, sentiment_analysis, image_classification, object_localization, other

        Allowed values for libraryName: scikit-learn, xgboost, tensorflow, pytorch, mxnet, keras, lightGBM, pymc3, pyOD, spacy, prophet, sktime, statsmodels, cuml, oracle_automl, h2o, transformers, nltk, emcee, pystan, bert, gensim, flair, word2vec, ensemble, other
        """
elif False:
    ModelCustomMetadataListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCustomMetadataListArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 has_artifact: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 keywords: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,Reports,Readme,other".
        :param pulumi.Input[_builtins.str] description: (Updatable) Description of model metadata
        :param pulumi.Input[_builtins.bool] has_artifact: (Updatable) Is there any artifact present for the metadata.
        :param pulumi.Input[_builtins.str] key: (Updatable) Key of the model Metadata. The key can either be user defined or Oracle Cloud Infrastructure defined. List of Oracle Cloud Infrastructure defined keys:
               * useCaseType
               * libraryName
               * libraryVersion
               * estimatorClass
               * hyperParameters
               * testArtifactresults
               * fineTuningConfiguration
               * deploymentConfiguration
               * readme
               * license
               * evaluationConfiguration
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keywords: (Updatable) list of keywords for searching
        :param pulumi.Input[_builtins.str] value: (Updatable) Allowed values for useCaseType: binary_classification, regression, multinomial_classification, clustering, recommender, dimensionality_reduction/representation, time_series_forecasting, anomaly_detection, topic_modeling, ner, sentiment_analysis, image_classification, object_localization, other
               
               Allowed values for libraryName: scikit-learn, xgboost, tensorflow, pytorch, mxnet, keras, lightGBM, pymc3, pyOD, spacy, prophet, sktime, statsmodels, cuml, oracle_automl, h2o, transformers, nltk, emcee, pystan, bert, gensim, flair, word2vec, ensemble, other
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if has_artifact is not None:
            pulumi.set(__self__, "has_artifact", has_artifact)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if keywords is not None:
            pulumi.set(__self__, "keywords", keywords)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,Reports,Readme,other".
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Description of model metadata
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="hasArtifact")
    def has_artifact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is there any artifact present for the metadata.
        """
        return pulumi.get(self, "has_artifact")

    @has_artifact.setter
    def has_artifact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "has_artifact", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Key of the model Metadata. The key can either be user defined or Oracle Cloud Infrastructure defined. List of Oracle Cloud Infrastructure defined keys:
        * useCaseType
        * libraryName
        * libraryVersion
        * estimatorClass
        * hyperParameters
        * testArtifactresults
        * fineTuningConfiguration
        * deploymentConfiguration
        * readme
        * license
        * evaluationConfiguration
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def keywords(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) list of keywords for searching
        """
        return pulumi.get(self, "keywords")

    @keywords.setter
    def keywords(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keywords", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Allowed values for useCaseType: binary_classification, regression, multinomial_classification, clustering, recommender, dimensionality_reduction/representation, time_series_forecasting, anomaly_detection, topic_modeling, ner, sentiment_analysis, image_classification, object_localization, other

        Allowed values for libraryName: scikit-learn, xgboost, tensorflow, pytorch, mxnet, keras, lightGBM, pymc3, pyOD, spacy, prophet, sktime, statsmodels, cuml, oracle_automl, h2o, transformers, nltk, emcee, pystan, bert, gensim, flair, word2vec, ensemble, other
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ModelDefinedMetadataListArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,Reports,Readme,other".
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Description of model metadata
        """
        has_artifact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is there any artifact present for the metadata.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Key of the model Metadata. The key can either be user defined or Oracle Cloud Infrastructure defined. List of Oracle Cloud Infrastructure defined keys:
        * useCaseType
        * libraryName
        * libraryVersion
        * estimatorClass
        * hyperParameters
        * testArtifactresults
        * fineTuningConfiguration
        * deploymentConfiguration
        * readme
        * license
        * evaluationConfiguration
        """
        keywords: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) list of keywords for searching
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Allowed values for useCaseType: binary_classification, regression, multinomial_classification, clustering, recommender, dimensionality_reduction/representation, time_series_forecasting, anomaly_detection, topic_modeling, ner, sentiment_analysis, image_classification, object_localization, other

        Allowed values for libraryName: scikit-learn, xgboost, tensorflow, pytorch, mxnet, keras, lightGBM, pymc3, pyOD, spacy, prophet, sktime, statsmodels, cuml, oracle_automl, h2o, transformers, nltk, emcee, pystan, bert, gensim, flair, word2vec, ensemble, other
        """
elif False:
    ModelDefinedMetadataListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDefinedMetadataListArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 has_artifact: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 keywords: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,Reports,Readme,other".
        :param pulumi.Input[_builtins.str] description: (Updatable) Description of model metadata
        :param pulumi.Input[_builtins.bool] has_artifact: (Updatable) Is there any artifact present for the metadata.
        :param pulumi.Input[_builtins.str] key: (Updatable) Key of the model Metadata. The key can either be user defined or Oracle Cloud Infrastructure defined. List of Oracle Cloud Infrastructure defined keys:
               * useCaseType
               * libraryName
               * libraryVersion
               * estimatorClass
               * hyperParameters
               * testArtifactresults
               * fineTuningConfiguration
               * deploymentConfiguration
               * readme
               * license
               * evaluationConfiguration
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keywords: (Updatable) list of keywords for searching
        :param pulumi.Input[_builtins.str] value: (Updatable) Allowed values for useCaseType: binary_classification, regression, multinomial_classification, clustering, recommender, dimensionality_reduction/representation, time_series_forecasting, anomaly_detection, topic_modeling, ner, sentiment_analysis, image_classification, object_localization, other
               
               Allowed values for libraryName: scikit-learn, xgboost, tensorflow, pytorch, mxnet, keras, lightGBM, pymc3, pyOD, spacy, prophet, sktime, statsmodels, cuml, oracle_automl, h2o, transformers, nltk, emcee, pystan, bert, gensim, flair, word2vec, ensemble, other
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if has_artifact is not None:
            pulumi.set(__self__, "has_artifact", has_artifact)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if keywords is not None:
            pulumi.set(__self__, "keywords", keywords)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,Reports,Readme,other".
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Description of model metadata
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="hasArtifact")
    def has_artifact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is there any artifact present for the metadata.
        """
        return pulumi.get(self, "has_artifact")

    @has_artifact.setter
    def has_artifact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "has_artifact", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Key of the model Metadata. The key can either be user defined or Oracle Cloud Infrastructure defined. List of Oracle Cloud Infrastructure defined keys:
        * useCaseType
        * libraryName
        * libraryVersion
        * estimatorClass
        * hyperParameters
        * testArtifactresults
        * fineTuningConfiguration
        * deploymentConfiguration
        * readme
        * license
        * evaluationConfiguration
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def keywords(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) list of keywords for searching
        """
        return pulumi.get(self, "keywords")

    @keywords.setter
    def keywords(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keywords", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Allowed values for useCaseType: binary_classification, regression, multinomial_classification, clustering, recommender, dimensionality_reduction/representation, time_series_forecasting, anomaly_detection, topic_modeling, ner, sentiment_analysis, image_classification, object_localization, other

        Allowed values for libraryName: scikit-learn, xgboost, tensorflow, pytorch, mxnet, keras, lightGBM, pymc3, pyOD, spacy, prophet, sktime, statsmodels, cuml, oracle_automl, h2o, transformers, nltk, emcee, pystan, bert, gensim, flair, word2vec, ensemble, other
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ModelDeploymentCategoryLogDetailsArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ModelDeploymentCategoryLogDetailsAccessArgsDict']]
        """
        (Updatable) The log details.
        """
        predict: NotRequired[pulumi.Input['ModelDeploymentCategoryLogDetailsPredictArgsDict']]
        """
        (Updatable) The log details.
        """
elif False:
    ModelDeploymentCategoryLogDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentCategoryLogDetailsArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ModelDeploymentCategoryLogDetailsAccessArgs']] = None,
                 predict: Optional[pulumi.Input['ModelDeploymentCategoryLogDetailsPredictArgs']] = None):
        """
        :param pulumi.Input['ModelDeploymentCategoryLogDetailsAccessArgs'] access: (Updatable) The log details.
        :param pulumi.Input['ModelDeploymentCategoryLogDetailsPredictArgs'] predict: (Updatable) The log details.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if predict is not None:
            pulumi.set(__self__, "predict", predict)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ModelDeploymentCategoryLogDetailsAccessArgs']]:
        """
        (Updatable) The log details.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ModelDeploymentCategoryLogDetailsAccessArgs']]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter
    def predict(self) -> Optional[pulumi.Input['ModelDeploymentCategoryLogDetailsPredictArgs']]:
        """
        (Updatable) The log details.
        """
        return pulumi.get(self, "predict")

    @predict.setter
    def predict(self, value: Optional[pulumi.Input['ModelDeploymentCategoryLogDetailsPredictArgs']]):
        pulumi.set(self, "predict", value)


if not MYPY:
    class ModelDeploymentCategoryLogDetailsAccessArgsDict(TypedDict):
        log_group_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        """
        log_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
elif False:
    ModelDeploymentCategoryLogDetailsAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentCategoryLogDetailsAccessArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[_builtins.str],
                 log_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class ModelDeploymentCategoryLogDetailsPredictArgsDict(TypedDict):
        log_group_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        """
        log_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
elif False:
    ModelDeploymentCategoryLogDetailsPredictArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentCategoryLogDetailsPredictArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[_builtins.str],
                 log_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsArgsDict(TypedDict):
        deployment_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of the model deployment.
        """
        environment_configuration_details: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgsDict']]
        """
        (Updatable) The configuration to carry the environment details thats used in Model Deployment creation
        """
        infrastructure_configuration_details: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgsDict']]
        model_configuration_details: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgsDict']]
        """
        (Updatable) The model configuration details.
        """
        model_group_configuration_details: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgsDict']]
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsArgs:
    def __init__(__self__, *,
                 deployment_type: pulumi.Input[_builtins.str],
                 environment_configuration_details: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgs']] = None,
                 infrastructure_configuration_details: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgs']] = None,
                 model_configuration_details: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs']] = None,
                 model_group_configuration_details: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] deployment_type: (Updatable) The type of the model deployment.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgs'] environment_configuration_details: (Updatable) The configuration to carry the environment details thats used in Model Deployment creation
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs'] model_configuration_details: (Updatable) The model configuration details.
        """
        pulumi.set(__self__, "deployment_type", deployment_type)
        if environment_configuration_details is not None:
            pulumi.set(__self__, "environment_configuration_details", environment_configuration_details)
        if infrastructure_configuration_details is not None:
            pulumi.set(__self__, "infrastructure_configuration_details", infrastructure_configuration_details)
        if model_configuration_details is not None:
            pulumi.set(__self__, "model_configuration_details", model_configuration_details)
        if model_group_configuration_details is not None:
            pulumi.set(__self__, "model_group_configuration_details", model_group_configuration_details)

    @_builtins.property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of the model deployment.
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_type", value)

    @_builtins.property
    @pulumi.getter(name="environmentConfigurationDetails")
    def environment_configuration_details(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgs']]:
        """
        (Updatable) The configuration to carry the environment details thats used in Model Deployment creation
        """
        return pulumi.get(self, "environment_configuration_details")

    @environment_configuration_details.setter
    def environment_configuration_details(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgs']]):
        pulumi.set(self, "environment_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="infrastructureConfigurationDetails")
    def infrastructure_configuration_details(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgs']]:
        return pulumi.get(self, "infrastructure_configuration_details")

    @infrastructure_configuration_details.setter
    def infrastructure_configuration_details(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgs']]):
        pulumi.set(self, "infrastructure_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="modelConfigurationDetails")
    def model_configuration_details(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs']]:
        """
        (Updatable) The model configuration details.
        """
        return pulumi.get(self, "model_configuration_details")

    @model_configuration_details.setter
    def model_configuration_details(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs']]):
        pulumi.set(self, "model_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="modelGroupConfigurationDetails")
    def model_group_configuration_details(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgs']]:
        return pulumi.get(self, "model_group_configuration_details")

    @model_group_configuration_details.setter
    def model_group_configuration_details(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgs']]):
        pulumi.set(self, "model_group_configuration_details", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgsDict(TypedDict):
        environment_configuration_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The environment configuration type
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Environment variables to set for the web server container. The size of envVars must be less than 2048 bytes. Key should be under 32 characters. Key should contain only letters, digits and underscore (_) Key should start with a letter. Key should have at least 2 characters. Key should not end with underscore eg. `TEST_` Key if added cannot be empty. Value can be empty. No specific size limits on individual Values. But overall environment variables is limited to 2048 bytes. Key can't be reserved Model Deployment environment variables.
        """
        health_check_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port on which the container [HEALTHCHECK](https://docs.docker.com/engine/reference/builder/#healthcheck) would listen. The port can be anything between `1024` and `65535`. The following ports cannot be used `24224`, `8446`, `8447`.
        """
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        server_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port on which the web server serving the inference is running. The port can be anything between `1024` and `65535`. The following ports cannot be used `24224`, `8446`, `8447`.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsEnvironmentConfigurationDetailsArgs:
    def __init__(__self__, *,
                 environment_configuration_type: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 health_check_port: Optional[pulumi.Input[_builtins.int]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 server_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] environment_configuration_type: (Updatable) The environment configuration type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: (Updatable) Environment variables to set for the web server container. The size of envVars must be less than 2048 bytes. Key should be under 32 characters. Key should contain only letters, digits and underscore (_) Key should start with a letter. Key should have at least 2 characters. Key should not end with underscore eg. `TEST_` Key if added cannot be empty. Value can be empty. No specific size limits on individual Values. But overall environment variables is limited to 2048 bytes. Key can't be reserved Model Deployment environment variables.
        :param pulumi.Input[_builtins.int] health_check_port: (Updatable) The port on which the container [HEALTHCHECK](https://docs.docker.com/engine/reference/builder/#healthcheck) would listen. The port can be anything between `1024` and `65535`. The following ports cannot be used `24224`, `8446`, `8447`.
        :param pulumi.Input[_builtins.str] image: (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        :param pulumi.Input[_builtins.str] image_digest: (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.int] server_port: (Updatable) The port on which the web server serving the inference is running. The port can be anything between `1024` and `65535`. The following ports cannot be used `24224`, `8446`, `8447`.
        """
        pulumi.set(__self__, "environment_configuration_type", environment_configuration_type)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if health_check_port is not None:
            pulumi.set(__self__, "health_check_port", health_check_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if server_port is not None:
            pulumi.set(__self__, "server_port", server_port)

    @_builtins.property
    @pulumi.getter(name="environmentConfigurationType")
    def environment_configuration_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The environment configuration type
        """
        return pulumi.get(self, "environment_configuration_type")

    @environment_configuration_type.setter
    def environment_configuration_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "environment_configuration_type", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Environment variables to set for the web server container. The size of envVars must be less than 2048 bytes. Key should be under 32 characters. Key should contain only letters, digits and underscore (_) Key should start with a letter. Key should have at least 2 characters. Key should not end with underscore eg. `TEST_` Key if added cannot be empty. Value can be empty. No specific size limits on individual Values. But overall environment variables is limited to 2048 bytes. Key can't be reserved Model Deployment environment variables.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port on which the container [HEALTHCHECK](https://docs.docker.com/engine/reference/builder/#healthcheck) would listen. The port can be anything between `1024` and `65535`. The following ports cannot be used `24224`, `8446`, `8447`.
        """
        return pulumi.get(self, "health_check_port")

    @health_check_port.setter
    def health_check_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "health_check_port", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="serverPort")
    def server_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port on which the web server serving the inference is running. The port can be anything between `1024` and `65535`. The following ports cannot be used `24224`, `8446`, `8447`.
        """
        return pulumi.get(self, "server_port")

    @server_port.setter
    def server_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "server_port", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgsDict(TypedDict):
        infrastructure_type: pulumi.Input[_builtins.str]
        instance_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgsDict']
        """
        The model deployment instance configuration.
        """
        bandwidth_mbps: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum network bandwidth for the model deployment.
        """
        maximum_bandwidth_mbps: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum network bandwidth for the model deployment.
        """
        scaling_policy: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgsDict']]
        """
        The scaling policy to apply to each model of the deployment.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 infrastructure_type: pulumi.Input[_builtins.str],
                 instance_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgs'],
                 bandwidth_mbps: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum_bandwidth_mbps: Optional[pulumi.Input[_builtins.int]] = None,
                 scaling_policy: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgs']] = None):
        """
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgs'] instance_configuration: The model deployment instance configuration.
        :param pulumi.Input[_builtins.int] bandwidth_mbps: The minimum network bandwidth for the model deployment.
        :param pulumi.Input[_builtins.int] maximum_bandwidth_mbps: The maximum network bandwidth for the model deployment.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgs'] scaling_policy: The scaling policy to apply to each model of the deployment.
        """
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        pulumi.set(__self__, "instance_configuration", instance_configuration)
        if bandwidth_mbps is not None:
            pulumi.set(__self__, "bandwidth_mbps", bandwidth_mbps)
        if maximum_bandwidth_mbps is not None:
            pulumi.set(__self__, "maximum_bandwidth_mbps", maximum_bandwidth_mbps)
        if scaling_policy is not None:
            pulumi.set(__self__, "scaling_policy", scaling_policy)

    @_builtins.property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "infrastructure_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceConfiguration")
    def instance_configuration(self) -> pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgs']:
        """
        The model deployment instance configuration.
        """
        return pulumi.get(self, "instance_configuration")

    @instance_configuration.setter
    def instance_configuration(self, value: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgs']):
        pulumi.set(self, "instance_configuration", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthMbps")
    def bandwidth_mbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum network bandwidth for the model deployment.
        """
        return pulumi.get(self, "bandwidth_mbps")

    @bandwidth_mbps.setter
    def bandwidth_mbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="maximumBandwidthMbps")
    def maximum_bandwidth_mbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum network bandwidth for the model deployment.
        """
        return pulumi.get(self, "maximum_bandwidth_mbps")

    @maximum_bandwidth_mbps.setter
    def maximum_bandwidth_mbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgs']]:
        """
        The scaling policy to apply to each model of the deployment.
        """
        return pulumi.get(self, "scaling_policy")

    @scaling_policy.setter
    def scaling_policy(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgs']]):
        pulumi.set(self, "scaling_policy", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgsDict(TypedDict):
        instance_shape_name: pulumi.Input[_builtins.str]
        """
        The shape used to launch the model deployment instances.
        """
        model_deployment_instance_shape_config_details: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict']]
        """
        Details for the model-deployment instance shape configuration.
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of a Data Science private endpoint.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A model deployment instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT/SGW gateway for egress.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationArgs:
    def __init__(__self__, *,
                 instance_shape_name: pulumi.Input[_builtins.str],
                 model_deployment_instance_shape_config_details: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs']] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_shape_name: The shape used to launch the model deployment instances.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs'] model_deployment_instance_shape_config_details: Details for the model-deployment instance shape configuration.
        :param pulumi.Input[_builtins.str] private_endpoint_id: The OCID of a Data Science private endpoint.
        :param pulumi.Input[_builtins.str] subnet_id: A model deployment instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT/SGW gateway for egress.
        """
        pulumi.set(__self__, "instance_shape_name", instance_shape_name)
        if model_deployment_instance_shape_config_details is not None:
            pulumi.set(__self__, "model_deployment_instance_shape_config_details", model_deployment_instance_shape_config_details)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="instanceShapeName")
    def instance_shape_name(self) -> pulumi.Input[_builtins.str]:
        """
        The shape used to launch the model deployment instances.
        """
        return pulumi.get(self, "instance_shape_name")

    @instance_shape_name.setter
    def instance_shape_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_shape_name", value)

    @_builtins.property
    @pulumi.getter(name="modelDeploymentInstanceShapeConfigDetails")
    def model_deployment_instance_shape_config_details(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs']]:
        """
        Details for the model-deployment instance shape configuration.
        """
        return pulumi.get(self, "model_deployment_instance_shape_config_details")

    @model_deployment_instance_shape_config_details.setter
    def model_deployment_instance_shape_config_details(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs']]):
        pulumi.set(self, "model_deployment_instance_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of a Data Science private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A model deployment instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT/SGW gateway for egress.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the memory to be specified with in the range of 6 to 1024 GB. VM.Standard3.Flex memory range is between 6 to 512 GB and VM.Optimized3.Flex memory range is between 6 to 256 GB.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the ocpu count to be specified with in the range of 1 to 64 ocpu. VM.Standard3.Flex OCPU range is between 1 to 32 ocpu and for VM.Optimized3.Flex OCPU range is 1 to 18 ocpu.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the memory to be specified with in the range of 6 to 1024 GB. VM.Standard3.Flex memory range is between 6 to 512 GB and VM.Optimized3.Flex memory range is between 6 to 256 GB.
        :param pulumi.Input[_builtins.float] ocpus: A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the ocpu count to be specified with in the range of 1 to 64 ocpu. VM.Standard3.Flex OCPU range is between 1 to 32 ocpu and for VM.Optimized3.Flex OCPU range is 1 to 18 ocpu.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the memory to be specified with in the range of 6 to 1024 GB. VM.Standard3.Flex memory range is between 6 to 512 GB and VM.Optimized3.Flex memory range is between 6 to 256 GB.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the ocpu count to be specified with in the range of 1 to 64 ocpu. VM.Standard3.Flex OCPU range is between 1 to 32 ocpu and for VM.Optimized3.Flex OCPU range is 1 to 18 ocpu.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgsDict(TypedDict):
        policy_type: pulumi.Input[_builtins.str]
        """
        The type of scaling policy.
        """
        auto_scaling_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict']]]]
        """
        The list of autoscaling policy details.
        """
        cool_down_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        For threshold-based autoscaling policies, this value is the minimum period of time to wait between scaling actions. The cooldown period gives the system time to stabilize before rescaling. The minimum value is 600 seconds, which is also the default. The cooldown period starts when the model deployment becomes ACTIVE after the scaling operation.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of instances for the model deployment.
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the autoscaling policy is enabled.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[_builtins.str],
                 auto_scaling_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]]] = None,
                 cool_down_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] policy_type: The type of scaling policy.
        :param pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]] auto_scaling_policies: The list of autoscaling policy details.
        :param pulumi.Input[_builtins.int] cool_down_in_seconds: For threshold-based autoscaling policies, this value is the minimum period of time to wait between scaling actions. The cooldown period gives the system time to stabilize before rescaling. The minimum value is 600 seconds, which is also the default. The cooldown period starts when the model deployment becomes ACTIVE after the scaling operation.
        :param pulumi.Input[_builtins.int] instance_count: The number of instances for the model deployment.
        :param pulumi.Input[_builtins.bool] is_enabled: Whether the autoscaling policy is enabled.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if auto_scaling_policies is not None:
            pulumi.set(__self__, "auto_scaling_policies", auto_scaling_policies)
        if cool_down_in_seconds is not None:
            pulumi.set(__self__, "cool_down_in_seconds", cool_down_in_seconds)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of scaling policy.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_type", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingPolicies")
    def auto_scaling_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]]]:
        """
        The list of autoscaling policy details.
        """
        return pulumi.get(self, "auto_scaling_policies")

    @auto_scaling_policies.setter
    def auto_scaling_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]]]):
        pulumi.set(self, "auto_scaling_policies", value)

    @_builtins.property
    @pulumi.getter(name="coolDownInSeconds")
    def cool_down_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        For threshold-based autoscaling policies, this value is the minimum period of time to wait between scaling actions. The cooldown period gives the system time to stabilize before rescaling. The minimum value is 600 seconds, which is also the default. The cooldown period starts when the model deployment becomes ACTIVE after the scaling operation.
        """
        return pulumi.get(self, "cool_down_in_seconds")

    @cool_down_in_seconds.setter
    def cool_down_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cool_down_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of instances for the model deployment.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the autoscaling policy is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict(TypedDict):
        auto_scaling_policy_type: pulumi.Input[_builtins.str]
        """
        The type of autoscaling policy.
        """
        initial_instance_count: pulumi.Input[_builtins.int]
        """
        For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the model deployment immediately after autoscaling is enabled. Note that anytime this value is updated, the number of instances will be reset to this value. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        """
        maximum_instance_count: pulumi.Input[_builtins.int]
        """
        For a threshold-based autoscaling policy, this value is the maximum number of instances the model deployment is allowed to increase to (scale out).
        """
        minimum_instance_count: pulumi.Input[_builtins.int]
        """
        For a threshold-based autoscaling policy, this value is the minimum number of instances the model deployment is allowed to decrease to (scale in).
        """
        rules: pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict']]]
        """
        The list of autoscaling policy rules.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyArgs:
    def __init__(__self__, *,
                 auto_scaling_policy_type: pulumi.Input[_builtins.str],
                 initial_instance_count: pulumi.Input[_builtins.int],
                 maximum_instance_count: pulumi.Input[_builtins.int],
                 minimum_instance_count: pulumi.Input[_builtins.int],
                 rules: pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]]):
        """
        :param pulumi.Input[_builtins.str] auto_scaling_policy_type: The type of autoscaling policy.
        :param pulumi.Input[_builtins.int] initial_instance_count: For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the model deployment immediately after autoscaling is enabled. Note that anytime this value is updated, the number of instances will be reset to this value. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        :param pulumi.Input[_builtins.int] maximum_instance_count: For a threshold-based autoscaling policy, this value is the maximum number of instances the model deployment is allowed to increase to (scale out).
        :param pulumi.Input[_builtins.int] minimum_instance_count: For a threshold-based autoscaling policy, this value is the minimum number of instances the model deployment is allowed to decrease to (scale in).
        :param pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]] rules: The list of autoscaling policy rules.
        """
        pulumi.set(__self__, "auto_scaling_policy_type", auto_scaling_policy_type)
        pulumi.set(__self__, "initial_instance_count", initial_instance_count)
        pulumi.set(__self__, "maximum_instance_count", maximum_instance_count)
        pulumi.set(__self__, "minimum_instance_count", minimum_instance_count)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="autoScalingPolicyType")
    def auto_scaling_policy_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of autoscaling policy.
        """
        return pulumi.get(self, "auto_scaling_policy_type")

    @auto_scaling_policy_type.setter
    def auto_scaling_policy_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auto_scaling_policy_type", value)

    @_builtins.property
    @pulumi.getter(name="initialInstanceCount")
    def initial_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the model deployment immediately after autoscaling is enabled. Note that anytime this value is updated, the number of instances will be reset to this value. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        """
        return pulumi.get(self, "initial_instance_count")

    @initial_instance_count.setter
    def initial_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "initial_instance_count", value)

    @_builtins.property
    @pulumi.getter(name="maximumInstanceCount")
    def maximum_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        For a threshold-based autoscaling policy, this value is the maximum number of instances the model deployment is allowed to increase to (scale out).
        """
        return pulumi.get(self, "maximum_instance_count")

    @maximum_instance_count.setter
    def maximum_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_instance_count", value)

    @_builtins.property
    @pulumi.getter(name="minimumInstanceCount")
    def minimum_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        For a threshold-based autoscaling policy, this value is the minimum number of instances the model deployment is allowed to decrease to (scale in).
        """
        return pulumi.get(self, "minimum_instance_count")

    @minimum_instance_count.setter
    def minimum_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_instance_count", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]]:
        """
        The list of autoscaling policy rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict(TypedDict):
        metric_expression_rule_type: pulumi.Input[_builtins.str]
        """
        The metric expression for creating the alarm used to trigger autoscaling actions on the model deployment.
        """
        scale_in_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict']
        """
        The scaling configuration for the predefined metric expression rule.
        """
        scale_out_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict']
        """
        The scaling configuration for the predefined metric expression rule.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric type
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs:
    def __init__(__self__, *,
                 metric_expression_rule_type: pulumi.Input[_builtins.str],
                 scale_in_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs'],
                 scale_out_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs'],
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_expression_rule_type: The metric expression for creating the alarm used to trigger autoscaling actions on the model deployment.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs'] scale_in_configuration: The scaling configuration for the predefined metric expression rule.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs'] scale_out_configuration: The scaling configuration for the predefined metric expression rule.
        :param pulumi.Input[_builtins.str] metric_type: Metric type
        """
        pulumi.set(__self__, "metric_expression_rule_type", metric_expression_rule_type)
        pulumi.set(__self__, "scale_in_configuration", scale_in_configuration)
        pulumi.set(__self__, "scale_out_configuration", scale_out_configuration)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)

    @_builtins.property
    @pulumi.getter(name="metricExpressionRuleType")
    def metric_expression_rule_type(self) -> pulumi.Input[_builtins.str]:
        """
        The metric expression for creating the alarm used to trigger autoscaling actions on the model deployment.
        """
        return pulumi.get(self, "metric_expression_rule_type")

    @metric_expression_rule_type.setter
    def metric_expression_rule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_expression_rule_type", value)

    @_builtins.property
    @pulumi.getter(name="scaleInConfiguration")
    def scale_in_configuration(self) -> pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs']:
        """
        The scaling configuration for the predefined metric expression rule.
        """
        return pulumi.get(self, "scale_in_configuration")

    @scale_in_configuration.setter
    def scale_in_configuration(self, value: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs']):
        pulumi.set(self, "scale_in_configuration", value)

    @_builtins.property
    @pulumi.getter(name="scaleOutConfiguration")
    def scale_out_configuration(self) -> pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs']:
        """
        The scaling configuration for the predefined metric expression rule.
        """
        return pulumi.get(self, "scale_out_configuration")

    @scale_out_configuration.setter
    def scale_out_configuration(self, value: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs']):
        pulumi.set(self, "scale_out_configuration", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric type
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict(TypedDict):
        instance_count_adjustment: NotRequired[pulumi.Input[_builtins.int]]
        """
        The value is used for adjusting the count of instances by.
        """
        pending_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
        """
        scaling_configuration_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of scaling configuration.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        A metric value at which the scaling operation will be triggered.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs:
    def __init__(__self__, *,
                 instance_count_adjustment: Optional[pulumi.Input[_builtins.int]] = None,
                 pending_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 scaling_configuration_type: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] instance_count_adjustment: The value is used for adjusting the count of instances by.
        :param pulumi.Input[_builtins.str] pending_duration: The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
        :param pulumi.Input[_builtins.str] query: The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
        :param pulumi.Input[_builtins.str] scaling_configuration_type: The type of scaling configuration.
        :param pulumi.Input[_builtins.int] threshold: A metric value at which the scaling operation will be triggered.
        """
        if instance_count_adjustment is not None:
            pulumi.set(__self__, "instance_count_adjustment", instance_count_adjustment)
        if pending_duration is not None:
            pulumi.set(__self__, "pending_duration", pending_duration)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if scaling_configuration_type is not None:
            pulumi.set(__self__, "scaling_configuration_type", scaling_configuration_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="instanceCountAdjustment")
    def instance_count_adjustment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The value is used for adjusting the count of instances by.
        """
        return pulumi.get(self, "instance_count_adjustment")

    @instance_count_adjustment.setter
    def instance_count_adjustment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count_adjustment", value)

    @_builtins.property
    @pulumi.getter(name="pendingDuration")
    def pending_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
        """
        return pulumi.get(self, "pending_duration")

    @pending_duration.setter
    def pending_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pending_duration", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationType")
    def scaling_configuration_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of scaling configuration.
        """
        return pulumi.get(self, "scaling_configuration_type")

    @scaling_configuration_type.setter
    def scaling_configuration_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_configuration_type", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A metric value at which the scaling operation will be triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict(TypedDict):
        instance_count_adjustment: NotRequired[pulumi.Input[_builtins.int]]
        """
        The value is used for adjusting the count of instances by.
        """
        pending_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
        """
        scaling_configuration_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of scaling configuration.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        A metric value at which the scaling operation will be triggered.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsInfrastructureConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs:
    def __init__(__self__, *,
                 instance_count_adjustment: Optional[pulumi.Input[_builtins.int]] = None,
                 pending_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 scaling_configuration_type: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] instance_count_adjustment: The value is used for adjusting the count of instances by.
        :param pulumi.Input[_builtins.str] pending_duration: The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
        :param pulumi.Input[_builtins.str] query: The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
        :param pulumi.Input[_builtins.str] scaling_configuration_type: The type of scaling configuration.
        :param pulumi.Input[_builtins.int] threshold: A metric value at which the scaling operation will be triggered.
        """
        if instance_count_adjustment is not None:
            pulumi.set(__self__, "instance_count_adjustment", instance_count_adjustment)
        if pending_duration is not None:
            pulumi.set(__self__, "pending_duration", pending_duration)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if scaling_configuration_type is not None:
            pulumi.set(__self__, "scaling_configuration_type", scaling_configuration_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="instanceCountAdjustment")
    def instance_count_adjustment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The value is used for adjusting the count of instances by.
        """
        return pulumi.get(self, "instance_count_adjustment")

    @instance_count_adjustment.setter
    def instance_count_adjustment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count_adjustment", value)

    @_builtins.property
    @pulumi.getter(name="pendingDuration")
    def pending_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
        """
        return pulumi.get(self, "pending_duration")

    @pending_duration.setter
    def pending_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pending_duration", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationType")
    def scaling_configuration_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of scaling configuration.
        """
        return pulumi.get(self, "scaling_configuration_type")

    @scaling_configuration_type.setter
    def scaling_configuration_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_configuration_type", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A metric value at which the scaling operation will be triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgsDict(TypedDict):
        bandwidth_mbps: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The minimum network bandwidth for the model deployment.
        """
        instance_configuration: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgsDict']]
        """
        (Updatable) The model deployment instance configuration.
        """
        maximum_bandwidth_mbps: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum network bandwidth for the model deployment.
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the model you want to deploy.
        """
        scaling_policy: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgsDict']]
        """
        (Updatable) The scaling policy to apply to each model of the deployment.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs:
    def __init__(__self__, *,
                 bandwidth_mbps: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_configuration: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs']] = None,
                 maximum_bandwidth_mbps: Optional[pulumi.Input[_builtins.int]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 scaling_policy: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] bandwidth_mbps: (Updatable) The minimum network bandwidth for the model deployment.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs'] instance_configuration: (Updatable) The model deployment instance configuration.
        :param pulumi.Input[_builtins.int] maximum_bandwidth_mbps: (Updatable) The maximum network bandwidth for the model deployment.
        :param pulumi.Input[_builtins.str] model_id: (Updatable) The OCID of the model you want to deploy.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs'] scaling_policy: (Updatable) The scaling policy to apply to each model of the deployment.
        """
        if bandwidth_mbps is not None:
            pulumi.set(__self__, "bandwidth_mbps", bandwidth_mbps)
        if instance_configuration is not None:
            pulumi.set(__self__, "instance_configuration", instance_configuration)
        if maximum_bandwidth_mbps is not None:
            pulumi.set(__self__, "maximum_bandwidth_mbps", maximum_bandwidth_mbps)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if scaling_policy is not None:
            pulumi.set(__self__, "scaling_policy", scaling_policy)

    @_builtins.property
    @pulumi.getter(name="bandwidthMbps")
    def bandwidth_mbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The minimum network bandwidth for the model deployment.
        """
        return pulumi.get(self, "bandwidth_mbps")

    @bandwidth_mbps.setter
    def bandwidth_mbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="instanceConfiguration")
    def instance_configuration(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs']]:
        """
        (Updatable) The model deployment instance configuration.
        """
        return pulumi.get(self, "instance_configuration")

    @instance_configuration.setter
    def instance_configuration(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs']]):
        pulumi.set(self, "instance_configuration", value)

    @_builtins.property
    @pulumi.getter(name="maximumBandwidthMbps")
    def maximum_bandwidth_mbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum network bandwidth for the model deployment.
        """
        return pulumi.get(self, "maximum_bandwidth_mbps")

    @maximum_bandwidth_mbps.setter
    def maximum_bandwidth_mbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the model you want to deploy.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs']]:
        """
        (Updatable) The scaling policy to apply to each model of the deployment.
        """
        return pulumi.get(self, "scaling_policy")

    @scaling_policy.setter
    def scaling_policy(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs']]):
        pulumi.set(self, "scaling_policy", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgsDict(TypedDict):
        instance_shape_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The shape used to launch the model deployment instances.
        """
        model_deployment_instance_shape_config_details: NotRequired[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the model-deployment instance shape configuration.
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of a Data Science private endpoint.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A model deployment instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT/SGW gateway for egress.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs:
    def __init__(__self__, *,
                 instance_shape_name: Optional[pulumi.Input[_builtins.str]] = None,
                 model_deployment_instance_shape_config_details: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs']] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_shape_name: (Updatable) The shape used to launch the model deployment instances.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs'] model_deployment_instance_shape_config_details: (Updatable) Details for the model-deployment instance shape configuration.
        :param pulumi.Input[_builtins.str] private_endpoint_id: (Updatable) The OCID of a Data Science private endpoint.
        :param pulumi.Input[_builtins.str] subnet_id: (Updatable) A model deployment instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT/SGW gateway for egress.
        """
        if instance_shape_name is not None:
            pulumi.set(__self__, "instance_shape_name", instance_shape_name)
        if model_deployment_instance_shape_config_details is not None:
            pulumi.set(__self__, "model_deployment_instance_shape_config_details", model_deployment_instance_shape_config_details)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="instanceShapeName")
    def instance_shape_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The shape used to launch the model deployment instances.
        """
        return pulumi.get(self, "instance_shape_name")

    @instance_shape_name.setter
    def instance_shape_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_shape_name", value)

    @_builtins.property
    @pulumi.getter(name="modelDeploymentInstanceShapeConfigDetails")
    def model_deployment_instance_shape_config_details(self) -> Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the model-deployment instance shape configuration.
        """
        return pulumi.get(self, "model_deployment_instance_shape_config_details")

    @model_deployment_instance_shape_config_details.setter
    def model_deployment_instance_shape_config_details(self, value: Optional[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs']]):
        pulumi.set(self, "model_deployment_instance_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of a Data Science private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A model deployment instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT/SGW gateway for egress.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the memory to be specified with in the range of 6 to 1024 GB. VM.Standard3.Flex memory range is between 6 to 512 GB and VM.Optimized3.Flex memory range is between 6 to 256 GB.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the ocpu count to be specified with in the range of 1 to 64 ocpu. VM.Standard3.Flex OCPU range is between 1 to 32 ocpu and for VM.Optimized3.Flex OCPU range is 1 to 18 ocpu.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationModelDeploymentInstanceShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the memory to be specified with in the range of 6 to 1024 GB. VM.Standard3.Flex memory range is between 6 to 512 GB and VM.Optimized3.Flex memory range is between 6 to 256 GB.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the ocpu count to be specified with in the range of 1 to 64 ocpu. VM.Standard3.Flex OCPU range is between 1 to 32 ocpu and for VM.Optimized3.Flex OCPU range is 1 to 18 ocpu.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the memory to be specified with in the range of 6 to 1024 GB. VM.Standard3.Flex memory range is between 6 to 512 GB and VM.Optimized3.Flex memory range is between 6 to 256 GB.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A model-deployment instance of type VM.Standard.E3.Flex or VM.Standard.E4.Flex allows the ocpu count to be specified with in the range of 1 to 64 ocpu. VM.Standard3.Flex OCPU range is between 1 to 32 ocpu and for VM.Optimized3.Flex OCPU range is 1 to 18 ocpu.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgsDict(TypedDict):
        policy_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of scaling policy.
        """
        auto_scaling_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict']]]]
        """
        (Updatable) The list of autoscaling policy details.
        """
        cool_down_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) For threshold-based autoscaling policies, this value is the minimum period of time to wait between scaling actions. The cooldown period gives the system time to stabilize before rescaling. The minimum value is 600 seconds, which is also the default. The cooldown period starts when the model deployment becomes ACTIVE after the scaling operation.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of instances for the model deployment.
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the autoscaling policy is enabled.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[_builtins.str],
                 auto_scaling_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]]] = None,
                 cool_down_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] policy_type: (Updatable) The type of scaling policy.
        :param pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]] auto_scaling_policies: (Updatable) The list of autoscaling policy details.
        :param pulumi.Input[_builtins.int] cool_down_in_seconds: (Updatable) For threshold-based autoscaling policies, this value is the minimum period of time to wait between scaling actions. The cooldown period gives the system time to stabilize before rescaling. The minimum value is 600 seconds, which is also the default. The cooldown period starts when the model deployment becomes ACTIVE after the scaling operation.
        :param pulumi.Input[_builtins.int] instance_count: (Updatable) The number of instances for the model deployment.
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Whether the autoscaling policy is enabled.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if auto_scaling_policies is not None:
            pulumi.set(__self__, "auto_scaling_policies", auto_scaling_policies)
        if cool_down_in_seconds is not None:
            pulumi.set(__self__, "cool_down_in_seconds", cool_down_in_seconds)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of scaling policy.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_type", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingPolicies")
    def auto_scaling_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]]]:
        """
        (Updatable) The list of autoscaling policy details.
        """
        return pulumi.get(self, "auto_scaling_policies")

    @auto_scaling_policies.setter
    def auto_scaling_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgs']]]]):
        pulumi.set(self, "auto_scaling_policies", value)

    @_builtins.property
    @pulumi.getter(name="coolDownInSeconds")
    def cool_down_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) For threshold-based autoscaling policies, this value is the minimum period of time to wait between scaling actions. The cooldown period gives the system time to stabilize before rescaling. The minimum value is 600 seconds, which is also the default. The cooldown period starts when the model deployment becomes ACTIVE after the scaling operation.
        """
        return pulumi.get(self, "cool_down_in_seconds")

    @cool_down_in_seconds.setter
    def cool_down_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cool_down_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of instances for the model deployment.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the autoscaling policy is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict(TypedDict):
        auto_scaling_policy_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of autoscaling policy.
        """
        initial_instance_count: pulumi.Input[_builtins.int]
        """
        (Updatable) For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the model deployment immediately after autoscaling is enabled. Note that anytime this value is updated, the number of instances will be reset to this value. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        """
        maximum_instance_count: pulumi.Input[_builtins.int]
        """
        (Updatable) For a threshold-based autoscaling policy, this value is the maximum number of instances the model deployment is allowed to increase to (scale out).
        """
        minimum_instance_count: pulumi.Input[_builtins.int]
        """
        (Updatable) For a threshold-based autoscaling policy, this value is the minimum number of instances the model deployment is allowed to decrease to (scale in).
        """
        rules: pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict']]]
        """
        (Updatable) The list of autoscaling policy rules.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyArgs:
    def __init__(__self__, *,
                 auto_scaling_policy_type: pulumi.Input[_builtins.str],
                 initial_instance_count: pulumi.Input[_builtins.int],
                 maximum_instance_count: pulumi.Input[_builtins.int],
                 minimum_instance_count: pulumi.Input[_builtins.int],
                 rules: pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]]):
        """
        :param pulumi.Input[_builtins.str] auto_scaling_policy_type: (Updatable) The type of autoscaling policy.
        :param pulumi.Input[_builtins.int] initial_instance_count: (Updatable) For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the model deployment immediately after autoscaling is enabled. Note that anytime this value is updated, the number of instances will be reset to this value. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        :param pulumi.Input[_builtins.int] maximum_instance_count: (Updatable) For a threshold-based autoscaling policy, this value is the maximum number of instances the model deployment is allowed to increase to (scale out).
        :param pulumi.Input[_builtins.int] minimum_instance_count: (Updatable) For a threshold-based autoscaling policy, this value is the minimum number of instances the model deployment is allowed to decrease to (scale in).
        :param pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]] rules: (Updatable) The list of autoscaling policy rules.
        """
        pulumi.set(__self__, "auto_scaling_policy_type", auto_scaling_policy_type)
        pulumi.set(__self__, "initial_instance_count", initial_instance_count)
        pulumi.set(__self__, "maximum_instance_count", maximum_instance_count)
        pulumi.set(__self__, "minimum_instance_count", minimum_instance_count)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="autoScalingPolicyType")
    def auto_scaling_policy_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of autoscaling policy.
        """
        return pulumi.get(self, "auto_scaling_policy_type")

    @auto_scaling_policy_type.setter
    def auto_scaling_policy_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auto_scaling_policy_type", value)

    @_builtins.property
    @pulumi.getter(name="initialInstanceCount")
    def initial_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the model deployment immediately after autoscaling is enabled. Note that anytime this value is updated, the number of instances will be reset to this value. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        """
        return pulumi.get(self, "initial_instance_count")

    @initial_instance_count.setter
    def initial_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "initial_instance_count", value)

    @_builtins.property
    @pulumi.getter(name="maximumInstanceCount")
    def maximum_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) For a threshold-based autoscaling policy, this value is the maximum number of instances the model deployment is allowed to increase to (scale out).
        """
        return pulumi.get(self, "maximum_instance_count")

    @maximum_instance_count.setter
    def maximum_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_instance_count", value)

    @_builtins.property
    @pulumi.getter(name="minimumInstanceCount")
    def minimum_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) For a threshold-based autoscaling policy, this value is the minimum number of instances the model deployment is allowed to decrease to (scale in).
        """
        return pulumi.get(self, "minimum_instance_count")

    @minimum_instance_count.setter
    def minimum_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_instance_count", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]]:
        """
        (Updatable) The list of autoscaling policy rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict(TypedDict):
        metric_expression_rule_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The metric expression for creating the alarm used to trigger autoscaling actions on the model deployment.

        The following values are supported:
        * `PREDEFINED_EXPRESSION`: An expression built using CPU or Memory metrics emitted by the Model Deployment Monitoring.
        * `CUSTOM_EXPRESSION`: A custom Monitoring Query Language (MQL) expression.
        """
        scale_in_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict']
        """
        (Updatable) The scaling configuration for the predefined metric expression rule.
        """
        scale_out_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict']
        """
        (Updatable) The scaling configuration for the predefined metric expression rule.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Metric type
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleArgs:
    def __init__(__self__, *,
                 metric_expression_rule_type: pulumi.Input[_builtins.str],
                 scale_in_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs'],
                 scale_out_configuration: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs'],
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_expression_rule_type: (Updatable) The metric expression for creating the alarm used to trigger autoscaling actions on the model deployment.
               
               The following values are supported:
               * `PREDEFINED_EXPRESSION`: An expression built using CPU or Memory metrics emitted by the Model Deployment Monitoring.
               * `CUSTOM_EXPRESSION`: A custom Monitoring Query Language (MQL) expression.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs'] scale_in_configuration: (Updatable) The scaling configuration for the predefined metric expression rule.
        :param pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs'] scale_out_configuration: (Updatable) The scaling configuration for the predefined metric expression rule.
        :param pulumi.Input[_builtins.str] metric_type: (Updatable) Metric type
        """
        pulumi.set(__self__, "metric_expression_rule_type", metric_expression_rule_type)
        pulumi.set(__self__, "scale_in_configuration", scale_in_configuration)
        pulumi.set(__self__, "scale_out_configuration", scale_out_configuration)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)

    @_builtins.property
    @pulumi.getter(name="metricExpressionRuleType")
    def metric_expression_rule_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The metric expression for creating the alarm used to trigger autoscaling actions on the model deployment.

        The following values are supported:
        * `PREDEFINED_EXPRESSION`: An expression built using CPU or Memory metrics emitted by the Model Deployment Monitoring.
        * `CUSTOM_EXPRESSION`: A custom Monitoring Query Language (MQL) expression.
        """
        return pulumi.get(self, "metric_expression_rule_type")

    @metric_expression_rule_type.setter
    def metric_expression_rule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_expression_rule_type", value)

    @_builtins.property
    @pulumi.getter(name="scaleInConfiguration")
    def scale_in_configuration(self) -> pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs']:
        """
        (Updatable) The scaling configuration for the predefined metric expression rule.
        """
        return pulumi.get(self, "scale_in_configuration")

    @scale_in_configuration.setter
    def scale_in_configuration(self, value: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs']):
        pulumi.set(self, "scale_in_configuration", value)

    @_builtins.property
    @pulumi.getter(name="scaleOutConfiguration")
    def scale_out_configuration(self) -> pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs']:
        """
        (Updatable) The scaling configuration for the predefined metric expression rule.
        """
        return pulumi.get(self, "scale_out_configuration")

    @scale_out_configuration.setter
    def scale_out_configuration(self, value: pulumi.Input['ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs']):
        pulumi.set(self, "scale_out_configuration", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Metric type
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict(TypedDict):
        instance_count_adjustment: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The value is used for adjusting the count of instances by.
        """
        pending_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."

        The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.

        Example of threshold alarm:

        -----

        CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() < 25 CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() > 75

        -----
        """
        scaling_configuration_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of scaling configuration.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) A metric value at which the scaling operation will be triggered.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfigurationArgs:
    def __init__(__self__, *,
                 instance_count_adjustment: Optional[pulumi.Input[_builtins.int]] = None,
                 pending_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 scaling_configuration_type: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] instance_count_adjustment: (Updatable) The value is used for adjusting the count of instances by.
        :param pulumi.Input[_builtins.str] pending_duration: (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
               
               The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
        :param pulumi.Input[_builtins.str] query: (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
               
               Example of threshold alarm:
               
               -----
               
               CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() < 25 CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() > 75
               
               -----
        :param pulumi.Input[_builtins.str] scaling_configuration_type: (Updatable) The type of scaling configuration.
        :param pulumi.Input[_builtins.int] threshold: (Updatable) A metric value at which the scaling operation will be triggered.
        """
        if instance_count_adjustment is not None:
            pulumi.set(__self__, "instance_count_adjustment", instance_count_adjustment)
        if pending_duration is not None:
            pulumi.set(__self__, "pending_duration", pending_duration)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if scaling_configuration_type is not None:
            pulumi.set(__self__, "scaling_configuration_type", scaling_configuration_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="instanceCountAdjustment")
    def instance_count_adjustment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The value is used for adjusting the count of instances by.
        """
        return pulumi.get(self, "instance_count_adjustment")

    @instance_count_adjustment.setter
    def instance_count_adjustment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count_adjustment", value)

    @_builtins.property
    @pulumi.getter(name="pendingDuration")
    def pending_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."

        The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
        """
        return pulumi.get(self, "pending_duration")

    @pending_duration.setter
    def pending_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pending_duration", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.

        Example of threshold alarm:

        -----

        CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() < 25 CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() > 75

        -----
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationType")
    def scaling_configuration_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of scaling configuration.
        """
        return pulumi.get(self, "scaling_configuration_type")

    @scaling_configuration_type.setter
    def scaling_configuration_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_configuration_type", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) A metric value at which the scaling operation will be triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict(TypedDict):
        instance_count_adjustment: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The value is used for adjusting the count of instances by.
        """
        pending_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."

        The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.

        Example of threshold alarm:

        -----

        CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() < 25 CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() > 75

        -----
        """
        scaling_configuration_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of scaling configuration.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) A metric value at which the scaling operation will be triggered.
        """
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleOutConfigurationArgs:
    def __init__(__self__, *,
                 instance_count_adjustment: Optional[pulumi.Input[_builtins.int]] = None,
                 pending_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 scaling_configuration_type: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] instance_count_adjustment: (Updatable) The value is used for adjusting the count of instances by.
        :param pulumi.Input[_builtins.str] pending_duration: (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."
               
               The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
        :param pulumi.Input[_builtins.str] query: (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
               
               Example of threshold alarm:
               
               -----
               
               CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() < 25 CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() > 75
               
               -----
        :param pulumi.Input[_builtins.str] scaling_configuration_type: (Updatable) The type of scaling configuration.
        :param pulumi.Input[_builtins.int] threshold: (Updatable) A metric value at which the scaling operation will be triggered.
        """
        if instance_count_adjustment is not None:
            pulumi.set(__self__, "instance_count_adjustment", instance_count_adjustment)
        if pending_duration is not None:
            pulumi.set(__self__, "pending_duration", pending_duration)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if scaling_configuration_type is not None:
            pulumi.set(__self__, "scaling_configuration_type", scaling_configuration_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="instanceCountAdjustment")
    def instance_count_adjustment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The value is used for adjusting the count of instances by.
        """
        return pulumi.get(self, "instance_count_adjustment")

    @instance_count_adjustment.setter
    def instance_count_adjustment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count_adjustment", value)

    @_builtins.property
    @pulumi.getter(name="pendingDuration")
    def pending_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from "OK" to "FIRING" or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to "FIRING"; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to "OK."

        The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
        """
        return pulumi.get(self, "pending_duration")

    @pending_duration.setter
    def pending_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pending_duration", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.

        Example of threshold alarm:

        -----

        CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() < 25 CPUUtilization[1m]{resourceId = "MODEL_DEPLOYMENT_OCID"}.grouping().mean() > 75

        -----
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationType")
    def scaling_configuration_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of scaling configuration.
        """
        return pulumi.get(self, "scaling_configuration_type")

    @scaling_configuration_type.setter
    def scaling_configuration_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_configuration_type", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) A metric value at which the scaling operation will be triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgsDict(TypedDict):
        model_group_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentConfigurationDetailsModelGroupConfigurationDetailsArgs:
    def __init__(__self__, *,
                 model_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        if model_group_id is not None:
            pulumi.set(__self__, "model_group_id", model_group_id)

    @_builtins.property
    @pulumi.getter(name="modelGroupId")
    def model_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "model_group_id")

    @model_group_id.setter
    def model_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_group_id", value)


if not MYPY:
    class ModelDeploymentModelDeploymentSystemDataArgsDict(TypedDict):
        current_instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        This value is the current count of the model deployment instances.
        """
        system_infra_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The infrastructure type of the model deployment.
        """
elif False:
    ModelDeploymentModelDeploymentSystemDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDeploymentModelDeploymentSystemDataArgs:
    def __init__(__self__, *,
                 current_instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 system_infra_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] current_instance_count: This value is the current count of the model deployment instances.
        :param pulumi.Input[_builtins.str] system_infra_type: The infrastructure type of the model deployment.
        """
        if current_instance_count is not None:
            pulumi.set(__self__, "current_instance_count", current_instance_count)
        if system_infra_type is not None:
            pulumi.set(__self__, "system_infra_type", system_infra_type)

    @_builtins.property
    @pulumi.getter(name="currentInstanceCount")
    def current_instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        This value is the current count of the model deployment instances.
        """
        return pulumi.get(self, "current_instance_count")

    @current_instance_count.setter
    def current_instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "current_instance_count", value)

    @_builtins.property
    @pulumi.getter(name="systemInfraType")
    def system_infra_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The infrastructure type of the model deployment.
        """
        return pulumi.get(self, "system_infra_type")

    @system_infra_type.setter
    def system_infra_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "system_infra_type", value)


if not MYPY:
    class ModelGroupMemberModelEntriesArgsDict(TypedDict):
        member_model_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelGroupMemberModelEntriesMemberModelDetailArgsDict']]]]
        """
        Each List item contains inference key and model ocid.
        """
elif False:
    ModelGroupMemberModelEntriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupMemberModelEntriesArgs:
    def __init__(__self__, *,
                 member_model_details: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupMemberModelEntriesMemberModelDetailArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ModelGroupMemberModelEntriesMemberModelDetailArgs']]] member_model_details: Each List item contains inference key and model ocid.
        """
        if member_model_details is not None:
            pulumi.set(__self__, "member_model_details", member_model_details)

    @_builtins.property
    @pulumi.getter(name="memberModelDetails")
    def member_model_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupMemberModelEntriesMemberModelDetailArgs']]]]:
        """
        Each List item contains inference key and model ocid.
        """
        return pulumi.get(self, "member_model_details")

    @member_model_details.setter
    def member_model_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupMemberModelEntriesMemberModelDetailArgs']]]]):
        pulumi.set(self, "member_model_details", value)


if not MYPY:
    class ModelGroupMemberModelEntriesMemberModelDetailArgsDict(TypedDict):
        inference_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        SaaS friendly name of the model.
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model.
        """
elif False:
    ModelGroupMemberModelEntriesMemberModelDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupMemberModelEntriesMemberModelDetailArgs:
    def __init__(__self__, *,
                 inference_key: Optional[pulumi.Input[_builtins.str]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inference_key: SaaS friendly name of the model.
        :param pulumi.Input[_builtins.str] model_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model.
        """
        if inference_key is not None:
            pulumi.set(__self__, "inference_key", inference_key)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="inferenceKey")
    def inference_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SaaS friendly name of the model.
        """
        return pulumi.get(self, "inference_key")

    @inference_key.setter
    def inference_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_key", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsArgsDict(TypedDict):
        model_group_clone_source_type: pulumi.Input[_builtins.str]
        """
        Source resource for model group clone operation.
        """
        source_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model group version history.
        """
        modify_model_group_details: NotRequired[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgsDict']]
        """
        Overwrites the properties of the source modelGroup.
        """
        patch_model_group_member_model_details: NotRequired[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgsDict']]
        """
        Specifies the list of new models to be added and list of models from source model group to be removed for cloning.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsArgs:
    def __init__(__self__, *,
                 model_group_clone_source_type: pulumi.Input[_builtins.str],
                 source_id: pulumi.Input[_builtins.str],
                 modify_model_group_details: Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgs']] = None,
                 patch_model_group_member_model_details: Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] model_group_clone_source_type: Source resource for model group clone operation.
        :param pulumi.Input[_builtins.str] source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model group version history.
        :param pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgs'] modify_model_group_details: Overwrites the properties of the source modelGroup.
        :param pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgs'] patch_model_group_member_model_details: Specifies the list of new models to be added and list of models from source model group to be removed for cloning.
        """
        pulumi.set(__self__, "model_group_clone_source_type", model_group_clone_source_type)
        pulumi.set(__self__, "source_id", source_id)
        if modify_model_group_details is not None:
            pulumi.set(__self__, "modify_model_group_details", modify_model_group_details)
        if patch_model_group_member_model_details is not None:
            pulumi.set(__self__, "patch_model_group_member_model_details", patch_model_group_member_model_details)

    @_builtins.property
    @pulumi.getter(name="modelGroupCloneSourceType")
    def model_group_clone_source_type(self) -> pulumi.Input[_builtins.str]:
        """
        Source resource for model group clone operation.
        """
        return pulumi.get(self, "model_group_clone_source_type")

    @model_group_clone_source_type.setter
    def model_group_clone_source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_group_clone_source_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model group version history.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="modifyModelGroupDetails")
    def modify_model_group_details(self) -> Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgs']]:
        """
        Overwrites the properties of the source modelGroup.
        """
        return pulumi.get(self, "modify_model_group_details")

    @modify_model_group_details.setter
    def modify_model_group_details(self, value: Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgs']]):
        pulumi.set(self, "modify_model_group_details", value)

    @_builtins.property
    @pulumi.getter(name="patchModelGroupMemberModelDetails")
    def patch_model_group_member_model_details(self) -> Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgs']]:
        """
        Specifies the list of new models to be added and list of models from source model group to be removed for cloning.
        """
        return pulumi.get(self, "patch_model_group_member_model_details")

    @patch_model_group_member_model_details.setter
    def patch_model_group_member_model_details(self, value: Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgs']]):
        pulumi.set(self, "patch_model_group_member_model_details", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgsDict(TypedDict):
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A short description of the modelGroup.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information. Example: `My ModelGroup`
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        model_group_details: NotRequired[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgsDict']]
        """
        The model group details.
        """
        model_group_version_history_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model group version history to which the modelGroup is associated.
        """
        version_label: NotRequired[pulumi.Input[_builtins.str]]
        """
        An additional description of the lifecycle state of the model group.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsArgs:
    def __init__(__self__, *,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 model_group_details: Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgs']] = None,
                 model_group_version_history_id: Optional[pulumi.Input[_builtins.str]] = None,
                 version_label: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[_builtins.str] description: A short description of the modelGroup.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information. Example: `My ModelGroup`
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        :param pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgs'] model_group_details: The model group details.
        :param pulumi.Input[_builtins.str] model_group_version_history_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model group version history to which the modelGroup is associated.
        :param pulumi.Input[_builtins.str] version_label: An additional description of the lifecycle state of the model group.
        """
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if model_group_details is not None:
            pulumi.set(__self__, "model_group_details", model_group_details)
        if model_group_version_history_id is not None:
            pulumi.set(__self__, "model_group_version_history_id", model_group_version_history_id)
        if version_label is not None:
            pulumi.set(__self__, "version_label", version_label)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A short description of the modelGroup.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information. Example: `My ModelGroup`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter(name="modelGroupDetails")
    def model_group_details(self) -> Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgs']]:
        """
        The model group details.
        """
        return pulumi.get(self, "model_group_details")

    @model_group_details.setter
    def model_group_details(self, value: Optional[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgs']]):
        pulumi.set(self, "model_group_details", value)

    @_builtins.property
    @pulumi.getter(name="modelGroupVersionHistoryId")
    def model_group_version_history_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model group version history to which the modelGroup is associated.
        """
        return pulumi.get(self, "model_group_version_history_id")

    @model_group_version_history_id.setter
    def model_group_version_history_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_group_version_history_id", value)

    @_builtins.property
    @pulumi.getter(name="versionLabel")
    def version_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An additional description of the lifecycle state of the model group.
        """
        return pulumi.get(self, "version_label")

    @version_label.setter
    def version_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_label", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the model group.
        """
        base_model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model in the group that represents the base model for stacked deployment.
        """
        custom_metadata_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgsDict']]]]
        """
        An array of custom metadata details for the model group.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 base_model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_metadata_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the model group.
        :param pulumi.Input[_builtins.str] base_model_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model in the group that represents the base model for stacked deployment.
        :param pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgs']]] custom_metadata_lists: An array of custom metadata details for the model group.
        """
        pulumi.set(__self__, "type", type)
        if base_model_id is not None:
            pulumi.set(__self__, "base_model_id", base_model_id)
        if custom_metadata_lists is not None:
            pulumi.set(__self__, "custom_metadata_lists", custom_metadata_lists)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the model group.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="baseModelId")
    def base_model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model in the group that represents the base model for stacked deployment.
        """
        return pulumi.get(self, "base_model_id")

    @base_model_id.setter
    def base_model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_model_id", value)

    @_builtins.property
    @pulumi.getter(name="customMetadataLists")
    def custom_metadata_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgs']]]]:
        """
        An array of custom metadata details for the model group.
        """
        return pulumi.get(self, "custom_metadata_lists")

    @custom_metadata_lists.setter
    def custom_metadata_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgs']]]]):
        pulumi.set(self, "custom_metadata_lists", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Category of the metadata.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of model metadata.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the metadata.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the metadata.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsModifyModelGroupDetailsModelGroupDetailsCustomMetadataListArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Category of the metadata.
        :param pulumi.Input[_builtins.str] description: Description of model metadata.
        :param pulumi.Input[_builtins.str] key: Key of the metadata.
        :param pulumi.Input[_builtins.str] value: Value of the metadata.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Category of the metadata.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of model metadata.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the metadata.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the metadata.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgsDict']]]]
        """
        Array of patch instructions.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgs']]] items: Array of patch instructions.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgs']]]]:
        """
        Array of patch instructions.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgsDict(TypedDict):
        operation: pulumi.Input[_builtins.str]
        """
        A single instruction to be included as part of Patch request content. Enum type (INSERT and REMOVE).
        """
        values: pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgsDict']]]
        """
        Array of inference key and model OCID.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemArgs:
    def __init__(__self__, *,
                 operation: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgs']]]):
        """
        :param pulumi.Input[_builtins.str] operation: A single instruction to be included as part of Patch request content. Enum type (INSERT and REMOVE).
        :param pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgs']]] values: Array of inference key and model OCID.
        """
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        A single instruction to be included as part of Patch request content. Enum type (INSERT and REMOVE).
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgs']]]:
        """
        Array of inference key and model OCID.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgs']]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgsDict(TypedDict):
        model_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model.
        """
        inference_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        SaaS friendly name of the model.
        """
elif False:
    ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupCloneSourceDetailsPatchModelGroupMemberModelDetailsItemValueArgs:
    def __init__(__self__, *,
                 model_id: pulumi.Input[_builtins.str],
                 inference_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model.
        :param pulumi.Input[_builtins.str] inference_key: SaaS friendly name of the model.
        """
        pulumi.set(__self__, "model_id", model_id)
        if inference_key is not None:
            pulumi.set(__self__, "inference_key", inference_key)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="inferenceKey")
    def inference_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SaaS friendly name of the model.
        """
        return pulumi.get(self, "inference_key")

    @inference_key.setter
    def inference_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_key", value)


if not MYPY:
    class ModelGroupModelGroupDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the model group.
        """
        base_model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model in the group that represents the base model for stacked deployment.
        """
        custom_metadata_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupDetailsCustomMetadataListArgsDict']]]]
        """
        An array of custom metadata details for the model group.
        """
elif False:
    ModelGroupModelGroupDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 base_model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_metadata_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupDetailsCustomMetadataListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the model group.
        :param pulumi.Input[_builtins.str] base_model_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model in the group that represents the base model for stacked deployment.
        :param pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupDetailsCustomMetadataListArgs']]] custom_metadata_lists: An array of custom metadata details for the model group.
        """
        pulumi.set(__self__, "type", type)
        if base_model_id is not None:
            pulumi.set(__self__, "base_model_id", base_model_id)
        if custom_metadata_lists is not None:
            pulumi.set(__self__, "custom_metadata_lists", custom_metadata_lists)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the model group.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="baseModelId")
    def base_model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the model in the group that represents the base model for stacked deployment.
        """
        return pulumi.get(self, "base_model_id")

    @base_model_id.setter
    def base_model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_model_id", value)

    @_builtins.property
    @pulumi.getter(name="customMetadataLists")
    def custom_metadata_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupDetailsCustomMetadataListArgs']]]]:
        """
        An array of custom metadata details for the model group.
        """
        return pulumi.get(self, "custom_metadata_lists")

    @custom_metadata_lists.setter
    def custom_metadata_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelGroupModelGroupDetailsCustomMetadataListArgs']]]]):
        pulumi.set(self, "custom_metadata_lists", value)


if not MYPY:
    class ModelGroupModelGroupDetailsCustomMetadataListArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Category of the metadata.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of model metadata.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the metadata.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the metadata.
        """
elif False:
    ModelGroupModelGroupDetailsCustomMetadataListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelGroupModelGroupDetailsCustomMetadataListArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Category of the metadata.
        :param pulumi.Input[_builtins.str] description: Description of model metadata.
        :param pulumi.Input[_builtins.str] key: Key of the metadata.
        :param pulumi.Input[_builtins.str] value: Value of the metadata.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Category of the metadata.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of model metadata.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the metadata.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the metadata.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ModelRetentionOperationDetailArgsDict(TypedDict):
        archive_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The archival status of model.
        """
        archive_state_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The archival state details of the model.
        """
        delete_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The deletion status of the archived model.
        """
        delete_state_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The deletion status details of the archived model.
        """
        time_archival_scheduled: NotRequired[pulumi.Input[_builtins.str]]
        """
        The estimated archival time of the model based on the provided retention setting.
        """
        time_deletion_scheduled: NotRequired[pulumi.Input[_builtins.str]]
        """
        The estimated deletion time of the model based on the provided retention setting.
        """
elif False:
    ModelRetentionOperationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelRetentionOperationDetailArgs:
    def __init__(__self__, *,
                 archive_state: Optional[pulumi.Input[_builtins.str]] = None,
                 archive_state_details: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_state: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_state_details: Optional[pulumi.Input[_builtins.str]] = None,
                 time_archival_scheduled: Optional[pulumi.Input[_builtins.str]] = None,
                 time_deletion_scheduled: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] archive_state: The archival status of model.
        :param pulumi.Input[_builtins.str] archive_state_details: The archival state details of the model.
        :param pulumi.Input[_builtins.str] delete_state: The deletion status of the archived model.
        :param pulumi.Input[_builtins.str] delete_state_details: The deletion status details of the archived model.
        :param pulumi.Input[_builtins.str] time_archival_scheduled: The estimated archival time of the model based on the provided retention setting.
        :param pulumi.Input[_builtins.str] time_deletion_scheduled: The estimated deletion time of the model based on the provided retention setting.
        """
        if archive_state is not None:
            pulumi.set(__self__, "archive_state", archive_state)
        if archive_state_details is not None:
            pulumi.set(__self__, "archive_state_details", archive_state_details)
        if delete_state is not None:
            pulumi.set(__self__, "delete_state", delete_state)
        if delete_state_details is not None:
            pulumi.set(__self__, "delete_state_details", delete_state_details)
        if time_archival_scheduled is not None:
            pulumi.set(__self__, "time_archival_scheduled", time_archival_scheduled)
        if time_deletion_scheduled is not None:
            pulumi.set(__self__, "time_deletion_scheduled", time_deletion_scheduled)

    @_builtins.property
    @pulumi.getter(name="archiveState")
    def archive_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The archival status of model.
        """
        return pulumi.get(self, "archive_state")

    @archive_state.setter
    def archive_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "archive_state", value)

    @_builtins.property
    @pulumi.getter(name="archiveStateDetails")
    def archive_state_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The archival state details of the model.
        """
        return pulumi.get(self, "archive_state_details")

    @archive_state_details.setter
    def archive_state_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "archive_state_details", value)

    @_builtins.property
    @pulumi.getter(name="deleteState")
    def delete_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The deletion status of the archived model.
        """
        return pulumi.get(self, "delete_state")

    @delete_state.setter
    def delete_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_state", value)

    @_builtins.property
    @pulumi.getter(name="deleteStateDetails")
    def delete_state_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The deletion status details of the archived model.
        """
        return pulumi.get(self, "delete_state_details")

    @delete_state_details.setter
    def delete_state_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_state_details", value)

    @_builtins.property
    @pulumi.getter(name="timeArchivalScheduled")
    def time_archival_scheduled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The estimated archival time of the model based on the provided retention setting.
        """
        return pulumi.get(self, "time_archival_scheduled")

    @time_archival_scheduled.setter
    def time_archival_scheduled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_archival_scheduled", value)

    @_builtins.property
    @pulumi.getter(name="timeDeletionScheduled")
    def time_deletion_scheduled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The estimated deletion time of the model based on the provided retention setting.
        """
        return pulumi.get(self, "time_deletion_scheduled")

    @time_deletion_scheduled.setter
    def time_deletion_scheduled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_deletion_scheduled", value)


if not MYPY:
    class ModelRetentionSettingArgsDict(TypedDict):
        archive_after_days: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of days after which the model will be archived.
        """
        customer_notification_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Customer notification options on success/failure of archival, deletion events.
        """
        delete_after_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Number of days after which the archived model will be deleted.
        """
elif False:
    ModelRetentionSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelRetentionSettingArgs:
    def __init__(__self__, *,
                 archive_after_days: pulumi.Input[_builtins.int],
                 customer_notification_type: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_after_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] archive_after_days: (Updatable) Number of days after which the model will be archived.
        :param pulumi.Input[_builtins.str] customer_notification_type: (Updatable) Customer notification options on success/failure of archival, deletion events.
        :param pulumi.Input[_builtins.int] delete_after_days: (Updatable) Number of days after which the archived model will be deleted.
        """
        pulumi.set(__self__, "archive_after_days", archive_after_days)
        if customer_notification_type is not None:
            pulumi.set(__self__, "customer_notification_type", customer_notification_type)
        if delete_after_days is not None:
            pulumi.set(__self__, "delete_after_days", delete_after_days)

    @_builtins.property
    @pulumi.getter(name="archiveAfterDays")
    def archive_after_days(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of days after which the model will be archived.
        """
        return pulumi.get(self, "archive_after_days")

    @archive_after_days.setter
    def archive_after_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "archive_after_days", value)

    @_builtins.property
    @pulumi.getter(name="customerNotificationType")
    def customer_notification_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Customer notification options on success/failure of archival, deletion events.
        """
        return pulumi.get(self, "customer_notification_type")

    @customer_notification_type.setter
    def customer_notification_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_notification_type", value)

    @_builtins.property
    @pulumi.getter(name="deleteAfterDays")
    def delete_after_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Number of days after which the archived model will be deleted.
        """
        return pulumi.get(self, "delete_after_days")

    @delete_after_days.setter
    def delete_after_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delete_after_days", value)


if not MYPY:
    class NotebookSessionNotebookSessionConfigDetailsArgsDict(TypedDict):
        shape: pulumi.Input[_builtins.str]
        """
        The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        """
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        """
        notebook_session_shape_config_details: NotRequired[pulumi.Input['NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgsDict']]
        """
        Details for the notebook session shape configuration.
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of a Data Science private endpoint.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        """
elif False:
    NotebookSessionNotebookSessionConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionConfigDetailsArgs:
    def __init__(__self__, *,
                 shape: pulumi.Input[_builtins.str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 notebook_session_shape_config_details: Optional[pulumi.Input['NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgs']] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] shape: The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        :param pulumi.Input['NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgs'] notebook_session_shape_config_details: Details for the notebook session shape configuration.
        :param pulumi.Input[_builtins.str] private_endpoint_id: The OCID of a Data Science private endpoint.
        :param pulumi.Input[_builtins.str] subnet_id: A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        """
        pulumi.set(__self__, "shape", shape)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if notebook_session_shape_config_details is not None:
            pulumi.set(__self__, "notebook_session_shape_config_details", notebook_session_shape_config_details)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> pulumi.Input[_builtins.str]:
        """
        The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape", value)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="notebookSessionShapeConfigDetails")
    def notebook_session_shape_config_details(self) -> Optional[pulumi.Input['NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgs']]:
        """
        Details for the notebook session shape configuration.
        """
        return pulumi.get(self, "notebook_session_shape_config_details")

    @notebook_session_shape_config_details.setter
    def notebook_session_shape_config_details(self, value: Optional[pulumi.Input['NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgs']]):
        pulumi.set(self, "notebook_session_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of a Data Science private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left bank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total amount of memory available to the notebook session instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        The total number of OCPUs available to the notebook session instance.
        """
elif False:
    NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left bank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: The total amount of memory available to the notebook session instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: The total number of OCPUs available to the notebook session instance.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left bank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total amount of memory available to the notebook session instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The total number of OCPUs available to the notebook session instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class NotebookSessionNotebookSessionConfigurationDetailsArgsDict(TypedDict):
        shape: pulumi.Input[_builtins.str]
        """
        (Updatable) The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        (Updatable) A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        """
        block_storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        """
        notebook_session_shape_config_details: NotRequired[pulumi.Input['NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the notebook session shape configuration.
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of a Data Science private endpoint.
        """
elif False:
    NotebookSessionNotebookSessionConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionConfigurationDetailsArgs:
    def __init__(__self__, *,
                 shape: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None,
                 notebook_session_shape_config_details: Optional[pulumi.Input['NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs']] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] shape: (Updatable) The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        :param pulumi.Input[_builtins.str] subnet_id: (Updatable) A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: (Updatable) A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        :param pulumi.Input['NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs'] notebook_session_shape_config_details: (Updatable) Details for the notebook session shape configuration.
        :param pulumi.Input[_builtins.str] private_endpoint_id: (Updatable) The OCID of a Data Science private endpoint.
        """
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if notebook_session_shape_config_details is not None:
            pulumi.set(__self__, "notebook_session_shape_config_details", notebook_session_shape_config_details)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="notebookSessionShapeConfigDetails")
    def notebook_session_shape_config_details(self) -> Optional[pulumi.Input['NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the notebook session shape configuration.
        """
        return pulumi.get(self, "notebook_session_shape_config_details")

    @notebook_session_shape_config_details.setter
    def notebook_session_shape_config_details(self, value: Optional[pulumi.Input['NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs']]):
        pulumi.set(self, "notebook_session_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of a Data Science private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)


if not MYPY:
    class NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left bank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The total amount of memory available to the notebook session instance, in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The total number of OCPUs available to the notebook session instance.
        """
elif False:
    NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left bank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) The total amount of memory available to the notebook session instance, in gigabytes.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) The total number of OCPUs available to the notebook session instance.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left bank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The total amount of memory available to the notebook session instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The total number of OCPUs available to the notebook session instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class NotebookSessionNotebookSessionRuntimeConfigDetailsArgsDict(TypedDict):
        custom_environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Custom environment variables for Notebook Session. These key-value pairs will be available for customers in Notebook Sessions.
        """
        notebook_session_git_config_details: NotRequired[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgsDict']]
        """
        (Updatable) Git configuration Details.
        """
elif False:
    NotebookSessionNotebookSessionRuntimeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionRuntimeConfigDetailsArgs:
    def __init__(__self__, *,
                 custom_environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 notebook_session_git_config_details: Optional[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_environment_variables: (Updatable) Custom environment variables for Notebook Session. These key-value pairs will be available for customers in Notebook Sessions.
        :param pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgs'] notebook_session_git_config_details: (Updatable) Git configuration Details.
        """
        if custom_environment_variables is not None:
            pulumi.set(__self__, "custom_environment_variables", custom_environment_variables)
        if notebook_session_git_config_details is not None:
            pulumi.set(__self__, "notebook_session_git_config_details", notebook_session_git_config_details)

    @_builtins.property
    @pulumi.getter(name="customEnvironmentVariables")
    def custom_environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Custom environment variables for Notebook Session. These key-value pairs will be available for customers in Notebook Sessions.
        """
        return pulumi.get(self, "custom_environment_variables")

    @custom_environment_variables.setter
    def custom_environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="notebookSessionGitConfigDetails")
    def notebook_session_git_config_details(self) -> Optional[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgs']]:
        """
        (Updatable) Git configuration Details.
        """
        return pulumi.get(self, "notebook_session_git_config_details")

    @notebook_session_git_config_details.setter
    def notebook_session_git_config_details(self, value: Optional[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgs']]):
        pulumi.set(self, "notebook_session_git_config_details", value)


if not MYPY:
    class NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgsDict(TypedDict):
        notebook_session_git_repo_config_collections: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgsDict']]]]
        """
        (Updatable) A collection of Git repository configurations.
        """
elif False:
    NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsArgs:
    def __init__(__self__, *,
                 notebook_session_git_repo_config_collections: Optional[pulumi.Input[Sequence[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgs']]] notebook_session_git_repo_config_collections: (Updatable) A collection of Git repository configurations.
        """
        if notebook_session_git_repo_config_collections is not None:
            pulumi.set(__self__, "notebook_session_git_repo_config_collections", notebook_session_git_repo_config_collections)

    @_builtins.property
    @pulumi.getter(name="notebookSessionGitRepoConfigCollections")
    def notebook_session_git_repo_config_collections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgs']]]]:
        """
        (Updatable) A collection of Git repository configurations.
        """
        return pulumi.get(self, "notebook_session_git_repo_config_collections")

    @notebook_session_git_repo_config_collections.setter
    def notebook_session_git_repo_config_collections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgs']]]]):
        pulumi.set(self, "notebook_session_git_repo_config_collections", value)


if not MYPY:
    class NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        (Updatable) The repository URL
        """
elif False:
    NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionRuntimeConfigDetailsNotebookSessionGitConfigDetailsNotebookSessionGitRepoConfigCollectionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] url: (Updatable) The repository URL
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The repository URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class NotebookSessionNotebookSessionStorageMountConfigurationDetailsListArgsDict(TypedDict):
        destination_directory_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The local directory name to be mounted
        """
        storage_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of storage.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage bucket
        """
        destination_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        export_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the export
        """
        mount_target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the mount target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage namespace
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Prefix in the bucket to mount
        """
elif False:
    NotebookSessionNotebookSessionStorageMountConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookSessionNotebookSessionStorageMountConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 destination_directory_name: pulumi.Input[_builtins.str],
                 storage_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_path: Optional[pulumi.Input[_builtins.str]] = None,
                 export_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_directory_name: (Updatable) The local directory name to be mounted
        :param pulumi.Input[_builtins.str] storage_type: (Updatable) The type of storage.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The object storage bucket
        :param pulumi.Input[_builtins.str] destination_path: (Updatable) The local path of the mounted directory, excluding directory name.
        :param pulumi.Input[_builtins.str] export_id: (Updatable) OCID of the export
        :param pulumi.Input[_builtins.str] mount_target_id: (Updatable) OCID of the mount target
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The object storage namespace
        :param pulumi.Input[_builtins.str] prefix: (Updatable) Prefix in the bucket to mount
        """
        pulumi.set(__self__, "destination_directory_name", destination_directory_name)
        pulumi.set(__self__, "storage_type", storage_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if mount_target_id is not None:
            pulumi.set(__self__, "mount_target_id", mount_target_id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="destinationDirectoryName")
    def destination_directory_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The local directory name to be mounted
        """
        return pulumi.get(self, "destination_directory_name")

    @destination_directory_name.setter
    def destination_directory_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_directory_name", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_path", value)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the export
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_id", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the mount target
        """
        return pulumi.get(self, "mount_target_id")

    @mount_target_id.setter
    def mount_target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_target_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Prefix in the bucket to mount
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class PipelineConfigurationDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of pipeline.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The command line arguments to set for steps in the pipeline.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Environment variables to set for steps in the pipeline.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
elif False:
    PipelineConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineConfigurationDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of pipeline.
        :param pulumi.Input[_builtins.str] command_line_arguments: (Updatable) The command line arguments to set for steps in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: (Updatable) Environment variables to set for steps in the pipeline.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: (Updatable) A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
        pulumi.set(__self__, "type", type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The command line arguments to set for steps in the pipeline.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Environment variables to set for steps in the pipeline.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class PipelineInfrastructureConfigurationDetailsArgsDict(TypedDict):
        block_storage_size_in_gbs: pulumi.Input[_builtins.int]
        """
        (Updatable) The size of the block storage volume to attach to the instance.
        """
        shape_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The shape used to launch the instance for all step runs in the pipeline.
        """
        shape_config_details: NotRequired[pulumi.Input['PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
elif False:
    PipelineInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 block_storage_size_in_gbs: pulumi.Input[_builtins.int],
                 shape_name: pulumi.Input[_builtins.str],
                 shape_config_details: Optional[pulumi.Input['PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgs']] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: (Updatable) The size of the block storage volume to attach to the instance.
        :param pulumi.Input[_builtins.str] shape_name: (Updatable) The shape used to launch the instance for all step runs in the pipeline.
        :param pulumi.Input['PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgs'] shape_config_details: (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] subnet_id: (Updatable) The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        pulumi.set(__self__, "shape_name", shape_name)
        if shape_config_details is not None:
            pulumi.set(__self__, "shape_config_details", shape_config_details)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The size of the block storage volume to attach to the instance.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The shape used to launch the instance for all step runs in the pipeline.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="shapeConfigDetails")
    def shape_config_details(self) -> Optional[pulumi.Input['PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "shape_config_details")

    @shape_config_details.setter
    def shape_config_details(self, value: Optional[pulumi.Input['PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgs']]):
        pulumi.set(self, "shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineInfrastructureConfigurationDetailsShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineLogConfigurationDetailsArgsDict(TypedDict):
        enable_auto_log_creation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If automatic on-behalf-of log object creation is enabled for pipeline runs.
        """
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If customer logging is enabled for pipeline.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
elif False:
    PipelineLogConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLogConfigurationDetailsArgs:
    def __init__(__self__, *,
                 enable_auto_log_creation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_auto_log_creation: (Updatable) If automatic on-behalf-of log object creation is enabled for pipeline runs.
        :param pulumi.Input[_builtins.bool] enable_logging: (Updatable) If customer logging is enabled for pipeline.
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if enable_auto_log_creation is not None:
            pulumi.set(__self__, "enable_auto_log_creation", enable_auto_log_creation)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableAutoLogCreation")
    def enable_auto_log_creation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If automatic on-behalf-of log object creation is enabled for pipeline runs.
        """
        return pulumi.get(self, "enable_auto_log_creation")

    @enable_auto_log_creation.setter
    def enable_auto_log_creation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_log_creation", value)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If customer logging is enabled for pipeline.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class PipelineRunConfigurationDetailArgsDict(TypedDict):
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The command line arguments to set for step.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for step.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the step.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of pipeline.
        """
elif False:
    PipelineRunConfigurationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunConfigurationDetailArgs:
    def __init__(__self__, *,
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] command_line_arguments: The command line arguments to set for step.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for step.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the step.
        :param pulumi.Input[_builtins.str] type: The type of pipeline.
        """
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The command line arguments to set for step.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for step.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the step.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PipelineRunConfigurationOverrideDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of pipeline.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The command line arguments to set for steps in the pipeline.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for steps in the pipeline.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
elif False:
    PipelineRunConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of pipeline.
        :param pulumi.Input[_builtins.str] command_line_arguments: The command line arguments to set for steps in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for steps in the pipeline.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
        pulumi.set(__self__, "type", type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The command line arguments to set for steps in the pipeline.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for steps in the pipeline.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class PipelineRunInfrastructureConfigurationOverrideDetailsArgsDict(TypedDict):
        block_storage_size_in_gbs: pulumi.Input[_builtins.int]
        """
        The size of the block storage volume to attach to the instance.
        """
        shape_name: pulumi.Input[_builtins.str]
        """
        The shape used to launch the instance for all step runs in the pipeline.
        """
        shape_config_details: NotRequired[pulumi.Input['PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgsDict']]
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
elif False:
    PipelineRunInfrastructureConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunInfrastructureConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 block_storage_size_in_gbs: pulumi.Input[_builtins.int],
                 shape_name: pulumi.Input[_builtins.str],
                 shape_config_details: Optional[pulumi.Input['PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgs']] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: The size of the block storage volume to attach to the instance.
        :param pulumi.Input[_builtins.str] shape_name: The shape used to launch the instance for all step runs in the pipeline.
        :param pulumi.Input['PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgs'] shape_config_details: Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] subnet_id: The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        pulumi.set(__self__, "shape_name", shape_name)
        if shape_config_details is not None:
            pulumi.set(__self__, "shape_config_details", shape_config_details)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        The size of the block storage volume to attach to the instance.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> pulumi.Input[_builtins.str]:
        """
        The shape used to launch the instance for all step runs in the pipeline.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="shapeConfigDetails")
    def shape_config_details(self) -> Optional[pulumi.Input['PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgs']]:
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "shape_config_details")

    @shape_config_details.setter
    def shape_config_details(self, value: Optional[pulumi.Input['PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgs']]):
        pulumi.set(self, "shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgsDict(TypedDict):
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunInfrastructureConfigurationOverrideDetailsShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] memory_in_gbs: A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineRunLogConfigurationOverrideDetailsArgsDict(TypedDict):
        enable_auto_log_creation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If automatic on-behalf-of log object creation is enabled for pipeline runs.
        """
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If customer logging is enabled for pipeline.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
elif False:
    PipelineRunLogConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunLogConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 enable_auto_log_creation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_auto_log_creation: If automatic on-behalf-of log object creation is enabled for pipeline runs.
        :param pulumi.Input[_builtins.bool] enable_logging: If customer logging is enabled for pipeline.
        :param pulumi.Input[_builtins.str] log_group_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if enable_auto_log_creation is not None:
            pulumi.set(__self__, "enable_auto_log_creation", enable_auto_log_creation)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableAutoLogCreation")
    def enable_auto_log_creation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If automatic on-behalf-of log object creation is enabled for pipeline runs.
        """
        return pulumi.get(self, "enable_auto_log_creation")

    @enable_auto_log_creation.setter
    def enable_auto_log_creation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_log_creation", value)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If customer logging is enabled for pipeline.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class PipelineRunLogDetailArgsDict(TypedDict):
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log group id for where log objects will be for pipeline runs.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log id of the log object the pipeline run logs will be shipped to.
        """
elif False:
    PipelineRunLogDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunLogDetailArgs:
    def __init__(__self__, *,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_group_id: The log group id for where log objects will be for pipeline runs.
        :param pulumi.Input[_builtins.str] log_id: The log id of the log object the pipeline run logs will be shipped to.
        """
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log group id for where log objects will be for pipeline runs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log id of the log object the pipeline run logs will be shipped to.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class PipelineRunStepOverrideDetailArgsDict(TypedDict):
        step_configuration_details: pulumi.Input['PipelineRunStepOverrideDetailStepConfigurationDetailsArgsDict']
        """
        The configuration details of a step.
        """
        step_name: pulumi.Input[_builtins.str]
        """
        The name of the step.
        """
        step_container_configuration_details: NotRequired[pulumi.Input['PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgsDict']]
        """
        Container Details for a step in pipeline.
        """
        step_dataflow_configuration_details: NotRequired[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgsDict']]
        """
        The configuration details of a Dataflow step.
        """
        step_infrastructure_configuration_details: NotRequired[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgsDict']]
        """
        The infrastructure configuration details of a pipeline or a step.
        """
elif False:
    PipelineRunStepOverrideDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailArgs:
    def __init__(__self__, *,
                 step_configuration_details: pulumi.Input['PipelineRunStepOverrideDetailStepConfigurationDetailsArgs'],
                 step_name: pulumi.Input[_builtins.str],
                 step_container_configuration_details: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgs']] = None,
                 step_dataflow_configuration_details: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgs']] = None,
                 step_infrastructure_configuration_details: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgs']] = None):
        """
        :param pulumi.Input['PipelineRunStepOverrideDetailStepConfigurationDetailsArgs'] step_configuration_details: The configuration details of a step.
        :param pulumi.Input[_builtins.str] step_name: The name of the step.
        :param pulumi.Input['PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgs'] step_container_configuration_details: Container Details for a step in pipeline.
        :param pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgs'] step_dataflow_configuration_details: The configuration details of a Dataflow step.
        :param pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgs'] step_infrastructure_configuration_details: The infrastructure configuration details of a pipeline or a step.
        """
        pulumi.set(__self__, "step_configuration_details", step_configuration_details)
        pulumi.set(__self__, "step_name", step_name)
        if step_container_configuration_details is not None:
            pulumi.set(__self__, "step_container_configuration_details", step_container_configuration_details)
        if step_dataflow_configuration_details is not None:
            pulumi.set(__self__, "step_dataflow_configuration_details", step_dataflow_configuration_details)
        if step_infrastructure_configuration_details is not None:
            pulumi.set(__self__, "step_infrastructure_configuration_details", step_infrastructure_configuration_details)

    @_builtins.property
    @pulumi.getter(name="stepConfigurationDetails")
    def step_configuration_details(self) -> pulumi.Input['PipelineRunStepOverrideDetailStepConfigurationDetailsArgs']:
        """
        The configuration details of a step.
        """
        return pulumi.get(self, "step_configuration_details")

    @step_configuration_details.setter
    def step_configuration_details(self, value: pulumi.Input['PipelineRunStepOverrideDetailStepConfigurationDetailsArgs']):
        pulumi.set(self, "step_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the step.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter(name="stepContainerConfigurationDetails")
    def step_container_configuration_details(self) -> Optional[pulumi.Input['PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgs']]:
        """
        Container Details for a step in pipeline.
        """
        return pulumi.get(self, "step_container_configuration_details")

    @step_container_configuration_details.setter
    def step_container_configuration_details(self, value: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgs']]):
        pulumi.set(self, "step_container_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepDataflowConfigurationDetails")
    def step_dataflow_configuration_details(self) -> Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgs']]:
        """
        The configuration details of a Dataflow step.
        """
        return pulumi.get(self, "step_dataflow_configuration_details")

    @step_dataflow_configuration_details.setter
    def step_dataflow_configuration_details(self, value: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgs']]):
        pulumi.set(self, "step_dataflow_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepInfrastructureConfigurationDetails")
    def step_infrastructure_configuration_details(self) -> Optional[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgs']]:
        """
        The infrastructure configuration details of a pipeline or a step.
        """
        return pulumi.get(self, "step_infrastructure_configuration_details")

    @step_infrastructure_configuration_details.setter
    def step_infrastructure_configuration_details(self, value: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgs']]):
        pulumi.set(self, "step_infrastructure_configuration_details", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepConfigurationDetailsArgsDict(TypedDict):
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        The command line arguments to set for step.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variables to set for step.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        A time bound for the execution of the step.
        """
elif False:
    PipelineRunStepOverrideDetailStepConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepConfigurationDetailsArgs:
    def __init__(__self__, *,
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] command_line_arguments: The command line arguments to set for step.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variables to set for step.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: A time bound for the execution of the step.
        """
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The command line arguments to set for step.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variables to set for step.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A time bound for the execution of the step.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgsDict(TypedDict):
        container_type: pulumi.Input[_builtins.str]
        """
        The type of container.
        """
        image: pulumi.Input[_builtins.str]
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the container image signature
        """
elif False:
    PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepContainerConfigurationDetailsArgs:
    def __init__(__self__, *,
                 container_type: pulumi.Input[_builtins.str],
                 image: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] container_type: The type of container.
        :param pulumi.Input[_builtins.str] image: The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: OCID of the container image signature
        """
        pulumi.set(__self__, "container_type", container_type)
        pulumi.set(__self__, "image", image)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter(name="containerType")
    def container_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of container.
        """
        return pulumi.get(self, "container_type")

    @container_type.setter
    def container_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_type", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The Spark configuration passed to the running process.
        """
        driver_shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        The VM shape for the driver.
        """
        driver_shape_config_details: NotRequired[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict']]
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        executor_shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        The VM shape for the executors.
        """
        executor_shape_config_details: NotRequired[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict']]
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        logs_bucket_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        An Oracle Cloud Infrastructure URI of the bucket where the Spark job logs are to be uploaded.
        """
        num_executors: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of executor VMs requested.
        """
        warehouse_bucket_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        An Oracle Cloud Infrastructure URI of the bucket to be used as default warehouse directory for BATCH SQL runs.
        """
elif False:
    PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 driver_shape: Optional[pulumi.Input[_builtins.str]] = None,
                 driver_shape_config_details: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs']] = None,
                 executor_shape: Optional[pulumi.Input[_builtins.str]] = None,
                 executor_shape_config_details: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs']] = None,
                 logs_bucket_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 num_executors: Optional[pulumi.Input[_builtins.int]] = None,
                 warehouse_bucket_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] configuration: The Spark configuration passed to the running process.
        :param pulumi.Input[_builtins.str] driver_shape: The VM shape for the driver.
        :param pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs'] driver_shape_config_details: Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] executor_shape: The VM shape for the executors.
        :param pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs'] executor_shape_config_details: Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] logs_bucket_uri: An Oracle Cloud Infrastructure URI of the bucket where the Spark job logs are to be uploaded.
        :param pulumi.Input[_builtins.int] num_executors: The number of executor VMs requested.
        :param pulumi.Input[_builtins.str] warehouse_bucket_uri: An Oracle Cloud Infrastructure URI of the bucket to be used as default warehouse directory for BATCH SQL runs.
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if driver_shape is not None:
            pulumi.set(__self__, "driver_shape", driver_shape)
        if driver_shape_config_details is not None:
            pulumi.set(__self__, "driver_shape_config_details", driver_shape_config_details)
        if executor_shape is not None:
            pulumi.set(__self__, "executor_shape", executor_shape)
        if executor_shape_config_details is not None:
            pulumi.set(__self__, "executor_shape_config_details", executor_shape_config_details)
        if logs_bucket_uri is not None:
            pulumi.set(__self__, "logs_bucket_uri", logs_bucket_uri)
        if num_executors is not None:
            pulumi.set(__self__, "num_executors", num_executors)
        if warehouse_bucket_uri is not None:
            pulumi.set(__self__, "warehouse_bucket_uri", warehouse_bucket_uri)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The Spark configuration passed to the running process.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter(name="driverShape")
    def driver_shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VM shape for the driver.
        """
        return pulumi.get(self, "driver_shape")

    @driver_shape.setter
    def driver_shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "driver_shape", value)

    @_builtins.property
    @pulumi.getter(name="driverShapeConfigDetails")
    def driver_shape_config_details(self) -> Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs']]:
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "driver_shape_config_details")

    @driver_shape_config_details.setter
    def driver_shape_config_details(self, value: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs']]):
        pulumi.set(self, "driver_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="executorShape")
    def executor_shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VM shape for the executors.
        """
        return pulumi.get(self, "executor_shape")

    @executor_shape.setter
    def executor_shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_shape", value)

    @_builtins.property
    @pulumi.getter(name="executorShapeConfigDetails")
    def executor_shape_config_details(self) -> Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs']]:
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "executor_shape_config_details")

    @executor_shape_config_details.setter
    def executor_shape_config_details(self, value: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs']]):
        pulumi.set(self, "executor_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="logsBucketUri")
    def logs_bucket_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An Oracle Cloud Infrastructure URI of the bucket where the Spark job logs are to be uploaded.
        """
        return pulumi.get(self, "logs_bucket_uri")

    @logs_bucket_uri.setter
    def logs_bucket_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logs_bucket_uri", value)

    @_builtins.property
    @pulumi.getter(name="numExecutors")
    def num_executors(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of executor VMs requested.
        """
        return pulumi.get(self, "num_executors")

    @num_executors.setter
    def num_executors(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_executors", value)

    @_builtins.property
    @pulumi.getter(name="warehouseBucketUri")
    def warehouse_bucket_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An Oracle Cloud Infrastructure URI of the bucket to be used as default warehouse directory for BATCH SQL runs.
        """
        return pulumi.get(self, "warehouse_bucket_uri")

    @warehouse_bucket_uri.setter
    def warehouse_bucket_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warehouse_bucket_uri", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgsDict(TypedDict):
        block_storage_size_in_gbs: pulumi.Input[_builtins.int]
        """
        The size of the block storage volume to attach to the instance.
        """
        shape_name: pulumi.Input[_builtins.str]
        """
        The shape used to launch the instance for all step runs in the pipeline.
        """
        shape_config_details: NotRequired[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict']]
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
elif False:
    PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 block_storage_size_in_gbs: pulumi.Input[_builtins.int],
                 shape_name: pulumi.Input[_builtins.str],
                 shape_config_details: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs']] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: The size of the block storage volume to attach to the instance.
        :param pulumi.Input[_builtins.str] shape_name: The shape used to launch the instance for all step runs in the pipeline.
        :param pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs'] shape_config_details: Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] subnet_id: The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        pulumi.set(__self__, "shape_name", shape_name)
        if shape_config_details is not None:
            pulumi.set(__self__, "shape_config_details", shape_config_details)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        The size of the block storage volume to attach to the instance.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> pulumi.Input[_builtins.str]:
        """
        The shape used to launch the instance for all step runs in the pipeline.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="shapeConfigDetails")
    def shape_config_details(self) -> Optional[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs']]:
        """
        Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "shape_config_details")

    @shape_config_details.setter
    def shape_config_details(self, value: Optional[pulumi.Input['PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs']]):
        pulumi.set(self, "shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict(TypedDict):
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepOverrideDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] memory_in_gbs: A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineRunStepRunArgsDict(TypedDict):
        dataflow_run_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the dataflow run triggered for this step run.
        """
        job_run_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job run triggered for this step run.
        """
        lifecycle_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        Details of the state of the step run.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the step run.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the step.
        """
        step_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of step.
        """
        time_finished: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the pipeline run request was finished in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        time_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the pipeline run request was started in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
elif False:
    PipelineRunStepRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunStepRunArgs:
    def __init__(__self__, *,
                 dataflow_run_id: Optional[pulumi.Input[_builtins.str]] = None,
                 job_run_id: Optional[pulumi.Input[_builtins.str]] = None,
                 lifecycle_details: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_type: Optional[pulumi.Input[_builtins.str]] = None,
                 time_finished: Optional[pulumi.Input[_builtins.str]] = None,
                 time_started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataflow_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the dataflow run triggered for this step run.
        :param pulumi.Input[_builtins.str] job_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job run triggered for this step run.
        :param pulumi.Input[_builtins.str] lifecycle_details: Details of the state of the step run.
        :param pulumi.Input[_builtins.str] state: The state of the step run.
        :param pulumi.Input[_builtins.str] step_name: The name of the step.
        :param pulumi.Input[_builtins.str] step_type: The type of step.
        :param pulumi.Input[_builtins.str] time_finished: The date and time the pipeline run request was finished in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param pulumi.Input[_builtins.str] time_started: The date and time the pipeline run request was started in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        if dataflow_run_id is not None:
            pulumi.set(__self__, "dataflow_run_id", dataflow_run_id)
        if job_run_id is not None:
            pulumi.set(__self__, "job_run_id", job_run_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if step_type is not None:
            pulumi.set(__self__, "step_type", step_type)
        if time_finished is not None:
            pulumi.set(__self__, "time_finished", time_finished)
        if time_started is not None:
            pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter(name="dataflowRunId")
    def dataflow_run_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the dataflow run triggered for this step run.
        """
        return pulumi.get(self, "dataflow_run_id")

    @dataflow_run_id.setter
    def dataflow_run_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataflow_run_id", value)

    @_builtins.property
    @pulumi.getter(name="jobRunId")
    def job_run_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job run triggered for this step run.
        """
        return pulumi.get(self, "job_run_id")

    @job_run_id.setter
    def job_run_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_run_id", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Details of the state of the step run.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifecycle_details", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the step run.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the step.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter(name="stepType")
    def step_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of step.
        """
        return pulumi.get(self, "step_type")

    @step_type.setter
    def step_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_type", value)

    @_builtins.property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the pipeline run request was finished in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_finished")

    @time_finished.setter
    def time_finished(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_finished", value)

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the pipeline run request was started in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_started")

    @time_started.setter
    def time_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_started", value)


if not MYPY:
    class PipelineStepArtifactArgsDict(TypedDict):
        pipeline_step_artifact: pulumi.Input[_builtins.str]
        step_name: pulumi.Input[_builtins.str]
        """
        The name of the step. It must be unique within the pipeline. This is used to create the pipeline DAG.
        """
        artifact_content_disposition: NotRequired[pulumi.Input[_builtins.str]]
        artifact_content_length: NotRequired[pulumi.Input[_builtins.str]]
        artifact_content_md5: NotRequired[pulumi.Input[_builtins.str]]
        artifact_last_modified: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStepArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepArtifactArgs:
    def __init__(__self__, *,
                 pipeline_step_artifact: pulumi.Input[_builtins.str],
                 step_name: pulumi.Input[_builtins.str],
                 artifact_content_disposition: Optional[pulumi.Input[_builtins.str]] = None,
                 artifact_content_length: Optional[pulumi.Input[_builtins.str]] = None,
                 artifact_content_md5: Optional[pulumi.Input[_builtins.str]] = None,
                 artifact_last_modified: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] step_name: The name of the step. It must be unique within the pipeline. This is used to create the pipeline DAG.
        """
        pulumi.set(__self__, "pipeline_step_artifact", pipeline_step_artifact)
        pulumi.set(__self__, "step_name", step_name)
        if artifact_content_disposition is not None:
            pulumi.set(__self__, "artifact_content_disposition", artifact_content_disposition)
        if artifact_content_length is not None:
            pulumi.set(__self__, "artifact_content_length", artifact_content_length)
        if artifact_content_md5 is not None:
            pulumi.set(__self__, "artifact_content_md5", artifact_content_md5)
        if artifact_last_modified is not None:
            pulumi.set(__self__, "artifact_last_modified", artifact_last_modified)

    @_builtins.property
    @pulumi.getter(name="pipelineStepArtifact")
    def pipeline_step_artifact(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "pipeline_step_artifact")

    @pipeline_step_artifact.setter
    def pipeline_step_artifact(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pipeline_step_artifact", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the step. It must be unique within the pipeline. This is used to create the pipeline DAG.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter(name="artifactContentDisposition")
    def artifact_content_disposition(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_content_disposition")

    @artifact_content_disposition.setter
    def artifact_content_disposition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_content_disposition", value)

    @_builtins.property
    @pulumi.getter(name="artifactContentLength")
    def artifact_content_length(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_content_length")

    @artifact_content_length.setter
    def artifact_content_length(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_content_length", value)

    @_builtins.property
    @pulumi.getter(name="artifactContentMd5")
    def artifact_content_md5(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_content_md5")

    @artifact_content_md5.setter
    def artifact_content_md5(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_content_md5", value)

    @_builtins.property
    @pulumi.getter(name="artifactLastModified")
    def artifact_last_modified(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_last_modified")

    @artifact_last_modified.setter
    def artifact_last_modified(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_last_modified", value)


if not MYPY:
    class PipelineStepDetailArgsDict(TypedDict):
        step_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the step. It must be unique within the pipeline. This is used to create the pipeline DAG.
        """
        step_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of step.
        """
        application_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the dataflow application to be used as a step.
        """
        depends_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of step names this current step depends on for execution.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A short description of the step.
        """
        is_artifact_uploaded: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to indicate whether the artifact has been uploaded for this step or not.
        """
        job_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job to be used as a step.
        """
        step_configuration_details: NotRequired[pulumi.Input['PipelineStepDetailStepConfigurationDetailsArgsDict']]
        """
        (Updatable) The configuration details of a step.
        """
        step_container_configuration_details: NotRequired[pulumi.Input['PipelineStepDetailStepContainerConfigurationDetailsArgsDict']]
        """
        Container Details for a step in pipeline.
        """
        step_dataflow_configuration_details: NotRequired[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsArgsDict']]
        """
        (Updatable) The configuration details of a Dataflow step.
        """
        step_infrastructure_configuration_details: NotRequired[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsArgsDict']]
        """
        (Updatable) The infrastructure configuration details of a pipeline or a step.
        """
        step_storage_mount_configuration_details_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineStepDetailStepStorageMountConfigurationDetailsListArgsDict']]]]
        """
        (Updatable) The storage mount details to mount to the instance running the pipeline step.
        """
elif False:
    PipelineStepDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailArgs:
    def __init__(__self__, *,
                 step_name: pulumi.Input[_builtins.str],
                 step_type: pulumi.Input[_builtins.str],
                 application_id: Optional[pulumi.Input[_builtins.str]] = None,
                 depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 is_artifact_uploaded: Optional[pulumi.Input[_builtins.bool]] = None,
                 job_id: Optional[pulumi.Input[_builtins.str]] = None,
                 step_configuration_details: Optional[pulumi.Input['PipelineStepDetailStepConfigurationDetailsArgs']] = None,
                 step_container_configuration_details: Optional[pulumi.Input['PipelineStepDetailStepContainerConfigurationDetailsArgs']] = None,
                 step_dataflow_configuration_details: Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsArgs']] = None,
                 step_infrastructure_configuration_details: Optional[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsArgs']] = None,
                 step_storage_mount_configuration_details_lists: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineStepDetailStepStorageMountConfigurationDetailsListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] step_name: (Updatable) The name of the step. It must be unique within the pipeline. This is used to create the pipeline DAG.
        :param pulumi.Input[_builtins.str] step_type: (Updatable) The type of step.
        :param pulumi.Input[_builtins.str] application_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the dataflow application to be used as a step.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] depends_ons: The list of step names this current step depends on for execution.
        :param pulumi.Input[_builtins.str] description: (Updatable) A short description of the step.
        :param pulumi.Input[_builtins.bool] is_artifact_uploaded: A flag to indicate whether the artifact has been uploaded for this step or not.
        :param pulumi.Input[_builtins.str] job_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job to be used as a step.
        :param pulumi.Input['PipelineStepDetailStepConfigurationDetailsArgs'] step_configuration_details: (Updatable) The configuration details of a step.
        :param pulumi.Input['PipelineStepDetailStepContainerConfigurationDetailsArgs'] step_container_configuration_details: Container Details for a step in pipeline.
        :param pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsArgs'] step_dataflow_configuration_details: (Updatable) The configuration details of a Dataflow step.
        :param pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsArgs'] step_infrastructure_configuration_details: (Updatable) The infrastructure configuration details of a pipeline or a step.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineStepDetailStepStorageMountConfigurationDetailsListArgs']]] step_storage_mount_configuration_details_lists: (Updatable) The storage mount details to mount to the instance running the pipeline step.
        """
        pulumi.set(__self__, "step_name", step_name)
        pulumi.set(__self__, "step_type", step_type)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_artifact_uploaded is not None:
            pulumi.set(__self__, "is_artifact_uploaded", is_artifact_uploaded)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if step_configuration_details is not None:
            pulumi.set(__self__, "step_configuration_details", step_configuration_details)
        if step_container_configuration_details is not None:
            pulumi.set(__self__, "step_container_configuration_details", step_container_configuration_details)
        if step_dataflow_configuration_details is not None:
            pulumi.set(__self__, "step_dataflow_configuration_details", step_dataflow_configuration_details)
        if step_infrastructure_configuration_details is not None:
            pulumi.set(__self__, "step_infrastructure_configuration_details", step_infrastructure_configuration_details)
        if step_storage_mount_configuration_details_lists is not None:
            pulumi.set(__self__, "step_storage_mount_configuration_details_lists", step_storage_mount_configuration_details_lists)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the step. It must be unique within the pipeline. This is used to create the pipeline DAG.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter(name="stepType")
    def step_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of step.
        """
        return pulumi.get(self, "step_type")

    @step_type.setter
    def step_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_type", value)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the dataflow application to be used as a step.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_id", value)

    @_builtins.property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of step names this current step depends on for execution.
        """
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "depends_ons", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A short description of the step.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="isArtifactUploaded")
    def is_artifact_uploaded(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to indicate whether the artifact has been uploaded for this step or not.
        """
        return pulumi.get(self, "is_artifact_uploaded")

    @is_artifact_uploaded.setter
    def is_artifact_uploaded(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_artifact_uploaded", value)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job to be used as a step.
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_id", value)

    @_builtins.property
    @pulumi.getter(name="stepConfigurationDetails")
    def step_configuration_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepConfigurationDetailsArgs']]:
        """
        (Updatable) The configuration details of a step.
        """
        return pulumi.get(self, "step_configuration_details")

    @step_configuration_details.setter
    def step_configuration_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepConfigurationDetailsArgs']]):
        pulumi.set(self, "step_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepContainerConfigurationDetails")
    def step_container_configuration_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepContainerConfigurationDetailsArgs']]:
        """
        Container Details for a step in pipeline.
        """
        return pulumi.get(self, "step_container_configuration_details")

    @step_container_configuration_details.setter
    def step_container_configuration_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepContainerConfigurationDetailsArgs']]):
        pulumi.set(self, "step_container_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepDataflowConfigurationDetails")
    def step_dataflow_configuration_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsArgs']]:
        """
        (Updatable) The configuration details of a Dataflow step.
        """
        return pulumi.get(self, "step_dataflow_configuration_details")

    @step_dataflow_configuration_details.setter
    def step_dataflow_configuration_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsArgs']]):
        pulumi.set(self, "step_dataflow_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepInfrastructureConfigurationDetails")
    def step_infrastructure_configuration_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsArgs']]:
        """
        (Updatable) The infrastructure configuration details of a pipeline or a step.
        """
        return pulumi.get(self, "step_infrastructure_configuration_details")

    @step_infrastructure_configuration_details.setter
    def step_infrastructure_configuration_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsArgs']]):
        pulumi.set(self, "step_infrastructure_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepStorageMountConfigurationDetailsLists")
    def step_storage_mount_configuration_details_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineStepDetailStepStorageMountConfigurationDetailsListArgs']]]]:
        """
        (Updatable) The storage mount details to mount to the instance running the pipeline step.
        """
        return pulumi.get(self, "step_storage_mount_configuration_details_lists")

    @step_storage_mount_configuration_details_lists.setter
    def step_storage_mount_configuration_details_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineStepDetailStepStorageMountConfigurationDetailsListArgs']]]]):
        pulumi.set(self, "step_storage_mount_configuration_details_lists", value)


if not MYPY:
    class PipelineStepDetailStepConfigurationDetailsArgsDict(TypedDict):
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The command line arguments to set for step.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Environment variables to set for step.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A time bound for the execution of the step.
        """
elif False:
    PipelineStepDetailStepConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepConfigurationDetailsArgs:
    def __init__(__self__, *,
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] command_line_arguments: (Updatable) The command line arguments to set for step.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: (Updatable) Environment variables to set for step.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: (Updatable) A time bound for the execution of the step.
        """
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The command line arguments to set for step.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Environment variables to set for step.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A time bound for the execution of the step.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class PipelineStepDetailStepContainerConfigurationDetailsArgsDict(TypedDict):
        container_type: pulumi.Input[_builtins.str]
        """
        The type of container.
        """
        image: pulumi.Input[_builtins.str]
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the container image signature
        """
elif False:
    PipelineStepDetailStepContainerConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepContainerConfigurationDetailsArgs:
    def __init__(__self__, *,
                 container_type: pulumi.Input[_builtins.str],
                 image: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] container_type: The type of container.
        :param pulumi.Input[_builtins.str] image: The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: OCID of the container image signature
        """
        pulumi.set(__self__, "container_type", container_type)
        pulumi.set(__self__, "image", image)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter(name="containerType")
    def container_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of container.
        """
        return pulumi.get(self, "container_type")

    @container_type.setter
    def container_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_type", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class PipelineStepDetailStepDataflowConfigurationDetailsArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The Spark configuration passed to the running process.
        """
        driver_shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The VM shape for the driver.
        """
        driver_shape_config_details: NotRequired[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        executor_shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The VM shape for the executors.
        """
        executor_shape_config_details: NotRequired[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        logs_bucket_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An Oracle Cloud Infrastructure URI of the bucket where the Spark job logs are to be uploaded.
        """
        num_executors: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of executor VMs requested.
        """
        warehouse_bucket_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An Oracle Cloud Infrastructure URI of the bucket to be used as default warehouse directory for BATCH SQL runs.
        """
elif False:
    PipelineStepDetailStepDataflowConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepDataflowConfigurationDetailsArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 driver_shape: Optional[pulumi.Input[_builtins.str]] = None,
                 driver_shape_config_details: Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs']] = None,
                 executor_shape: Optional[pulumi.Input[_builtins.str]] = None,
                 executor_shape_config_details: Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs']] = None,
                 logs_bucket_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 num_executors: Optional[pulumi.Input[_builtins.int]] = None,
                 warehouse_bucket_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] configuration: (Updatable) The Spark configuration passed to the running process.
        :param pulumi.Input[_builtins.str] driver_shape: (Updatable) The VM shape for the driver.
        :param pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs'] driver_shape_config_details: (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] executor_shape: (Updatable) The VM shape for the executors.
        :param pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs'] executor_shape_config_details: (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] logs_bucket_uri: (Updatable) An Oracle Cloud Infrastructure URI of the bucket where the Spark job logs are to be uploaded.
        :param pulumi.Input[_builtins.int] num_executors: (Updatable) The number of executor VMs requested.
        :param pulumi.Input[_builtins.str] warehouse_bucket_uri: (Updatable) An Oracle Cloud Infrastructure URI of the bucket to be used as default warehouse directory for BATCH SQL runs.
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if driver_shape is not None:
            pulumi.set(__self__, "driver_shape", driver_shape)
        if driver_shape_config_details is not None:
            pulumi.set(__self__, "driver_shape_config_details", driver_shape_config_details)
        if executor_shape is not None:
            pulumi.set(__self__, "executor_shape", executor_shape)
        if executor_shape_config_details is not None:
            pulumi.set(__self__, "executor_shape_config_details", executor_shape_config_details)
        if logs_bucket_uri is not None:
            pulumi.set(__self__, "logs_bucket_uri", logs_bucket_uri)
        if num_executors is not None:
            pulumi.set(__self__, "num_executors", num_executors)
        if warehouse_bucket_uri is not None:
            pulumi.set(__self__, "warehouse_bucket_uri", warehouse_bucket_uri)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The Spark configuration passed to the running process.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter(name="driverShape")
    def driver_shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The VM shape for the driver.
        """
        return pulumi.get(self, "driver_shape")

    @driver_shape.setter
    def driver_shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "driver_shape", value)

    @_builtins.property
    @pulumi.getter(name="driverShapeConfigDetails")
    def driver_shape_config_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "driver_shape_config_details")

    @driver_shape_config_details.setter
    def driver_shape_config_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs']]):
        pulumi.set(self, "driver_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="executorShape")
    def executor_shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The VM shape for the executors.
        """
        return pulumi.get(self, "executor_shape")

    @executor_shape.setter
    def executor_shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "executor_shape", value)

    @_builtins.property
    @pulumi.getter(name="executorShapeConfigDetails")
    def executor_shape_config_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "executor_shape_config_details")

    @executor_shape_config_details.setter
    def executor_shape_config_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs']]):
        pulumi.set(self, "executor_shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="logsBucketUri")
    def logs_bucket_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An Oracle Cloud Infrastructure URI of the bucket where the Spark job logs are to be uploaded.
        """
        return pulumi.get(self, "logs_bucket_uri")

    @logs_bucket_uri.setter
    def logs_bucket_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logs_bucket_uri", value)

    @_builtins.property
    @pulumi.getter(name="numExecutors")
    def num_executors(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of executor VMs requested.
        """
        return pulumi.get(self, "num_executors")

    @num_executors.setter
    def num_executors(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_executors", value)

    @_builtins.property
    @pulumi.getter(name="warehouseBucketUri")
    def warehouse_bucket_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An Oracle Cloud Infrastructure URI of the bucket to be used as default warehouse directory for BATCH SQL runs.
        """
        return pulumi.get(self, "warehouse_bucket_uri")

    @warehouse_bucket_uri.setter
    def warehouse_bucket_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warehouse_bucket_uri", value)


if not MYPY:
    class PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepDataflowConfigurationDetailsDriverShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepDataflowConfigurationDetailsExecutorShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineStepDetailStepInfrastructureConfigurationDetailsArgsDict(TypedDict):
        block_storage_size_in_gbs: pulumi.Input[_builtins.int]
        """
        (Updatable) The size of the block storage volume to attach to the instance.
        """
        shape_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The shape used to launch the instance for all step runs in the pipeline.
        """
        shape_config_details: NotRequired[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict']]
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
elif False:
    PipelineStepDetailStepInfrastructureConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepInfrastructureConfigurationDetailsArgs:
    def __init__(__self__, *,
                 block_storage_size_in_gbs: pulumi.Input[_builtins.int],
                 shape_name: pulumi.Input[_builtins.str],
                 shape_config_details: Optional[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs']] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] block_storage_size_in_gbs: (Updatable) The size of the block storage volume to attach to the instance.
        :param pulumi.Input[_builtins.str] shape_name: (Updatable) The shape used to launch the instance for all step runs in the pipeline.
        :param pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs'] shape_config_details: (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        :param pulumi.Input[_builtins.str] subnet_id: (Updatable) The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        pulumi.set(__self__, "shape_name", shape_name)
        if shape_config_details is not None:
            pulumi.set(__self__, "shape_config_details", shape_config_details)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The size of the block storage volume to attach to the instance.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The shape used to launch the instance for all step runs in the pipeline.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape_name", value)

    @_builtins.property
    @pulumi.getter(name="shapeConfigDetails")
    def shape_config_details(self) -> Optional[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the pipeline step run shape configuration. Specify only when a flex shape is selected.
        """
        return pulumi.get(self, "shape_config_details")

    @shape_config_details.setter
    def shape_config_details(self, value: Optional[pulumi.Input['PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs']]):
        pulumi.set(self, "shape_config_details", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The subnet to create a secondary vnic in to attach to the instance running the pipeline step.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict(TypedDict):
        cpu_baseline: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        ocpus: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
elif False:
    PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepInfrastructureConfigurationDetailsShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 cpu_baseline: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[_builtins.float]] = None,
                 ocpus: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_baseline: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        :param pulumi.Input[_builtins.float] memory_in_gbs: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[_builtins.float] ocpus: (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if cpu_baseline is not None:
            pulumi.set(__self__, "cpu_baseline", cpu_baseline)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="cpuBaseline")
    def cpu_baseline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. If this attribute is left blank, it will default to `BASELINE_1_1`. The following values are supported: BASELINE_1_8 - baseline usage is 1/8 of an OCPU. BASELINE_1_2 - baseline usage is 1/2 of an OCPU. BASELINE_1_1 - baseline usage is an entire OCPU. This represents a non-burstable instance.
        """
        return pulumi.get(self, "cpu_baseline")

    @cpu_baseline.setter
    def cpu_baseline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_baseline", value)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) A pipeline step run instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class PipelineStepDetailStepStorageMountConfigurationDetailsListArgsDict(TypedDict):
        destination_directory_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The local directory name to be mounted
        """
        storage_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of storage.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage bucket
        """
        destination_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        export_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the export
        """
        mount_target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the mount target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage namespace
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Prefix in the bucket to mount
        """
elif False:
    PipelineStepDetailStepStorageMountConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStepDetailStepStorageMountConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 destination_directory_name: pulumi.Input[_builtins.str],
                 storage_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_path: Optional[pulumi.Input[_builtins.str]] = None,
                 export_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_directory_name: (Updatable) The local directory name to be mounted
        :param pulumi.Input[_builtins.str] storage_type: (Updatable) The type of storage.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The object storage bucket
        :param pulumi.Input[_builtins.str] destination_path: (Updatable) The local path of the mounted directory, excluding directory name.
        :param pulumi.Input[_builtins.str] export_id: (Updatable) OCID of the export
        :param pulumi.Input[_builtins.str] mount_target_id: (Updatable) OCID of the mount target
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The object storage namespace
        :param pulumi.Input[_builtins.str] prefix: (Updatable) Prefix in the bucket to mount
        """
        pulumi.set(__self__, "destination_directory_name", destination_directory_name)
        pulumi.set(__self__, "storage_type", storage_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if mount_target_id is not None:
            pulumi.set(__self__, "mount_target_id", mount_target_id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="destinationDirectoryName")
    def destination_directory_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The local directory name to be mounted
        """
        return pulumi.get(self, "destination_directory_name")

    @destination_directory_name.setter
    def destination_directory_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_directory_name", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of storage.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_path", value)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the export
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_id", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the mount target
        """
        return pulumi.get(self, "mount_target_id")

    @mount_target_id.setter
    def mount_target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_target_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Prefix in the bucket to mount
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class PipelineStorageMountConfigurationDetailsListArgsDict(TypedDict):
        destination_directory_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The local directory name to be mounted
        """
        storage_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of storage.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage bucket
        """
        destination_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        export_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the export
        """
        mount_target_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the mount target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The object storage namespace
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Prefix in the bucket to mount
        """
elif False:
    PipelineStorageMountConfigurationDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStorageMountConfigurationDetailsListArgs:
    def __init__(__self__, *,
                 destination_directory_name: pulumi.Input[_builtins.str],
                 storage_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_path: Optional[pulumi.Input[_builtins.str]] = None,
                 export_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_target_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_directory_name: (Updatable) The local directory name to be mounted
        :param pulumi.Input[_builtins.str] storage_type: (Updatable) The type of storage.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The object storage bucket
        :param pulumi.Input[_builtins.str] destination_path: (Updatable) The local path of the mounted directory, excluding directory name.
        :param pulumi.Input[_builtins.str] export_id: (Updatable) OCID of the export
        :param pulumi.Input[_builtins.str] mount_target_id: (Updatable) OCID of the mount target
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The object storage namespace
        :param pulumi.Input[_builtins.str] prefix: (Updatable) Prefix in the bucket to mount
        """
        pulumi.set(__self__, "destination_directory_name", destination_directory_name)
        pulumi.set(__self__, "storage_type", storage_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if mount_target_id is not None:
            pulumi.set(__self__, "mount_target_id", mount_target_id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="destinationDirectoryName")
    def destination_directory_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The local directory name to be mounted
        """
        return pulumi.get(self, "destination_directory_name")

    @destination_directory_name.setter
    def destination_directory_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_directory_name", value)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of storage.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The local path of the mounted directory, excluding directory name.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_path", value)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the export
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_id", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the mount target
        """
        return pulumi.get(self, "mount_target_id")

    @mount_target_id.setter
    def mount_target_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_target_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The object storage namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Prefix in the bucket to mount
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ScheduleActionArgsDict(TypedDict):
        action_details: pulumi.Input['ScheduleActionActionDetailsArgsDict']
        """
        (Updatable) Schedule Http action details
        """
        action_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The Schedule Action type
        """
elif False:
    ScheduleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionArgs:
    def __init__(__self__, *,
                 action_details: pulumi.Input['ScheduleActionActionDetailsArgs'],
                 action_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['ScheduleActionActionDetailsArgs'] action_details: (Updatable) Schedule Http action details
        :param pulumi.Input[_builtins.str] action_type: (Updatable) The Schedule Action type
        """
        pulumi.set(__self__, "action_details", action_details)
        pulumi.set(__self__, "action_type", action_type)

    @_builtins.property
    @pulumi.getter(name="actionDetails")
    def action_details(self) -> pulumi.Input['ScheduleActionActionDetailsArgs']:
        """
        (Updatable) Schedule Http action details
        """
        return pulumi.get(self, "action_details")

    @action_details.setter
    def action_details(self, value: pulumi.Input['ScheduleActionActionDetailsArgs']):
        pulumi.set(self, "action_details", value)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Schedule Action type
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_type", value)


if not MYPY:
    class ScheduleActionActionDetailsArgsDict(TypedDict):
        http_action_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of http action to trigger.
        """
        create_job_run_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsArgsDict']]
        """
        (Updatable) Parameters needed to create a new job run.
        """
        create_pipeline_run_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsArgsDict']]
        """
        (Updatable) The information about new PipelineRun.
        """
        ml_application_instance_view_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the schedule.
        """
        trigger_ml_application_instance_view_flow_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgsDict']]
        """
        (Updatable) Payload for trigger request endpoint
        """
elif False:
    ScheduleActionActionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsArgs:
    def __init__(__self__, *,
                 http_action_type: pulumi.Input[_builtins.str],
                 create_job_run_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsArgs']] = None,
                 create_pipeline_run_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsArgs']] = None,
                 ml_application_instance_view_id: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_ml_application_instance_view_flow_details: Optional[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] http_action_type: (Updatable) The type of http action to trigger.
        :param pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsArgs'] create_job_run_details: (Updatable) Parameters needed to create a new job run.
        :param pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsArgs'] create_pipeline_run_details: (Updatable) The information about new PipelineRun.
        :param pulumi.Input[_builtins.str] ml_application_instance_view_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the schedule.
        :param pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgs'] trigger_ml_application_instance_view_flow_details: (Updatable) Payload for trigger request endpoint
        """
        pulumi.set(__self__, "http_action_type", http_action_type)
        if create_job_run_details is not None:
            pulumi.set(__self__, "create_job_run_details", create_job_run_details)
        if create_pipeline_run_details is not None:
            pulumi.set(__self__, "create_pipeline_run_details", create_pipeline_run_details)
        if ml_application_instance_view_id is not None:
            pulumi.set(__self__, "ml_application_instance_view_id", ml_application_instance_view_id)
        if trigger_ml_application_instance_view_flow_details is not None:
            pulumi.set(__self__, "trigger_ml_application_instance_view_flow_details", trigger_ml_application_instance_view_flow_details)

    @_builtins.property
    @pulumi.getter(name="httpActionType")
    def http_action_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of http action to trigger.
        """
        return pulumi.get(self, "http_action_type")

    @http_action_type.setter
    def http_action_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "http_action_type", value)

    @_builtins.property
    @pulumi.getter(name="createJobRunDetails")
    def create_job_run_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsArgs']]:
        """
        (Updatable) Parameters needed to create a new job run.
        """
        return pulumi.get(self, "create_job_run_details")

    @create_job_run_details.setter
    def create_job_run_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsArgs']]):
        pulumi.set(self, "create_job_run_details", value)

    @_builtins.property
    @pulumi.getter(name="createPipelineRunDetails")
    def create_pipeline_run_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsArgs']]:
        """
        (Updatable) The information about new PipelineRun.
        """
        return pulumi.get(self, "create_pipeline_run_details")

    @create_pipeline_run_details.setter
    def create_pipeline_run_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsArgs']]):
        pulumi.set(self, "create_pipeline_run_details", value)

    @_builtins.property
    @pulumi.getter(name="mlApplicationInstanceViewId")
    def ml_application_instance_view_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the schedule.
        """
        return pulumi.get(self, "ml_application_instance_view_id")

    @ml_application_instance_view_id.setter
    def ml_application_instance_view_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ml_application_instance_view_id", value)

    @_builtins.property
    @pulumi.getter(name="triggerMlApplicationInstanceViewFlowDetails")
    def trigger_ml_application_instance_view_flow_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgs']]:
        """
        (Updatable) Payload for trigger request endpoint
        """
        return pulumi.get(self, "trigger_ml_application_instance_view_flow_details")

    @trigger_ml_application_instance_view_flow_details.setter
    def trigger_ml_application_instance_view_flow_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgs']]):
        pulumi.set(self, "trigger_ml_application_instance_view_flow_details", value)


if not MYPY:
    class ScheduleActionActionDetailsCreateJobRunDetailsArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the job run.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly display name for the resource.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        job_configuration_override_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgsDict']]
        """
        (Updatable) The job configuration details
        """
        job_environment_configuration_override_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgsDict']]
        """
        (Updatable) Environment configuration to capture job runtime dependencies.
        """
        job_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job to create a run for.
        """
        job_log_configuration_override_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgsDict']]
        """
        (Updatable) Logging configuration for resource.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the project to associate the job run with.
        """
elif False:
    ScheduleActionActionDetailsCreateJobRunDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreateJobRunDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 job_configuration_override_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgs']] = None,
                 job_environment_configuration_override_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgs']] = None,
                 job_id: Optional[pulumi.Input[_builtins.str]] = None,
                 job_log_configuration_override_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgs']] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the job run.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly display name for the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        :param pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgs'] job_configuration_override_details: (Updatable) The job configuration details
        :param pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgs'] job_environment_configuration_override_details: (Updatable) Environment configuration to capture job runtime dependencies.
        :param pulumi.Input[_builtins.str] job_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job to create a run for.
        :param pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgs'] job_log_configuration_override_details: (Updatable) Logging configuration for resource.
        :param pulumi.Input[_builtins.str] project_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the project to associate the job run with.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if job_configuration_override_details is not None:
            pulumi.set(__self__, "job_configuration_override_details", job_configuration_override_details)
        if job_environment_configuration_override_details is not None:
            pulumi.set(__self__, "job_environment_configuration_override_details", job_environment_configuration_override_details)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if job_log_configuration_override_details is not None:
            pulumi.set(__self__, "job_log_configuration_override_details", job_log_configuration_override_details)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the job run.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly display name for the resource.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter(name="jobConfigurationOverrideDetails")
    def job_configuration_override_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgs']]:
        """
        (Updatable) The job configuration details
        """
        return pulumi.get(self, "job_configuration_override_details")

    @job_configuration_override_details.setter
    def job_configuration_override_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgs']]):
        pulumi.set(self, "job_configuration_override_details", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentConfigurationOverrideDetails")
    def job_environment_configuration_override_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgs']]:
        """
        (Updatable) Environment configuration to capture job runtime dependencies.
        """
        return pulumi.get(self, "job_environment_configuration_override_details")

    @job_environment_configuration_override_details.setter
    def job_environment_configuration_override_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgs']]):
        pulumi.set(self, "job_environment_configuration_override_details", value)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the job to create a run for.
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_id", value)

    @_builtins.property
    @pulumi.getter(name="jobLogConfigurationOverrideDetails")
    def job_log_configuration_override_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgs']]:
        """
        (Updatable) Logging configuration for resource.
        """
        return pulumi.get(self, "job_log_configuration_override_details")

    @job_log_configuration_override_details.setter
    def job_log_configuration_override_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgs']]):
        pulumi.set(self, "job_log_configuration_override_details", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the project to associate the job run with.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgsDict(TypedDict):
        job_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of job.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The arguments to pass to the job.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Environment variables to set for the job.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A time bound for the execution of the job. Timer starts when the job becomes active.
        """
elif False:
    ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreateJobRunDetailsJobConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 job_type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] job_type: (Updatable) The type of job.
        :param pulumi.Input[_builtins.str] command_line_arguments: (Updatable) The arguments to pass to the job.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: (Updatable) Environment variables to set for the job.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: (Updatable) A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        pulumi.set(__self__, "job_type", job_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of job.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The arguments to pass to the job.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Environment variables to set for the job.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A time bound for the execution of the job. Timer starts when the job becomes active.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        job_environment_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The environment configuration type used for job runtime.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the container image signature
        """
elif False:
    ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreateJobRunDetailsJobEnvironmentConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 job_environment_type: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        :param pulumi.Input[_builtins.str] job_environment_type: (Updatable) The environment configuration type used for job runtime.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: (Updatable) OCID of the container image signature
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "job_environment_type", job_environment_type)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format. Acceptable format: `<region>.ocir.io/<registry>/<image>:<tag>` `<region>.ocir.io/<registry>/<image>:<tag>@digest`
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="jobEnvironmentType")
    def job_environment_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The environment configuration type used for job runtime.
        """
        return pulumi.get(self, "job_environment_type")

    @job_environment_type.setter
    def job_environment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_environment_type", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgsDict(TypedDict):
        enable_auto_log_creation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If automatic on-behalf-of log object creation is enabled for job runs.
        """
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If customer logging is enabled for job runs.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The log group id for where log objects are for job runs.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The log id the job run will push logs too.
        """
elif False:
    ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreateJobRunDetailsJobLogConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 enable_auto_log_creation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_auto_log_creation: (Updatable) If automatic on-behalf-of log object creation is enabled for job runs.
        :param pulumi.Input[_builtins.bool] enable_logging: (Updatable) If customer logging is enabled for job runs.
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The log group id for where log objects are for job runs.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The log id the job run will push logs too.
        """
        if enable_auto_log_creation is not None:
            pulumi.set(__self__, "enable_auto_log_creation", enable_auto_log_creation)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableAutoLogCreation")
    def enable_auto_log_creation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If automatic on-behalf-of log object creation is enabled for job runs.
        """
        return pulumi.get(self, "enable_auto_log_creation")

    @enable_auto_log_creation.setter
    def enable_auto_log_creation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_log_creation", value)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If customer logging is enabled for job runs.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The log group id for where log objects are for job runs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The log id the job run will push logs too.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class ScheduleActionActionDetailsCreatePipelineRunDetailsArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the pipeline run.
        """
        configuration_override_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgsDict']]
        """
        (Updatable) The configuration details of a pipeline.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly display name for the resource.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        log_configuration_override_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgsDict']]
        """
        (Updatable) The pipeline log configuration details.
        """
        pipeline_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pipeline for which pipeline run is created.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the project to associate the pipeline run with.
        """
        step_override_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgsDict']]]]
        """
        (Updatable) Array of step override details. Only Step Configuration is allowed to be overridden.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
elif False:
    ScheduleActionActionDetailsCreatePipelineRunDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreatePipelineRunDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 configuration_override_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgs']] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 log_configuration_override_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgs']] = None,
                 pipeline_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 step_override_details: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgs']]]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the pipeline run.
        :param pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgs'] configuration_override_details: (Updatable) The configuration details of a pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly display name for the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        :param pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgs'] log_configuration_override_details: (Updatable) The pipeline log configuration details.
        :param pulumi.Input[_builtins.str] pipeline_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pipeline for which pipeline run is created.
        :param pulumi.Input[_builtins.str] project_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the project to associate the pipeline run with.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgs']]] step_override_details: (Updatable) Array of step override details. Only Step Configuration is allowed to be overridden.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_tags: (Updatable) Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if configuration_override_details is not None:
            pulumi.set(__self__, "configuration_override_details", configuration_override_details)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if log_configuration_override_details is not None:
            pulumi.set(__self__, "log_configuration_override_details", log_configuration_override_details)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if step_override_details is not None:
            pulumi.set(__self__, "step_override_details", step_override_details)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the pipeline run.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="configurationOverrideDetails")
    def configuration_override_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgs']]:
        """
        (Updatable) The configuration details of a pipeline.
        """
        return pulumi.get(self, "configuration_override_details")

    @configuration_override_details.setter
    def configuration_override_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgs']]):
        pulumi.set(self, "configuration_override_details", value)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "defined_tags", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly display name for the resource.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @_builtins.property
    @pulumi.getter(name="logConfigurationOverrideDetails")
    def log_configuration_override_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgs']]:
        """
        (Updatable) The pipeline log configuration details.
        """
        return pulumi.get(self, "log_configuration_override_details")

    @log_configuration_override_details.setter
    def log_configuration_override_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgs']]):
        pulumi.set(self, "log_configuration_override_details", value)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pipeline for which pipeline run is created.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the project to associate the pipeline run with.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="stepOverrideDetails")
    def step_override_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgs']]]]:
        """
        (Updatable) Array of step override details. Only Step Configuration is allowed to be overridden.
        """
        return pulumi.get(self, "step_override_details")

    @step_override_details.setter
    def step_override_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgs']]]]):
        pulumi.set(self, "step_override_details", value)

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_tags", value)


if not MYPY:
    class ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of pipeline.
        """
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The command line arguments to set for steps in the pipeline.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Environment variables to set for steps in the pipeline.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
elif False:
    ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreatePipelineRunDetailsConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of pipeline.
        :param pulumi.Input[_builtins.str] command_line_arguments: (Updatable) The command line arguments to set for steps in the pipeline.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: (Updatable) Environment variables to set for steps in the pipeline.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: (Updatable) A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
        pulumi.set(__self__, "type", type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The command line arguments to set for steps in the pipeline.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Environment variables to set for steps in the pipeline.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A time bound for the execution of the entire Pipeline. Timer starts when the Pipeline Run is in progress.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgsDict(TypedDict):
        enable_auto_log_creation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If automatic on-behalf-of log object creation is enabled for pipeline runs.
        """
        enable_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) If customer logging is enabled for pipeline.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
elif False:
    ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreatePipelineRunDetailsLogConfigurationOverrideDetailsArgs:
    def __init__(__self__, *,
                 enable_auto_log_creation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_auto_log_creation: (Updatable) If automatic on-behalf-of log object creation is enabled for pipeline runs.
        :param pulumi.Input[_builtins.bool] enable_logging: (Updatable) If customer logging is enabled for pipeline.
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if enable_auto_log_creation is not None:
            pulumi.set(__self__, "enable_auto_log_creation", enable_auto_log_creation)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="enableAutoLogCreation")
    def enable_auto_log_creation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If automatic on-behalf-of log object creation is enabled for pipeline runs.
        """
        return pulumi.get(self, "enable_auto_log_creation")

    @enable_auto_log_creation.setter
    def enable_auto_log_creation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_auto_log_creation", value)

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) If customer logging is enabled for pipeline.
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_logging", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgsDict(TypedDict):
        step_configuration_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgsDict']]
        """
        (Updatable) The configuration details of a step.
        """
        step_container_configuration_details: NotRequired[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgsDict']]
        """
        (Updatable) Container Details for a step in pipeline.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the step.
        """
elif False:
    ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailArgs:
    def __init__(__self__, *,
                 step_configuration_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgs']] = None,
                 step_container_configuration_details: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgs']] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgs'] step_configuration_details: (Updatable) The configuration details of a step.
        :param pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgs'] step_container_configuration_details: (Updatable) Container Details for a step in pipeline.
        :param pulumi.Input[_builtins.str] step_name: (Updatable) The name of the step.
        """
        if step_configuration_details is not None:
            pulumi.set(__self__, "step_configuration_details", step_configuration_details)
        if step_container_configuration_details is not None:
            pulumi.set(__self__, "step_container_configuration_details", step_container_configuration_details)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="stepConfigurationDetails")
    def step_configuration_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgs']]:
        """
        (Updatable) The configuration details of a step.
        """
        return pulumi.get(self, "step_configuration_details")

    @step_configuration_details.setter
    def step_configuration_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgs']]):
        pulumi.set(self, "step_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepContainerConfigurationDetails")
    def step_container_configuration_details(self) -> Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgs']]:
        """
        (Updatable) Container Details for a step in pipeline.
        """
        return pulumi.get(self, "step_container_configuration_details")

    @step_container_configuration_details.setter
    def step_container_configuration_details(self, value: Optional[pulumi.Input['ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgs']]):
        pulumi.set(self, "step_container_configuration_details", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the step.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgsDict(TypedDict):
        command_line_arguments: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The command line arguments to set for step.
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Environment variables to set for step.
        """
        maximum_runtime_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A time bound for the execution of the step.
        """
elif False:
    ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepConfigurationDetailsArgs:
    def __init__(__self__, *,
                 command_line_arguments: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 maximum_runtime_in_minutes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] command_line_arguments: (Updatable) The command line arguments to set for step.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: (Updatable) Environment variables to set for step.
        :param pulumi.Input[_builtins.str] maximum_runtime_in_minutes: (Updatable) A time bound for the execution of the step.
        """
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if maximum_runtime_in_minutes is not None:
            pulumi.set(__self__, "maximum_runtime_in_minutes", maximum_runtime_in_minutes)

    @_builtins.property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The command line arguments to set for step.
        """
        return pulumi.get(self, "command_line_arguments")

    @command_line_arguments.setter
    def command_line_arguments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_line_arguments", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Environment variables to set for step.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="maximumRuntimeInMinutes")
    def maximum_runtime_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A time bound for the execution of the step.
        """
        return pulumi.get(self, "maximum_runtime_in_minutes")

    @maximum_runtime_in_minutes.setter
    def maximum_runtime_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_runtime_in_minutes", value)


if not MYPY:
    class ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgsDict(TypedDict):
        container_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of container.
        """
        image: pulumi.Input[_builtins.str]
        """
        (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        """
        cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        image_digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        image_signature_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the container image signature
        """
elif False:
    ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsCreatePipelineRunDetailsStepOverrideDetailStepContainerConfigurationDetailsArgs:
    def __init__(__self__, *,
                 container_type: pulumi.Input[_builtins.str],
                 image: pulumi.Input[_builtins.str],
                 cmds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image_digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image_signature_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] container_type: (Updatable) The type of container.
        :param pulumi.Input[_builtins.str] image: (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cmds: (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entrypoints: (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        :param pulumi.Input[_builtins.str] image_digest: (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        :param pulumi.Input[_builtins.str] image_signature_id: (Updatable) OCID of the container image signature
        """
        pulumi.set(__self__, "container_type", container_type)
        pulumi.set(__self__, "image", image)
        if cmds is not None:
            pulumi.set(__self__, "cmds", cmds)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_signature_id is not None:
            pulumi.set(__self__, "image_signature_id", image_signature_id)

    @_builtins.property
    @pulumi.getter(name="containerType")
    def container_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of container.
        """
        return pulumi.get(self, "container_type")

    @container_type.setter
    def container_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_type", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The full path to the Oracle Container Repository (OCIR) registry, image, and tag in a canonical format.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The container image run [CMD](https://docs.docker.com/engine/reference/builder/#cmd) as a list of strings. Use `CMD` as arguments to the `ENTRYPOINT` or the only command to run in the absence of an `ENTRYPOINT`. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes.
        """
        return pulumi.get(self, "cmds")

    @cmds.setter
    def cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cmds", value)

    @_builtins.property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The container image run [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) as a list of strings. Accept the `CMD` as extra arguments. The combined size of `CMD` and `ENTRYPOINT` must be less than 2048 bytes. More information on how `CMD` and `ENTRYPOINT` interact are [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entrypoints", value)

    @_builtins.property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The digest of the container image. For example, `sha256:881303a6b2738834d795a32b4a98eb0e5e3d1cad590a712d1e04f9b2fa90a030`
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_digest", value)

    @_builtins.property
    @pulumi.getter(name="imageSignatureId")
    def image_signature_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the container image signature
        """
        return pulumi.get(self, "image_signature_id")

    @image_signature_id.setter
    def image_signature_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_signature_id", value)


if not MYPY:
    class ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgsDict']]]]
        """
        (Updatable) Parameters provided for given trigger invocation (they must match predefined schema)
        """
        trigger_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of trigger
        """
elif False:
    ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgs']]]] = None,
                 trigger_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgs']]] parameters: (Updatable) Parameters provided for given trigger invocation (they must match predefined schema)
        :param pulumi.Input[_builtins.str] trigger_name: (Updatable) Name of trigger
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if trigger_name is not None:
            pulumi.set(__self__, "trigger_name", trigger_name)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgs']]]]:
        """
        (Updatable) Parameters provided for given trigger invocation (they must match predefined schema)
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of trigger
        """
        return pulumi.get(self, "trigger_name")

    @trigger_name.setter
    def trigger_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_name", value)


if not MYPY:
    class ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of trigger parameter
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Value of trigger parameter
        """
elif False:
    ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleActionActionDetailsTriggerMlApplicationInstanceViewFlowDetailsParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of trigger parameter
        :param pulumi.Input[_builtins.str] value: (Updatable) Value of trigger parameter
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of trigger parameter
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Value of trigger parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduleLogDetailsArgsDict(TypedDict):
        log_group_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom log to be used for Schedule logging.
        """
elif False:
    ScheduleLogDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleLogDetailsArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[_builtins.str],
                 log_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom log to be used for Schedule logging.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_id", log_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom log to be used for Schedule logging.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_id", value)


if not MYPY:
    class ScheduleTriggerArgsDict(TypedDict):
        trigger_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The schedule trigger type


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        cron_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Schedule cron expression
        """
        frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of frequency
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The interval of frequency.
        """
        is_random_start_time: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) when true and timeStart is null, system generate a random start time between now and now + interval;  isRandomStartTime can be true if timeStart is null.
        """
        recurrence: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) This recurrence field conforms to RFC-5545 formatting
        """
        time_end: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The schedule end date time, if null, the schedule will never expire. Format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        time_start: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The schedule starting date time, if null, System set the time when schedule is created. Format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
elif False:
    ScheduleTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleTriggerArgs:
    def __init__(__self__, *,
                 trigger_type: pulumi.Input[_builtins.str],
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 is_random_start_time: Optional[pulumi.Input[_builtins.bool]] = None,
                 recurrence: Optional[pulumi.Input[_builtins.str]] = None,
                 time_end: Optional[pulumi.Input[_builtins.str]] = None,
                 time_start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] trigger_type: (Updatable) The schedule trigger type
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] cron_expression: (Updatable) Schedule cron expression
        :param pulumi.Input[_builtins.str] frequency: (Updatable) The type of frequency
        :param pulumi.Input[_builtins.int] interval: (Updatable) The interval of frequency.
        :param pulumi.Input[_builtins.bool] is_random_start_time: (Updatable) when true and timeStart is null, system generate a random start time between now and now + interval;  isRandomStartTime can be true if timeStart is null.
        :param pulumi.Input[_builtins.str] recurrence: (Updatable) This recurrence field conforms to RFC-5545 formatting
        :param pulumi.Input[_builtins.str] time_end: (Updatable) The schedule end date time, if null, the schedule will never expire. Format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param pulumi.Input[_builtins.str] time_start: (Updatable) The schedule starting date time, if null, System set the time when schedule is created. Format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if is_random_start_time is not None:
            pulumi.set(__self__, "is_random_start_time", is_random_start_time)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if time_end is not None:
            pulumi.set(__self__, "time_end", time_end)
        if time_start is not None:
            pulumi.set(__self__, "time_start", time_start)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The schedule trigger type


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_type", value)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Schedule cron expression
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of frequency
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The interval of frequency.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="isRandomStartTime")
    def is_random_start_time(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) when true and timeStart is null, system generate a random start time between now and now + interval;  isRandomStartTime can be true if timeStart is null.
        """
        return pulumi.get(self, "is_random_start_time")

    @is_random_start_time.setter
    def is_random_start_time(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_random_start_time", value)

    @_builtins.property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) This recurrence field conforms to RFC-5545 formatting
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence", value)

    @_builtins.property
    @pulumi.getter(name="timeEnd")
    def time_end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The schedule end date time, if null, the schedule will never expire. Format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_end")

    @time_end.setter
    def time_end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_end", value)

    @_builtins.property
    @pulumi.getter(name="timeStart")
    def time_start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The schedule starting date time, if null, System set the time when schedule is created. Format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_start")

    @time_start.setter
    def time_start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_start", value)


if not MYPY:
    class GetContainersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetContainersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetContainersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFastLaunchJobConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the fast launch job config
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFastLaunchJobConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFastLaunchJobConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the fast launch job config
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the fast launch job config
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetJobRunsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        node group name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetJobRunsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobRunsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: node group name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        node group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetJobShapesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the job shape.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetJobShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobShapesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the job shape.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the job shape.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetJobsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        node group name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetJobsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: node group name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        node group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMlApplicationImplementationsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMlApplicationImplementationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlApplicationImplementationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMlApplicationInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMlApplicationInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlApplicationInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMlApplicationsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMlApplicationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlApplicationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelDeploymentModelStatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelDeploymentModelStatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelDeploymentModelStatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelDeploymentShapesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the model deployment shape.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelDeploymentShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelDeploymentShapesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the model deployment shape.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the model deployment shape.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelDeploymentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelDeploymentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelGroupModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelGroupModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelGroupModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelGroupVersionHistoriesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelGroupVersionHistoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelGroupVersionHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelVersionSetsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelVersionSetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelVersionSetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNotebookSessionShapesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the notebook session shape.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNotebookSessionShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNotebookSessionShapesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the notebook session shape.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the notebook session shape.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNotebookSessionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNotebookSessionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNotebookSessionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPipelineRunsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPipelineRunsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelineRunsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPipelinesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPipelinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelinesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPrivateEndpointsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPrivateEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrivateEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProjectsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of trigger parameter
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of trigger parameter
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of trigger parameter
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


