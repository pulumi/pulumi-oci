# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'OccDemandSignalOccDemandSignalArgs',
    'OccDemandSignalOccDemandSignalArgsDict',
    'OccDemandSignalOccDemandSignalValueArgs',
    'OccDemandSignalOccDemandSignalValueArgsDict',
    'OccDemandSignalPatchOperationArgs',
    'OccDemandSignalPatchOperationArgsDict',
    'GetOccDemandSignalsFilterArgs',
    'GetOccDemandSignalsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class OccDemandSignalOccDemandSignalArgsDict(TypedDict):
        resource_type: pulumi.Input[_builtins.str]
        """
        The name of the resource for the data.
        """
        units: pulumi.Input[_builtins.str]
        """
        The units of the data.
        """
        values: pulumi.Input[Sequence[pulumi.Input['OccDemandSignalOccDemandSignalValueArgsDict']]]
        """
        The values of forecast.
        """
elif False:
    OccDemandSignalOccDemandSignalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OccDemandSignalOccDemandSignalArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[_builtins.str],
                 units: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input['OccDemandSignalOccDemandSignalValueArgs']]]):
        """
        :param pulumi.Input[_builtins.str] resource_type: The name of the resource for the data.
        :param pulumi.Input[_builtins.str] units: The units of the data.
        :param pulumi.Input[Sequence[pulumi.Input['OccDemandSignalOccDemandSignalValueArgs']]] values: The values of forecast.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "units", units)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the resource for the data.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def units(self) -> pulumi.Input[_builtins.str]:
        """
        The units of the data.
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "units", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['OccDemandSignalOccDemandSignalValueArgs']]]:
        """
        The values of forecast.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['OccDemandSignalOccDemandSignalValueArgs']]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class OccDemandSignalOccDemandSignalValueArgsDict(TypedDict):
        time_expected: pulumi.Input[_builtins.str]
        """
        The date of the Demand Signal Value.
        """
        value: pulumi.Input[_builtins.float]
        """
        The Demand Signal Value.
        """
        comments: NotRequired[pulumi.Input[_builtins.str]]
        """
        Space provided for users to make comments regarding the value.
        """
elif False:
    OccDemandSignalOccDemandSignalValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OccDemandSignalOccDemandSignalValueArgs:
    def __init__(__self__, *,
                 time_expected: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.float],
                 comments: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_expected: The date of the Demand Signal Value.
        :param pulumi.Input[_builtins.float] value: The Demand Signal Value.
        :param pulumi.Input[_builtins.str] comments: Space provided for users to make comments regarding the value.
        """
        pulumi.set(__self__, "time_expected", time_expected)
        pulumi.set(__self__, "value", value)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)

    @_builtins.property
    @pulumi.getter(name="timeExpected")
    def time_expected(self) -> pulumi.Input[_builtins.str]:
        """
        The date of the Demand Signal Value.
        """
        return pulumi.get(self, "time_expected")

    @time_expected.setter
    def time_expected(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_expected", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.float]:
        """
        The Demand Signal Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Space provided for users to make comments regarding the value.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comments", value)


if not MYPY:
    class OccDemandSignalPatchOperationArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        """
        (Updatable)
        """
        operation: pulumi.Input[_builtins.str]
        """
        (Updatable) The operation can be one of these values: `INSERT`, `INSERT_MULTIPLE`, `MERGE`, `MOVE`, `PROHIBIT`, `REMOVE`, `REPLACE`, `REQUIRE`
        """
        selection: pulumi.Input[_builtins.str]
        """
        (Updatable)
        """
        value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable)
        """
        position: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable)
        """
        selected_item: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable)
        """
elif False:
    OccDemandSignalPatchOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OccDemandSignalPatchOperationArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str],
                 selection: pulumi.Input[_builtins.str],
                 value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 position: Optional[pulumi.Input[_builtins.str]] = None,
                 selected_item: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] from_: (Updatable)
        :param pulumi.Input[_builtins.str] operation: (Updatable) The operation can be one of these values: `INSERT`, `INSERT_MULTIPLE`, `MERGE`, `MOVE`, `PROHIBIT`, `REMOVE`, `REPLACE`, `REQUIRE`
        :param pulumi.Input[_builtins.str] selection: (Updatable)
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] value: (Updatable)
        :param pulumi.Input[_builtins.str] position: (Updatable)
        :param pulumi.Input[_builtins.str] selected_item: (Updatable)
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "selection", selection)
        pulumi.set(__self__, "value", value)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if selected_item is not None:
            pulumi.set(__self__, "selected_item", selected_item)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable)
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The operation can be one of these values: `INSERT`, `INSERT_MULTIPLE`, `MERGE`, `MOVE`, `PROHIBIT`, `REMOVE`, `REPLACE`, `REQUIRE`
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def selection(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable)
        """
        return pulumi.get(self, "selection")

    @selection.setter
    def selection(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "selection", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "position", value)

    @_builtins.property
    @pulumi.getter(name="selectedItem")
    def selected_item(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "selected_item")

    @selected_item.setter
    def selected_item(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selected_item", value)


if not MYPY:
    class GetOccDemandSignalsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        """
        The values of forecast.
        """
        regex: NotRequired[_builtins.bool]
elif False:
    GetOccDemandSignalsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOccDemandSignalsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] values: The values of forecast.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values of forecast.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


