# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BuildPipelineBuildPipelineParametersArgs',
    'BuildPipelineBuildPipelineParametersArgsDict',
    'BuildPipelineBuildPipelineParametersItemArgs',
    'BuildPipelineBuildPipelineParametersItemArgsDict',
    'BuildPipelineStageBuildPipelineStagePredecessorCollectionArgs',
    'BuildPipelineStageBuildPipelineStagePredecessorCollectionArgsDict',
    'BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgs',
    'BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgsDict',
    'BuildPipelineStageBuildRunnerShapeConfigArgs',
    'BuildPipelineStageBuildRunnerShapeConfigArgsDict',
    'BuildPipelineStageBuildSourceCollectionArgs',
    'BuildPipelineStageBuildSourceCollectionArgsDict',
    'BuildPipelineStageBuildSourceCollectionItemArgs',
    'BuildPipelineStageBuildSourceCollectionItemArgsDict',
    'BuildPipelineStageDeliverArtifactCollectionArgs',
    'BuildPipelineStageDeliverArtifactCollectionArgsDict',
    'BuildPipelineStageDeliverArtifactCollectionItemArgs',
    'BuildPipelineStageDeliverArtifactCollectionItemArgsDict',
    'BuildPipelineStagePrivateAccessConfigArgs',
    'BuildPipelineStagePrivateAccessConfigArgsDict',
    'BuildPipelineStageWaitCriteriaArgs',
    'BuildPipelineStageWaitCriteriaArgsDict',
    'BuildRunBuildOutputArgs',
    'BuildRunBuildOutputArgsDict',
    'BuildRunBuildOutputArtifactOverrideParameterArgs',
    'BuildRunBuildOutputArtifactOverrideParameterArgsDict',
    'BuildRunBuildOutputArtifactOverrideParameterItemArgs',
    'BuildRunBuildOutputArtifactOverrideParameterItemArgsDict',
    'BuildRunBuildOutputDeliveredArtifactArgs',
    'BuildRunBuildOutputDeliveredArtifactArgsDict',
    'BuildRunBuildOutputDeliveredArtifactItemArgs',
    'BuildRunBuildOutputDeliveredArtifactItemArgsDict',
    'BuildRunBuildOutputExportedVariableArgs',
    'BuildRunBuildOutputExportedVariableArgsDict',
    'BuildRunBuildOutputExportedVariableItemArgs',
    'BuildRunBuildOutputExportedVariableItemArgsDict',
    'BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgs',
    'BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgsDict',
    'BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgs',
    'BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgsDict',
    'BuildRunBuildRunArgumentsArgs',
    'BuildRunBuildRunArgumentsArgsDict',
    'BuildRunBuildRunArgumentsItemArgs',
    'BuildRunBuildRunArgumentsItemArgsDict',
    'BuildRunBuildRunProgressArgs',
    'BuildRunBuildRunProgressArgsDict',
    'BuildRunBuildRunSourceArgs',
    'BuildRunBuildRunSourceArgsDict',
    'BuildRunBuildRunSourceTriggerInfoArgs',
    'BuildRunBuildRunSourceTriggerInfoArgsDict',
    'BuildRunBuildRunSourceTriggerInfoActionArgs',
    'BuildRunBuildRunSourceTriggerInfoActionArgsDict',
    'BuildRunBuildRunSourceTriggerInfoActionFilterArgs',
    'BuildRunBuildRunSourceTriggerInfoActionFilterArgsDict',
    'BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgs',
    'BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgsDict',
    'BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgs',
    'BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgsDict',
    'BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgs',
    'BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgsDict',
    'BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgs',
    'BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgsDict',
    'BuildRunCommitInfoArgs',
    'BuildRunCommitInfoArgsDict',
    'ConnectionLastConnectionValidationResultArgs',
    'ConnectionLastConnectionValidationResultArgsDict',
    'ConnectionTlsVerifyConfigArgs',
    'ConnectionTlsVerifyConfigArgsDict',
    'DeployArtifactDeployArtifactSourceArgs',
    'DeployArtifactDeployArtifactSourceArgsDict',
    'DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgs',
    'DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgsDict',
    'DeployEnvironmentComputeInstanceGroupSelectorsArgs',
    'DeployEnvironmentComputeInstanceGroupSelectorsArgsDict',
    'DeployEnvironmentComputeInstanceGroupSelectorsItemArgs',
    'DeployEnvironmentComputeInstanceGroupSelectorsItemArgsDict',
    'DeployEnvironmentNetworkChannelArgs',
    'DeployEnvironmentNetworkChannelArgsDict',
    'DeployPipelineDeployPipelineArtifactArgs',
    'DeployPipelineDeployPipelineArtifactArgsDict',
    'DeployPipelineDeployPipelineArtifactItemArgs',
    'DeployPipelineDeployPipelineArtifactItemArgsDict',
    'DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgs',
    'DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgsDict',
    'DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgs',
    'DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgsDict',
    'DeployPipelineDeployPipelineEnvironmentArgs',
    'DeployPipelineDeployPipelineEnvironmentArgsDict',
    'DeployPipelineDeployPipelineEnvironmentItemArgs',
    'DeployPipelineDeployPipelineEnvironmentItemArgsDict',
    'DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgs',
    'DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgsDict',
    'DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgs',
    'DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict',
    'DeployPipelineDeployPipelineParametersArgs',
    'DeployPipelineDeployPipelineParametersArgsDict',
    'DeployPipelineDeployPipelineParametersItemArgs',
    'DeployPipelineDeployPipelineParametersItemArgsDict',
    'DeployStageApprovalPolicyArgs',
    'DeployStageApprovalPolicyArgsDict',
    'DeployStageBlueBackendIpsArgs',
    'DeployStageBlueBackendIpsArgsDict',
    'DeployStageBlueGreenStrategyArgs',
    'DeployStageBlueGreenStrategyArgsDict',
    'DeployStageCanaryStrategyArgs',
    'DeployStageCanaryStrategyArgsDict',
    'DeployStageContainerConfigArgs',
    'DeployStageContainerConfigArgsDict',
    'DeployStageContainerConfigNetworkChannelArgs',
    'DeployStageContainerConfigNetworkChannelArgsDict',
    'DeployStageContainerConfigShapeConfigArgs',
    'DeployStageContainerConfigShapeConfigArgsDict',
    'DeployStageDeployStagePredecessorCollectionArgs',
    'DeployStageDeployStagePredecessorCollectionArgsDict',
    'DeployStageDeployStagePredecessorCollectionItemArgs',
    'DeployStageDeployStagePredecessorCollectionItemArgsDict',
    'DeployStageFailurePolicyArgs',
    'DeployStageFailurePolicyArgsDict',
    'DeployStageGreenBackendIpsArgs',
    'DeployStageGreenBackendIpsArgsDict',
    'DeployStageLoadBalancerConfigArgs',
    'DeployStageLoadBalancerConfigArgsDict',
    'DeployStageProductionLoadBalancerConfigArgs',
    'DeployStageProductionLoadBalancerConfigArgsDict',
    'DeployStageRollbackPolicyArgs',
    'DeployStageRollbackPolicyArgsDict',
    'DeployStageRolloutPolicyArgs',
    'DeployStageRolloutPolicyArgsDict',
    'DeployStageSetStringArgs',
    'DeployStageSetStringArgsDict',
    'DeployStageSetStringItemArgs',
    'DeployStageSetStringItemArgsDict',
    'DeployStageSetValuesArgs',
    'DeployStageSetValuesArgsDict',
    'DeployStageSetValuesItemArgs',
    'DeployStageSetValuesItemArgsDict',
    'DeployStageTestLoadBalancerConfigArgs',
    'DeployStageTestLoadBalancerConfigArgsDict',
    'DeployStageWaitCriteriaArgs',
    'DeployStageWaitCriteriaArgsDict',
    'DeploymentDeployArtifactOverrideArgumentsArgs',
    'DeploymentDeployArtifactOverrideArgumentsArgsDict',
    'DeploymentDeployArtifactOverrideArgumentsItemArgs',
    'DeploymentDeployArtifactOverrideArgumentsItemArgsDict',
    'DeploymentDeployPipelineArtifactArgs',
    'DeploymentDeployPipelineArtifactArgsDict',
    'DeploymentDeployPipelineArtifactItemArgs',
    'DeploymentDeployPipelineArtifactItemArgsDict',
    'DeploymentDeployPipelineArtifactItemDeployPipelineStageArgs',
    'DeploymentDeployPipelineArtifactItemDeployPipelineStageArgsDict',
    'DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgs',
    'DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgsDict',
    'DeploymentDeployPipelineEnvironmentArgs',
    'DeploymentDeployPipelineEnvironmentArgsDict',
    'DeploymentDeployPipelineEnvironmentItemArgs',
    'DeploymentDeployPipelineEnvironmentItemArgsDict',
    'DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgs',
    'DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgsDict',
    'DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgs',
    'DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict',
    'DeploymentDeployStageOverrideArgumentsArgs',
    'DeploymentDeployStageOverrideArgumentsArgsDict',
    'DeploymentDeployStageOverrideArgumentsItemArgs',
    'DeploymentDeployStageOverrideArgumentsItemArgsDict',
    'DeploymentDeploymentArgumentsArgs',
    'DeploymentDeploymentArgumentsArgsDict',
    'DeploymentDeploymentArgumentsItemArgs',
    'DeploymentDeploymentArgumentsItemArgsDict',
    'DeploymentDeploymentExecutionProgressArgs',
    'DeploymentDeploymentExecutionProgressArgsDict',
    'ProjectNotificationConfigArgs',
    'ProjectNotificationConfigArgsDict',
    'ProjectRepositorySettingApprovalRulesArgs',
    'ProjectRepositorySettingApprovalRulesArgsDict',
    'ProjectRepositorySettingApprovalRulesItemArgs',
    'ProjectRepositorySettingApprovalRulesItemArgsDict',
    'ProjectRepositorySettingApprovalRulesItemReviewerArgs',
    'ProjectRepositorySettingApprovalRulesItemReviewerArgsDict',
    'ProjectRepositorySettingMergeSettingsArgs',
    'ProjectRepositorySettingMergeSettingsArgsDict',
    'RepositoryMirrorRepositoryConfigArgs',
    'RepositoryMirrorRepositoryConfigArgsDict',
    'RepositoryMirrorRepositoryConfigTriggerScheduleArgs',
    'RepositoryMirrorRepositoryConfigTriggerScheduleArgsDict',
    'RepositorySettingApprovalRulesArgs',
    'RepositorySettingApprovalRulesArgsDict',
    'RepositorySettingApprovalRulesItemArgs',
    'RepositorySettingApprovalRulesItemArgsDict',
    'RepositorySettingApprovalRulesItemReviewerArgs',
    'RepositorySettingApprovalRulesItemReviewerArgsDict',
    'RepositorySettingMergeChecksArgs',
    'RepositorySettingMergeChecksArgsDict',
    'RepositorySettingMergeSettingsArgs',
    'RepositorySettingMergeSettingsArgsDict',
    'TriggerActionArgs',
    'TriggerActionArgsDict',
    'TriggerActionFilterArgs',
    'TriggerActionFilterArgsDict',
    'TriggerActionFilterExcludeArgs',
    'TriggerActionFilterExcludeArgsDict',
    'TriggerActionFilterExcludeFileFilterArgs',
    'TriggerActionFilterExcludeFileFilterArgsDict',
    'TriggerActionFilterIncludeArgs',
    'TriggerActionFilterIncludeArgsDict',
    'TriggerActionFilterIncludeFileFilterArgs',
    'TriggerActionFilterIncludeFileFilterArgsDict',
    'GetBuildPipelineStagesFilterArgs',
    'GetBuildPipelineStagesFilterArgsDict',
    'GetBuildPipelinesFilterArgs',
    'GetBuildPipelinesFilterArgsDict',
    'GetBuildRunsFilterArgs',
    'GetBuildRunsFilterArgsDict',
    'GetConnectionsFilterArgs',
    'GetConnectionsFilterArgsDict',
    'GetDeployArtifactsFilterArgs',
    'GetDeployArtifactsFilterArgsDict',
    'GetDeployEnvironmentsFilterArgs',
    'GetDeployEnvironmentsFilterArgsDict',
    'GetDeployPipelinesFilterArgs',
    'GetDeployPipelinesFilterArgsDict',
    'GetDeployStagesFilterArgs',
    'GetDeployStagesFilterArgsDict',
    'GetDeploymentsFilterArgs',
    'GetDeploymentsFilterArgsDict',
    'GetProjectsFilterArgs',
    'GetProjectsFilterArgsDict',
    'GetRepositoriesFilterArgs',
    'GetRepositoriesFilterArgsDict',
    'GetRepositoryAuthorsFilterArgs',
    'GetRepositoryAuthorsFilterArgsDict',
    'GetRepositoryCommitsFilterArgs',
    'GetRepositoryCommitsFilterArgsDict',
    'GetRepositoryDiffsFilterArgs',
    'GetRepositoryDiffsFilterArgsDict',
    'GetRepositoryMirrorRecordsFilterArgs',
    'GetRepositoryMirrorRecordsFilterArgsDict',
    'GetRepositoryPathsFilterArgs',
    'GetRepositoryPathsFilterArgsDict',
    'GetRepositoryProtectedBranchesFilterArgs',
    'GetRepositoryProtectedBranchesFilterArgsDict',
    'GetRepositoryRefsFilterArgs',
    'GetRepositoryRefsFilterArgsDict',
    'GetTriggersFilterArgs',
    'GetTriggersFilterArgsDict',
]

MYPY = False

if not MYPY:
    class BuildPipelineBuildPipelineParametersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['BuildPipelineBuildPipelineParametersItemArgsDict']]]
        """
        (Updatable) List of parameters defined for a build pipeline.
        """
elif False:
    BuildPipelineBuildPipelineParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineBuildPipelineParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['BuildPipelineBuildPipelineParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildPipelineBuildPipelineParametersItemArgs']]] items: (Updatable) List of parameters defined for a build pipeline.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['BuildPipelineBuildPipelineParametersItemArgs']]]:
        """
        (Updatable) List of parameters defined for a build pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['BuildPipelineBuildPipelineParametersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildPipelineBuildPipelineParametersItemArgsDict(TypedDict):
        default_value: pulumi.Input[str]
        """
        (Updatable) Default value of the parameter.
        """
        name: pulumi.Input[str]
        """
        (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Description of the parameter.
        """
elif False:
    BuildPipelineBuildPipelineParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineBuildPipelineParametersItemArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[str],
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_value: (Updatable) Default value of the parameter.
        :param pulumi.Input[str] name: (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        :param pulumi.Input[str] description: (Updatable) Description of the parameter.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[str]:
        """
        (Updatable) Default value of the parameter.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class BuildPipelineStageBuildPipelineStagePredecessorCollectionArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgsDict']]]
        """
        (Updatable) A list of build pipeline stage predecessors for a stage.
        """
elif False:
    BuildPipelineStageBuildPipelineStagePredecessorCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageBuildPipelineStagePredecessorCollectionArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgs']]] items: (Updatable) A list of build pipeline stage predecessors for a stage.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgs']]]:
        """
        (Updatable) A list of build pipeline stage predecessors for a stage.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
elif False:
    BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageBuildPipelineStagePredecessorCollectionItemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BuildPipelineStageBuildRunnerShapeConfigArgsDict(TypedDict):
        build_runner_type: pulumi.Input[str]
        """
        (Updatable) Name of the build runner shape in which the execution occurs. If not specified, the default shape is chosen.
        """
        memory_in_gbs: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The total amount of memory set for the instance in gigabytes.
        """
        ocpus: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The total number of OCPUs set for the instance.
        """
elif False:
    BuildPipelineStageBuildRunnerShapeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageBuildRunnerShapeConfigArgs:
    def __init__(__self__, *,
                 build_runner_type: pulumi.Input[str],
                 memory_in_gbs: Optional[pulumi.Input[int]] = None,
                 ocpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] build_runner_type: (Updatable) Name of the build runner shape in which the execution occurs. If not specified, the default shape is chosen.
        :param pulumi.Input[int] memory_in_gbs: (Updatable) The total amount of memory set for the instance in gigabytes.
        :param pulumi.Input[int] ocpus: (Updatable) The total number of OCPUs set for the instance.
        """
        pulumi.set(__self__, "build_runner_type", build_runner_type)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @property
    @pulumi.getter(name="buildRunnerType")
    def build_runner_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the build runner shape in which the execution occurs. If not specified, the default shape is chosen.
        """
        return pulumi.get(self, "build_runner_type")

    @build_runner_type.setter
    def build_runner_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "build_runner_type", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The total amount of memory set for the instance in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The total number of OCPUs set for the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class BuildPipelineStageBuildSourceCollectionArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildSourceCollectionItemArgsDict']]]]
        """
        (Updatable) Collection of build sources. In case of UPDATE operation, replaces existing build sources list. Merging with existing build sources is not supported.
        """
elif False:
    BuildPipelineStageBuildSourceCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageBuildSourceCollectionArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildSourceCollectionItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildSourceCollectionItemArgs']]] items: (Updatable) Collection of build sources. In case of UPDATE operation, replaces existing build sources list. Merging with existing build sources is not supported.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildSourceCollectionItemArgs']]]]:
        """
        (Updatable) Collection of build sources. In case of UPDATE operation, replaces existing build sources list. Merging with existing build sources is not supported.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageBuildSourceCollectionItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildPipelineStageBuildSourceCollectionItemArgsDict(TypedDict):
        connection_type: pulumi.Input[str]
        """
        (Updatable) The type of source provider.
        """
        branch: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Branch name.
        """
        connection_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Connection identifier pertinent to Bitbucket Server source provider
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the build source. This must be unique within a build source collection. The name can be used by customers to locate the working directory pertinent to this repository.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The DevOps code repository ID.
        """
        repository_url: NotRequired[pulumi.Input[str]]
        """
        (Updatable) URL for the repository.
        """
elif False:
    BuildPipelineStageBuildSourceCollectionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageBuildSourceCollectionItemArgs:
    def __init__(__self__, *,
                 connection_type: pulumi.Input[str],
                 branch: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_type: (Updatable) The type of source provider.
        :param pulumi.Input[str] branch: (Updatable) Branch name.
        :param pulumi.Input[str] connection_id: (Updatable) Connection identifier pertinent to Bitbucket Server source provider
        :param pulumi.Input[str] name: (Updatable) Name of the build source. This must be unique within a build source collection. The name can be used by customers to locate the working directory pertinent to this repository.
        :param pulumi.Input[str] repository_id: (Updatable) The DevOps code repository ID.
        :param pulumi.Input[str] repository_url: (Updatable) URL for the repository.
        """
        pulumi.set(__self__, "connection_type", connection_type)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_url is not None:
            pulumi.set(__self__, "repository_url", repository_url)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of source provider.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Branch name.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Connection identifier pertinent to Bitbucket Server source provider
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the build source. This must be unique within a build source collection. The name can be used by customers to locate the working directory pertinent to this repository.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The DevOps code repository ID.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) URL for the repository.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_url", value)


if not MYPY:
    class BuildPipelineStageDeliverArtifactCollectionArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageDeliverArtifactCollectionItemArgsDict']]]]
        """
        (Updatable) Collection of artifacts that were generated in the Build stage and need to be pushed to the artifactory stores. In case of UPDATE operation, replaces existing artifacts list. Merging with existing artifacts is not supported.
        """
elif False:
    BuildPipelineStageDeliverArtifactCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageDeliverArtifactCollectionArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageDeliverArtifactCollectionItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageDeliverArtifactCollectionItemArgs']]] items: (Updatable) Collection of artifacts that were generated in the Build stage and need to be pushed to the artifactory stores. In case of UPDATE operation, replaces existing artifacts list. Merging with existing artifacts is not supported.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageDeliverArtifactCollectionItemArgs']]]]:
        """
        (Updatable) Collection of artifacts that were generated in the Build stage and need to be pushed to the artifactory stores. In case of UPDATE operation, replaces existing artifacts list. Merging with existing artifacts is not supported.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildPipelineStageDeliverArtifactCollectionItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildPipelineStageDeliverArtifactCollectionItemArgsDict(TypedDict):
        artifact_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Artifact identifier that contains the artifact definition.
        """
        artifact_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the artifact specified in the build_spec.yaml file.
        """
elif False:
    BuildPipelineStageDeliverArtifactCollectionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageDeliverArtifactCollectionItemArgs:
    def __init__(__self__, *,
                 artifact_id: Optional[pulumi.Input[str]] = None,
                 artifact_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] artifact_id: (Updatable) Artifact identifier that contains the artifact definition.
        :param pulumi.Input[str] artifact_name: (Updatable) Name of the artifact specified in the build_spec.yaml file.
        """
        if artifact_id is not None:
            pulumi.set(__self__, "artifact_id", artifact_id)
        if artifact_name is not None:
            pulumi.set(__self__, "artifact_name", artifact_name)

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Artifact identifier that contains the artifact definition.
        """
        return pulumi.get(self, "artifact_id")

    @artifact_id.setter
    def artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_id", value)

    @property
    @pulumi.getter(name="artifactName")
    def artifact_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the artifact specified in the build_spec.yaml file.
        """
        return pulumi.get(self, "artifact_name")

    @artifact_name.setter
    def artifact_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_name", value)


if not MYPY:
    class BuildPipelineStagePrivateAccessConfigArgsDict(TypedDict):
        network_channel_type: pulumi.Input[str]
        """
        (Updatable) Network channel type.
        """
        subnet_id: pulumi.Input[str]
        """
        (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        """
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) An array of network security group OCIDs.
        """
elif False:
    BuildPipelineStagePrivateAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStagePrivateAccessConfigArgs:
    def __init__(__self__, *,
                 network_channel_type: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] network_channel_type: (Updatable) Network channel type.
        :param pulumi.Input[str] subnet_id: (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) An array of network security group OCIDs.
        """
        pulumi.set(__self__, "network_channel_type", network_channel_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="networkChannelType")
    def network_channel_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Network channel type.
        """
        return pulumi.get(self, "network_channel_type")

    @network_channel_type.setter
    def network_channel_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_channel_type", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of network security group OCIDs.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)


if not MYPY:
    class BuildPipelineStageWaitCriteriaArgsDict(TypedDict):
        wait_duration: pulumi.Input[str]
        """
        (Updatable) The absolute wait duration. Minimum wait duration must be 5 seconds. Maximum wait duration can be up to 2 days.
        """
        wait_type: pulumi.Input[str]
        """
        (Updatable) Wait criteria type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    BuildPipelineStageWaitCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildPipelineStageWaitCriteriaArgs:
    def __init__(__self__, *,
                 wait_duration: pulumi.Input[str],
                 wait_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] wait_duration: (Updatable) The absolute wait duration. Minimum wait duration must be 5 seconds. Maximum wait duration can be up to 2 days.
        :param pulumi.Input[str] wait_type: (Updatable) Wait criteria type.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "wait_duration", wait_duration)
        pulumi.set(__self__, "wait_type", wait_type)

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> pulumi.Input[str]:
        """
        (Updatable) The absolute wait duration. Minimum wait duration must be 5 seconds. Maximum wait duration can be up to 2 days.
        """
        return pulumi.get(self, "wait_duration")

    @wait_duration.setter
    def wait_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "wait_duration", value)

    @property
    @pulumi.getter(name="waitType")
    def wait_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Wait criteria type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "wait_type")

    @wait_type.setter
    def wait_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "wait_type", value)


if not MYPY:
    class BuildRunBuildOutputArgsDict(TypedDict):
        artifact_override_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterArgsDict']]]]
        """
        Specifies the list of artifact override arguments at the time of deployment.
        """
        delivered_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactArgsDict']]]]
        """
        Specifies the list of artifacts delivered through the Deliver Artifacts stage.
        """
        exported_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableArgsDict']]]]
        """
        Specifies list of exported variables.
        """
        vulnerability_audit_summary_collections: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgsDict']]]]
        """
        List of vulnerability audit summary.
        """
elif False:
    BuildRunBuildOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputArgs:
    def __init__(__self__, *,
                 artifact_override_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterArgs']]]] = None,
                 delivered_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactArgs']]]] = None,
                 exported_variables: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableArgs']]]] = None,
                 vulnerability_audit_summary_collections: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterArgs']]] artifact_override_parameters: Specifies the list of artifact override arguments at the time of deployment.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactArgs']]] delivered_artifacts: Specifies the list of artifacts delivered through the Deliver Artifacts stage.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableArgs']]] exported_variables: Specifies list of exported variables.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgs']]] vulnerability_audit_summary_collections: List of vulnerability audit summary.
        """
        if artifact_override_parameters is not None:
            pulumi.set(__self__, "artifact_override_parameters", artifact_override_parameters)
        if delivered_artifacts is not None:
            pulumi.set(__self__, "delivered_artifacts", delivered_artifacts)
        if exported_variables is not None:
            pulumi.set(__self__, "exported_variables", exported_variables)
        if vulnerability_audit_summary_collections is not None:
            pulumi.set(__self__, "vulnerability_audit_summary_collections", vulnerability_audit_summary_collections)

    @property
    @pulumi.getter(name="artifactOverrideParameters")
    def artifact_override_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterArgs']]]]:
        """
        Specifies the list of artifact override arguments at the time of deployment.
        """
        return pulumi.get(self, "artifact_override_parameters")

    @artifact_override_parameters.setter
    def artifact_override_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterArgs']]]]):
        pulumi.set(self, "artifact_override_parameters", value)

    @property
    @pulumi.getter(name="deliveredArtifacts")
    def delivered_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactArgs']]]]:
        """
        Specifies the list of artifacts delivered through the Deliver Artifacts stage.
        """
        return pulumi.get(self, "delivered_artifacts")

    @delivered_artifacts.setter
    def delivered_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactArgs']]]]):
        pulumi.set(self, "delivered_artifacts", value)

    @property
    @pulumi.getter(name="exportedVariables")
    def exported_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableArgs']]]]:
        """
        Specifies list of exported variables.
        """
        return pulumi.get(self, "exported_variables")

    @exported_variables.setter
    def exported_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableArgs']]]]):
        pulumi.set(self, "exported_variables", value)

    @property
    @pulumi.getter(name="vulnerabilityAuditSummaryCollections")
    def vulnerability_audit_summary_collections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgs']]]]:
        """
        List of vulnerability audit summary.
        """
        return pulumi.get(self, "vulnerability_audit_summary_collections")

    @vulnerability_audit_summary_collections.setter
    def vulnerability_audit_summary_collections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgs']]]]):
        pulumi.set(self, "vulnerability_audit_summary_collections", value)


if not MYPY:
    class BuildRunBuildOutputArtifactOverrideParameterArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterItemArgsDict']]]]
        """
        List of exported variables.
        """
elif False:
    BuildRunBuildOutputArtifactOverrideParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputArtifactOverrideParameterArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterItemArgs']]] items: List of exported variables.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterItemArgs']]]]:
        """
        List of exported variables.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputArtifactOverrideParameterItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildRunBuildOutputArtifactOverrideParameterItemArgsDict(TypedDict):
        deploy_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the deployment artifact definition.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the step.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the argument.
        """
elif False:
    BuildRunBuildOutputArtifactOverrideParameterItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputArtifactOverrideParameterItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of the deployment artifact definition.
        :param pulumi.Input[str] name: Name of the step.
        :param pulumi.Input[str] value: Value of the argument.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the deployment artifact definition.
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the argument.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BuildRunBuildOutputDeliveredArtifactArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactItemArgsDict']]]]
        """
        List of exported variables.
        """
elif False:
    BuildRunBuildOutputDeliveredArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputDeliveredArtifactArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactItemArgs']]] items: List of exported variables.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactItemArgs']]]]:
        """
        List of exported variables.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputDeliveredArtifactItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildRunBuildOutputDeliveredArtifactItemArgsDict(TypedDict):
        artifact_repository_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the artifact registry repository used by the DeliverArtifactStage
        """
        artifact_type: NotRequired[pulumi.Input[str]]
        """
        Type of artifact delivered.
        """
        delivered_artifact_hash: NotRequired[pulumi.Input[str]]
        """
        The hash of the container registry artifact pushed by the Deliver Artifacts stage.
        """
        delivered_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the artifact pushed by the Deliver Artifacts stage.
        """
        deploy_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the deployment artifact definition.
        """
        image_uri: NotRequired[pulumi.Input[str]]
        """
        The imageUri of the OCIR artifact pushed by the DeliverArtifactStage
        """
        output_artifact_name: NotRequired[pulumi.Input[str]]
        """
        Name of the output artifact defined in the build specification file.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path of the repository where artifact was pushed
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the artifact pushed
        """
elif False:
    BuildRunBuildOutputDeliveredArtifactItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputDeliveredArtifactItemArgs:
    def __init__(__self__, *,
                 artifact_repository_id: Optional[pulumi.Input[str]] = None,
                 artifact_type: Optional[pulumi.Input[str]] = None,
                 delivered_artifact_hash: Optional[pulumi.Input[str]] = None,
                 delivered_artifact_id: Optional[pulumi.Input[str]] = None,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 image_uri: Optional[pulumi.Input[str]] = None,
                 output_artifact_name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] artifact_repository_id: The OCID of the artifact registry repository used by the DeliverArtifactStage
        :param pulumi.Input[str] artifact_type: Type of artifact delivered.
        :param pulumi.Input[str] delivered_artifact_hash: The hash of the container registry artifact pushed by the Deliver Artifacts stage.
        :param pulumi.Input[str] delivered_artifact_id: The OCID of the artifact pushed by the Deliver Artifacts stage.
        :param pulumi.Input[str] deploy_artifact_id: The OCID of the deployment artifact definition.
        :param pulumi.Input[str] image_uri: The imageUri of the OCIR artifact pushed by the DeliverArtifactStage
        :param pulumi.Input[str] output_artifact_name: Name of the output artifact defined in the build specification file.
        :param pulumi.Input[str] path: Path of the repository where artifact was pushed
        :param pulumi.Input[str] version: Version of the artifact pushed
        """
        if artifact_repository_id is not None:
            pulumi.set(__self__, "artifact_repository_id", artifact_repository_id)
        if artifact_type is not None:
            pulumi.set(__self__, "artifact_type", artifact_type)
        if delivered_artifact_hash is not None:
            pulumi.set(__self__, "delivered_artifact_hash", delivered_artifact_hash)
        if delivered_artifact_id is not None:
            pulumi.set(__self__, "delivered_artifact_id", delivered_artifact_id)
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if output_artifact_name is not None:
            pulumi.set(__self__, "output_artifact_name", output_artifact_name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="artifactRepositoryId")
    def artifact_repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the artifact registry repository used by the DeliverArtifactStage
        """
        return pulumi.get(self, "artifact_repository_id")

    @artifact_repository_id.setter
    def artifact_repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_repository_id", value)

    @property
    @pulumi.getter(name="artifactType")
    def artifact_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of artifact delivered.
        """
        return pulumi.get(self, "artifact_type")

    @artifact_type.setter
    def artifact_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_type", value)

    @property
    @pulumi.getter(name="deliveredArtifactHash")
    def delivered_artifact_hash(self) -> Optional[pulumi.Input[str]]:
        """
        The hash of the container registry artifact pushed by the Deliver Artifacts stage.
        """
        return pulumi.get(self, "delivered_artifact_hash")

    @delivered_artifact_hash.setter
    def delivered_artifact_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delivered_artifact_hash", value)

    @property
    @pulumi.getter(name="deliveredArtifactId")
    def delivered_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the artifact pushed by the Deliver Artifacts stage.
        """
        return pulumi.get(self, "delivered_artifact_id")

    @delivered_artifact_id.setter
    def delivered_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delivered_artifact_id", value)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the deployment artifact definition.
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The imageUri of the OCIR artifact pushed by the DeliverArtifactStage
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="outputArtifactName")
    def output_artifact_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the output artifact defined in the build specification file.
        """
        return pulumi.get(self, "output_artifact_name")

    @output_artifact_name.setter
    def output_artifact_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_artifact_name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the repository where artifact was pushed
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the artifact pushed
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class BuildRunBuildOutputExportedVariableArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableItemArgsDict']]]]
        """
        List of exported variables.
        """
elif False:
    BuildRunBuildOutputExportedVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputExportedVariableArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableItemArgs']]] items: List of exported variables.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableItemArgs']]]]:
        """
        List of exported variables.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputExportedVariableItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildRunBuildOutputExportedVariableItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the step.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the argument.
        """
elif False:
    BuildRunBuildOutputExportedVariableItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputExportedVariableItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the step.
        :param pulumi.Input[str] value: Value of the argument.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the argument.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgsDict']]]]
        """
        List of exported variables.
        """
elif False:
    BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputVulnerabilityAuditSummaryCollectionArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgs']]] items: List of exported variables.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgs']]]]:
        """
        List of exported variables.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgsDict(TypedDict):
        build_stage_id: NotRequired[pulumi.Input[str]]
        """
        Build stage OCID where scan was configured.
        """
        commit_hash: NotRequired[pulumi.Input[str]]
        """
        Commit hash pertinent to the repository URL and the specified branch.
        """
        vulnerability_audit_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the vulnerability audit.
        """
elif False:
    BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildOutputVulnerabilityAuditSummaryCollectionItemArgs:
    def __init__(__self__, *,
                 build_stage_id: Optional[pulumi.Input[str]] = None,
                 commit_hash: Optional[pulumi.Input[str]] = None,
                 vulnerability_audit_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] build_stage_id: Build stage OCID where scan was configured.
        :param pulumi.Input[str] commit_hash: Commit hash pertinent to the repository URL and the specified branch.
        :param pulumi.Input[str] vulnerability_audit_id: The OCID of the vulnerability audit.
        """
        if build_stage_id is not None:
            pulumi.set(__self__, "build_stage_id", build_stage_id)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if vulnerability_audit_id is not None:
            pulumi.set(__self__, "vulnerability_audit_id", vulnerability_audit_id)

    @property
    @pulumi.getter(name="buildStageId")
    def build_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        Build stage OCID where scan was configured.
        """
        return pulumi.get(self, "build_stage_id")

    @build_stage_id.setter
    def build_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_stage_id", value)

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[pulumi.Input[str]]:
        """
        Commit hash pertinent to the repository URL and the specified branch.
        """
        return pulumi.get(self, "commit_hash")

    @commit_hash.setter
    def commit_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_hash", value)

    @property
    @pulumi.getter(name="vulnerabilityAuditId")
    def vulnerability_audit_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the vulnerability audit.
        """
        return pulumi.get(self, "vulnerability_audit_id")

    @vulnerability_audit_id.setter
    def vulnerability_audit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vulnerability_audit_id", value)


if not MYPY:
    class BuildRunBuildRunArgumentsArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunArgumentsItemArgsDict']]]
        """
        List of arguments provided at the time of running the build.
        """
elif False:
    BuildRunBuildRunArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunArgumentsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunArgumentsItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunArgumentsItemArgs']]] items: List of arguments provided at the time of running the build.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunArgumentsItemArgs']]]:
        """
        List of arguments provided at the time of running the build.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunArgumentsItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class BuildRunBuildRunArgumentsItemArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        value: pulumi.Input[str]
        """
        Value of the argument.
        """
elif False:
    BuildRunBuildRunArgumentsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunArgumentsItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        :param pulumi.Input[str] value: Value of the argument.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the argument.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BuildRunBuildRunProgressArgsDict(TypedDict):
        build_pipeline_stage_run_progress: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Map of stage OCIDs to build pipeline stage run progress model.
        """
        time_finished: NotRequired[pulumi.Input[str]]
        """
        The time the build run finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        time_started: NotRequired[pulumi.Input[str]]
        """
        The time the build run started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
elif False:
    BuildRunBuildRunProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunProgressArgs:
    def __init__(__self__, *,
                 build_pipeline_stage_run_progress: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_finished: Optional[pulumi.Input[str]] = None,
                 time_started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] build_pipeline_stage_run_progress: Map of stage OCIDs to build pipeline stage run progress model.
        :param pulumi.Input[str] time_finished: The time the build run finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        :param pulumi.Input[str] time_started: The time the build run started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        if build_pipeline_stage_run_progress is not None:
            pulumi.set(__self__, "build_pipeline_stage_run_progress", build_pipeline_stage_run_progress)
        if time_finished is not None:
            pulumi.set(__self__, "time_finished", time_finished)
        if time_started is not None:
            pulumi.set(__self__, "time_started", time_started)

    @property
    @pulumi.getter(name="buildPipelineStageRunProgress")
    def build_pipeline_stage_run_progress(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of stage OCIDs to build pipeline stage run progress model.
        """
        return pulumi.get(self, "build_pipeline_stage_run_progress")

    @build_pipeline_stage_run_progress.setter
    def build_pipeline_stage_run_progress(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "build_pipeline_stage_run_progress", value)

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[pulumi.Input[str]]:
        """
        The time the build run finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_finished")

    @time_finished.setter
    def time_finished(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_finished", value)

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> Optional[pulumi.Input[str]]:
        """
        The time the build run started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_started")

    @time_started.setter
    def time_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_started", value)


if not MYPY:
    class BuildRunBuildRunSourceArgsDict(TypedDict):
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The DevOps code repository identifier that invoked the build run.
        """
        source_type: NotRequired[pulumi.Input[str]]
        """
        The source from which the build run is triggered.
        """
        trigger_id: NotRequired[pulumi.Input[str]]
        """
        The trigger that invoked the build run.
        """
        trigger_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoArgsDict']]]]
        """
        Trigger details that need to be used for the BuildRun
        """
elif False:
    BuildRunBuildRunSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceArgs:
    def __init__(__self__, *,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 trigger_id: Optional[pulumi.Input[str]] = None,
                 trigger_infos: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoArgs']]]] = None):
        """
        :param pulumi.Input[str] repository_id: The DevOps code repository identifier that invoked the build run.
        :param pulumi.Input[str] source_type: The source from which the build run is triggered.
        :param pulumi.Input[str] trigger_id: The trigger that invoked the build run.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoArgs']]] trigger_infos: Trigger details that need to be used for the BuildRun
        """
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if trigger_id is not None:
            pulumi.set(__self__, "trigger_id", trigger_id)
        if trigger_infos is not None:
            pulumi.set(__self__, "trigger_infos", trigger_infos)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The DevOps code repository identifier that invoked the build run.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        The source from which the build run is triggered.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="triggerId")
    def trigger_id(self) -> Optional[pulumi.Input[str]]:
        """
        The trigger that invoked the build run.
        """
        return pulumi.get(self, "trigger_id")

    @trigger_id.setter
    def trigger_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_id", value)

    @property
    @pulumi.getter(name="triggerInfos")
    def trigger_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoArgs']]]]:
        """
        Trigger details that need to be used for the BuildRun
        """
        return pulumi.get(self, "trigger_infos")

    @trigger_infos.setter
    def trigger_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoArgs']]]]):
        pulumi.set(self, "trigger_infos", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionArgsDict']]]]
        """
        The list of actions that are to be performed for this Trigger
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Build run display name, which can be renamed and is not necessarily unique. Avoid entering confidential information.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionArgs']]] actions: The list of actions that are to be performed for this Trigger
        :param pulumi.Input[str] display_name: (Updatable) Build run display name, which can be renamed and is not necessarily unique. Avoid entering confidential information.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionArgs']]]]:
        """
        The list of actions that are to be performed for this Trigger
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Build run display name, which can be renamed and is not necessarily unique. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoActionArgsDict(TypedDict):
        build_pipeline_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the build pipeline.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterArgsDict']]]]
        type: NotRequired[pulumi.Input[str]]
        """
        The type of action that will be taken. Allowed value is TRIGGER_BUILD_PIPELINE.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoActionArgs:
    def __init__(__self__, *,
                 build_pipeline_id: Optional[pulumi.Input[str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] build_pipeline_id: The OCID of the build pipeline.
        :param pulumi.Input[str] type: The type of action that will be taken. Allowed value is TRIGGER_BUILD_PIPELINE.
        """
        if build_pipeline_id is not None:
            pulumi.set(__self__, "build_pipeline_id", build_pipeline_id)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="buildPipelineId")
    def build_pipeline_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the build pipeline.
        """
        return pulumi.get(self, "build_pipeline_id")

    @build_pipeline_id.setter
    def build_pipeline_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_pipeline_id", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterArgs']]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action that will be taken. Allowed value is TRIGGER_BUILD_PIPELINE.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoActionFilterArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The events, for example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED.
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgsDict']]]]
        """
        Attributes to filter GitLab self-hosted server events. File filter criteria - Changes only affecting excluded files will not invoke a build. if both include and exclude filter are used then exclusion filter will be applied on the result set of inclusion filter.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgsDict']]]]
        """
        Attributes to filter GitLab self-hosted server events.
        """
        trigger_source: NotRequired[pulumi.Input[str]]
        """
        Source of the trigger. Allowed values are, GITHUB and GITLAB.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoActionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoActionFilterArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgs']]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgs']]]] = None,
                 trigger_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: The events, for example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgs']]] excludes: Attributes to filter GitLab self-hosted server events. File filter criteria - Changes only affecting excluded files will not invoke a build. if both include and exclude filter are used then exclusion filter will be applied on the result set of inclusion filter.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgs']]] includes: Attributes to filter GitLab self-hosted server events.
        :param pulumi.Input[str] trigger_source: Source of the trigger. Allowed values are, GITHUB and GITLAB.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)
        if trigger_source is not None:
            pulumi.set(__self__, "trigger_source", trigger_source)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The events, for example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgs']]]]:
        """
        Attributes to filter GitLab self-hosted server events. File filter criteria - Changes only affecting excluded files will not invoke a build. if both include and exclude filter are used then exclusion filter will be applied on the result set of inclusion filter.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgs']]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgs']]]]:
        """
        Attributes to filter GitLab self-hosted server events.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgs']]]]):
        pulumi.set(self, "includes", value)

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> Optional[pulumi.Input[str]]:
        """
        Source of the trigger. Allowed values are, GITHUB and GITLAB.
        """
        return pulumi.get(self, "trigger_source")

    @trigger_source.setter
    def trigger_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_source", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgsDict(TypedDict):
        file_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgsDict']]]]
        """
        Attributes to support include/exclude files for triggering build runs.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoActionFilterExcludeArgs:
    def __init__(__self__, *,
                 file_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgs']]] file_filters: Attributes to support include/exclude files for triggering build runs.
        """
        if file_filters is not None:
            pulumi.set(__self__, "file_filters", file_filters)

    @property
    @pulumi.getter(name="fileFilters")
    def file_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgs']]]]:
        """
        Attributes to support include/exclude files for triggering build runs.
        """
        return pulumi.get(self, "file_filters")

    @file_filters.setter
    def file_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgs']]]]):
        pulumi.set(self, "file_filters", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgsDict(TypedDict):
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The file paths/glob pattern for files.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoActionFilterExcludeFileFilterArgs:
    def __init__(__self__, *,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_paths: The file paths/glob pattern for files.
        """
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The file paths/glob pattern for files.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgsDict(TypedDict):
        base_ref: NotRequired[pulumi.Input[str]]
        """
        The target branch for pull requests; not applicable for push requests.
        """
        file_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgsDict']]]]
        """
        Attributes to support include/exclude files for triggering build runs.
        """
        head_ref: NotRequired[pulumi.Input[str]]
        """
        Branch for push event; source branch for pull requests.
        """
        repository_name: NotRequired[pulumi.Input[str]]
        """
        The repository name for trigger events.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoActionFilterIncludeArgs:
    def __init__(__self__, *,
                 base_ref: Optional[pulumi.Input[str]] = None,
                 file_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgs']]]] = None,
                 head_ref: Optional[pulumi.Input[str]] = None,
                 repository_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_ref: The target branch for pull requests; not applicable for push requests.
        :param pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgs']]] file_filters: Attributes to support include/exclude files for triggering build runs.
        :param pulumi.Input[str] head_ref: Branch for push event; source branch for pull requests.
        :param pulumi.Input[str] repository_name: The repository name for trigger events.
        """
        if base_ref is not None:
            pulumi.set(__self__, "base_ref", base_ref)
        if file_filters is not None:
            pulumi.set(__self__, "file_filters", file_filters)
        if head_ref is not None:
            pulumi.set(__self__, "head_ref", head_ref)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)

    @property
    @pulumi.getter(name="baseRef")
    def base_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The target branch for pull requests; not applicable for push requests.
        """
        return pulumi.get(self, "base_ref")

    @base_ref.setter
    def base_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_ref", value)

    @property
    @pulumi.getter(name="fileFilters")
    def file_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgs']]]]:
        """
        Attributes to support include/exclude files for triggering build runs.
        """
        return pulumi.get(self, "file_filters")

    @file_filters.setter
    def file_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgs']]]]):
        pulumi.set(self, "file_filters", value)

    @property
    @pulumi.getter(name="headRef")
    def head_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Branch for push event; source branch for pull requests.
        """
        return pulumi.get(self, "head_ref")

    @head_ref.setter
    def head_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "head_ref", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[str]]:
        """
        The repository name for trigger events.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_name", value)


if not MYPY:
    class BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgsDict(TypedDict):
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The file paths/glob pattern for files.
        """
elif False:
    BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunBuildRunSourceTriggerInfoActionFilterIncludeFileFilterArgs:
    def __init__(__self__, *,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_paths: The file paths/glob pattern for files.
        """
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The file paths/glob pattern for files.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class BuildRunCommitInfoArgsDict(TypedDict):
        commit_hash: pulumi.Input[str]
        """
        Commit hash pertinent to the repository URL and the specified branch.
        """
        repository_branch: pulumi.Input[str]
        """
        Name of the repository branch.
        """
        repository_url: pulumi.Input[str]
        """
        Repository URL.
        """
elif False:
    BuildRunCommitInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildRunCommitInfoArgs:
    def __init__(__self__, *,
                 commit_hash: pulumi.Input[str],
                 repository_branch: pulumi.Input[str],
                 repository_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] commit_hash: Commit hash pertinent to the repository URL and the specified branch.
        :param pulumi.Input[str] repository_branch: Name of the repository branch.
        :param pulumi.Input[str] repository_url: Repository URL.
        """
        pulumi.set(__self__, "commit_hash", commit_hash)
        pulumi.set(__self__, "repository_branch", repository_branch)
        pulumi.set(__self__, "repository_url", repository_url)

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> pulumi.Input[str]:
        """
        Commit hash pertinent to the repository URL and the specified branch.
        """
        return pulumi.get(self, "commit_hash")

    @commit_hash.setter
    def commit_hash(self, value: pulumi.Input[str]):
        pulumi.set(self, "commit_hash", value)

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> pulumi.Input[str]:
        """
        Name of the repository branch.
        """
        return pulumi.get(self, "repository_branch")

    @repository_branch.setter
    def repository_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_branch", value)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> pulumi.Input[str]:
        """
        Repository URL.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_url", value)


if not MYPY:
    class ConnectionLastConnectionValidationResultArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
        """
        A message describing the result of connection validation in more detail.
        """
        result: NotRequired[pulumi.Input[str]]
        """
        The latest result of whether the credentials pass the validation.
        """
        time_validated: NotRequired[pulumi.Input[str]]
        """
        The latest timestamp when the connection was validated. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
elif False:
    ConnectionLastConnectionValidationResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionLastConnectionValidationResultArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 result: Optional[pulumi.Input[str]] = None,
                 time_validated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: A message describing the result of connection validation in more detail.
        :param pulumi.Input[str] result: The latest result of whether the credentials pass the validation.
        :param pulumi.Input[str] time_validated: The latest timestamp when the connection was validated. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if time_validated is not None:
            pulumi.set(__self__, "time_validated", time_validated)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the result of connection validation in more detail.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[str]]:
        """
        The latest result of whether the credentials pass the validation.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "result", value)

    @property
    @pulumi.getter(name="timeValidated")
    def time_validated(self) -> Optional[pulumi.Input[str]]:
        """
        The latest timestamp when the connection was validated. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_validated")

    @time_validated.setter
    def time_validated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_validated", value)


if not MYPY:
    class ConnectionTlsVerifyConfigArgsDict(TypedDict):
        ca_certificate_bundle_id: pulumi.Input[str]
        """
        (Updatable) The OCID of Oracle Cloud Infrastructure certificate service CA bundle.
        """
        tls_verify_mode: pulumi.Input[str]
        """
        (Updatable) The type of TLS verification.
        """
elif False:
    ConnectionTlsVerifyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionTlsVerifyConfigArgs:
    def __init__(__self__, *,
                 ca_certificate_bundle_id: pulumi.Input[str],
                 tls_verify_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ca_certificate_bundle_id: (Updatable) The OCID of Oracle Cloud Infrastructure certificate service CA bundle.
        :param pulumi.Input[str] tls_verify_mode: (Updatable) The type of TLS verification.
        """
        pulumi.set(__self__, "ca_certificate_bundle_id", ca_certificate_bundle_id)
        pulumi.set(__self__, "tls_verify_mode", tls_verify_mode)

    @property
    @pulumi.getter(name="caCertificateBundleId")
    def ca_certificate_bundle_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of Oracle Cloud Infrastructure certificate service CA bundle.
        """
        return pulumi.get(self, "ca_certificate_bundle_id")

    @ca_certificate_bundle_id.setter
    def ca_certificate_bundle_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate_bundle_id", value)

    @property
    @pulumi.getter(name="tlsVerifyMode")
    def tls_verify_mode(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of TLS verification.
        """
        return pulumi.get(self, "tls_verify_mode")

    @tls_verify_mode.setter
    def tls_verify_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "tls_verify_mode", value)


if not MYPY:
    class DeployArtifactDeployArtifactSourceArgsDict(TypedDict):
        deploy_artifact_source_type: pulumi.Input[str]
        """
        (Updatable) Specifies types of artifact sources.
        """
        base64encoded_content: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The Helm commands to be executed, base 64 encoded
        """
        chart_url: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The URL of an OCIR repository.
        """
        deploy_artifact_path: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Specifies the artifact path in the repository.
        """
        deploy_artifact_version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Users can set this as a placeholder value that refers to a pipeline parameter, for example, ${appVersion}.
        """
        helm_artifact_source_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Specifies types of artifact sources.
        """
        helm_verification_key_source: NotRequired[pulumi.Input['DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgsDict']]
        """
        (Updatable) The source of the verification material.
        """
        image_digest: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Specifies image digest for the version of the image.
        """
        image_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Specifies OCIR Image Path - optionally include tag.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of a repository
        """
elif False:
    DeployArtifactDeployArtifactSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployArtifactDeployArtifactSourceArgs:
    def __init__(__self__, *,
                 deploy_artifact_source_type: pulumi.Input[str],
                 base64encoded_content: Optional[pulumi.Input[str]] = None,
                 chart_url: Optional[pulumi.Input[str]] = None,
                 deploy_artifact_path: Optional[pulumi.Input[str]] = None,
                 deploy_artifact_version: Optional[pulumi.Input[str]] = None,
                 helm_artifact_source_type: Optional[pulumi.Input[str]] = None,
                 helm_verification_key_source: Optional[pulumi.Input['DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgs']] = None,
                 image_digest: Optional[pulumi.Input[str]] = None,
                 image_uri: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_source_type: (Updatable) Specifies types of artifact sources.
        :param pulumi.Input[str] base64encoded_content: (Updatable) The Helm commands to be executed, base 64 encoded
        :param pulumi.Input[str] chart_url: (Updatable) The URL of an OCIR repository.
        :param pulumi.Input[str] deploy_artifact_path: (Updatable) Specifies the artifact path in the repository.
        :param pulumi.Input[str] deploy_artifact_version: (Updatable) Users can set this as a placeholder value that refers to a pipeline parameter, for example, ${appVersion}.
        :param pulumi.Input[str] helm_artifact_source_type: (Updatable) Specifies types of artifact sources.
        :param pulumi.Input['DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgs'] helm_verification_key_source: (Updatable) The source of the verification material.
        :param pulumi.Input[str] image_digest: (Updatable) Specifies image digest for the version of the image.
        :param pulumi.Input[str] image_uri: (Updatable) Specifies OCIR Image Path - optionally include tag.
        :param pulumi.Input[str] repository_id: (Updatable) The OCID of a repository
        """
        pulumi.set(__self__, "deploy_artifact_source_type", deploy_artifact_source_type)
        if base64encoded_content is not None:
            pulumi.set(__self__, "base64encoded_content", base64encoded_content)
        if chart_url is not None:
            pulumi.set(__self__, "chart_url", chart_url)
        if deploy_artifact_path is not None:
            pulumi.set(__self__, "deploy_artifact_path", deploy_artifact_path)
        if deploy_artifact_version is not None:
            pulumi.set(__self__, "deploy_artifact_version", deploy_artifact_version)
        if helm_artifact_source_type is not None:
            pulumi.set(__self__, "helm_artifact_source_type", helm_artifact_source_type)
        if helm_verification_key_source is not None:
            pulumi.set(__self__, "helm_verification_key_source", helm_verification_key_source)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @property
    @pulumi.getter(name="deployArtifactSourceType")
    def deploy_artifact_source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies types of artifact sources.
        """
        return pulumi.get(self, "deploy_artifact_source_type")

    @deploy_artifact_source_type.setter
    def deploy_artifact_source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "deploy_artifact_source_type", value)

    @property
    @pulumi.getter(name="base64encodedContent")
    def base64encoded_content(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The Helm commands to be executed, base 64 encoded
        """
        return pulumi.get(self, "base64encoded_content")

    @base64encoded_content.setter
    def base64encoded_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base64encoded_content", value)

    @property
    @pulumi.getter(name="chartUrl")
    def chart_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The URL of an OCIR repository.
        """
        return pulumi.get(self, "chart_url")

    @chart_url.setter
    def chart_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chart_url", value)

    @property
    @pulumi.getter(name="deployArtifactPath")
    def deploy_artifact_path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies the artifact path in the repository.
        """
        return pulumi.get(self, "deploy_artifact_path")

    @deploy_artifact_path.setter
    def deploy_artifact_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_path", value)

    @property
    @pulumi.getter(name="deployArtifactVersion")
    def deploy_artifact_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Users can set this as a placeholder value that refers to a pipeline parameter, for example, ${appVersion}.
        """
        return pulumi.get(self, "deploy_artifact_version")

    @deploy_artifact_version.setter
    def deploy_artifact_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_version", value)

    @property
    @pulumi.getter(name="helmArtifactSourceType")
    def helm_artifact_source_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies types of artifact sources.
        """
        return pulumi.get(self, "helm_artifact_source_type")

    @helm_artifact_source_type.setter
    def helm_artifact_source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "helm_artifact_source_type", value)

    @property
    @pulumi.getter(name="helmVerificationKeySource")
    def helm_verification_key_source(self) -> Optional[pulumi.Input['DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgs']]:
        """
        (Updatable) The source of the verification material.
        """
        return pulumi.get(self, "helm_verification_key_source")

    @helm_verification_key_source.setter
    def helm_verification_key_source(self, value: Optional[pulumi.Input['DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgs']]):
        pulumi.set(self, "helm_verification_key_source", value)

    @property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies image digest for the version of the image.
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_digest", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies OCIR Image Path - optionally include tag.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of a repository
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)


if not MYPY:
    class DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgsDict(TypedDict):
        verification_key_source_type: pulumi.Input[str]
        """
        (Updatable) Specifies type of verification material.
        """
        current_public_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Current version of Base64 encoding of the public key which is in binary GPG exported format.
        """
        previous_public_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Previous version of Base64 encoding of the public key which is in binary GPG exported format. This would be used for key rotation scenarios.
        """
        vault_secret_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the Vault Secret containing the verification key versions.
        """
elif False:
    DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployArtifactDeployArtifactSourceHelmVerificationKeySourceArgs:
    def __init__(__self__, *,
                 verification_key_source_type: pulumi.Input[str],
                 current_public_key: Optional[pulumi.Input[str]] = None,
                 previous_public_key: Optional[pulumi.Input[str]] = None,
                 vault_secret_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] verification_key_source_type: (Updatable) Specifies type of verification material.
        :param pulumi.Input[str] current_public_key: (Updatable) Current version of Base64 encoding of the public key which is in binary GPG exported format.
        :param pulumi.Input[str] previous_public_key: (Updatable) Previous version of Base64 encoding of the public key which is in binary GPG exported format. This would be used for key rotation scenarios.
        :param pulumi.Input[str] vault_secret_id: (Updatable) The OCID of the Vault Secret containing the verification key versions.
        """
        pulumi.set(__self__, "verification_key_source_type", verification_key_source_type)
        if current_public_key is not None:
            pulumi.set(__self__, "current_public_key", current_public_key)
        if previous_public_key is not None:
            pulumi.set(__self__, "previous_public_key", previous_public_key)
        if vault_secret_id is not None:
            pulumi.set(__self__, "vault_secret_id", vault_secret_id)

    @property
    @pulumi.getter(name="verificationKeySourceType")
    def verification_key_source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies type of verification material.
        """
        return pulumi.get(self, "verification_key_source_type")

    @verification_key_source_type.setter
    def verification_key_source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "verification_key_source_type", value)

    @property
    @pulumi.getter(name="currentPublicKey")
    def current_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Current version of Base64 encoding of the public key which is in binary GPG exported format.
        """
        return pulumi.get(self, "current_public_key")

    @current_public_key.setter
    def current_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_public_key", value)

    @property
    @pulumi.getter(name="previousPublicKey")
    def previous_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Previous version of Base64 encoding of the public key which is in binary GPG exported format. This would be used for key rotation scenarios.
        """
        return pulumi.get(self, "previous_public_key")

    @previous_public_key.setter
    def previous_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "previous_public_key", value)

    @property
    @pulumi.getter(name="vaultSecretId")
    def vault_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the Vault Secret containing the verification key versions.
        """
        return pulumi.get(self, "vault_secret_id")

    @vault_secret_id.setter
    def vault_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_secret_id", value)


if not MYPY:
    class DeployEnvironmentComputeInstanceGroupSelectorsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployEnvironmentComputeInstanceGroupSelectorsItemArgsDict']]]]
        """
        (Updatable) A list of selectors for the instance group. UNION operator is used for combining the instances selected by each selector.
        """
elif False:
    DeployEnvironmentComputeInstanceGroupSelectorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployEnvironmentComputeInstanceGroupSelectorsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]] items: (Updatable) A list of selectors for the instance group. UNION operator is used for combining the instances selected by each selector.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]]]:
        """
        (Updatable) A list of selectors for the instance group. UNION operator is used for combining the instances selected by each selector.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployEnvironmentComputeInstanceGroupSelectorsItemArgsDict(TypedDict):
        selector_type: pulumi.Input[str]
        """
        (Updatable) Defines the type of the instance selector for the group.
        """
        compute_instance_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Compute instance OCID identifiers that are members of this group.
        """
        query: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Query expression confirming to the Oracle Cloud Infrastructure Search Language syntax to select compute instances for the group. The language is documented at https://docs.oracle.com/en-us/iaas/Content/Search/Concepts/querysyntax.htm
        """
        region: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Region identifier referred by the deployment environment. Region identifiers are listed at https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        """
elif False:
    DeployEnvironmentComputeInstanceGroupSelectorsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployEnvironmentComputeInstanceGroupSelectorsItemArgs:
    def __init__(__self__, *,
                 selector_type: pulumi.Input[str],
                 compute_instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] selector_type: (Updatable) Defines the type of the instance selector for the group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compute_instance_ids: (Updatable) Compute instance OCID identifiers that are members of this group.
        :param pulumi.Input[str] query: (Updatable) Query expression confirming to the Oracle Cloud Infrastructure Search Language syntax to select compute instances for the group. The language is documented at https://docs.oracle.com/en-us/iaas/Content/Search/Concepts/querysyntax.htm
        :param pulumi.Input[str] region: (Updatable) Region identifier referred by the deployment environment. Region identifiers are listed at https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        """
        pulumi.set(__self__, "selector_type", selector_type)
        if compute_instance_ids is not None:
            pulumi.set(__self__, "compute_instance_ids", compute_instance_ids)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="selectorType")
    def selector_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Defines the type of the instance selector for the group.
        """
        return pulumi.get(self, "selector_type")

    @selector_type.setter
    def selector_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector_type", value)

    @property
    @pulumi.getter(name="computeInstanceIds")
    def compute_instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Compute instance OCID identifiers that are members of this group.
        """
        return pulumi.get(self, "compute_instance_ids")

    @compute_instance_ids.setter
    def compute_instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compute_instance_ids", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Query expression confirming to the Oracle Cloud Infrastructure Search Language syntax to select compute instances for the group. The language is documented at https://docs.oracle.com/en-us/iaas/Content/Search/Concepts/querysyntax.htm
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Region identifier referred by the deployment environment. Region identifiers are listed at https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class DeployEnvironmentNetworkChannelArgsDict(TypedDict):
        network_channel_type: pulumi.Input[str]
        """
        (Updatable) Network channel type.
        """
        subnet_id: pulumi.Input[str]
        """
        (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        """
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) An array of network security group OCIDs.
        """
elif False:
    DeployEnvironmentNetworkChannelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployEnvironmentNetworkChannelArgs:
    def __init__(__self__, *,
                 network_channel_type: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] network_channel_type: (Updatable) Network channel type.
        :param pulumi.Input[str] subnet_id: (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) An array of network security group OCIDs.
        """
        pulumi.set(__self__, "network_channel_type", network_channel_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="networkChannelType")
    def network_channel_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Network channel type.
        """
        return pulumi.get(self, "network_channel_type")

    @network_channel_type.setter
    def network_channel_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_channel_type", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of network security group OCIDs.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)


if not MYPY:
    class DeployPipelineDeployPipelineArtifactArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemArgsDict']]]]
        """
        List of parameters defined for a deployment pipeline.
        """
elif False:
    DeployPipelineDeployPipelineArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineArtifactArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemArgs']]] items: List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemArgs']]]]:
        """
        List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployPipelineDeployPipelineArtifactItemArgsDict(TypedDict):
        deploy_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of an artifact
        """
        deploy_pipeline_stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgsDict']]]]
        """
        List of stages.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
elif False:
    DeployPipelineDeployPipelineArtifactItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineArtifactItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of an artifact
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgs']]] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an artifact
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgs']]]]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgs']]]]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgsDict']]]]
        """
        List of parameters defined for a deployment pipeline.
        """
elif False:
    DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineArtifactItemDeployPipelineStageArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgs']]] items: List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgs']]]]:
        """
        List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgsDict(TypedDict):
        deploy_stage_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of a stage
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
elif False:
    DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineArtifactItemDeployPipelineStageItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: The OCID of a stage
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of a stage
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeployPipelineDeployPipelineEnvironmentArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemArgsDict']]]]
        """
        List of parameters defined for a deployment pipeline.
        """
elif False:
    DeployPipelineDeployPipelineEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineEnvironmentArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemArgs']]] items: List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemArgs']]]]:
        """
        List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployPipelineDeployPipelineEnvironmentItemArgsDict(TypedDict):
        deploy_environment_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of an Environment
        """
        deploy_pipeline_stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgsDict']]]]
        """
        List of stages.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
elif False:
    DeployPipelineDeployPipelineEnvironmentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineEnvironmentItemArgs:
    def __init__(__self__, *,
                 deploy_environment_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_environment_id: The OCID of an Environment
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgs']]] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_environment_id is not None:
            pulumi.set(__self__, "deploy_environment_id", deploy_environment_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployEnvironmentId")
    def deploy_environment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an Environment
        """
        return pulumi.get(self, "deploy_environment_id")

    @deploy_environment_id.setter
    def deploy_environment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_environment_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgs']]]]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgs']]]]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict']]]]
        """
        List of parameters defined for a deployment pipeline.
        """
elif False:
    DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]] items: List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]]]:
        """
        List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict(TypedDict):
        deploy_stage_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of a stage
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
elif False:
    DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineEnvironmentItemDeployPipelineStageItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: The OCID of a stage
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of a stage
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeployPipelineDeployPipelineParametersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineParametersItemArgsDict']]]
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
elif False:
    DeployPipelineDeployPipelineParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineParametersItemArgs']]] items: (Updatable) List of parameters defined for a deployment pipeline.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineParametersItemArgs']]]:
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeployPipelineDeployPipelineParametersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployPipelineDeployPipelineParametersItemArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        default_value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Default value of the parameter.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Description of the parameter.
        """
elif False:
    DeployPipelineDeployPipelineParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPipelineDeployPipelineParametersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default_value: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        :param pulumi.Input[str] default_value: (Updatable) Default value of the parameter.
        :param pulumi.Input[str] description: (Updatable) Description of the parameter.
        """
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Default value of the parameter.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeployStageApprovalPolicyArgsDict(TypedDict):
        approval_policy_type: pulumi.Input[str]
        """
        (Updatable) Approval policy type.
        """
        number_of_approvals_required: pulumi.Input[int]
        """
        (Updatable) A minimum number of approvals required for stage to proceed.
        """
elif False:
    DeployStageApprovalPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageApprovalPolicyArgs:
    def __init__(__self__, *,
                 approval_policy_type: pulumi.Input[str],
                 number_of_approvals_required: pulumi.Input[int]):
        """
        :param pulumi.Input[str] approval_policy_type: (Updatable) Approval policy type.
        :param pulumi.Input[int] number_of_approvals_required: (Updatable) A minimum number of approvals required for stage to proceed.
        """
        pulumi.set(__self__, "approval_policy_type", approval_policy_type)
        pulumi.set(__self__, "number_of_approvals_required", number_of_approvals_required)

    @property
    @pulumi.getter(name="approvalPolicyType")
    def approval_policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Approval policy type.
        """
        return pulumi.get(self, "approval_policy_type")

    @approval_policy_type.setter
    def approval_policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "approval_policy_type", value)

    @property
    @pulumi.getter(name="numberOfApprovalsRequired")
    def number_of_approvals_required(self) -> pulumi.Input[int]:
        """
        (Updatable) A minimum number of approvals required for stage to proceed.
        """
        return pulumi.get(self, "number_of_approvals_required")

    @number_of_approvals_required.setter
    def number_of_approvals_required(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_approvals_required", value)


if not MYPY:
    class DeployStageBlueBackendIpsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
elif False:
    DeployStageBlueBackendIpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageBlueBackendIpsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] items: (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployStageBlueGreenStrategyArgsDict(TypedDict):
        ingress_name: pulumi.Input[str]
        """
        Name of the Ingress resource.
        """
        namespace_a: pulumi.Input[str]
        """
        First Namespace for deployment.
        """
        namespace_b: pulumi.Input[str]
        """
        Second Namespace for deployment.
        """
        strategy_type: pulumi.Input[str]
        """
        Blue Green strategy type
        """
elif False:
    DeployStageBlueGreenStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageBlueGreenStrategyArgs:
    def __init__(__self__, *,
                 ingress_name: pulumi.Input[str],
                 namespace_a: pulumi.Input[str],
                 namespace_b: pulumi.Input[str],
                 strategy_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ingress_name: Name of the Ingress resource.
        :param pulumi.Input[str] namespace_a: First Namespace for deployment.
        :param pulumi.Input[str] namespace_b: Second Namespace for deployment.
        :param pulumi.Input[str] strategy_type: Blue Green strategy type
        """
        pulumi.set(__self__, "ingress_name", ingress_name)
        pulumi.set(__self__, "namespace_a", namespace_a)
        pulumi.set(__self__, "namespace_b", namespace_b)
        pulumi.set(__self__, "strategy_type", strategy_type)

    @property
    @pulumi.getter(name="ingressName")
    def ingress_name(self) -> pulumi.Input[str]:
        """
        Name of the Ingress resource.
        """
        return pulumi.get(self, "ingress_name")

    @ingress_name.setter
    def ingress_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "ingress_name", value)

    @property
    @pulumi.getter(name="namespaceA")
    def namespace_a(self) -> pulumi.Input[str]:
        """
        First Namespace for deployment.
        """
        return pulumi.get(self, "namespace_a")

    @namespace_a.setter
    def namespace_a(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_a", value)

    @property
    @pulumi.getter(name="namespaceB")
    def namespace_b(self) -> pulumi.Input[str]:
        """
        Second Namespace for deployment.
        """
        return pulumi.get(self, "namespace_b")

    @namespace_b.setter
    def namespace_b(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_b", value)

    @property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> pulumi.Input[str]:
        """
        Blue Green strategy type
        """
        return pulumi.get(self, "strategy_type")

    @strategy_type.setter
    def strategy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "strategy_type", value)


if not MYPY:
    class DeployStageCanaryStrategyArgsDict(TypedDict):
        ingress_name: pulumi.Input[str]
        """
        Name of the Ingress resource.
        """
        namespace: pulumi.Input[str]
        """
        Canary namespace to be used for Kubernetes canary deployment.
        """
        strategy_type: pulumi.Input[str]
        """
        Canary strategy type.
        """
elif False:
    DeployStageCanaryStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageCanaryStrategyArgs:
    def __init__(__self__, *,
                 ingress_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 strategy_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ingress_name: Name of the Ingress resource.
        :param pulumi.Input[str] namespace: Canary namespace to be used for Kubernetes canary deployment.
        :param pulumi.Input[str] strategy_type: Canary strategy type.
        """
        pulumi.set(__self__, "ingress_name", ingress_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "strategy_type", strategy_type)

    @property
    @pulumi.getter(name="ingressName")
    def ingress_name(self) -> pulumi.Input[str]:
        """
        Name of the Ingress resource.
        """
        return pulumi.get(self, "ingress_name")

    @ingress_name.setter
    def ingress_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "ingress_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        Canary namespace to be used for Kubernetes canary deployment.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> pulumi.Input[str]:
        """
        Canary strategy type.
        """
        return pulumi.get(self, "strategy_type")

    @strategy_type.setter
    def strategy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "strategy_type", value)


if not MYPY:
    class DeployStageContainerConfigArgsDict(TypedDict):
        container_config_type: pulumi.Input[str]
        """
        (Updatable) Container configuration type.
        """
        network_channel: pulumi.Input['DeployStageContainerConfigNetworkChannelArgsDict']
        """
        (Updatable) Specifies the configuration needed when the target Oracle Cloud Infrastructure resource, i.e., OKE cluster, resides in customer's private network.
        """
        shape_config: pulumi.Input['DeployStageContainerConfigShapeConfigArgsDict']
        """
        (Updatable) Determines the size and amount of resources available to the instance.
        """
        shape_name: pulumi.Input[str]
        """
        (Updatable) The shape of the ContainerInstance. The shape determines the resources available to the ContainerInstance.
        """
        availability_domain: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Availability domain where the ContainerInstance will be created.
        """
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the compartment where the ContainerInstance will be created.
        """
elif False:
    DeployStageContainerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageContainerConfigArgs:
    def __init__(__self__, *,
                 container_config_type: pulumi.Input[str],
                 network_channel: pulumi.Input['DeployStageContainerConfigNetworkChannelArgs'],
                 shape_config: pulumi.Input['DeployStageContainerConfigShapeConfigArgs'],
                 shape_name: pulumi.Input[str],
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container_config_type: (Updatable) Container configuration type.
        :param pulumi.Input['DeployStageContainerConfigNetworkChannelArgs'] network_channel: (Updatable) Specifies the configuration needed when the target Oracle Cloud Infrastructure resource, i.e., OKE cluster, resides in customer's private network.
        :param pulumi.Input['DeployStageContainerConfigShapeConfigArgs'] shape_config: (Updatable) Determines the size and amount of resources available to the instance.
        :param pulumi.Input[str] shape_name: (Updatable) The shape of the ContainerInstance. The shape determines the resources available to the ContainerInstance.
        :param pulumi.Input[str] availability_domain: (Updatable) Availability domain where the ContainerInstance will be created.
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment where the ContainerInstance will be created.
        """
        pulumi.set(__self__, "container_config_type", container_config_type)
        pulumi.set(__self__, "network_channel", network_channel)
        pulumi.set(__self__, "shape_config", shape_config)
        pulumi.set(__self__, "shape_name", shape_name)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)

    @property
    @pulumi.getter(name="containerConfigType")
    def container_config_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Container configuration type.
        """
        return pulumi.get(self, "container_config_type")

    @container_config_type.setter
    def container_config_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_config_type", value)

    @property
    @pulumi.getter(name="networkChannel")
    def network_channel(self) -> pulumi.Input['DeployStageContainerConfigNetworkChannelArgs']:
        """
        (Updatable) Specifies the configuration needed when the target Oracle Cloud Infrastructure resource, i.e., OKE cluster, resides in customer's private network.
        """
        return pulumi.get(self, "network_channel")

    @network_channel.setter
    def network_channel(self, value: pulumi.Input['DeployStageContainerConfigNetworkChannelArgs']):
        pulumi.set(self, "network_channel", value)

    @property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> pulumi.Input['DeployStageContainerConfigShapeConfigArgs']:
        """
        (Updatable) Determines the size and amount of resources available to the instance.
        """
        return pulumi.get(self, "shape_config")

    @shape_config.setter
    def shape_config(self, value: pulumi.Input['DeployStageContainerConfigShapeConfigArgs']):
        pulumi.set(self, "shape_config", value)

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The shape of the ContainerInstance. The shape determines the resources available to the ContainerInstance.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "shape_name", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Availability domain where the ContainerInstance will be created.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment where the ContainerInstance will be created.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)


if not MYPY:
    class DeployStageContainerConfigNetworkChannelArgsDict(TypedDict):
        network_channel_type: pulumi.Input[str]
        """
        (Updatable) Network channel type.
        """
        subnet_id: pulumi.Input[str]
        """
        (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        """
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) An array of network security group OCIDs.
        """
elif False:
    DeployStageContainerConfigNetworkChannelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageContainerConfigNetworkChannelArgs:
    def __init__(__self__, *,
                 network_channel_type: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] network_channel_type: (Updatable) Network channel type.
        :param pulumi.Input[str] subnet_id: (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) An array of network security group OCIDs.
        """
        pulumi.set(__self__, "network_channel_type", network_channel_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="networkChannelType")
    def network_channel_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Network channel type.
        """
        return pulumi.get(self, "network_channel_type")

    @network_channel_type.setter
    def network_channel_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_channel_type", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the subnet where VNIC resources will be created for private endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of network security group OCIDs.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)


if not MYPY:
    class DeployStageContainerConfigShapeConfigArgsDict(TypedDict):
        ocpus: pulumi.Input[float]
        """
        (Updatable) The total number of OCPUs available to the instance.
        """
        memory_in_gbs: NotRequired[pulumi.Input[float]]
        """
        (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
elif False:
    DeployStageContainerConfigShapeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageContainerConfigShapeConfigArgs:
    def __init__(__self__, *,
                 ocpus: pulumi.Input[float],
                 memory_in_gbs: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] ocpus: (Updatable) The total number of OCPUs available to the instance.
        :param pulumi.Input[float] memory_in_gbs: (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
        pulumi.set(__self__, "ocpus", ocpus)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)

    @property
    @pulumi.getter
    def ocpus(self) -> pulumi.Input[float]:
        """
        (Updatable) The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: pulumi.Input[float]):
        pulumi.set(self, "ocpus", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)


if not MYPY:
    class DeployStageDeployStagePredecessorCollectionArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeployStageDeployStagePredecessorCollectionItemArgsDict']]]
        """
        (Updatable) A list of stage predecessors for a stage.
        """
elif False:
    DeployStageDeployStagePredecessorCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageDeployStagePredecessorCollectionArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeployStageDeployStagePredecessorCollectionItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployStageDeployStagePredecessorCollectionItemArgs']]] items: (Updatable) A list of stage predecessors for a stage.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeployStageDeployStagePredecessorCollectionItemArgs']]]:
        """
        (Updatable) A list of stage predecessors for a stage.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeployStageDeployStagePredecessorCollectionItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployStageDeployStagePredecessorCollectionItemArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
elif False:
    DeployStageDeployStagePredecessorCollectionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageDeployStagePredecessorCollectionItemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DeployStageFailurePolicyArgsDict(TypedDict):
        policy_type: pulumi.Input[str]
        """
        (Updatable) Specifies if the failure instance size is given by absolute number or by percentage.
        """
        failure_count: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The threshold count of failed instances in the group, which when reached or exceeded sets the stage as FAILED.
        """
        failure_percentage: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The failure percentage threshold, which when reached or exceeded sets the stage as FAILED. Percentage is computed as the ceiling value of the number of failed instances over the total count of the instances in the group.
        """
elif False:
    DeployStageFailurePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageFailurePolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[str],
                 failure_count: Optional[pulumi.Input[int]] = None,
                 failure_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] policy_type: (Updatable) Specifies if the failure instance size is given by absolute number or by percentage.
        :param pulumi.Input[int] failure_count: (Updatable) The threshold count of failed instances in the group, which when reached or exceeded sets the stage as FAILED.
        :param pulumi.Input[int] failure_percentage: (Updatable) The failure percentage threshold, which when reached or exceeded sets the stage as FAILED. Percentage is computed as the ceiling value of the number of failed instances over the total count of the instances in the group.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if failure_count is not None:
            pulumi.set(__self__, "failure_count", failure_count)
        if failure_percentage is not None:
            pulumi.set(__self__, "failure_percentage", failure_percentage)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies if the failure instance size is given by absolute number or by percentage.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter(name="failureCount")
    def failure_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The threshold count of failed instances in the group, which when reached or exceeded sets the stage as FAILED.
        """
        return pulumi.get(self, "failure_count")

    @failure_count.setter
    def failure_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_count", value)

    @property
    @pulumi.getter(name="failurePercentage")
    def failure_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The failure percentage threshold, which when reached or exceeded sets the stage as FAILED. Percentage is computed as the ceiling value of the number of failed instances over the total count of the instances in the group.
        """
        return pulumi.get(self, "failure_percentage")

    @failure_percentage.setter
    def failure_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_percentage", value)


if not MYPY:
    class DeployStageGreenBackendIpsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
elif False:
    DeployStageGreenBackendIpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageGreenBackendIpsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] items: (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployStageLoadBalancerConfigArgsDict(TypedDict):
        backend_port: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Listen port for the backend server.
        """
        listener_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the load balancer listener.
        """
        load_balancer_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the load balancer.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the deployment stage.
        """
elif False:
    DeployStageLoadBalancerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 backend_port: Optional[pulumi.Input[int]] = None,
                 listener_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] backend_port: (Updatable) Listen port for the backend server.
        :param pulumi.Input[str] listener_name: (Updatable) Name of the load balancer listener.
        :param pulumi.Input[str] load_balancer_id: (Updatable) The OCID of the load balancer.
        :param pulumi.Input[str] state: The current state of the deployment stage.
        """
        if backend_port is not None:
            pulumi.set(__self__, "backend_port", backend_port)
        if listener_name is not None:
            pulumi.set(__self__, "listener_name", listener_name)
        if load_balancer_id is not None:
            pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Listen port for the backend server.
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backend_port", value)

    @property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the load balancer listener.
        """
        return pulumi.get(self, "listener_name")

    @listener_name.setter
    def listener_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listener_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the load balancer.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the deployment stage.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DeployStageProductionLoadBalancerConfigArgsDict(TypedDict):
        backend_port: NotRequired[pulumi.Input[int]]
        """
        Listen port for the backend server.
        """
        listener_name: NotRequired[pulumi.Input[str]]
        """
        Name of the load balancer listener.
        """
        load_balancer_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the load balancer.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the deployment stage.
        """
elif False:
    DeployStageProductionLoadBalancerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageProductionLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 backend_port: Optional[pulumi.Input[int]] = None,
                 listener_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] backend_port: Listen port for the backend server.
        :param pulumi.Input[str] listener_name: Name of the load balancer listener.
        :param pulumi.Input[str] load_balancer_id: The OCID of the load balancer.
        :param pulumi.Input[str] state: The current state of the deployment stage.
        """
        if backend_port is not None:
            pulumi.set(__self__, "backend_port", backend_port)
        if listener_name is not None:
            pulumi.set(__self__, "listener_name", listener_name)
        if load_balancer_id is not None:
            pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[pulumi.Input[int]]:
        """
        Listen port for the backend server.
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backend_port", value)

    @property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the load balancer listener.
        """
        return pulumi.get(self, "listener_name")

    @listener_name.setter
    def listener_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listener_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the load balancer.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the deployment stage.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DeployStageRollbackPolicyArgsDict(TypedDict):
        policy_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Specifies type of the deployment stage rollback policy.
        """
elif False:
    DeployStageRollbackPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageRollbackPolicyArgs:
    def __init__(__self__, *,
                 policy_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_type: (Updatable) Specifies type of the deployment stage rollback policy.
        """
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies type of the deployment stage rollback policy.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_type", value)


if not MYPY:
    class DeployStageRolloutPolicyArgsDict(TypedDict):
        batch_count: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The number that will be used to determine how many instances will be deployed concurrently.
        """
        batch_delay_in_seconds: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The duration of delay between batch rollout. The default delay is 1 minute.
        """
        batch_percentage: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The percentage that will be used to determine how many instances will be deployed concurrently.
        """
        policy_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The type of policy used for rolling out a deployment stage.
        """
        ramp_limit_percent: NotRequired[pulumi.Input[float]]
        """
        (Updatable) Indicates the criteria to stop.
        """
elif False:
    DeployStageRolloutPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageRolloutPolicyArgs:
    def __init__(__self__, *,
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_delay_in_seconds: Optional[pulumi.Input[int]] = None,
                 batch_percentage: Optional[pulumi.Input[int]] = None,
                 policy_type: Optional[pulumi.Input[str]] = None,
                 ramp_limit_percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] batch_count: (Updatable) The number that will be used to determine how many instances will be deployed concurrently.
        :param pulumi.Input[int] batch_delay_in_seconds: (Updatable) The duration of delay between batch rollout. The default delay is 1 minute.
        :param pulumi.Input[int] batch_percentage: (Updatable) The percentage that will be used to determine how many instances will be deployed concurrently.
        :param pulumi.Input[str] policy_type: (Updatable) The type of policy used for rolling out a deployment stage.
        :param pulumi.Input[float] ramp_limit_percent: (Updatable) Indicates the criteria to stop.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if batch_delay_in_seconds is not None:
            pulumi.set(__self__, "batch_delay_in_seconds", batch_delay_in_seconds)
        if batch_percentage is not None:
            pulumi.set(__self__, "batch_percentage", batch_percentage)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if ramp_limit_percent is not None:
            pulumi.set(__self__, "ramp_limit_percent", ramp_limit_percent)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number that will be used to determine how many instances will be deployed concurrently.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchDelayInSeconds")
    def batch_delay_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The duration of delay between batch rollout. The default delay is 1 minute.
        """
        return pulumi.get(self, "batch_delay_in_seconds")

    @batch_delay_in_seconds.setter
    def batch_delay_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_delay_in_seconds", value)

    @property
    @pulumi.getter(name="batchPercentage")
    def batch_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The percentage that will be used to determine how many instances will be deployed concurrently.
        """
        return pulumi.get(self, "batch_percentage")

    @batch_percentage.setter
    def batch_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_percentage", value)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of policy used for rolling out a deployment stage.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter(name="rampLimitPercent")
    def ramp_limit_percent(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) Indicates the criteria to stop.
        """
        return pulumi.get(self, "ramp_limit_percent")

    @ramp_limit_percent.setter
    def ramp_limit_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ramp_limit_percent", value)


if not MYPY:
    class DeployStageSetStringArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployStageSetStringItemArgsDict']]]]
        """
        (Updatable) List of parameters defined to set helm value.
        """
elif False:
    DeployStageSetStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageSetStringArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployStageSetStringItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployStageSetStringItemArgs']]] items: (Updatable) List of parameters defined to set helm value.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployStageSetStringItemArgs']]]]:
        """
        (Updatable) List of parameters defined to set helm value.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployStageSetStringItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployStageSetStringItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the parameter (case-sensitive).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Value of the parameter.
        """
elif False:
    DeployStageSetStringItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageSetStringItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: (Updatable) Value of the parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeployStageSetValuesArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployStageSetValuesItemArgsDict']]]]
        """
        (Updatable) List of parameters defined to set helm value.
        """
elif False:
    DeployStageSetValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageSetValuesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeployStageSetValuesItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeployStageSetValuesItemArgs']]] items: (Updatable) List of parameters defined to set helm value.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployStageSetValuesItemArgs']]]]:
        """
        (Updatable) List of parameters defined to set helm value.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployStageSetValuesItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeployStageSetValuesItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the parameter (case-sensitive).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Value of the parameter.
        """
elif False:
    DeployStageSetValuesItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageSetValuesItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: (Updatable) Value of the parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeployStageTestLoadBalancerConfigArgsDict(TypedDict):
        backend_port: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Listen port for the backend server.
        """
        listener_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the load balancer listener.
        """
        load_balancer_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the load balancer.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the deployment stage.
        """
elif False:
    DeployStageTestLoadBalancerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageTestLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 backend_port: Optional[pulumi.Input[int]] = None,
                 listener_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] backend_port: (Updatable) Listen port for the backend server.
        :param pulumi.Input[str] listener_name: (Updatable) Name of the load balancer listener.
        :param pulumi.Input[str] load_balancer_id: (Updatable) The OCID of the load balancer.
        :param pulumi.Input[str] state: The current state of the deployment stage.
        """
        if backend_port is not None:
            pulumi.set(__self__, "backend_port", backend_port)
        if listener_name is not None:
            pulumi.set(__self__, "listener_name", listener_name)
        if load_balancer_id is not None:
            pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Listen port for the backend server.
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backend_port", value)

    @property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the load balancer listener.
        """
        return pulumi.get(self, "listener_name")

    @listener_name.setter
    def listener_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listener_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the load balancer.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the deployment stage.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DeployStageWaitCriteriaArgsDict(TypedDict):
        wait_duration: pulumi.Input[str]
        """
        (Updatable) The absolute wait duration. An ISO 8601 formatted duration string. Minimum waitDuration should be 5 seconds. Maximum waitDuration can be up to 2 days.
        """
        wait_type: pulumi.Input[str]
        """
        (Updatable) Wait criteria type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    DeployStageWaitCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployStageWaitCriteriaArgs:
    def __init__(__self__, *,
                 wait_duration: pulumi.Input[str],
                 wait_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] wait_duration: (Updatable) The absolute wait duration. An ISO 8601 formatted duration string. Minimum waitDuration should be 5 seconds. Maximum waitDuration can be up to 2 days.
        :param pulumi.Input[str] wait_type: (Updatable) Wait criteria type.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "wait_duration", wait_duration)
        pulumi.set(__self__, "wait_type", wait_type)

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> pulumi.Input[str]:
        """
        (Updatable) The absolute wait duration. An ISO 8601 formatted duration string. Minimum waitDuration should be 5 seconds. Maximum waitDuration can be up to 2 days.
        """
        return pulumi.get(self, "wait_duration")

    @wait_duration.setter
    def wait_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "wait_duration", value)

    @property
    @pulumi.getter(name="waitType")
    def wait_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Wait criteria type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "wait_type")

    @wait_type.setter
    def wait_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "wait_type", value)


if not MYPY:
    class DeploymentDeployArtifactOverrideArgumentsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployArtifactOverrideArgumentsItemArgsDict']]]]
        """
        List of artifact override arguments at the time of deployment.
        """
elif False:
    DeploymentDeployArtifactOverrideArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployArtifactOverrideArgumentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployArtifactOverrideArgumentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployArtifactOverrideArgumentsItemArgs']]] items: List of artifact override arguments at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployArtifactOverrideArgumentsItemArgs']]]]:
        """
        List of artifact override arguments at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployArtifactOverrideArgumentsItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeployArtifactOverrideArgumentsItemArgsDict(TypedDict):
        deploy_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the artifact to which this parameter applies.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the parameter (case-sensitive).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the parameter.
        """
elif False:
    DeploymentDeployArtifactOverrideArgumentsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployArtifactOverrideArgumentsItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of the artifact to which this parameter applies.
        :param pulumi.Input[str] name: Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: Value of the parameter.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the artifact to which this parameter applies.
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentDeployPipelineArtifactArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemArgsDict']]]]
        """
        A list of stage predecessors for a stage.
        """
elif False:
    DeploymentDeployPipelineArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineArtifactArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemArgs']]] items: A list of stage predecessors for a stage.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemArgs']]]]:
        """
        A list of stage predecessors for a stage.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeployPipelineArtifactItemArgsDict(TypedDict):
        deploy_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of an artifact
        """
        deploy_pipeline_stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageArgsDict']]]]
        """
        List of stages.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
elif False:
    DeploymentDeployPipelineArtifactItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineArtifactItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of an artifact
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageArgs']]] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an artifact
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageArgs']]]]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageArgs']]]]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeploymentDeployPipelineArtifactItemDeployPipelineStageArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgsDict']]]]
        """
        A list of stage predecessors for a stage.
        """
elif False:
    DeploymentDeployPipelineArtifactItemDeployPipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineArtifactItemDeployPipelineStageArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgs']]] items: A list of stage predecessors for a stage.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgs']]]]:
        """
        A list of stage predecessors for a stage.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgsDict(TypedDict):
        deploy_stage_id: NotRequired[pulumi.Input[str]]
        """
        Specifies the OCID of the stage to be redeployed.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
elif False:
    DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineArtifactItemDeployPipelineStageItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: Specifies the OCID of the stage to be redeployed.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the OCID of the stage to be redeployed.
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeploymentDeployPipelineEnvironmentArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemArgsDict']]]]
        """
        A list of stage predecessors for a stage.
        """
elif False:
    DeploymentDeployPipelineEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineEnvironmentArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemArgs']]] items: A list of stage predecessors for a stage.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemArgs']]]]:
        """
        A list of stage predecessors for a stage.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeployPipelineEnvironmentItemArgsDict(TypedDict):
        deploy_environment_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of an Environment
        """
        deploy_pipeline_stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgsDict']]]]
        """
        List of stages.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
elif False:
    DeploymentDeployPipelineEnvironmentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineEnvironmentItemArgs:
    def __init__(__self__, *,
                 deploy_environment_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_environment_id: The OCID of an Environment
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgs']]] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_environment_id is not None:
            pulumi.set(__self__, "deploy_environment_id", deploy_environment_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployEnvironmentId")
    def deploy_environment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an Environment
        """
        return pulumi.get(self, "deploy_environment_id")

    @deploy_environment_id.setter
    def deploy_environment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_environment_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgs']]]]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgs']]]]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict']]]]
        """
        A list of stage predecessors for a stage.
        """
elif False:
    DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineEnvironmentItemDeployPipelineStageArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]] items: A list of stage predecessors for a stage.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]]]:
        """
        A list of stage predecessors for a stage.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict(TypedDict):
        deploy_stage_id: NotRequired[pulumi.Input[str]]
        """
        Specifies the OCID of the stage to be redeployed.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
elif False:
    DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployPipelineEnvironmentItemDeployPipelineStageItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: Specifies the OCID of the stage to be redeployed.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the OCID of the stage to be redeployed.
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeploymentDeployStageOverrideArgumentsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployStageOverrideArgumentsItemArgsDict']]]]
        """
        List of stage override arguments at the time of deployment.
        """
elif False:
    DeploymentDeployStageOverrideArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployStageOverrideArgumentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployStageOverrideArgumentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeployStageOverrideArgumentsItemArgs']]] items: List of stage override arguments at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployStageOverrideArgumentsItemArgs']]]]:
        """
        List of stage override arguments at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeployStageOverrideArgumentsItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeployStageOverrideArgumentsItemArgsDict(TypedDict):
        deploy_stage_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the stage.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the parameter (case-sensitive).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the parameter.
        """
elif False:
    DeploymentDeployStageOverrideArgumentsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeployStageOverrideArgumentsItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: The OCID of the stage.
        :param pulumi.Input[str] name: Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: Value of the parameter.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the stage.
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentDeploymentArgumentsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentDeploymentArgumentsItemArgsDict']]]]
        """
        List of arguments provided at the time of deployment.
        """
elif False:
    DeploymentDeploymentArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeploymentArgumentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeploymentArgumentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentDeploymentArgumentsItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeploymentArgumentsItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentDeploymentArgumentsItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentDeploymentArgumentsItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the parameter (case-sensitive).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of the argument.
        *  To retrieve Helm Diff for Helm stages in the pipeline add deployment_arguments with name=PLAN_DRY_RUN and value=true
        """
elif False:
    DeploymentDeploymentArgumentsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeploymentArgumentsItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: value of the argument.
               *  To retrieve Helm Diff for Helm stages in the pipeline add deployment_arguments with name=PLAN_DRY_RUN and value=true
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the argument.
        *  To retrieve Helm Diff for Helm stages in the pipeline add deployment_arguments with name=PLAN_DRY_RUN and value=true
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentDeploymentExecutionProgressArgsDict(TypedDict):
        deploy_stage_execution_progress: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Map of stage OCIDs to deploy stage execution progress model.
        """
        time_finished: NotRequired[pulumi.Input[str]]
        """
        Time the deployment is finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        time_started: NotRequired[pulumi.Input[str]]
        """
        Time the deployment is started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
elif False:
    DeploymentDeploymentExecutionProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeploymentExecutionProgressArgs:
    def __init__(__self__, *,
                 deploy_stage_execution_progress: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_finished: Optional[pulumi.Input[str]] = None,
                 time_started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] deploy_stage_execution_progress: Map of stage OCIDs to deploy stage execution progress model.
        :param pulumi.Input[str] time_finished: Time the deployment is finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        :param pulumi.Input[str] time_started: Time the deployment is started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        if deploy_stage_execution_progress is not None:
            pulumi.set(__self__, "deploy_stage_execution_progress", deploy_stage_execution_progress)
        if time_finished is not None:
            pulumi.set(__self__, "time_finished", time_finished)
        if time_started is not None:
            pulumi.set(__self__, "time_started", time_started)

    @property
    @pulumi.getter(name="deployStageExecutionProgress")
    def deploy_stage_execution_progress(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of stage OCIDs to deploy stage execution progress model.
        """
        return pulumi.get(self, "deploy_stage_execution_progress")

    @deploy_stage_execution_progress.setter
    def deploy_stage_execution_progress(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "deploy_stage_execution_progress", value)

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[pulumi.Input[str]]:
        """
        Time the deployment is finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_finished")

    @time_finished.setter
    def time_finished(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_finished", value)

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> Optional[pulumi.Input[str]]:
        """
        Time the deployment is started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_started")

    @time_started.setter
    def time_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_started", value)


if not MYPY:
    class ProjectNotificationConfigArgsDict(TypedDict):
        topic_id: pulumi.Input[str]
        """
        (Updatable) The topic ID for notifications.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ProjectNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectNotificationConfigArgs:
    def __init__(__self__, *,
                 topic_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] topic_id: (Updatable) The topic ID for notifications.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "topic_id", topic_id)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The topic ID for notifications.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_id", value)


if not MYPY:
    class ProjectRepositorySettingApprovalRulesArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemArgsDict']]]
        """
        (Updatable) List of approval rules.
        """
elif False:
    ProjectRepositorySettingApprovalRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectRepositorySettingApprovalRulesArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemArgs']]] items: (Updatable) List of approval rules.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemArgs']]]:
        """
        (Updatable) List of approval rules.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ProjectRepositorySettingApprovalRulesItemArgsDict(TypedDict):
        min_approvals_count: pulumi.Input[int]
        """
        (Updatable) Minimum number of approvals which must be provided by the reviewers specified in the list before the rule can be satisfied
        """
        name: pulumi.Input[str]
        """
        (Updatable) Name which is used to uniquely identify an approval rule.
        """
        destination_branch: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Branch name where pull requests targeting the branch must satisfy the approval rule. This value being null means the rule applies to all pull requests
        """
        reviewers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemReviewerArgsDict']]]]
        """
        (Updatable) List of users who must provide approvals up to the minApprovalsCount specified in the rule. An empty list means the approvals can come from any user.
        """
elif False:
    ProjectRepositorySettingApprovalRulesItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectRepositorySettingApprovalRulesItemArgs:
    def __init__(__self__, *,
                 min_approvals_count: pulumi.Input[int],
                 name: pulumi.Input[str],
                 destination_branch: Optional[pulumi.Input[str]] = None,
                 reviewers: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemReviewerArgs']]]] = None):
        """
        :param pulumi.Input[int] min_approvals_count: (Updatable) Minimum number of approvals which must be provided by the reviewers specified in the list before the rule can be satisfied
        :param pulumi.Input[str] name: (Updatable) Name which is used to uniquely identify an approval rule.
        :param pulumi.Input[str] destination_branch: (Updatable) Branch name where pull requests targeting the branch must satisfy the approval rule. This value being null means the rule applies to all pull requests
        :param pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemReviewerArgs']]] reviewers: (Updatable) List of users who must provide approvals up to the minApprovalsCount specified in the rule. An empty list means the approvals can come from any user.
        """
        pulumi.set(__self__, "min_approvals_count", min_approvals_count)
        pulumi.set(__self__, "name", name)
        if destination_branch is not None:
            pulumi.set(__self__, "destination_branch", destination_branch)
        if reviewers is not None:
            pulumi.set(__self__, "reviewers", reviewers)

    @property
    @pulumi.getter(name="minApprovalsCount")
    def min_approvals_count(self) -> pulumi.Input[int]:
        """
        (Updatable) Minimum number of approvals which must be provided by the reviewers specified in the list before the rule can be satisfied
        """
        return pulumi.get(self, "min_approvals_count")

    @min_approvals_count.setter
    def min_approvals_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_approvals_count", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name which is used to uniquely identify an approval rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="destinationBranch")
    def destination_branch(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Branch name where pull requests targeting the branch must satisfy the approval rule. This value being null means the rule applies to all pull requests
        """
        return pulumi.get(self, "destination_branch")

    @destination_branch.setter
    def destination_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_branch", value)

    @property
    @pulumi.getter
    def reviewers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemReviewerArgs']]]]:
        """
        (Updatable) List of users who must provide approvals up to the minApprovalsCount specified in the rule. An empty list means the approvals can come from any user.
        """
        return pulumi.get(self, "reviewers")

    @reviewers.setter
    def reviewers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectRepositorySettingApprovalRulesItemReviewerArgs']]]]):
        pulumi.set(self, "reviewers", value)


if not MYPY:
    class ProjectRepositorySettingApprovalRulesItemReviewerArgsDict(TypedDict):
        principal_id: pulumi.Input[str]
        """
        (Updatable) Pull Request reviewer id
        """
        principal_name: NotRequired[pulumi.Input[str]]
        """
        the name of the principal
        """
        principal_state: NotRequired[pulumi.Input[str]]
        """
        The state of the principal, it can be active or inactive or suppressed for emails
        """
        principal_type: NotRequired[pulumi.Input[str]]
        """
        the type of principal
        """
elif False:
    ProjectRepositorySettingApprovalRulesItemReviewerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectRepositorySettingApprovalRulesItemReviewerArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_name: Optional[pulumi.Input[str]] = None,
                 principal_state: Optional[pulumi.Input[str]] = None,
                 principal_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] principal_id: (Updatable) Pull Request reviewer id
        :param pulumi.Input[str] principal_name: the name of the principal
        :param pulumi.Input[str] principal_state: The state of the principal, it can be active or inactive or suppressed for emails
        :param pulumi.Input[str] principal_type: the type of principal
        """
        pulumi.set(__self__, "principal_id", principal_id)
        if principal_name is not None:
            pulumi.set(__self__, "principal_name", principal_name)
        if principal_state is not None:
            pulumi.set(__self__, "principal_state", principal_state)
        if principal_type is not None:
            pulumi.set(__self__, "principal_type", principal_type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Pull Request reviewer id
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        the name of the principal
        """
        return pulumi.get(self, "principal_name")

    @principal_name.setter
    def principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_name", value)

    @property
    @pulumi.getter(name="principalState")
    def principal_state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the principal, it can be active or inactive or suppressed for emails
        """
        return pulumi.get(self, "principal_state")

    @principal_state.setter
    def principal_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_state", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> Optional[pulumi.Input[str]]:
        """
        the type of principal
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_type", value)


if not MYPY:
    class ProjectRepositorySettingMergeSettingsArgsDict(TypedDict):
        allowed_merge_strategies: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Updatable) List of merge strategies which are allowed for a Project or Repository.
        """
        default_merge_strategy: pulumi.Input[str]
        """
        (Updatable) Default type of merge strategy associated with the a Project or Repository.
        """
elif False:
    ProjectRepositorySettingMergeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectRepositorySettingMergeSettingsArgs:
    def __init__(__self__, *,
                 allowed_merge_strategies: pulumi.Input[Sequence[pulumi.Input[str]]],
                 default_merge_strategy: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_merge_strategies: (Updatable) List of merge strategies which are allowed for a Project or Repository.
        :param pulumi.Input[str] default_merge_strategy: (Updatable) Default type of merge strategy associated with the a Project or Repository.
        """
        pulumi.set(__self__, "allowed_merge_strategies", allowed_merge_strategies)
        pulumi.set(__self__, "default_merge_strategy", default_merge_strategy)

    @property
    @pulumi.getter(name="allowedMergeStrategies")
    def allowed_merge_strategies(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) List of merge strategies which are allowed for a Project or Repository.
        """
        return pulumi.get(self, "allowed_merge_strategies")

    @allowed_merge_strategies.setter
    def allowed_merge_strategies(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_merge_strategies", value)

    @property
    @pulumi.getter(name="defaultMergeStrategy")
    def default_merge_strategy(self) -> pulumi.Input[str]:
        """
        (Updatable) Default type of merge strategy associated with the a Project or Repository.
        """
        return pulumi.get(self, "default_merge_strategy")

    @default_merge_strategy.setter
    def default_merge_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_merge_strategy", value)


if not MYPY:
    class RepositoryMirrorRepositoryConfigArgsDict(TypedDict):
        connector_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Upstream git repository connection identifier.
        """
        repository_url: NotRequired[pulumi.Input[str]]
        """
        (Updatable) URL of external repository you want to mirror.
        """
        trigger_schedule: NotRequired[pulumi.Input['RepositoryMirrorRepositoryConfigTriggerScheduleArgsDict']]
        """
        (Updatable) Specifies a trigger schedule. Timing information for when to initiate automated syncs.
        """
elif False:
    RepositoryMirrorRepositoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryMirrorRepositoryConfigArgs:
    def __init__(__self__, *,
                 connector_id: Optional[pulumi.Input[str]] = None,
                 repository_url: Optional[pulumi.Input[str]] = None,
                 trigger_schedule: Optional[pulumi.Input['RepositoryMirrorRepositoryConfigTriggerScheduleArgs']] = None):
        """
        :param pulumi.Input[str] connector_id: (Updatable) Upstream git repository connection identifier.
        :param pulumi.Input[str] repository_url: (Updatable) URL of external repository you want to mirror.
        :param pulumi.Input['RepositoryMirrorRepositoryConfigTriggerScheduleArgs'] trigger_schedule: (Updatable) Specifies a trigger schedule. Timing information for when to initiate automated syncs.
        """
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if repository_url is not None:
            pulumi.set(__self__, "repository_url", repository_url)
        if trigger_schedule is not None:
            pulumi.set(__self__, "trigger_schedule", trigger_schedule)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Upstream git repository connection identifier.
        """
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) URL of external repository you want to mirror.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_url", value)

    @property
    @pulumi.getter(name="triggerSchedule")
    def trigger_schedule(self) -> Optional[pulumi.Input['RepositoryMirrorRepositoryConfigTriggerScheduleArgs']]:
        """
        (Updatable) Specifies a trigger schedule. Timing information for when to initiate automated syncs.
        """
        return pulumi.get(self, "trigger_schedule")

    @trigger_schedule.setter
    def trigger_schedule(self, value: Optional[pulumi.Input['RepositoryMirrorRepositoryConfigTriggerScheduleArgs']]):
        pulumi.set(self, "trigger_schedule", value)


if not MYPY:
    class RepositoryMirrorRepositoryConfigTriggerScheduleArgsDict(TypedDict):
        schedule_type: pulumi.Input[str]
        """
        (Updatable) Different types of trigger schedule: NONE - No automated synchronization schedule. DEFAULT - Trigger schedule is every 30 minutes. CUSTOM - Custom triggering schedule.
        """
        custom_schedule: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Valid if type is CUSTOM. Following RFC 5545 recurrence rules, we can specify starting time, occurrence frequency, and interval size. Example for frequency could be DAILY/WEEKLY/HOURLY or any RFC 5545 supported frequency, which is followed by start time of this window. You can control the start time with BYHOUR, BYMINUTE and BYSECONDS. It is followed by the interval size.
        """
elif False:
    RepositoryMirrorRepositoryConfigTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryMirrorRepositoryConfigTriggerScheduleArgs:
    def __init__(__self__, *,
                 schedule_type: pulumi.Input[str],
                 custom_schedule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] schedule_type: (Updatable) Different types of trigger schedule: NONE - No automated synchronization schedule. DEFAULT - Trigger schedule is every 30 minutes. CUSTOM - Custom triggering schedule.
        :param pulumi.Input[str] custom_schedule: (Updatable) Valid if type is CUSTOM. Following RFC 5545 recurrence rules, we can specify starting time, occurrence frequency, and interval size. Example for frequency could be DAILY/WEEKLY/HOURLY or any RFC 5545 supported frequency, which is followed by start time of this window. You can control the start time with BYHOUR, BYMINUTE and BYSECONDS. It is followed by the interval size.
        """
        pulumi.set(__self__, "schedule_type", schedule_type)
        if custom_schedule is not None:
            pulumi.set(__self__, "custom_schedule", custom_schedule)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Different types of trigger schedule: NONE - No automated synchronization schedule. DEFAULT - Trigger schedule is every 30 minutes. CUSTOM - Custom triggering schedule.
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_type", value)

    @property
    @pulumi.getter(name="customSchedule")
    def custom_schedule(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Valid if type is CUSTOM. Following RFC 5545 recurrence rules, we can specify starting time, occurrence frequency, and interval size. Example for frequency could be DAILY/WEEKLY/HOURLY or any RFC 5545 supported frequency, which is followed by start time of this window. You can control the start time with BYHOUR, BYMINUTE and BYSECONDS. It is followed by the interval size.
        """
        return pulumi.get(self, "custom_schedule")

    @custom_schedule.setter
    def custom_schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_schedule", value)


if not MYPY:
    class RepositorySettingApprovalRulesArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemArgsDict']]]
        """
        (Updatable) List of approval rules.
        """
elif False:
    RepositorySettingApprovalRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySettingApprovalRulesArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemArgs']]] items: (Updatable) List of approval rules.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemArgs']]]:
        """
        (Updatable) List of approval rules.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class RepositorySettingApprovalRulesItemArgsDict(TypedDict):
        min_approvals_count: pulumi.Input[int]
        """
        (Updatable) Minimum number of approvals which must be provided by the reviewers specified in the list before the rule can be satisfied
        """
        name: pulumi.Input[str]
        """
        (Updatable) Name which is used to uniquely identify an approval rule.
        """
        destination_branch: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Branch name where pull requests targeting the branch must satisfy the approval rule. This value being null means the rule applies to all pull requests
        """
        reviewers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemReviewerArgsDict']]]]
        """
        (Updatable) List of users who must provide approvals up to the minApprovalsCount specified in the rule. An empty list means the approvals can come from any user.
        """
elif False:
    RepositorySettingApprovalRulesItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySettingApprovalRulesItemArgs:
    def __init__(__self__, *,
                 min_approvals_count: pulumi.Input[int],
                 name: pulumi.Input[str],
                 destination_branch: Optional[pulumi.Input[str]] = None,
                 reviewers: Optional[pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemReviewerArgs']]]] = None):
        """
        :param pulumi.Input[int] min_approvals_count: (Updatable) Minimum number of approvals which must be provided by the reviewers specified in the list before the rule can be satisfied
        :param pulumi.Input[str] name: (Updatable) Name which is used to uniquely identify an approval rule.
        :param pulumi.Input[str] destination_branch: (Updatable) Branch name where pull requests targeting the branch must satisfy the approval rule. This value being null means the rule applies to all pull requests
        :param pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemReviewerArgs']]] reviewers: (Updatable) List of users who must provide approvals up to the minApprovalsCount specified in the rule. An empty list means the approvals can come from any user.
        """
        pulumi.set(__self__, "min_approvals_count", min_approvals_count)
        pulumi.set(__self__, "name", name)
        if destination_branch is not None:
            pulumi.set(__self__, "destination_branch", destination_branch)
        if reviewers is not None:
            pulumi.set(__self__, "reviewers", reviewers)

    @property
    @pulumi.getter(name="minApprovalsCount")
    def min_approvals_count(self) -> pulumi.Input[int]:
        """
        (Updatable) Minimum number of approvals which must be provided by the reviewers specified in the list before the rule can be satisfied
        """
        return pulumi.get(self, "min_approvals_count")

    @min_approvals_count.setter
    def min_approvals_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_approvals_count", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name which is used to uniquely identify an approval rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="destinationBranch")
    def destination_branch(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Branch name where pull requests targeting the branch must satisfy the approval rule. This value being null means the rule applies to all pull requests
        """
        return pulumi.get(self, "destination_branch")

    @destination_branch.setter
    def destination_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_branch", value)

    @property
    @pulumi.getter
    def reviewers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemReviewerArgs']]]]:
        """
        (Updatable) List of users who must provide approvals up to the minApprovalsCount specified in the rule. An empty list means the approvals can come from any user.
        """
        return pulumi.get(self, "reviewers")

    @reviewers.setter
    def reviewers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RepositorySettingApprovalRulesItemReviewerArgs']]]]):
        pulumi.set(self, "reviewers", value)


if not MYPY:
    class RepositorySettingApprovalRulesItemReviewerArgsDict(TypedDict):
        principal_id: pulumi.Input[str]
        """
        (Updatable) Pull Request reviewer id
        """
        principal_name: NotRequired[pulumi.Input[str]]
        """
        the name of the principal
        """
        principal_state: NotRequired[pulumi.Input[str]]
        """
        The state of the principal, it can be active or inactive or suppressed for emails
        """
        principal_type: NotRequired[pulumi.Input[str]]
        """
        the type of principal
        """
elif False:
    RepositorySettingApprovalRulesItemReviewerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySettingApprovalRulesItemReviewerArgs:
    def __init__(__self__, *,
                 principal_id: pulumi.Input[str],
                 principal_name: Optional[pulumi.Input[str]] = None,
                 principal_state: Optional[pulumi.Input[str]] = None,
                 principal_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] principal_id: (Updatable) Pull Request reviewer id
        :param pulumi.Input[str] principal_name: the name of the principal
        :param pulumi.Input[str] principal_state: The state of the principal, it can be active or inactive or suppressed for emails
        :param pulumi.Input[str] principal_type: the type of principal
        """
        pulumi.set(__self__, "principal_id", principal_id)
        if principal_name is not None:
            pulumi.set(__self__, "principal_name", principal_name)
        if principal_state is not None:
            pulumi.set(__self__, "principal_state", principal_state)
        if principal_type is not None:
            pulumi.set(__self__, "principal_type", principal_type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Pull Request reviewer id
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        the name of the principal
        """
        return pulumi.get(self, "principal_name")

    @principal_name.setter
    def principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_name", value)

    @property
    @pulumi.getter(name="principalState")
    def principal_state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the principal, it can be active or inactive or suppressed for emails
        """
        return pulumi.get(self, "principal_state")

    @principal_state.setter
    def principal_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_state", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> Optional[pulumi.Input[str]]:
        """
        the type of principal
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_type", value)


if not MYPY:
    class RepositorySettingMergeChecksArgsDict(TypedDict):
        last_build_succeeded: pulumi.Input[str]
        """
        (Updatable) Indicates whether or not a pull request must have a successful build run and no queued builds before it can be merged
        """
elif False:
    RepositorySettingMergeChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySettingMergeChecksArgs:
    def __init__(__self__, *,
                 last_build_succeeded: pulumi.Input[str]):
        """
        :param pulumi.Input[str] last_build_succeeded: (Updatable) Indicates whether or not a pull request must have a successful build run and no queued builds before it can be merged
        """
        pulumi.set(__self__, "last_build_succeeded", last_build_succeeded)

    @property
    @pulumi.getter(name="lastBuildSucceeded")
    def last_build_succeeded(self) -> pulumi.Input[str]:
        """
        (Updatable) Indicates whether or not a pull request must have a successful build run and no queued builds before it can be merged
        """
        return pulumi.get(self, "last_build_succeeded")

    @last_build_succeeded.setter
    def last_build_succeeded(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_build_succeeded", value)


if not MYPY:
    class RepositorySettingMergeSettingsArgsDict(TypedDict):
        allowed_merge_strategies: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Updatable) List of merge strategies which are allowed for a Project or Repository.
        """
        default_merge_strategy: pulumi.Input[str]
        """
        (Updatable) Default type of merge strategy associated with the a Project or Repository.
        """
elif False:
    RepositorySettingMergeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySettingMergeSettingsArgs:
    def __init__(__self__, *,
                 allowed_merge_strategies: pulumi.Input[Sequence[pulumi.Input[str]]],
                 default_merge_strategy: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_merge_strategies: (Updatable) List of merge strategies which are allowed for a Project or Repository.
        :param pulumi.Input[str] default_merge_strategy: (Updatable) Default type of merge strategy associated with the a Project or Repository.
        """
        pulumi.set(__self__, "allowed_merge_strategies", allowed_merge_strategies)
        pulumi.set(__self__, "default_merge_strategy", default_merge_strategy)

    @property
    @pulumi.getter(name="allowedMergeStrategies")
    def allowed_merge_strategies(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) List of merge strategies which are allowed for a Project or Repository.
        """
        return pulumi.get(self, "allowed_merge_strategies")

    @allowed_merge_strategies.setter
    def allowed_merge_strategies(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_merge_strategies", value)

    @property
    @pulumi.getter(name="defaultMergeStrategy")
    def default_merge_strategy(self) -> pulumi.Input[str]:
        """
        (Updatable) Default type of merge strategy associated with the a Project or Repository.
        """
        return pulumi.get(self, "default_merge_strategy")

    @default_merge_strategy.setter
    def default_merge_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_merge_strategy", value)


if not MYPY:
    class TriggerActionArgsDict(TypedDict):
        build_pipeline_id: pulumi.Input[str]
        """
        (Updatable) The OCID of the build pipeline to be triggered.
        """
        type: pulumi.Input[str]
        """
        (Updatable) The type of action that will be taken. Allowed value is TRIGGER_BUILD_PIPELINE.
        """
        filter: NotRequired[pulumi.Input['TriggerActionFilterArgsDict']]
elif False:
    TriggerActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionArgs:
    def __init__(__self__, *,
                 build_pipeline_id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 filter: Optional[pulumi.Input['TriggerActionFilterArgs']] = None):
        """
        :param pulumi.Input[str] build_pipeline_id: (Updatable) The OCID of the build pipeline to be triggered.
        :param pulumi.Input[str] type: (Updatable) The type of action that will be taken. Allowed value is TRIGGER_BUILD_PIPELINE.
        """
        pulumi.set(__self__, "build_pipeline_id", build_pipeline_id)
        pulumi.set(__self__, "type", type)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="buildPipelineId")
    def build_pipeline_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the build pipeline to be triggered.
        """
        return pulumi.get(self, "build_pipeline_id")

    @build_pipeline_id.setter
    def build_pipeline_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "build_pipeline_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of action that will be taken. Allowed value is TRIGGER_BUILD_PIPELINE.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['TriggerActionFilterArgs']]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['TriggerActionFilterArgs']]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class TriggerActionFilterArgsDict(TypedDict):
        trigger_source: pulumi.Input[str]
        """
        (Updatable) Source of the trigger. Allowed values are,  GITHUB, GITLAB, BITBUCKET_CLOUD, VBS and DEVOPS_CODE_REPOSITORY.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The events, for example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED.
        """
        exclude: NotRequired[pulumi.Input['TriggerActionFilterExcludeArgsDict']]
        """
        Attributes to filter GitLab self-hosted server events. File filter criteria - Changes only affecting excluded files will not invoke a build. if both include and exclude filter are used then exclusion filter will be applied on the result set of inclusion filter.
        """
        include: NotRequired[pulumi.Input['TriggerActionFilterIncludeArgsDict']]
        """
        Attributes to filter GitLab self-hosted server events.
        """
elif False:
    TriggerActionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionFilterArgs:
    def __init__(__self__, *,
                 trigger_source: pulumi.Input[str],
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude: Optional[pulumi.Input['TriggerActionFilterExcludeArgs']] = None,
                 include: Optional[pulumi.Input['TriggerActionFilterIncludeArgs']] = None):
        """
        :param pulumi.Input[str] trigger_source: (Updatable) Source of the trigger. Allowed values are,  GITHUB, GITLAB, BITBUCKET_CLOUD, VBS and DEVOPS_CODE_REPOSITORY.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: The events, for example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED.
        :param pulumi.Input['TriggerActionFilterExcludeArgs'] exclude: Attributes to filter GitLab self-hosted server events. File filter criteria - Changes only affecting excluded files will not invoke a build. if both include and exclude filter are used then exclusion filter will be applied on the result set of inclusion filter.
        :param pulumi.Input['TriggerActionFilterIncludeArgs'] include: Attributes to filter GitLab self-hosted server events.
        """
        pulumi.set(__self__, "trigger_source", trigger_source)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> pulumi.Input[str]:
        """
        (Updatable) Source of the trigger. Allowed values are,  GITHUB, GITLAB, BITBUCKET_CLOUD, VBS and DEVOPS_CODE_REPOSITORY.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "trigger_source")

    @trigger_source.setter
    def trigger_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_source", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The events, for example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input['TriggerActionFilterExcludeArgs']]:
        """
        Attributes to filter GitLab self-hosted server events. File filter criteria - Changes only affecting excluded files will not invoke a build. if both include and exclude filter are used then exclusion filter will be applied on the result set of inclusion filter.
        """
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input['TriggerActionFilterExcludeArgs']]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input['TriggerActionFilterIncludeArgs']]:
        """
        Attributes to filter GitLab self-hosted server events.
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input['TriggerActionFilterIncludeArgs']]):
        pulumi.set(self, "include", value)


if not MYPY:
    class TriggerActionFilterExcludeArgsDict(TypedDict):
        file_filter: NotRequired[pulumi.Input['TriggerActionFilterExcludeFileFilterArgsDict']]
        """
        Attributes to support include/exclude files for triggering build runs.
        """
elif False:
    TriggerActionFilterExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionFilterExcludeArgs:
    def __init__(__self__, *,
                 file_filter: Optional[pulumi.Input['TriggerActionFilterExcludeFileFilterArgs']] = None):
        """
        :param pulumi.Input['TriggerActionFilterExcludeFileFilterArgs'] file_filter: Attributes to support include/exclude files for triggering build runs.
        """
        if file_filter is not None:
            pulumi.set(__self__, "file_filter", file_filter)

    @property
    @pulumi.getter(name="fileFilter")
    def file_filter(self) -> Optional[pulumi.Input['TriggerActionFilterExcludeFileFilterArgs']]:
        """
        Attributes to support include/exclude files for triggering build runs.
        """
        return pulumi.get(self, "file_filter")

    @file_filter.setter
    def file_filter(self, value: Optional[pulumi.Input['TriggerActionFilterExcludeFileFilterArgs']]):
        pulumi.set(self, "file_filter", value)


if not MYPY:
    class TriggerActionFilterExcludeFileFilterArgsDict(TypedDict):
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The file paths/glob pattern for files.
        """
elif False:
    TriggerActionFilterExcludeFileFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionFilterExcludeFileFilterArgs:
    def __init__(__self__, *,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_paths: The file paths/glob pattern for files.
        """
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The file paths/glob pattern for files.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class TriggerActionFilterIncludeArgsDict(TypedDict):
        base_ref: NotRequired[pulumi.Input[str]]
        """
        The target branch for pull requests; not applicable for push requests.
        """
        file_filter: NotRequired[pulumi.Input['TriggerActionFilterIncludeFileFilterArgsDict']]
        """
        Attributes to support include/exclude files for triggering build runs.
        """
        head_ref: NotRequired[pulumi.Input[str]]
        """
        Branch for push event; source branch for pull requests.
        """
        repository_name: NotRequired[pulumi.Input[str]]
        """
        The repository name for trigger events.
        """
elif False:
    TriggerActionFilterIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionFilterIncludeArgs:
    def __init__(__self__, *,
                 base_ref: Optional[pulumi.Input[str]] = None,
                 file_filter: Optional[pulumi.Input['TriggerActionFilterIncludeFileFilterArgs']] = None,
                 head_ref: Optional[pulumi.Input[str]] = None,
                 repository_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_ref: The target branch for pull requests; not applicable for push requests.
        :param pulumi.Input['TriggerActionFilterIncludeFileFilterArgs'] file_filter: Attributes to support include/exclude files for triggering build runs.
        :param pulumi.Input[str] head_ref: Branch for push event; source branch for pull requests.
        :param pulumi.Input[str] repository_name: The repository name for trigger events.
        """
        if base_ref is not None:
            pulumi.set(__self__, "base_ref", base_ref)
        if file_filter is not None:
            pulumi.set(__self__, "file_filter", file_filter)
        if head_ref is not None:
            pulumi.set(__self__, "head_ref", head_ref)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)

    @property
    @pulumi.getter(name="baseRef")
    def base_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The target branch for pull requests; not applicable for push requests.
        """
        return pulumi.get(self, "base_ref")

    @base_ref.setter
    def base_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_ref", value)

    @property
    @pulumi.getter(name="fileFilter")
    def file_filter(self) -> Optional[pulumi.Input['TriggerActionFilterIncludeFileFilterArgs']]:
        """
        Attributes to support include/exclude files for triggering build runs.
        """
        return pulumi.get(self, "file_filter")

    @file_filter.setter
    def file_filter(self, value: Optional[pulumi.Input['TriggerActionFilterIncludeFileFilterArgs']]):
        pulumi.set(self, "file_filter", value)

    @property
    @pulumi.getter(name="headRef")
    def head_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Branch for push event; source branch for pull requests.
        """
        return pulumi.get(self, "head_ref")

    @head_ref.setter
    def head_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "head_ref", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[str]]:
        """
        The repository name for trigger events.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_name", value)


if not MYPY:
    class TriggerActionFilterIncludeFileFilterArgsDict(TypedDict):
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The file paths/glob pattern for files.
        """
elif False:
    TriggerActionFilterIncludeFileFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionFilterIncludeFileFilterArgs:
    def __init__(__self__, *,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_paths: The file paths/glob pattern for files.
        """
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The file paths/glob pattern for files.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class GetBuildPipelineStagesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the build source. This must be unique within a build source collection. The name can be used by customers to locate the working directory pertinent to this repository.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetBuildPipelineStagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBuildPipelineStagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the build source. This must be unique within a build source collection. The name can be used by customers to locate the working directory pertinent to this repository.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the build source. This must be unique within a build source collection. The name can be used by customers to locate the working directory pertinent to this repository.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBuildPipelinesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetBuildPipelinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBuildPipelinesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$. Example: 'Build_Pipeline_param' is not same as 'build_pipeline_Param'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBuildRunsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the step.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetBuildRunsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBuildRunsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetConnectionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetConnectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeployArtifactsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeployArtifactsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeployArtifactsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeployEnvironmentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeployEnvironmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeployEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeployPipelinesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeployPipelinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeployPipelinesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeployStagesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the parameter (case-sensitive).
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeployStagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeployStagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the parameter (case-sensitive).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the step.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProjectsFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetProjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoriesFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryAuthorsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryAuthorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryAuthorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryCommitsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryCommitsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryCommitsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryDiffsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryDiffsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryDiffsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryMirrorRecordsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryMirrorRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryMirrorRecordsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryPathsFilterArgsDict(TypedDict):
        name: str
        """
        Name of file or directory.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryPathsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryPathsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of file or directory.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of file or directory.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryProtectedBranchesFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the given branch name.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryProtectedBranchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryProtectedBranchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the given branch name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the given branch name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRepositoryRefsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRepositoryRefsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepositoryRefsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTriggersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetTriggersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTriggersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


