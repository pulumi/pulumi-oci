# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ActionCreateZoneFromZoneFileDnssecConfig',
    'ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion',
    'ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData',
    'ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion',
    'ActionCreateZoneFromZoneFileExternalDownstream',
    'ActionCreateZoneFromZoneFileExternalMaster',
    'ActionCreateZoneFromZoneFileNameserver',
    'ActionCreateZoneFromZoneFileZoneTransferServer',
    'ResolverAttachedView',
    'ResolverEndpoint',
    'ResolverRule',
    'RrsetItem',
    'SteeringPolicyAnswer',
    'SteeringPolicyRule',
    'SteeringPolicyRuleCase',
    'SteeringPolicyRuleCaseAnswerData',
    'SteeringPolicyRuleDefaultAnswerData',
    'ZoneDnssecConfig',
    'ZoneDnssecConfigKskDnssecKeyVersion',
    'ZoneDnssecConfigKskDnssecKeyVersionDsData',
    'ZoneDnssecConfigZskDnssecKeyVersion',
    'ZoneExternalDownstream',
    'ZoneExternalMaster',
    'ZoneNameserver',
    'ZoneZoneTransferServer',
    'GetRecordsFilterResult',
    'GetRecordsRecordResult',
    'GetResolverAttachedViewResult',
    'GetResolverEndpointResult',
    'GetResolverEndpointsFilterResult',
    'GetResolverEndpointsResolverEndpointResult',
    'GetResolverRuleResult',
    'GetResolversFilterResult',
    'GetResolversResolverResult',
    'GetResolversResolverAttachedViewResult',
    'GetResolversResolverEndpointResult',
    'GetResolversResolverRuleResult',
    'GetRrsetItemResult',
    'GetRrsetsFilterResult',
    'GetRrsetsRrsetResult',
    'GetRrsetsRrsetItemResult',
    'GetSteeringPoliciesFilterResult',
    'GetSteeringPoliciesSteeringPolicyResult',
    'GetSteeringPoliciesSteeringPolicyAnswerResult',
    'GetSteeringPoliciesSteeringPolicyRuleResult',
    'GetSteeringPoliciesSteeringPolicyRuleCaseResult',
    'GetSteeringPoliciesSteeringPolicyRuleCaseAnswerDataResult',
    'GetSteeringPoliciesSteeringPolicyRuleDefaultAnswerDataResult',
    'GetSteeringPolicyAnswerResult',
    'GetSteeringPolicyAttachmentsFilterResult',
    'GetSteeringPolicyAttachmentsSteeringPolicyAttachmentResult',
    'GetSteeringPolicyRuleResult',
    'GetSteeringPolicyRuleCaseResult',
    'GetSteeringPolicyRuleCaseAnswerDataResult',
    'GetSteeringPolicyRuleDefaultAnswerDataResult',
    'GetTsigKeysFilterResult',
    'GetTsigKeysTsigKeyResult',
    'GetViewsFilterResult',
    'GetViewsViewResult',
    'GetZonesFilterResult',
    'GetZonesZoneResult',
    'GetZonesZoneDnssecConfigResult',
    'GetZonesZoneDnssecConfigKskDnssecKeyVersionResult',
    'GetZonesZoneDnssecConfigKskDnssecKeyVersionDsDataResult',
    'GetZonesZoneDnssecConfigZskDnssecKeyVersionResult',
    'GetZonesZoneExternalDownstreamResult',
    'GetZonesZoneExternalMasterResult',
    'GetZonesZoneNameserverResult',
    'GetZonesZoneZoneTransferServerResult',
]

@pulumi.output_type
class ActionCreateZoneFromZoneFileDnssecConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kskDnssecKeyVersions":
            suggest = "ksk_dnssec_key_versions"
        elif key == "zskDnssecKeyVersions":
            suggest = "zsk_dnssec_key_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileDnssecConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ksk_dnssec_key_versions: Optional[Sequence['outputs.ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion']] = None,
                 zsk_dnssec_key_versions: Optional[Sequence['outputs.ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion']] = None):
        if ksk_dnssec_key_versions is not None:
            pulumi.set(__self__, "ksk_dnssec_key_versions", ksk_dnssec_key_versions)
        if zsk_dnssec_key_versions is not None:
            pulumi.set(__self__, "zsk_dnssec_key_versions", zsk_dnssec_key_versions)

    @property
    @pulumi.getter(name="kskDnssecKeyVersions")
    def ksk_dnssec_key_versions(self) -> Optional[Sequence['outputs.ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion']]:
        return pulumi.get(self, "ksk_dnssec_key_versions")

    @property
    @pulumi.getter(name="zskDnssecKeyVersions")
    def zsk_dnssec_key_versions(self) -> Optional[Sequence['outputs.ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion']]:
        return pulumi.get(self, "zsk_dnssec_key_versions")


@pulumi.output_type
class ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dsDatas":
            suggest = "ds_datas"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "lengthInBytes":
            suggest = "length_in_bytes"
        elif key == "predecessorDnssecKeyVersionUuid":
            suggest = "predecessor_dnssec_key_version_uuid"
        elif key == "successorDnssecKeyVersionUuid":
            suggest = "successor_dnssec_key_version_uuid"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeExpired":
            suggest = "time_expired"
        elif key == "timeInactivated":
            suggest = "time_inactivated"
        elif key == "timePromoted":
            suggest = "time_promoted"
        elif key == "timePublished":
            suggest = "time_published"
        elif key == "timeUnpublished":
            suggest = "time_unpublished"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 ds_datas: Optional[Sequence['outputs.ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData']] = None,
                 key_tag: Optional[int] = None,
                 length_in_bytes: Optional[int] = None,
                 predecessor_dnssec_key_version_uuid: Optional[str] = None,
                 successor_dnssec_key_version_uuid: Optional[str] = None,
                 time_activated: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_expired: Optional[str] = None,
                 time_inactivated: Optional[str] = None,
                 time_promoted: Optional[str] = None,
                 time_published: Optional[str] = None,
                 time_unpublished: Optional[str] = None,
                 uuid: Optional[str] = None):
        """
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if ds_datas is not None:
            pulumi.set(__self__, "ds_datas", ds_datas)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if length_in_bytes is not None:
            pulumi.set(__self__, "length_in_bytes", length_in_bytes)
        if predecessor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "predecessor_dnssec_key_version_uuid", predecessor_dnssec_key_version_uuid)
        if successor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "successor_dnssec_key_version_uuid", successor_dnssec_key_version_uuid)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_expired is not None:
            pulumi.set(__self__, "time_expired", time_expired)
        if time_inactivated is not None:
            pulumi.set(__self__, "time_inactivated", time_inactivated)
        if time_promoted is not None:
            pulumi.set(__self__, "time_promoted", time_promoted)
        if time_published is not None:
            pulumi.set(__self__, "time_published", time_published)
        if time_unpublished is not None:
            pulumi.set(__self__, "time_unpublished", time_unpublished)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="dsDatas")
    def ds_datas(self) -> Optional[Sequence['outputs.ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData']]:
        return pulumi.get(self, "ds_datas")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[int]:
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="lengthInBytes")
    def length_in_bytes(self) -> Optional[int]:
        return pulumi.get(self, "length_in_bytes")

    @property
    @pulumi.getter(name="predecessorDnssecKeyVersionUuid")
    def predecessor_dnssec_key_version_uuid(self) -> Optional[str]:
        return pulumi.get(self, "predecessor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="successorDnssecKeyVersionUuid")
    def successor_dnssec_key_version_uuid(self) -> Optional[str]:
        return pulumi.get(self, "successor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[str]:
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeExpired")
    def time_expired(self) -> Optional[str]:
        return pulumi.get(self, "time_expired")

    @property
    @pulumi.getter(name="timeInactivated")
    def time_inactivated(self) -> Optional[str]:
        return pulumi.get(self, "time_inactivated")

    @property
    @pulumi.getter(name="timePromoted")
    def time_promoted(self) -> Optional[str]:
        return pulumi.get(self, "time_promoted")

    @property
    @pulumi.getter(name="timePublished")
    def time_published(self) -> Optional[str]:
        return pulumi.get(self, "time_published")

    @property
    @pulumi.getter(name="timeUnpublished")
    def time_unpublished(self) -> Optional[str]:
        return pulumi.get(self, "time_unpublished")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfigKskDnssecKeyVersionDsData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digest_type: Optional[str] = None,
                 rdata: Optional[str] = None):
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if rdata is not None:
            pulumi.set(__self__, "rdata", rdata)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[str]:
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def rdata(self) -> Optional[str]:
        return pulumi.get(self, "rdata")


@pulumi.output_type
class ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyTag":
            suggest = "key_tag"
        elif key == "lengthInBytes":
            suggest = "length_in_bytes"
        elif key == "predecessorDnssecKeyVersionUuid":
            suggest = "predecessor_dnssec_key_version_uuid"
        elif key == "successorDnssecKeyVersionUuid":
            suggest = "successor_dnssec_key_version_uuid"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeExpired":
            suggest = "time_expired"
        elif key == "timeInactivated":
            suggest = "time_inactivated"
        elif key == "timePromoted":
            suggest = "time_promoted"
        elif key == "timePublished":
            suggest = "time_published"
        elif key == "timeUnpublished":
            suggest = "time_unpublished"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileDnssecConfigZskDnssecKeyVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 key_tag: Optional[int] = None,
                 length_in_bytes: Optional[int] = None,
                 predecessor_dnssec_key_version_uuid: Optional[str] = None,
                 successor_dnssec_key_version_uuid: Optional[str] = None,
                 time_activated: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_expired: Optional[str] = None,
                 time_inactivated: Optional[str] = None,
                 time_promoted: Optional[str] = None,
                 time_published: Optional[str] = None,
                 time_unpublished: Optional[str] = None,
                 uuid: Optional[str] = None):
        """
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if length_in_bytes is not None:
            pulumi.set(__self__, "length_in_bytes", length_in_bytes)
        if predecessor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "predecessor_dnssec_key_version_uuid", predecessor_dnssec_key_version_uuid)
        if successor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "successor_dnssec_key_version_uuid", successor_dnssec_key_version_uuid)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_expired is not None:
            pulumi.set(__self__, "time_expired", time_expired)
        if time_inactivated is not None:
            pulumi.set(__self__, "time_inactivated", time_inactivated)
        if time_promoted is not None:
            pulumi.set(__self__, "time_promoted", time_promoted)
        if time_published is not None:
            pulumi.set(__self__, "time_published", time_published)
        if time_unpublished is not None:
            pulumi.set(__self__, "time_unpublished", time_unpublished)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[int]:
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="lengthInBytes")
    def length_in_bytes(self) -> Optional[int]:
        return pulumi.get(self, "length_in_bytes")

    @property
    @pulumi.getter(name="predecessorDnssecKeyVersionUuid")
    def predecessor_dnssec_key_version_uuid(self) -> Optional[str]:
        return pulumi.get(self, "predecessor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="successorDnssecKeyVersionUuid")
    def successor_dnssec_key_version_uuid(self) -> Optional[str]:
        return pulumi.get(self, "successor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[str]:
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeExpired")
    def time_expired(self) -> Optional[str]:
        return pulumi.get(self, "time_expired")

    @property
    @pulumi.getter(name="timeInactivated")
    def time_inactivated(self) -> Optional[str]:
        return pulumi.get(self, "time_inactivated")

    @property
    @pulumi.getter(name="timePromoted")
    def time_promoted(self) -> Optional[str]:
        return pulumi.get(self, "time_promoted")

    @property
    @pulumi.getter(name="timePublished")
    def time_published(self) -> Optional[str]:
        return pulumi.get(self, "time_published")

    @property
    @pulumi.getter(name="timeUnpublished")
    def time_unpublished(self) -> Optional[str]:
        return pulumi.get(self, "time_unpublished")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ActionCreateZoneFromZoneFileExternalDownstream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tsigKeyId":
            suggest = "tsig_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileExternalDownstream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileExternalDownstream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileExternalDownstream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 port: Optional[int] = None,
                 tsig_key_id: Optional[str] = None):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param int port: The server's port.
        :param str tsig_key_id: The OCID of the TSIG key.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tsig_key_id is not None:
            pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The server's port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> Optional[str]:
        """
        The OCID of the TSIG key.
        """
        return pulumi.get(self, "tsig_key_id")


@pulumi.output_type
class ActionCreateZoneFromZoneFileExternalMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tsigKeyId":
            suggest = "tsig_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileExternalMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileExternalMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileExternalMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 port: Optional[int] = None,
                 tsig_key_id: Optional[str] = None):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param int port: The server's port.
        :param str tsig_key_id: The OCID of the TSIG key.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tsig_key_id is not None:
            pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The server's port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> Optional[str]:
        """
        The OCID of the TSIG key.
        """
        return pulumi.get(self, "tsig_key_id")


@pulumi.output_type
class ActionCreateZoneFromZoneFileNameserver(dict):
    def __init__(__self__, *,
                 hostname: Optional[str] = None):
        """
        :param str hostname: The hostname of the nameserver.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname of the nameserver.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class ActionCreateZoneFromZoneFileZoneTransferServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isTransferDestination":
            suggest = "is_transfer_destination"
        elif key == "isTransferSource":
            suggest = "is_transfer_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionCreateZoneFromZoneFileZoneTransferServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionCreateZoneFromZoneFileZoneTransferServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionCreateZoneFromZoneFileZoneTransferServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 is_transfer_destination: Optional[bool] = None,
                 is_transfer_source: Optional[bool] = None,
                 port: Optional[int] = None):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param bool is_transfer_destination: A Boolean flag indicating whether or not the server is a zone data transfer destination.
        :param bool is_transfer_source: A Boolean flag indicating whether or not the server is a zone data transfer source.
        :param int port: The server's port.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if is_transfer_destination is not None:
            pulumi.set(__self__, "is_transfer_destination", is_transfer_destination)
        if is_transfer_source is not None:
            pulumi.set(__self__, "is_transfer_source", is_transfer_source)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="isTransferDestination")
    def is_transfer_destination(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not the server is a zone data transfer destination.
        """
        return pulumi.get(self, "is_transfer_destination")

    @property
    @pulumi.getter(name="isTransferSource")
    def is_transfer_source(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not the server is a zone data transfer source.
        """
        return pulumi.get(self, "is_transfer_source")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The server's port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ResolverAttachedView(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewId":
            suggest = "view_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResolverAttachedView. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResolverAttachedView.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResolverAttachedView.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view_id: str):
        """
        :param str view_id: (Updatable) The OCID of the view.
        """
        pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        """
        (Updatable) The OCID of the view.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class ResolverEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "forwardingAddress":
            suggest = "forwarding_address"
        elif key == "isForwarding":
            suggest = "is_forwarding"
        elif key == "isListening":
            suggest = "is_listening"
        elif key == "listeningAddress":
            suggest = "listening_address"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResolverEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResolverEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResolverEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[str] = None,
                 endpoint_type: Optional[str] = None,
                 forwarding_address: Optional[str] = None,
                 is_forwarding: Optional[bool] = None,
                 is_listening: Optional[bool] = None,
                 listening_address: Optional[str] = None,
                 name: Optional[str] = None,
                 self: Optional[str] = None,
                 state: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str compartment_id: (Updatable) The OCID of the owning compartment.
        :param str endpoint_type: The type of resolver endpoint. VNIC is currently the only supported type.
        :param str forwarding_address: An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        :param bool is_forwarding: A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        :param bool is_listening: A Boolean flag indicating whether or not the resolver endpoint is for listening.
        :param str listening_address: An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        :param str name: The name of the resolver endpoint. Must be unique, case-insensitive, within the resolver.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The current state of the resource.
        :param str subnet_id: The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if forwarding_address is not None:
            pulumi.set(__self__, "forwarding_address", forwarding_address)
        if is_forwarding is not None:
            pulumi.set(__self__, "is_forwarding", is_forwarding)
        if is_listening is not None:
            pulumi.set(__self__, "is_listening", is_listening)
        if listening_address is not None:
            pulumi.set(__self__, "listening_address", listening_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if self is not None:
            pulumi.set(__self__, "self", self)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the owning compartment.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        """
        The type of resolver endpoint. VNIC is currently the only supported type.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="forwardingAddress")
    def forwarding_address(self) -> Optional[str]:
        """
        An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        """
        return pulumi.get(self, "forwarding_address")

    @property
    @pulumi.getter(name="isForwarding")
    def is_forwarding(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        """
        return pulumi.get(self, "is_forwarding")

    @property
    @pulumi.getter(name="isListening")
    def is_listening(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for listening.
        """
        return pulumi.get(self, "is_listening")

    @property
    @pulumi.getter(name="listeningAddress")
    def listening_address(self) -> Optional[str]:
        """
        An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        """
        return pulumi.get(self, "listening_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resolver endpoint. Must be unique, case-insensitive, within the resolver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def self(self) -> Optional[str]:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class ResolverRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "sourceEndpointName":
            suggest = "source_endpoint_name"
        elif key == "clientAddressConditions":
            suggest = "client_address_conditions"
        elif key == "qnameCoverConditions":
            suggest = "qname_cover_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResolverRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResolverRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResolverRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 destination_addresses: Sequence[str],
                 source_endpoint_name: str,
                 client_address_conditions: Optional[Sequence[str]] = None,
                 qname_cover_conditions: Optional[Sequence[str]] = None):
        """
        :param str action: (Updatable) The action determines the behavior of the rule. If a query matches a supplied condition, the action will apply. If there are no conditions on the rule, all queries are subject to the specified action.
               * `FORWARD` - Matching requests will be forwarded from the source interface to the destination address.
        :param Sequence[str] destination_addresses: (Updatable) IP addresses to which queries should be forwarded. Currently limited to a single address.
        :param str source_endpoint_name: (Updatable) Case-insensitive name of an endpoint, that is a sub-resource of the resolver, to use as the forwarding interface. The endpoint must have isForwarding set to true.
        :param Sequence[str] client_address_conditions: (Updatable) A list of CIDR blocks. The query must come from a client within one of the blocks in order for the rule action to apply.
        :param Sequence[str] qname_cover_conditions: (Updatable) A list of domain names. The query must be covered by one of the domains in order for the rule action to apply.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "source_endpoint_name", source_endpoint_name)
        if client_address_conditions is not None:
            pulumi.set(__self__, "client_address_conditions", client_address_conditions)
        if qname_cover_conditions is not None:
            pulumi.set(__self__, "qname_cover_conditions", qname_cover_conditions)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Updatable) The action determines the behavior of the rule. If a query matches a supplied condition, the action will apply. If there are no conditions on the rule, all queries are subject to the specified action.
        * `FORWARD` - Matching requests will be forwarded from the source interface to the destination address.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        """
        (Updatable) IP addresses to which queries should be forwarded. Currently limited to a single address.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="sourceEndpointName")
    def source_endpoint_name(self) -> str:
        """
        (Updatable) Case-insensitive name of an endpoint, that is a sub-resource of the resolver, to use as the forwarding interface. The endpoint must have isForwarding set to true.
        """
        return pulumi.get(self, "source_endpoint_name")

    @property
    @pulumi.getter(name="clientAddressConditions")
    def client_address_conditions(self) -> Optional[Sequence[str]]:
        """
        (Updatable) A list of CIDR blocks. The query must come from a client within one of the blocks in order for the rule action to apply.
        """
        return pulumi.get(self, "client_address_conditions")

    @property
    @pulumi.getter(name="qnameCoverConditions")
    def qname_cover_conditions(self) -> Optional[Sequence[str]]:
        """
        (Updatable) A list of domain names. The query must be covered by one of the domains in order for the rule action to apply.
        """
        return pulumi.get(self, "qname_cover_conditions")


@pulumi.output_type
class RrsetItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isProtected":
            suggest = "is_protected"
        elif key == "recordHash":
            suggest = "record_hash"
        elif key == "rrsetVersion":
            suggest = "rrset_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RrsetItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RrsetItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RrsetItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 rdata: str,
                 rtype: str,
                 ttl: int,
                 is_protected: Optional[bool] = None,
                 record_hash: Optional[str] = None,
                 rrset_version: Optional[str] = None):
        """
        :param str domain: The fully qualified domain name where the record can be located.
        :param str rdata: (Updatable) The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        :param str rtype: The type of DNS record, such as A or CNAME. For more information, see [Resource Record (RR) TYPEs](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4).
        :param int ttl: (Updatable) The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        :param str record_hash: A unique identifier for the record within its zone.
        :param str rrset_version: The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "rtype", rtype)
        pulumi.set(__self__, "ttl", ttl)
        if is_protected is not None:
            pulumi.set(__self__, "is_protected", is_protected)
        if record_hash is not None:
            pulumi.set(__self__, "record_hash", record_hash)
        if rrset_version is not None:
            pulumi.set(__self__, "rrset_version", rrset_version)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The fully qualified domain name where the record can be located.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        (Updatable) The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        The type of DNS record, such as A or CNAME. For more information, see [Resource Record (RR) TYPEs](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4).
        """
        return pulumi.get(self, "rtype")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        (Updatable) The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter(name="recordHash")
    def record_hash(self) -> Optional[str]:
        """
        A unique identifier for the record within its zone.
        """
        return pulumi.get(self, "record_hash")

    @property
    @pulumi.getter(name="rrsetVersion")
    def rrset_version(self) -> Optional[str]:
        """
        The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        return pulumi.get(self, "rrset_version")


@pulumi.output_type
class SteeringPolicyAnswer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDisabled":
            suggest = "is_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SteeringPolicyAnswer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SteeringPolicyAnswer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SteeringPolicyAnswer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 rdata: str,
                 rtype: str,
                 is_disabled: Optional[bool] = None,
                 pool: Optional[str] = None):
        """
        :param str name: A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        :param str rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        :param str rtype: The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        :param bool is_disabled: Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        :param str pool: The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "rtype", rtype)
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rtype")

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[bool]:
        """
        Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter
    def pool(self) -> Optional[str]:
        """
        The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        """
        return pulumi.get(self, "pool")


@pulumi.output_type
class SteeringPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "defaultAnswerDatas":
            suggest = "default_answer_datas"
        elif key == "defaultCount":
            suggest = "default_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SteeringPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SteeringPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SteeringPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 cases: Optional[Sequence['outputs.SteeringPolicyRuleCase']] = None,
                 default_answer_datas: Optional[Sequence['outputs.SteeringPolicyRuleDefaultAnswerData']] = None,
                 default_count: Optional[int] = None,
                 description: Optional[str] = None):
        """
        :param str rule_type: The type of a rule determines its sorting/filtering behavior.
               * `FILTER` - Filters the list of answers based on their defined boolean data. Answers remain only if their `shouldKeep` value is `true`.
               * `HEALTH` - Removes answers from the list if their `rdata` matches a target in the health check monitor referenced by the steering policy and the target is reported down.
               * `WEIGHTED` - Uses a number between 0 and 255 to determine how often an answer will be served in relation to other answers. Anwers with a higher weight will be served more frequently.
               * `PRIORITY` - Uses a defined rank value of answers to determine which answer to serve, moving those with the lowest values to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
               * `LIMIT` - Filters answers that are too far down the list. Parameter `defaultCount` specifies how many answers to keep. **Example:** If `defaultCount` has a value of `2` and there are five answers left, when the `LIMIT` rule is processed, only the first two answers will remain in the list.
        :param Sequence['SteeringPolicyRuleCaseArgs'] cases: An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        :param Sequence['SteeringPolicyRuleDefaultAnswerDataArgs'] default_answer_datas: Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        :param int default_count: Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        :param str description: A user-defined description of the rule's purpose or behavior.
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if cases is not None:
            pulumi.set(__self__, "cases", cases)
        if default_answer_datas is not None:
            pulumi.set(__self__, "default_answer_datas", default_answer_datas)
        if default_count is not None:
            pulumi.set(__self__, "default_count", default_count)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of a rule determines its sorting/filtering behavior.
        * `FILTER` - Filters the list of answers based on their defined boolean data. Answers remain only if their `shouldKeep` value is `true`.
        * `HEALTH` - Removes answers from the list if their `rdata` matches a target in the health check monitor referenced by the steering policy and the target is reported down.
        * `WEIGHTED` - Uses a number between 0 and 255 to determine how often an answer will be served in relation to other answers. Anwers with a higher weight will be served more frequently.
        * `PRIORITY` - Uses a defined rank value of answers to determine which answer to serve, moving those with the lowest values to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        * `LIMIT` - Filters answers that are too far down the list. Parameter `defaultCount` specifies how many answers to keep. **Example:** If `defaultCount` has a value of `2` and there are five answers left, when the `LIMIT` rule is processed, only the first two answers will remain in the list.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def cases(self) -> Optional[Sequence['outputs.SteeringPolicyRuleCase']]:
        """
        An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        """
        return pulumi.get(self, "cases")

    @property
    @pulumi.getter(name="defaultAnswerDatas")
    def default_answer_datas(self) -> Optional[Sequence['outputs.SteeringPolicyRuleDefaultAnswerData']]:
        """
        Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        """
        return pulumi.get(self, "default_answer_datas")

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> Optional[int]:
        """
        Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        """
        return pulumi.get(self, "default_count")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A user-defined description of the rule's purpose or behavior.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class SteeringPolicyRuleCase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "answerDatas":
            suggest = "answer_datas"
        elif key == "caseCondition":
            suggest = "case_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SteeringPolicyRuleCase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SteeringPolicyRuleCase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SteeringPolicyRuleCase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 answer_datas: Optional[Sequence['outputs.SteeringPolicyRuleCaseAnswerData']] = None,
                 case_condition: Optional[str] = None,
                 count: Optional[int] = None):
        """
        :param Sequence['SteeringPolicyRuleCaseAnswerDataArgs'] answer_datas: An array of `SteeringPolicyPriorityAnswerData` objects.
        :param str case_condition: An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.address in ('192.0.2.0/24')` to define a case that matches queries from that office.
        :param int count: The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        if answer_datas is not None:
            pulumi.set(__self__, "answer_datas", answer_datas)
        if case_condition is not None:
            pulumi.set(__self__, "case_condition", case_condition)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter(name="answerDatas")
    def answer_datas(self) -> Optional[Sequence['outputs.SteeringPolicyRuleCaseAnswerData']]:
        """
        An array of `SteeringPolicyPriorityAnswerData` objects.
        """
        return pulumi.get(self, "answer_datas")

    @property
    @pulumi.getter(name="caseCondition")
    def case_condition(self) -> Optional[str]:
        """
        An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.address in ('192.0.2.0/24')` to define a case that matches queries from that office.
        """
        return pulumi.get(self, "case_condition")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class SteeringPolicyRuleCaseAnswerData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "answerCondition":
            suggest = "answer_condition"
        elif key == "shouldKeep":
            suggest = "should_keep"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SteeringPolicyRuleCaseAnswerData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SteeringPolicyRuleCaseAnswerData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SteeringPolicyRuleCaseAnswerData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 answer_condition: Optional[str] = None,
                 should_keep: Optional[bool] = None,
                 value: Optional[int] = None):
        """
        :param str answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param bool should_keep: Keeps the answer only if the value is `true`.
        :param int value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        if answer_condition is not None:
            pulumi.set(__self__, "answer_condition", answer_condition)
        if should_keep is not None:
            pulumi.set(__self__, "should_keep", should_keep)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> Optional[str]:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> Optional[bool]:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SteeringPolicyRuleDefaultAnswerData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "answerCondition":
            suggest = "answer_condition"
        elif key == "shouldKeep":
            suggest = "should_keep"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SteeringPolicyRuleDefaultAnswerData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SteeringPolicyRuleDefaultAnswerData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SteeringPolicyRuleDefaultAnswerData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 answer_condition: Optional[str] = None,
                 should_keep: Optional[bool] = None,
                 value: Optional[int] = None):
        """
        :param str answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param bool should_keep: Keeps the answer only if the value is `true`.
        :param int value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        if answer_condition is not None:
            pulumi.set(__self__, "answer_condition", answer_condition)
        if should_keep is not None:
            pulumi.set(__self__, "should_keep", should_keep)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> Optional[str]:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> Optional[bool]:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ZoneDnssecConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kskDnssecKeyVersions":
            suggest = "ksk_dnssec_key_versions"
        elif key == "zskDnssecKeyVersions":
            suggest = "zsk_dnssec_key_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDnssecConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDnssecConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDnssecConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ksk_dnssec_key_versions: Optional[Sequence['outputs.ZoneDnssecConfigKskDnssecKeyVersion']] = None,
                 zsk_dnssec_key_versions: Optional[Sequence['outputs.ZoneDnssecConfigZskDnssecKeyVersion']] = None):
        """
        :param Sequence['ZoneDnssecConfigKskDnssecKeyVersionArgs'] ksk_dnssec_key_versions: A read-only array of key signing key (KSK) versions.
        :param Sequence['ZoneDnssecConfigZskDnssecKeyVersionArgs'] zsk_dnssec_key_versions: A read-only array of zone signing key (ZSK) versions.
        """
        if ksk_dnssec_key_versions is not None:
            pulumi.set(__self__, "ksk_dnssec_key_versions", ksk_dnssec_key_versions)
        if zsk_dnssec_key_versions is not None:
            pulumi.set(__self__, "zsk_dnssec_key_versions", zsk_dnssec_key_versions)

    @property
    @pulumi.getter(name="kskDnssecKeyVersions")
    def ksk_dnssec_key_versions(self) -> Optional[Sequence['outputs.ZoneDnssecConfigKskDnssecKeyVersion']]:
        """
        A read-only array of key signing key (KSK) versions.
        """
        return pulumi.get(self, "ksk_dnssec_key_versions")

    @property
    @pulumi.getter(name="zskDnssecKeyVersions")
    def zsk_dnssec_key_versions(self) -> Optional[Sequence['outputs.ZoneDnssecConfigZskDnssecKeyVersion']]:
        """
        A read-only array of zone signing key (ZSK) versions.
        """
        return pulumi.get(self, "zsk_dnssec_key_versions")


@pulumi.output_type
class ZoneDnssecConfigKskDnssecKeyVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dsDatas":
            suggest = "ds_datas"
        elif key == "keyTag":
            suggest = "key_tag"
        elif key == "lengthInBytes":
            suggest = "length_in_bytes"
        elif key == "predecessorDnssecKeyVersionUuid":
            suggest = "predecessor_dnssec_key_version_uuid"
        elif key == "successorDnssecKeyVersionUuid":
            suggest = "successor_dnssec_key_version_uuid"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeExpired":
            suggest = "time_expired"
        elif key == "timeInactivated":
            suggest = "time_inactivated"
        elif key == "timePromoted":
            suggest = "time_promoted"
        elif key == "timePublished":
            suggest = "time_published"
        elif key == "timeUnpublished":
            suggest = "time_unpublished"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDnssecConfigKskDnssecKeyVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDnssecConfigKskDnssecKeyVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDnssecConfigKskDnssecKeyVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 ds_datas: Optional[Sequence['outputs.ZoneDnssecConfigKskDnssecKeyVersionDsData']] = None,
                 key_tag: Optional[int] = None,
                 length_in_bytes: Optional[int] = None,
                 predecessor_dnssec_key_version_uuid: Optional[str] = None,
                 successor_dnssec_key_version_uuid: Optional[str] = None,
                 time_activated: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_expired: Optional[str] = None,
                 time_inactivated: Optional[str] = None,
                 time_promoted: Optional[str] = None,
                 time_published: Optional[str] = None,
                 time_unpublished: Optional[str] = None,
                 uuid: Optional[str] = None):
        """
        :param str algorithm: The signing algorithm used for the key.
        :param Sequence['ZoneDnssecConfigKskDnssecKeyVersionDsDataArgs'] ds_datas: An array of data for DS records corresponding with this key version. An entry will exist for each supported DS digest algorithm.
        :param int key_tag: The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        :param int length_in_bytes: The length of the corresponding private key in bytes, expressed as an integer.
        :param str predecessor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        :param str successor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        :param str time_activated: The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_expired: The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        :param str time_inactivated: The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str time_promoted: The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        :param str time_published: The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        :param str time_unpublished: The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str uuid: The UUID of the `DnssecKeyVersion`.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if ds_datas is not None:
            pulumi.set(__self__, "ds_datas", ds_datas)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if length_in_bytes is not None:
            pulumi.set(__self__, "length_in_bytes", length_in_bytes)
        if predecessor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "predecessor_dnssec_key_version_uuid", predecessor_dnssec_key_version_uuid)
        if successor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "successor_dnssec_key_version_uuid", successor_dnssec_key_version_uuid)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_expired is not None:
            pulumi.set(__self__, "time_expired", time_expired)
        if time_inactivated is not None:
            pulumi.set(__self__, "time_inactivated", time_inactivated)
        if time_promoted is not None:
            pulumi.set(__self__, "time_promoted", time_promoted)
        if time_published is not None:
            pulumi.set(__self__, "time_published", time_published)
        if time_unpublished is not None:
            pulumi.set(__self__, "time_unpublished", time_unpublished)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        """
        The signing algorithm used for the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="dsDatas")
    def ds_datas(self) -> Optional[Sequence['outputs.ZoneDnssecConfigKskDnssecKeyVersionDsData']]:
        """
        An array of data for DS records corresponding with this key version. An entry will exist for each supported DS digest algorithm.
        """
        return pulumi.get(self, "ds_datas")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[int]:
        """
        The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="lengthInBytes")
    def length_in_bytes(self) -> Optional[int]:
        """
        The length of the corresponding private key in bytes, expressed as an integer.
        """
        return pulumi.get(self, "length_in_bytes")

    @property
    @pulumi.getter(name="predecessorDnssecKeyVersionUuid")
    def predecessor_dnssec_key_version_uuid(self) -> Optional[str]:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        """
        return pulumi.get(self, "predecessor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="successorDnssecKeyVersionUuid")
    def successor_dnssec_key_version_uuid(self) -> Optional[str]:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        """
        return pulumi.get(self, "successor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[str]:
        """
        The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeExpired")
    def time_expired(self) -> Optional[str]:
        """
        The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        """
        return pulumi.get(self, "time_expired")

    @property
    @pulumi.getter(name="timeInactivated")
    def time_inactivated(self) -> Optional[str]:
        """
        The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_inactivated")

    @property
    @pulumi.getter(name="timePromoted")
    def time_promoted(self) -> Optional[str]:
        """
        The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_promoted")

    @property
    @pulumi.getter(name="timePublished")
    def time_published(self) -> Optional[str]:
        """
        The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        """
        return pulumi.get(self, "time_published")

    @property
    @pulumi.getter(name="timeUnpublished")
    def time_unpublished(self) -> Optional[str]:
        """
        The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_unpublished")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        The UUID of the `DnssecKeyVersion`.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ZoneDnssecConfigKskDnssecKeyVersionDsData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digestType":
            suggest = "digest_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDnssecConfigKskDnssecKeyVersionDsData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDnssecConfigKskDnssecKeyVersionDsData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDnssecConfigKskDnssecKeyVersionDsData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digest_type: Optional[str] = None,
                 rdata: Optional[str] = None):
        """
        :param str digest_type: The type of the digest associated with the rdata.
        :param str rdata: Presentation-format DS record data that must be added to the parent zone. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if rdata is not None:
            pulumi.set(__self__, "rdata", rdata)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[str]:
        """
        The type of the digest associated with the rdata.
        """
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def rdata(self) -> Optional[str]:
        """
        Presentation-format DS record data that must be added to the parent zone. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")


@pulumi.output_type
class ZoneDnssecConfigZskDnssecKeyVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyTag":
            suggest = "key_tag"
        elif key == "lengthInBytes":
            suggest = "length_in_bytes"
        elif key == "predecessorDnssecKeyVersionUuid":
            suggest = "predecessor_dnssec_key_version_uuid"
        elif key == "successorDnssecKeyVersionUuid":
            suggest = "successor_dnssec_key_version_uuid"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeExpired":
            suggest = "time_expired"
        elif key == "timeInactivated":
            suggest = "time_inactivated"
        elif key == "timePromoted":
            suggest = "time_promoted"
        elif key == "timePublished":
            suggest = "time_published"
        elif key == "timeUnpublished":
            suggest = "time_unpublished"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDnssecConfigZskDnssecKeyVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDnssecConfigZskDnssecKeyVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDnssecConfigZskDnssecKeyVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 key_tag: Optional[int] = None,
                 length_in_bytes: Optional[int] = None,
                 predecessor_dnssec_key_version_uuid: Optional[str] = None,
                 successor_dnssec_key_version_uuid: Optional[str] = None,
                 time_activated: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_expired: Optional[str] = None,
                 time_inactivated: Optional[str] = None,
                 time_promoted: Optional[str] = None,
                 time_published: Optional[str] = None,
                 time_unpublished: Optional[str] = None,
                 uuid: Optional[str] = None):
        """
        :param str algorithm: The signing algorithm used for the key.
        :param int key_tag: The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        :param int length_in_bytes: The length of the corresponding private key in bytes, expressed as an integer.
        :param str predecessor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        :param str successor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        :param str time_activated: The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_expired: The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        :param str time_inactivated: The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str time_promoted: The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        :param str time_published: The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        :param str time_unpublished: The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str uuid: The UUID of the `DnssecKeyVersion`.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if length_in_bytes is not None:
            pulumi.set(__self__, "length_in_bytes", length_in_bytes)
        if predecessor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "predecessor_dnssec_key_version_uuid", predecessor_dnssec_key_version_uuid)
        if successor_dnssec_key_version_uuid is not None:
            pulumi.set(__self__, "successor_dnssec_key_version_uuid", successor_dnssec_key_version_uuid)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_expired is not None:
            pulumi.set(__self__, "time_expired", time_expired)
        if time_inactivated is not None:
            pulumi.set(__self__, "time_inactivated", time_inactivated)
        if time_promoted is not None:
            pulumi.set(__self__, "time_promoted", time_promoted)
        if time_published is not None:
            pulumi.set(__self__, "time_published", time_published)
        if time_unpublished is not None:
            pulumi.set(__self__, "time_unpublished", time_unpublished)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        """
        The signing algorithm used for the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[int]:
        """
        The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="lengthInBytes")
    def length_in_bytes(self) -> Optional[int]:
        """
        The length of the corresponding private key in bytes, expressed as an integer.
        """
        return pulumi.get(self, "length_in_bytes")

    @property
    @pulumi.getter(name="predecessorDnssecKeyVersionUuid")
    def predecessor_dnssec_key_version_uuid(self) -> Optional[str]:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        """
        return pulumi.get(self, "predecessor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="successorDnssecKeyVersionUuid")
    def successor_dnssec_key_version_uuid(self) -> Optional[str]:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        """
        return pulumi.get(self, "successor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[str]:
        """
        The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeExpired")
    def time_expired(self) -> Optional[str]:
        """
        The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        """
        return pulumi.get(self, "time_expired")

    @property
    @pulumi.getter(name="timeInactivated")
    def time_inactivated(self) -> Optional[str]:
        """
        The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_inactivated")

    @property
    @pulumi.getter(name="timePromoted")
    def time_promoted(self) -> Optional[str]:
        """
        The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_promoted")

    @property
    @pulumi.getter(name="timePublished")
    def time_published(self) -> Optional[str]:
        """
        The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        """
        return pulumi.get(self, "time_published")

    @property
    @pulumi.getter(name="timeUnpublished")
    def time_unpublished(self) -> Optional[str]:
        """
        The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_unpublished")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        The UUID of the `DnssecKeyVersion`.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ZoneExternalDownstream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tsigKeyId":
            suggest = "tsig_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneExternalDownstream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneExternalDownstream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneExternalDownstream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 port: Optional[int] = None,
                 tsig_key_id: Optional[str] = None):
        """
        :param str address: (Updatable) The server's IP address (IPv4 or IPv6).
        :param int port: (Updatable) The server's port. Port value must be a value of 53, otherwise omit the port value.
        :param str tsig_key_id: (Updatable) The OCID of the TSIG key. A TSIG key is used to secure DNS messages (in this case, zone transfers) between two systems that both have the (shared) secret.
        """
        pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tsig_key_id is not None:
            pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        (Updatable) The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        (Updatable) The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the TSIG key. A TSIG key is used to secure DNS messages (in this case, zone transfers) between two systems that both have the (shared) secret.
        """
        return pulumi.get(self, "tsig_key_id")


@pulumi.output_type
class ZoneExternalMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tsigKeyId":
            suggest = "tsig_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneExternalMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneExternalMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneExternalMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 port: Optional[int] = None,
                 tsig_key_id: Optional[str] = None):
        """
        :param str address: (Updatable) The server's IP address (IPv4 or IPv6).
        :param int port: (Updatable) The server's port. Port value must be a value of 53, otherwise omit the port value.
        :param str tsig_key_id: (Updatable) The OCID of the TSIG key.
        """
        pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tsig_key_id is not None:
            pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        (Updatable) The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        (Updatable) The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the TSIG key.
        """
        return pulumi.get(self, "tsig_key_id")


@pulumi.output_type
class ZoneNameserver(dict):
    def __init__(__self__, *,
                 hostname: Optional[str] = None):
        """
        :param str hostname: The hostname of the nameserver.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname of the nameserver.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class ZoneZoneTransferServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isTransferDestination":
            suggest = "is_transfer_destination"
        elif key == "isTransferSource":
            suggest = "is_transfer_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneZoneTransferServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneZoneTransferServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneZoneTransferServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 is_transfer_destination: Optional[bool] = None,
                 is_transfer_source: Optional[bool] = None,
                 port: Optional[int] = None):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param bool is_transfer_destination: A Boolean flag indicating whether or not the server is a zone data transfer destination.
        :param bool is_transfer_source: A Boolean flag indicating whether or not the server is a zone data transfer source.
        :param int port: The server's port.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if is_transfer_destination is not None:
            pulumi.set(__self__, "is_transfer_destination", is_transfer_destination)
        if is_transfer_source is not None:
            pulumi.set(__self__, "is_transfer_source", is_transfer_source)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="isTransferDestination")
    def is_transfer_destination(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not the server is a zone data transfer destination.
        """
        return pulumi.get(self, "is_transfer_destination")

    @property
    @pulumi.getter(name="isTransferSource")
    def is_transfer_source(self) -> Optional[bool]:
        """
        A Boolean flag indicating whether or not the server is a zone data transfer source.
        """
        return pulumi.get(self, "is_transfer_source")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The server's port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRecordsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRecordsRecordResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 is_protected: bool,
                 record_hash: str,
                 rrset_version: str,
                 rtype: str,
                 zone_name_or_id: str,
                 compartment_id: Optional[str] = None,
                 rdata: Optional[str] = None,
                 ttl: Optional[int] = None):
        """
        :param str domain: Search by domain. Will match any record whose domain (case-insensitive) equals the provided value.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        :param str record_hash: A unique identifier for the record within its zone.
        :param str rrset_version: The latest version of the record's zone in which its RRSet differs from the preceding version.
        :param str rtype: Search by record type. Will match any record whose [type](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4) (case-insensitive) equals the provided value.
        :param str zone_name_or_id: The name or OCID of the target zone.
        :param str compartment_id: The OCID of the compartment the zone belongs to.
               
               This parameter is deprecated and should be omitted.
        :param str rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        :param int ttl: The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "is_protected", is_protected)
        pulumi.set(__self__, "record_hash", record_hash)
        pulumi.set(__self__, "rrset_version", rrset_version)
        pulumi.set(__self__, "rtype", rtype)
        pulumi.set(__self__, "zone_name_or_id", zone_name_or_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if rdata is not None:
            pulumi.set(__self__, "rdata", rdata)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The 'oci_dns_record' resource has been deprecated. Please use 'oci_dns_rrset' instead.""")
    def domain(self) -> str:
        """
        Search by domain. Will match any record whose domain (case-insensitive) equals the provided value.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> bool:
        """
        A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter(name="recordHash")
    def record_hash(self) -> str:
        """
        A unique identifier for the record within its zone.
        """
        return pulumi.get(self, "record_hash")

    @property
    @pulumi.getter(name="rrsetVersion")
    def rrset_version(self) -> str:
        """
        The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        return pulumi.get(self, "rrset_version")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The 'oci_dns_record' resource has been deprecated. Please use 'oci_dns_rrset' instead.""")
    def rtype(self) -> str:
        """
        Search by record type. Will match any record whose [type](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4) (case-insensitive) equals the provided value.
        """
        return pulumi.get(self, "rtype")

    @property
    @pulumi.getter(name="zoneNameOrId")
    @_utilities.deprecated("""The 'oci_dns_record' resource has been deprecated. Please use 'oci_dns_rrset' instead.""")
    def zone_name_or_id(self) -> str:
        """
        The name or OCID of the target zone.
        """
        return pulumi.get(self, "zone_name_or_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        The OCID of the compartment the zone belongs to.

        This parameter is deprecated and should be omitted.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def rdata(self) -> Optional[str]:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetResolverAttachedViewResult(dict):
    def __init__(__self__, *,
                 view_id: str):
        """
        :param str view_id: The OCID of the view.
        """
        pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        """
        The OCID of the view.
        """
        return pulumi.get(self, "view_id")


@pulumi.output_type
class GetResolverEndpointResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 endpoint_type: str,
                 forwarding_address: str,
                 is_forwarding: bool,
                 is_listening: bool,
                 listening_address: str,
                 name: str,
                 self: str,
                 state: str,
                 subnet_id: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The OCID of the owning compartment. This will match the resolver that the resolver endpoint is under and will be updated if the resolver's compartment is changed.
        :param str endpoint_type: The type of resolver endpoint. VNIC is currently the only supported type.
        :param str forwarding_address: An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        :param bool is_forwarding: A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        :param bool is_listening: A Boolean flag indicating whether or not the resolver endpoint is for listening.
        :param str listening_address: An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        :param str name: The name of the resolver endpoint. Must be unique, case-insensitive, within the resolver.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The current state of the resource.
        :param str subnet_id: The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        pulumi.set(__self__, "forwarding_address", forwarding_address)
        pulumi.set(__self__, "is_forwarding", is_forwarding)
        pulumi.set(__self__, "is_listening", is_listening)
        pulumi.set(__self__, "listening_address", listening_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the owning compartment. This will match the resolver that the resolver endpoint is under and will be updated if the resolver's compartment is changed.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> str:
        """
        The type of resolver endpoint. VNIC is currently the only supported type.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="forwardingAddress")
    def forwarding_address(self) -> str:
        """
        An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        """
        return pulumi.get(self, "forwarding_address")

    @property
    @pulumi.getter(name="isForwarding")
    def is_forwarding(self) -> bool:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        """
        return pulumi.get(self, "is_forwarding")

    @property
    @pulumi.getter(name="isListening")
    def is_listening(self) -> bool:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for listening.
        """
        return pulumi.get(self, "is_listening")

    @property
    @pulumi.getter(name="listeningAddress")
    def listening_address(self) -> str:
        """
        An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        """
        return pulumi.get(self, "listening_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resolver endpoint. Must be unique, case-insensitive, within the resolver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetResolverEndpointsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of a resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetResolverEndpointsResolverEndpointResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 endpoint_type: str,
                 forwarding_address: str,
                 is_forwarding: bool,
                 is_listening: bool,
                 listening_address: str,
                 name: str,
                 resolver_id: str,
                 self: str,
                 state: str,
                 subnet_id: str,
                 time_created: str,
                 time_updated: str,
                 nsg_ids: Optional[Sequence[str]] = None,
                 scope: Optional[str] = None):
        """
        :param str compartment_id: The OCID of the owning compartment. This will match the resolver that the resolver endpoint is under and will be updated if the resolver's compartment is changed.
        :param str endpoint_type: The type of resolver endpoint. VNIC is currently the only supported type.
        :param str forwarding_address: An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        :param bool is_forwarding: A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        :param bool is_listening: A Boolean flag indicating whether or not the resolver endpoint is for listening.
        :param str listening_address: An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        :param str name: The name of a resource.
        :param str resolver_id: The OCID of the target resolver.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str subnet_id: The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param Sequence[str] nsg_ids: An array of network security group OCIDs for the resolver endpoint. These must be part of the VCN that the resolver endpoint is a part of.
        :param str scope: Value must be `PRIVATE` when listing private name resolver endpoints.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        pulumi.set(__self__, "forwarding_address", forwarding_address)
        pulumi.set(__self__, "is_forwarding", is_forwarding)
        pulumi.set(__self__, "is_listening", is_listening)
        pulumi.set(__self__, "listening_address", listening_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolver_id", resolver_id)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the owning compartment. This will match the resolver that the resolver endpoint is under and will be updated if the resolver's compartment is changed.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> str:
        """
        The type of resolver endpoint. VNIC is currently the only supported type.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="forwardingAddress")
    def forwarding_address(self) -> str:
        """
        An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        """
        return pulumi.get(self, "forwarding_address")

    @property
    @pulumi.getter(name="isForwarding")
    def is_forwarding(self) -> bool:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        """
        return pulumi.get(self, "is_forwarding")

    @property
    @pulumi.getter(name="isListening")
    def is_listening(self) -> bool:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for listening.
        """
        return pulumi.get(self, "is_listening")

    @property
    @pulumi.getter(name="listeningAddress")
    def listening_address(self) -> str:
        """
        An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        """
        return pulumi.get(self, "listening_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolverId")
    def resolver_id(self) -> str:
        """
        The OCID of the target resolver.
        """
        return pulumi.get(self, "resolver_id")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[Sequence[str]]:
        """
        An array of network security group OCIDs for the resolver endpoint. These must be part of the VCN that the resolver endpoint is a part of.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Value must be `PRIVATE` when listing private name resolver endpoints.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetResolverRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 client_address_conditions: Sequence[str],
                 destination_addresses: Sequence[str],
                 qname_cover_conditions: Sequence[str],
                 source_endpoint_name: str):
        """
        :param str action: The action determines the behavior of the rule. If a query matches a supplied condition, the action will apply. If there are no conditions on the rule, all queries are subject to the specified action.
               * `FORWARD` - Matching requests will be forwarded from the source interface to the destination address.
        :param Sequence[str] client_address_conditions: A list of CIDR blocks. The query must come from a client within one of the blocks in order for the rule action to apply.
        :param Sequence[str] destination_addresses: IP addresses to which queries should be forwarded. Currently limited to a single address.
        :param Sequence[str] qname_cover_conditions: A list of domain names. The query must be covered by one of the domains in order for the rule action to apply.
        :param str source_endpoint_name: Case-insensitive name of an endpoint, that is a sub-resource of the resolver, to use as the forwarding interface. The endpoint must have isForwarding set to true.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "client_address_conditions", client_address_conditions)
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "qname_cover_conditions", qname_cover_conditions)
        pulumi.set(__self__, "source_endpoint_name", source_endpoint_name)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action determines the behavior of the rule. If a query matches a supplied condition, the action will apply. If there are no conditions on the rule, all queries are subject to the specified action.
        * `FORWARD` - Matching requests will be forwarded from the source interface to the destination address.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="clientAddressConditions")
    def client_address_conditions(self) -> Sequence[str]:
        """
        A list of CIDR blocks. The query must come from a client within one of the blocks in order for the rule action to apply.
        """
        return pulumi.get(self, "client_address_conditions")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        """
        IP addresses to which queries should be forwarded. Currently limited to a single address.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="qnameCoverConditions")
    def qname_cover_conditions(self) -> Sequence[str]:
        """
        A list of domain names. The query must be covered by one of the domains in order for the rule action to apply.
        """
        return pulumi.get(self, "qname_cover_conditions")

    @property
    @pulumi.getter(name="sourceEndpointName")
    def source_endpoint_name(self) -> str:
        """
        Case-insensitive name of an endpoint, that is a sub-resource of the resolver, to use as the forwarding interface. The endpoint must have isForwarding set to true.
        """
        return pulumi.get(self, "source_endpoint_name")


@pulumi.output_type
class GetResolversFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetResolversResolverResult(dict):
    def __init__(__self__, *,
                 attached_vcn_id: str,
                 attached_views: Sequence['outputs.GetResolversResolverAttachedViewResult'],
                 compartment_id: str,
                 default_view_id: str,
                 defined_tags: Mapping[str, str],
                 display_name: str,
                 endpoints: Sequence['outputs.GetResolversResolverEndpointResult'],
                 freeform_tags: Mapping[str, str],
                 id: str,
                 is_protected: bool,
                 resolver_id: str,
                 rules: Sequence['outputs.GetResolversResolverRuleResult'],
                 scope: str,
                 self: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str attached_vcn_id: The OCID of the attached VCN.
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param str default_view_id: The OCID of the default view.
        :param Mapping[str, str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The displayName of a resource.
        :param Mapping[str, str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str id: The OCID of a resource.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the resource are unable to be explicitly managed.
        :param str scope: Value must be `PRIVATE` when listing private name resolvers.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        pulumi.set(__self__, "attached_vcn_id", attached_vcn_id)
        pulumi.set(__self__, "attached_views", attached_views)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "default_view_id", default_view_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_protected", is_protected)
        pulumi.set(__self__, "resolver_id", resolver_id)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="attachedVcnId")
    def attached_vcn_id(self) -> str:
        """
        The OCID of the attached VCN.
        """
        return pulumi.get(self, "attached_vcn_id")

    @property
    @pulumi.getter(name="attachedViews")
    def attached_views(self) -> Sequence['outputs.GetResolversResolverAttachedViewResult']:
        return pulumi.get(self, "attached_views")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="defaultViewId")
    def default_view_id(self) -> str:
        """
        The OCID of the default view.
        """
        return pulumi.get(self, "default_view_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The displayName of a resource.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetResolversResolverEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of a resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> bool:
        """
        A Boolean flag indicating whether or not parts of the resource are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter(name="resolverId")
    def resolver_id(self) -> str:
        return pulumi.get(self, "resolver_id")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetResolversResolverRuleResult']:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Value must be `PRIVATE` when listing private name resolvers.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetResolversResolverAttachedViewResult(dict):
    def __init__(__self__, *,
                 view_id: str):
        pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        return pulumi.get(self, "view_id")


@pulumi.output_type
class GetResolversResolverEndpointResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 endpoint_type: str,
                 forwarding_address: str,
                 is_forwarding: bool,
                 is_listening: bool,
                 listening_address: str,
                 name: str,
                 self: str,
                 state: str,
                 subnet_id: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        pulumi.set(__self__, "forwarding_address", forwarding_address)
        pulumi.set(__self__, "is_forwarding", is_forwarding)
        pulumi.set(__self__, "is_listening", is_listening)
        pulumi.set(__self__, "listening_address", listening_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> str:
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="forwardingAddress")
    def forwarding_address(self) -> str:
        return pulumi.get(self, "forwarding_address")

    @property
    @pulumi.getter(name="isForwarding")
    def is_forwarding(self) -> bool:
        return pulumi.get(self, "is_forwarding")

    @property
    @pulumi.getter(name="isListening")
    def is_listening(self) -> bool:
        return pulumi.get(self, "is_listening")

    @property
    @pulumi.getter(name="listeningAddress")
    def listening_address(self) -> str:
        return pulumi.get(self, "listening_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetResolversResolverRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 client_address_conditions: Sequence[str],
                 destination_addresses: Sequence[str],
                 qname_cover_conditions: Sequence[str],
                 source_endpoint_name: str):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "client_address_conditions", client_address_conditions)
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "qname_cover_conditions", qname_cover_conditions)
        pulumi.set(__self__, "source_endpoint_name", source_endpoint_name)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="clientAddressConditions")
    def client_address_conditions(self) -> Sequence[str]:
        return pulumi.get(self, "client_address_conditions")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="qnameCoverConditions")
    def qname_cover_conditions(self) -> Sequence[str]:
        return pulumi.get(self, "qname_cover_conditions")

    @property
    @pulumi.getter(name="sourceEndpointName")
    def source_endpoint_name(self) -> str:
        return pulumi.get(self, "source_endpoint_name")


@pulumi.output_type
class GetRrsetItemResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 is_protected: bool,
                 rdata: str,
                 record_hash: str,
                 rrset_version: str,
                 rtype: str,
                 ttl: int):
        """
        :param str domain: The target fully-qualified domain name (FQDN) within the target zone.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        :param str rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        :param str record_hash: A unique identifier for the record within its zone.
        :param str rrset_version: The latest version of the record's zone in which its RRSet differs from the preceding version.
        :param str rtype: The type of the target RRSet within the target zone.
        :param int ttl: The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "is_protected", is_protected)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "record_hash", record_hash)
        pulumi.set(__self__, "rrset_version", rrset_version)
        pulumi.set(__self__, "rtype", rtype)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The target fully-qualified domain name (FQDN) within the target zone.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> bool:
        """
        A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter(name="recordHash")
    def record_hash(self) -> str:
        """
        A unique identifier for the record within its zone.
        """
        return pulumi.get(self, "record_hash")

    @property
    @pulumi.getter(name="rrsetVersion")
    def rrset_version(self) -> str:
        """
        The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        return pulumi.get(self, "rrset_version")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        The type of the target RRSet within the target zone.
        """
        return pulumi.get(self, "rtype")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetRrsetsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRrsetsRrsetResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 items: Sequence['outputs.GetRrsetsRrsetItemResult'],
                 rtype: str):
        """
        :param str domain: The target fully-qualified domain name (FQDN) within the target zone.
        :param str rtype: Search by record type. Will match any record whose [type](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4) (case-insensitive) equals the provided value.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "rtype", rtype)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The target fully-qualified domain name (FQDN) within the target zone.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetRrsetsRrsetItemResult']:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        Search by record type. Will match any record whose [type](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4) (case-insensitive) equals the provided value.
        """
        return pulumi.get(self, "rtype")


@pulumi.output_type
class GetRrsetsRrsetItemResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 is_protected: bool,
                 rdata: str,
                 record_hash: str,
                 rrset_version: str,
                 rtype: str,
                 ttl: int):
        """
        :param str domain: The target fully-qualified domain name (FQDN) within the target zone.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        :param str rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        :param str record_hash: A unique identifier for the record within its zone.
        :param str rrset_version: The latest version of the record's zone in which its RRSet differs from the preceding version.
        :param str rtype: Search by record type. Will match any record whose [type](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4) (case-insensitive) equals the provided value.
        :param int ttl: The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "is_protected", is_protected)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "record_hash", record_hash)
        pulumi.set(__self__, "rrset_version", rrset_version)
        pulumi.set(__self__, "rtype", rtype)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The target fully-qualified domain name (FQDN) within the target zone.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> bool:
        """
        A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter(name="recordHash")
    def record_hash(self) -> str:
        """
        A unique identifier for the record within its zone.
        """
        return pulumi.get(self, "record_hash")

    @property
    @pulumi.getter(name="rrsetVersion")
    def rrset_version(self) -> str:
        """
        The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        return pulumi.get(self, "rrset_version")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        Search by record type. Will match any record whose [type](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4) (case-insensitive) equals the provided value.
        """
        return pulumi.get(self, "rtype")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The Time To Live for the record, in seconds. Using a TTL lower than 30 seconds is not recommended.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetSteeringPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSteeringPoliciesSteeringPolicyResult(dict):
    def __init__(__self__, *,
                 answers: Sequence['outputs.GetSteeringPoliciesSteeringPolicyAnswerResult'],
                 compartment_id: str,
                 defined_tags: Mapping[str, str],
                 display_name: str,
                 freeform_tags: Mapping[str, str],
                 health_check_monitor_id: str,
                 id: str,
                 rules: Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleResult'],
                 self: str,
                 state: str,
                 template: str,
                 time_created: str,
                 ttl: int):
        """
        :param Sequence['GetSteeringPoliciesSteeringPolicyAnswerArgs'] answers: The set of all answers that can potentially issue from the steering policy.
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param Mapping[str, str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The displayName of a resource.
        :param Mapping[str, str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str health_check_monitor_id: Search by health check monitor OCID. Will match any resource whose health check monitor ID matches the provided value.
        :param str id: The OCID of a resource.
        :param Sequence['GetSteeringPoliciesSteeringPolicyRuleArgs'] rules: The series of rules that will be processed in sequence to reduce the pool of answers to a response for any given request.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str template: Search by steering template type. Will match any resource whose template type matches the provided value.
        :param str time_created: The date and time the resource was created, expressed in RFC 3339 timestamp format.
        :param int ttl: The Time To Live (TTL) for responses from the steering policy, in seconds. If not specified during creation, a value of 30 seconds will be used.
        """
        pulumi.set(__self__, "answers", answers)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "health_check_monitor_id", health_check_monitor_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def answers(self) -> Sequence['outputs.GetSteeringPoliciesSteeringPolicyAnswerResult']:
        """
        The set of all answers that can potentially issue from the steering policy.
        """
        return pulumi.get(self, "answers")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The displayName of a resource.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="healthCheckMonitorId")
    def health_check_monitor_id(self) -> str:
        """
        Search by health check monitor OCID. Will match any resource whose health check monitor ID matches the provided value.
        """
        return pulumi.get(self, "health_check_monitor_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of a resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleResult']:
        """
        The series of rules that will be processed in sequence to reduce the pool of answers to a response for any given request.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        Search by steering template type. Will match any resource whose template type matches the provided value.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The Time To Live (TTL) for responses from the steering policy, in seconds. If not specified during creation, a value of 30 seconds will be used.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetSteeringPoliciesSteeringPolicyAnswerResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 name: str,
                 pool: str,
                 rdata: str,
                 rtype: str):
        """
        :param bool is_disabled: Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        :param str name: A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        :param str pool: The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        :param str rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        :param str rtype: The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pool", pool)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "rtype", rtype)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rtype")


@pulumi.output_type
class GetSteeringPoliciesSteeringPolicyRuleResult(dict):
    def __init__(__self__, *,
                 cases: Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleCaseResult'],
                 default_answer_datas: Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleDefaultAnswerDataResult'],
                 default_count: int,
                 description: str,
                 rule_type: str):
        """
        :param Sequence['GetSteeringPoliciesSteeringPolicyRuleCaseArgs'] cases: An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        :param Sequence['GetSteeringPoliciesSteeringPolicyRuleDefaultAnswerDataArgs'] default_answer_datas: Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        :param int default_count: Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        :param str description: A user-defined description of the rule's purpose or behavior.
        :param str rule_type: The type of a rule determines its sorting/filtering behavior.
               * `FILTER` - Filters the list of answers based on their defined boolean data. Answers remain only if their `shouldKeep` value is `true`.
               * `HEALTH` - Removes answers from the list if their `rdata` matches a target in the health check monitor referenced by the steering policy and the target is reported down.
               * `WEIGHTED` - Uses a number between 0 and 255 to determine how often an answer will be served in relation to other answers. Anwers with a higher weight will be served more frequently.
               * `PRIORITY` - Uses a defined rank value of answers to determine which answer to serve, moving those with the lowest values to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
               * `LIMIT` - Filters answers that are too far down the list. Parameter `defaultCount` specifies how many answers to keep. **Example:** If `defaultCount` has a value of `2` and there are five answers left, when the `LIMIT` rule is processed, only the first two answers will remain in the list.
        """
        pulumi.set(__self__, "cases", cases)
        pulumi.set(__self__, "default_answer_datas", default_answer_datas)
        pulumi.set(__self__, "default_count", default_count)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def cases(self) -> Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleCaseResult']:
        """
        An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        """
        return pulumi.get(self, "cases")

    @property
    @pulumi.getter(name="defaultAnswerDatas")
    def default_answer_datas(self) -> Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleDefaultAnswerDataResult']:
        """
        Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        """
        return pulumi.get(self, "default_answer_datas")

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> int:
        """
        Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        """
        return pulumi.get(self, "default_count")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A user-defined description of the rule's purpose or behavior.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of a rule determines its sorting/filtering behavior.
        * `FILTER` - Filters the list of answers based on their defined boolean data. Answers remain only if their `shouldKeep` value is `true`.
        * `HEALTH` - Removes answers from the list if their `rdata` matches a target in the health check monitor referenced by the steering policy and the target is reported down.
        * `WEIGHTED` - Uses a number between 0 and 255 to determine how often an answer will be served in relation to other answers. Anwers with a higher weight will be served more frequently.
        * `PRIORITY` - Uses a defined rank value of answers to determine which answer to serve, moving those with the lowest values to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        * `LIMIT` - Filters answers that are too far down the list. Parameter `defaultCount` specifies how many answers to keep. **Example:** If `defaultCount` has a value of `2` and there are five answers left, when the `LIMIT` rule is processed, only the first two answers will remain in the list.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class GetSteeringPoliciesSteeringPolicyRuleCaseResult(dict):
    def __init__(__self__, *,
                 answer_datas: Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleCaseAnswerDataResult'],
                 case_condition: str,
                 count: int):
        """
        :param Sequence['GetSteeringPoliciesSteeringPolicyRuleCaseAnswerDataArgs'] answer_datas: An array of `SteeringPolicyPriorityAnswerData` objects.
        :param str case_condition: An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.address in ('192.0.2.0/24')` to define a case that matches queries from that office.
        :param int count: The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        pulumi.set(__self__, "answer_datas", answer_datas)
        pulumi.set(__self__, "case_condition", case_condition)
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter(name="answerDatas")
    def answer_datas(self) -> Sequence['outputs.GetSteeringPoliciesSteeringPolicyRuleCaseAnswerDataResult']:
        """
        An array of `SteeringPolicyPriorityAnswerData` objects.
        """
        return pulumi.get(self, "answer_datas")

    @property
    @pulumi.getter(name="caseCondition")
    def case_condition(self) -> str:
        """
        An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.address in ('192.0.2.0/24')` to define a case that matches queries from that office.
        """
        return pulumi.get(self, "case_condition")

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class GetSteeringPoliciesSteeringPolicyRuleCaseAnswerDataResult(dict):
    def __init__(__self__, *,
                 answer_condition: str,
                 should_keep: bool,
                 value: int):
        """
        :param str answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param bool should_keep: Keeps the answer only if the value is `true`.
        :param int value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        pulumi.set(__self__, "answer_condition", answer_condition)
        pulumi.set(__self__, "should_keep", should_keep)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> str:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> bool:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSteeringPoliciesSteeringPolicyRuleDefaultAnswerDataResult(dict):
    def __init__(__self__, *,
                 answer_condition: str,
                 should_keep: bool,
                 value: int):
        """
        :param str answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param bool should_keep: Keeps the answer only if the value is `true`.
        :param int value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        pulumi.set(__self__, "answer_condition", answer_condition)
        pulumi.set(__self__, "should_keep", should_keep)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> str:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> bool:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSteeringPolicyAnswerResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 name: str,
                 pool: str,
                 rdata: str,
                 rtype: str):
        """
        :param bool is_disabled: Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        :param str name: A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        :param str pool: The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        :param str rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        :param str rtype: The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        pulumi.set(__self__, "is_disabled", is_disabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pool", pool)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "rtype", rtype)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter
    def rtype(self) -> str:
        """
        The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rtype")


@pulumi.output_type
class GetSteeringPolicyAttachmentsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSteeringPolicyAttachmentsSteeringPolicyAttachmentResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 display_name: str,
                 domain_name: str,
                 id: str,
                 rtypes: Sequence[str],
                 self: str,
                 state: str,
                 steering_policy_id: str,
                 time_created: str,
                 zone_id: str):
        """
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param str display_name: The displayName of a resource.
        :param str domain_name: The attached domain within the attached zone.
        :param str id: The OCID of a resource.
        :param Sequence[str] rtypes: The record types covered by the attachment at the domain. The set of record types is determined by aggregating the record types from the answers defined in the steering policy.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str steering_policy_id: Search by steering policy OCID. Will match any resource whose steering policy ID matches the provided value.
        :param str time_created: The date and time the resource was created, expressed in RFC 3339 timestamp format.
        :param str zone_id: Search by zone OCID. Will match any resource whose zone ID matches the provided value.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "rtypes", rtypes)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "steering_policy_id", steering_policy_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The displayName of a resource.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The attached domain within the attached zone.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of a resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def rtypes(self) -> Sequence[str]:
        """
        The record types covered by the attachment at the domain. The set of record types is determined by aggregating the record types from the answers defined in the steering policy.
        """
        return pulumi.get(self, "rtypes")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="steeringPolicyId")
    def steering_policy_id(self) -> str:
        """
        Search by steering policy OCID. Will match any resource whose steering policy ID matches the provided value.
        """
        return pulumi.get(self, "steering_policy_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Search by zone OCID. Will match any resource whose zone ID matches the provided value.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetSteeringPolicyRuleResult(dict):
    def __init__(__self__, *,
                 cases: Sequence['outputs.GetSteeringPolicyRuleCaseResult'],
                 default_answer_datas: Sequence['outputs.GetSteeringPolicyRuleDefaultAnswerDataResult'],
                 default_count: int,
                 description: str,
                 rule_type: str):
        """
        :param Sequence['GetSteeringPolicyRuleCaseArgs'] cases: An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        :param Sequence['GetSteeringPolicyRuleDefaultAnswerDataArgs'] default_answer_datas: Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        :param int default_count: Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        :param str description: A user-defined description of the rule's purpose or behavior.
        :param str rule_type: The type of a rule determines its sorting/filtering behavior.
               * `FILTER` - Filters the list of answers based on their defined boolean data. Answers remain only if their `shouldKeep` value is `true`.
               * `HEALTH` - Removes answers from the list if their `rdata` matches a target in the health check monitor referenced by the steering policy and the target is reported down.
               * `WEIGHTED` - Uses a number between 0 and 255 to determine how often an answer will be served in relation to other answers. Anwers with a higher weight will be served more frequently.
               * `PRIORITY` - Uses a defined rank value of answers to determine which answer to serve, moving those with the lowest values to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
               * `LIMIT` - Filters answers that are too far down the list. Parameter `defaultCount` specifies how many answers to keep. **Example:** If `defaultCount` has a value of `2` and there are five answers left, when the `LIMIT` rule is processed, only the first two answers will remain in the list.
        """
        pulumi.set(__self__, "cases", cases)
        pulumi.set(__self__, "default_answer_datas", default_answer_datas)
        pulumi.set(__self__, "default_count", default_count)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def cases(self) -> Sequence['outputs.GetSteeringPolicyRuleCaseResult']:
        """
        An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        """
        return pulumi.get(self, "cases")

    @property
    @pulumi.getter(name="defaultAnswerDatas")
    def default_answer_datas(self) -> Sequence['outputs.GetSteeringPolicyRuleDefaultAnswerDataResult']:
        """
        Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        """
        return pulumi.get(self, "default_answer_datas")

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> int:
        """
        Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        """
        return pulumi.get(self, "default_count")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A user-defined description of the rule's purpose or behavior.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of a rule determines its sorting/filtering behavior.
        * `FILTER` - Filters the list of answers based on their defined boolean data. Answers remain only if their `shouldKeep` value is `true`.
        * `HEALTH` - Removes answers from the list if their `rdata` matches a target in the health check monitor referenced by the steering policy and the target is reported down.
        * `WEIGHTED` - Uses a number between 0 and 255 to determine how often an answer will be served in relation to other answers. Anwers with a higher weight will be served more frequently.
        * `PRIORITY` - Uses a defined rank value of answers to determine which answer to serve, moving those with the lowest values to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        * `LIMIT` - Filters answers that are too far down the list. Parameter `defaultCount` specifies how many answers to keep. **Example:** If `defaultCount` has a value of `2` and there are five answers left, when the `LIMIT` rule is processed, only the first two answers will remain in the list.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class GetSteeringPolicyRuleCaseResult(dict):
    def __init__(__self__, *,
                 answer_datas: Sequence['outputs.GetSteeringPolicyRuleCaseAnswerDataResult'],
                 case_condition: str,
                 count: int):
        """
        :param Sequence['GetSteeringPolicyRuleCaseAnswerDataArgs'] answer_datas: An array of `SteeringPolicyPriorityAnswerData` objects.
        :param str case_condition: An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.address in ('192.0.2.0/24')` to define a case that matches queries from that office.
        :param int count: The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        pulumi.set(__self__, "answer_datas", answer_datas)
        pulumi.set(__self__, "case_condition", case_condition)
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter(name="answerDatas")
    def answer_datas(self) -> Sequence['outputs.GetSteeringPolicyRuleCaseAnswerDataResult']:
        """
        An array of `SteeringPolicyPriorityAnswerData` objects.
        """
        return pulumi.get(self, "answer_datas")

    @property
    @pulumi.getter(name="caseCondition")
    def case_condition(self) -> str:
        """
        An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.address in ('192.0.2.0/24')` to define a case that matches queries from that office.
        """
        return pulumi.get(self, "case_condition")

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class GetSteeringPolicyRuleCaseAnswerDataResult(dict):
    def __init__(__self__, *,
                 answer_condition: str,
                 should_keep: bool,
                 value: int):
        """
        :param str answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param bool should_keep: Keeps the answer only if the value is `true`.
        :param int value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        pulumi.set(__self__, "answer_condition", answer_condition)
        pulumi.set(__self__, "should_keep", should_keep)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> str:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> bool:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSteeringPolicyRuleDefaultAnswerDataResult(dict):
    def __init__(__self__, *,
                 answer_condition: str,
                 should_keep: bool,
                 value: int):
        """
        :param str answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param bool should_keep: Keeps the answer only if the value is `true`.
        :param int value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        pulumi.set(__self__, "answer_condition", answer_condition)
        pulumi.set(__self__, "should_keep", should_keep)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> str:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> bool:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTsigKeysFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of a resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetTsigKeysTsigKeyResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, str],
                 freeform_tags: Mapping[str, str],
                 id: str,
                 name: str,
                 secret: str,
                 self: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str algorithm: TSIG key algorithms are encoded as domain names, but most consist of only one non-empty label, which is not required to be explicitly absolute. Applicable algorithms include: hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha512. For more information on these algorithms, see [RFC 4635](https://tools.ietf.org/html/rfc4635#section-2).
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param Mapping[str, str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str id: The OCID of a resource.
        :param str name: The name of a resource.
        :param str secret: A base64 string encoding the binary shared secret.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str time_created: The date and time the resource was created, expressed in RFC 3339 timestamp format.
        :param str time_updated: The date and time the resource was last updated, expressed in RFC 3339 timestamp format.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        TSIG key algorithms are encoded as domain names, but most consist of only one non-empty label, which is not required to be explicitly absolute. Applicable algorithms include: hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha512. For more information on these algorithms, see [RFC 4635](https://tools.ietf.org/html/rfc4635#section-2).
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of a resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        A base64 string encoding the binary shared secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the resource was last updated, expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetViewsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetViewsViewResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, str],
                 display_name: str,
                 freeform_tags: Mapping[str, str],
                 id: str,
                 is_protected: bool,
                 scope: str,
                 self: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param Mapping[str, str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The displayName of a resource.
        :param Mapping[str, str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str id: The OCID of a resource.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the resource are unable to be explicitly managed.
        :param str scope: Value must be `PRIVATE` when listing private views.
        :param str self: The canonical absolute URL of the resource.
        :param str state: The state of a resource.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_protected", is_protected)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The displayName of a resource.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of a resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> bool:
        """
        A Boolean flag indicating whether or not parts of the resource are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Value must be `PRIVATE` when listing private views.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetZonesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A case-sensitive filter for zone names. Will match any zone with a name that equals the provided value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A case-sensitive filter for zone names. Will match any zone with a name that equals the provided value.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, str],
                 dnssec_configs: Sequence['outputs.GetZonesZoneDnssecConfigResult'],
                 dnssec_state: str,
                 external_downstreams: Sequence['outputs.GetZonesZoneExternalDownstreamResult'],
                 external_masters: Sequence['outputs.GetZonesZoneExternalMasterResult'],
                 freeform_tags: Mapping[str, str],
                 id: str,
                 is_protected: bool,
                 name: str,
                 nameservers: Sequence['outputs.GetZonesZoneNameserverResult'],
                 scope: str,
                 self: str,
                 serial: int,
                 state: str,
                 time_created: str,
                 version: str,
                 view_id: str,
                 zone_transfer_servers: Sequence['outputs.GetZonesZoneZoneTransferServerResult'],
                 zone_type: str):
        """
        :param str compartment_id: The OCID of the compartment the resource belongs to.
        :param Mapping[str, str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Sequence['GetZonesZoneDnssecConfigArgs'] dnssec_configs: DNSSEC configuration data.
        :param str dnssec_state: Search for zones that have the given `DnssecState`.
        :param Sequence['GetZonesZoneExternalDownstreamArgs'] external_downstreams: External secondary servers for the zone. This field is currently not supported when `zoneType` is `SECONDARY` or `scope` is `PRIVATE`.
        :param Sequence['GetZonesZoneExternalMasterArgs'] external_masters: External master servers for the zone. `externalMasters` becomes a required parameter when the `zoneType` value is `SECONDARY`.
        :param Mapping[str, str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str id: The OCID of the zone.
        :param bool is_protected: A Boolean flag indicating whether or not parts of the resource are unable to be explicitly managed.
        :param str name: A case-sensitive filter for zone names. Will match any zone with a name that equals the provided value.
        :param Sequence['GetZonesZoneNameserverArgs'] nameservers: The authoritative nameservers for the zone.
        :param str scope: Specifies to operate only on resources that have a matching DNS scope.
        :param str self: The canonical absolute URL of the resource.
        :param int serial: The current serial of the zone. As seen in the zone's SOA record.
        :param str state: The state of a resource.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str version: Version is the never-repeating, totally-orderable, version of the zone, from which the serial field of the zone's SOA record is derived.
        :param str view_id: The OCID of the view the resource is associated with.
        :param Sequence['GetZonesZoneZoneTransferServerArgs'] zone_transfer_servers: The Oracle Cloud Infrastructure nameservers that transfer the zone data with external nameservers.
        :param str zone_type: Search by zone type, `PRIMARY` or `SECONDARY`. Will match any zone whose type equals the provided value.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "dnssec_configs", dnssec_configs)
        pulumi.set(__self__, "dnssec_state", dnssec_state)
        pulumi.set(__self__, "external_downstreams", external_downstreams)
        pulumi.set(__self__, "external_masters", external_masters)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_protected", is_protected)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nameservers", nameservers)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "view_id", view_id)
        pulumi.set(__self__, "zone_transfer_servers", zone_transfer_servers)
        pulumi.set(__self__, "zone_type", zone_type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="dnssecConfigs")
    def dnssec_configs(self) -> Sequence['outputs.GetZonesZoneDnssecConfigResult']:
        """
        DNSSEC configuration data.
        """
        return pulumi.get(self, "dnssec_configs")

    @property
    @pulumi.getter(name="dnssecState")
    def dnssec_state(self) -> str:
        """
        Search for zones that have the given `DnssecState`.
        """
        return pulumi.get(self, "dnssec_state")

    @property
    @pulumi.getter(name="externalDownstreams")
    def external_downstreams(self) -> Sequence['outputs.GetZonesZoneExternalDownstreamResult']:
        """
        External secondary servers for the zone. This field is currently not supported when `zoneType` is `SECONDARY` or `scope` is `PRIVATE`.
        """
        return pulumi.get(self, "external_downstreams")

    @property
    @pulumi.getter(name="externalMasters")
    def external_masters(self) -> Sequence['outputs.GetZonesZoneExternalMasterResult']:
        """
        External master servers for the zone. `externalMasters` becomes a required parameter when the `zoneType` value is `SECONDARY`.
        """
        return pulumi.get(self, "external_masters")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the zone.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> bool:
        """
        A Boolean flag indicating whether or not parts of the resource are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A case-sensitive filter for zone names. Will match any zone with a name that equals the provided value.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nameservers(self) -> Sequence['outputs.GetZonesZoneNameserverResult']:
        """
        The authoritative nameservers for the zone.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Specifies to operate only on resources that have a matching DNS scope.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def self(self) -> str:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @property
    @pulumi.getter
    def serial(self) -> int:
        """
        The current serial of the zone. As seen in the zone's SOA record.
        """
        return pulumi.get(self, "serial")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of a resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version is the never-repeating, totally-orderable, version of the zone, from which the serial field of the zone's SOA record is derived.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        """
        The OCID of the view the resource is associated with.
        """
        return pulumi.get(self, "view_id")

    @property
    @pulumi.getter(name="zoneTransferServers")
    def zone_transfer_servers(self) -> Sequence['outputs.GetZonesZoneZoneTransferServerResult']:
        """
        The Oracle Cloud Infrastructure nameservers that transfer the zone data with external nameservers.
        """
        return pulumi.get(self, "zone_transfer_servers")

    @property
    @pulumi.getter(name="zoneType")
    def zone_type(self) -> str:
        """
        Search by zone type, `PRIMARY` or `SECONDARY`. Will match any zone whose type equals the provided value.
        """
        return pulumi.get(self, "zone_type")


@pulumi.output_type
class GetZonesZoneDnssecConfigResult(dict):
    def __init__(__self__, *,
                 ksk_dnssec_key_versions: Sequence['outputs.GetZonesZoneDnssecConfigKskDnssecKeyVersionResult'],
                 zsk_dnssec_key_versions: Sequence['outputs.GetZonesZoneDnssecConfigZskDnssecKeyVersionResult']):
        """
        :param Sequence['GetZonesZoneDnssecConfigKskDnssecKeyVersionArgs'] ksk_dnssec_key_versions: A read-only array of key signing key (KSK) versions.
        :param Sequence['GetZonesZoneDnssecConfigZskDnssecKeyVersionArgs'] zsk_dnssec_key_versions: A read-only array of zone signing key (ZSK) versions.
        """
        pulumi.set(__self__, "ksk_dnssec_key_versions", ksk_dnssec_key_versions)
        pulumi.set(__self__, "zsk_dnssec_key_versions", zsk_dnssec_key_versions)

    @property
    @pulumi.getter(name="kskDnssecKeyVersions")
    def ksk_dnssec_key_versions(self) -> Sequence['outputs.GetZonesZoneDnssecConfigKskDnssecKeyVersionResult']:
        """
        A read-only array of key signing key (KSK) versions.
        """
        return pulumi.get(self, "ksk_dnssec_key_versions")

    @property
    @pulumi.getter(name="zskDnssecKeyVersions")
    def zsk_dnssec_key_versions(self) -> Sequence['outputs.GetZonesZoneDnssecConfigZskDnssecKeyVersionResult']:
        """
        A read-only array of zone signing key (ZSK) versions.
        """
        return pulumi.get(self, "zsk_dnssec_key_versions")


@pulumi.output_type
class GetZonesZoneDnssecConfigKskDnssecKeyVersionResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 ds_datas: Sequence['outputs.GetZonesZoneDnssecConfigKskDnssecKeyVersionDsDataResult'],
                 key_tag: int,
                 length_in_bytes: int,
                 predecessor_dnssec_key_version_uuid: str,
                 successor_dnssec_key_version_uuid: str,
                 time_activated: str,
                 time_created: str,
                 time_expired: str,
                 time_inactivated: str,
                 time_promoted: str,
                 time_published: str,
                 time_unpublished: str,
                 uuid: str):
        """
        :param str algorithm: The signing algorithm used for the key.
        :param Sequence['GetZonesZoneDnssecConfigKskDnssecKeyVersionDsDataArgs'] ds_datas: An array of data for DS records corresponding with this key version. An entry will exist for each supported DS digest algorithm.
        :param int key_tag: The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        :param int length_in_bytes: The length of the corresponding private key in bytes, expressed as an integer.
        :param str predecessor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        :param str successor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        :param str time_activated: The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_expired: The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        :param str time_inactivated: The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str time_promoted: The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        :param str time_published: The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        :param str time_unpublished: The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str uuid: The UUID of the `DnssecKeyVersion`.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "ds_datas", ds_datas)
        pulumi.set(__self__, "key_tag", key_tag)
        pulumi.set(__self__, "length_in_bytes", length_in_bytes)
        pulumi.set(__self__, "predecessor_dnssec_key_version_uuid", predecessor_dnssec_key_version_uuid)
        pulumi.set(__self__, "successor_dnssec_key_version_uuid", successor_dnssec_key_version_uuid)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_expired", time_expired)
        pulumi.set(__self__, "time_inactivated", time_inactivated)
        pulumi.set(__self__, "time_promoted", time_promoted)
        pulumi.set(__self__, "time_published", time_published)
        pulumi.set(__self__, "time_unpublished", time_unpublished)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        The signing algorithm used for the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="dsDatas")
    def ds_datas(self) -> Sequence['outputs.GetZonesZoneDnssecConfigKskDnssecKeyVersionDsDataResult']:
        """
        An array of data for DS records corresponding with this key version. An entry will exist for each supported DS digest algorithm.
        """
        return pulumi.get(self, "ds_datas")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> int:
        """
        The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="lengthInBytes")
    def length_in_bytes(self) -> int:
        """
        The length of the corresponding private key in bytes, expressed as an integer.
        """
        return pulumi.get(self, "length_in_bytes")

    @property
    @pulumi.getter(name="predecessorDnssecKeyVersionUuid")
    def predecessor_dnssec_key_version_uuid(self) -> str:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        """
        return pulumi.get(self, "predecessor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="successorDnssecKeyVersionUuid")
    def successor_dnssec_key_version_uuid(self) -> str:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        """
        return pulumi.get(self, "successor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeExpired")
    def time_expired(self) -> str:
        """
        The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        """
        return pulumi.get(self, "time_expired")

    @property
    @pulumi.getter(name="timeInactivated")
    def time_inactivated(self) -> str:
        """
        The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_inactivated")

    @property
    @pulumi.getter(name="timePromoted")
    def time_promoted(self) -> str:
        """
        The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_promoted")

    @property
    @pulumi.getter(name="timePublished")
    def time_published(self) -> str:
        """
        The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        """
        return pulumi.get(self, "time_published")

    @property
    @pulumi.getter(name="timeUnpublished")
    def time_unpublished(self) -> str:
        """
        The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_unpublished")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        The UUID of the `DnssecKeyVersion`.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetZonesZoneDnssecConfigKskDnssecKeyVersionDsDataResult(dict):
    def __init__(__self__, *,
                 digest_type: str,
                 rdata: str):
        """
        :param str digest_type: The type of the digest associated with the rdata.
        :param str rdata: Presentation-format DS record data that must be added to the parent zone. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        pulumi.set(__self__, "digest_type", digest_type)
        pulumi.set(__self__, "rdata", rdata)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> str:
        """
        The type of the digest associated with the rdata.
        """
        return pulumi.get(self, "digest_type")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        Presentation-format DS record data that must be added to the parent zone. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")


@pulumi.output_type
class GetZonesZoneDnssecConfigZskDnssecKeyVersionResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 key_tag: int,
                 length_in_bytes: int,
                 predecessor_dnssec_key_version_uuid: str,
                 successor_dnssec_key_version_uuid: str,
                 time_activated: str,
                 time_created: str,
                 time_expired: str,
                 time_inactivated: str,
                 time_promoted: str,
                 time_published: str,
                 time_unpublished: str,
                 uuid: str):
        """
        :param str algorithm: The signing algorithm used for the key.
        :param int key_tag: The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        :param int length_in_bytes: The length of the corresponding private key in bytes, expressed as an integer.
        :param str predecessor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        :param str successor_dnssec_key_version_uuid: When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        :param str time_activated: The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        :param str time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param str time_expired: The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        :param str time_inactivated: The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str time_promoted: The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        :param str time_published: The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        :param str time_unpublished: The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        :param str uuid: The UUID of the `DnssecKeyVersion`.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "key_tag", key_tag)
        pulumi.set(__self__, "length_in_bytes", length_in_bytes)
        pulumi.set(__self__, "predecessor_dnssec_key_version_uuid", predecessor_dnssec_key_version_uuid)
        pulumi.set(__self__, "successor_dnssec_key_version_uuid", successor_dnssec_key_version_uuid)
        pulumi.set(__self__, "time_activated", time_activated)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_expired", time_expired)
        pulumi.set(__self__, "time_inactivated", time_inactivated)
        pulumi.set(__self__, "time_promoted", time_promoted)
        pulumi.set(__self__, "time_published", time_published)
        pulumi.set(__self__, "time_unpublished", time_unpublished)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        The signing algorithm used for the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> int:
        """
        The key tag associated with the `DnssecKeyVersion`. This key tag will be present in the RRSIG and DS records associated with the key material for this `DnssecKeyVersion`. For more information about key tags, see [RFC 4034](https://tools.ietf.org/html/rfc4034).
        """
        return pulumi.get(self, "key_tag")

    @property
    @pulumi.getter(name="lengthInBytes")
    def length_in_bytes(self) -> int:
        """
        The length of the corresponding private key in bytes, expressed as an integer.
        """
        return pulumi.get(self, "length_in_bytes")

    @property
    @pulumi.getter(name="predecessorDnssecKeyVersionUuid")
    def predecessor_dnssec_key_version_uuid(self) -> str:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that this `DnssecKeyVersion` will replace or has replaced.
        """
        return pulumi.get(self, "predecessor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="successorDnssecKeyVersionUuid")
    def successor_dnssec_key_version_uuid(self) -> str:
        """
        When populated, this is the UUID of the `DnssecKeyVersion` that will replace, or has replaced, this `DnssecKeyVersion`.
        """
        return pulumi.get(self, "successor_dnssec_key_version_uuid")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the key version went, or will go, active, expressed in RFC 3339 timestamp format. This is when the key material will be used to generate RRSIGs.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeExpired")
    def time_expired(self) -> str:
        """
        The date and time at which the recommended key version publication/activation lifetime ends, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY should no longer exist in zone contents and no longer be used to generate RRSIGs. For a key sigining key (KSK), if `PromoteZoneDnssecKeyVersion` has not been called on this `DnssecKeyVersion`'s successor then it will remain active for arbitrarily long past its recommended lifetime. This prevents service disruption at the potential increased risk of key compromise.
        """
        return pulumi.get(self, "time_expired")

    @property
    @pulumi.getter(name="timeInactivated")
    def time_inactivated(self) -> str:
        """
        The date and time the key version went, or will go, inactive, expressed in RFC 3339 timestamp format. This is when the key material will no longer be used to generate RRSIGs. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_inactivated")

    @property
    @pulumi.getter(name="timePromoted")
    def time_promoted(self) -> str:
        """
        The date and time the key version was promoted expressed in RFC 3339 timestamp format.
        """
        return pulumi.get(self, "time_promoted")

    @property
    @pulumi.getter(name="timePublished")
    def time_published(self) -> str:
        """
        The date and time the key version was, or will be, published, expressed in RFC 3339 timestamp format. This is when the zone contents will include a DNSKEY record corresponding to the key material.
        """
        return pulumi.get(self, "time_published")

    @property
    @pulumi.getter(name="timeUnpublished")
    def time_unpublished(self) -> str:
        """
        The date and time the key version was, or will be, unpublished, expressed in RFC 3339 timestamp format. This is when the corresponding DNSKEY will be removed from zone contents. For a key signing key (KSK) `DnssecKeyVersion`, this is populated after `PromoteZoneDnssecKeyVersion` has been called on its successor `DnssecKeyVersion`.
        """
        return pulumi.get(self, "time_unpublished")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        The UUID of the `DnssecKeyVersion`.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetZonesZoneExternalDownstreamResult(dict):
    def __init__(__self__, *,
                 address: str,
                 port: int,
                 tsig_key_id: str):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param int port: The server's port. Port value must be a value of 53, otherwise omit the port value.
        :param str tsig_key_id: Search for zones that are associated with a TSIG key.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> str:
        """
        Search for zones that are associated with a TSIG key.
        """
        return pulumi.get(self, "tsig_key_id")


@pulumi.output_type
class GetZonesZoneExternalMasterResult(dict):
    def __init__(__self__, *,
                 address: str,
                 port: int,
                 tsig_key_id: str):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param int port: The server's port. Port value must be a value of 53, otherwise omit the port value.
        :param str tsig_key_id: Search for zones that are associated with a TSIG key.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> str:
        """
        Search for zones that are associated with a TSIG key.
        """
        return pulumi.get(self, "tsig_key_id")


@pulumi.output_type
class GetZonesZoneNameserverResult(dict):
    def __init__(__self__, *,
                 hostname: str):
        """
        :param str hostname: The hostname of the nameserver.
        """
        pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the nameserver.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class GetZonesZoneZoneTransferServerResult(dict):
    def __init__(__self__, *,
                 address: str,
                 is_transfer_destination: bool,
                 is_transfer_source: bool,
                 port: int):
        """
        :param str address: The server's IP address (IPv4 or IPv6).
        :param bool is_transfer_destination: A Boolean flag indicating whether or not the server is a zone data transfer destination.
        :param bool is_transfer_source: A Boolean flag indicating whether or not the server is a zone data transfer source.
        :param int port: The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "is_transfer_destination", is_transfer_destination)
        pulumi.set(__self__, "is_transfer_source", is_transfer_source)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="isTransferDestination")
    def is_transfer_destination(self) -> bool:
        """
        A Boolean flag indicating whether or not the server is a zone data transfer destination.
        """
        return pulumi.get(self, "is_transfer_destination")

    @property
    @pulumi.getter(name="isTransferSource")
    def is_transfer_source(self) -> bool:
        """
        A Boolean flag indicating whether or not the server is a zone data transfer source.
        """
        return pulumi.get(self, "is_transfer_source")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        return pulumi.get(self, "port")


