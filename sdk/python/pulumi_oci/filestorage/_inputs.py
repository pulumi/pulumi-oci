# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ExportExportOptionArgs',
    'FileSystemSourceDetailArgs',
    'FilesystemSnapshotPolicyScheduleArgs',
    'GetExportSetsFilterArgs',
    'GetExportsFilterArgs',
    'GetFileSystemsFilterArgs',
    'GetFilesystemSnapshotPoliciesFilterArgs',
    'GetMountTargetsFilterArgs',
    'GetReplicationTargetsFilterArgs',
    'GetReplicationsFilterArgs',
    'GetSnapshotsFilterArgs',
]

@pulumi.input_type
class ExportExportOptionArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 access: Optional[pulumi.Input[str]] = None,
                 anonymous_gid: Optional[pulumi.Input[str]] = None,
                 anonymous_uid: Optional[pulumi.Input[str]] = None,
                 identity_squash: Optional[pulumi.Input[str]] = None,
                 require_privileged_source_port: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] source: (Updatable) Clients these options should apply to. Must be a either single IPv4 address or single IPv4 CIDR block.
               
               **Note:** Access will also be limited by any applicable VCN security rules and the ability to route IP packets to the mount target. Mount targets do not have Internet-routable IP addresses.
        :param pulumi.Input[str] access: (Updatable) Type of access to grant clients using the file system through this export. If unspecified defaults to `READ_WRITE`.
        :param pulumi.Input[str] anonymous_gid: (Updatable) GID value to remap to when squashing a client GID (see identitySquash for more details.) If unspecified defaults to `65534`.
        :param pulumi.Input[str] anonymous_uid: (Updatable) UID value to remap to when squashing a client UID (see identitySquash for more details.) If unspecified, defaults to `65534`.
        :param pulumi.Input[str] identity_squash: (Updatable) Used when clients accessing the file system through this export have their UID and GID remapped to 'anonymousUid' and 'anonymousGid'. If `ALL`, all users and groups are remapped; if `ROOT`, only the root user and group (UID/GID 0) are remapped; if `NONE`, no remapping is done. If unspecified, defaults to `ROOT`.
        :param pulumi.Input[bool] require_privileged_source_port: (Updatable) If `true`, clients accessing the file system through this export must connect from a privileged source port. If unspecified, defaults to `true`.
        """
        pulumi.set(__self__, "source", source)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if anonymous_gid is not None:
            pulumi.set(__self__, "anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            pulumi.set(__self__, "anonymous_uid", anonymous_uid)
        if identity_squash is not None:
            pulumi.set(__self__, "identity_squash", identity_squash)
        if require_privileged_source_port is not None:
            pulumi.set(__self__, "require_privileged_source_port", require_privileged_source_port)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        (Updatable) Clients these options should apply to. Must be a either single IPv4 address or single IPv4 CIDR block.

        **Note:** Access will also be limited by any applicable VCN security rules and the ability to route IP packets to the mount target. Mount targets do not have Internet-routable IP addresses.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of access to grant clients using the file system through this export. If unspecified defaults to `READ_WRITE`.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="anonymousGid")
    def anonymous_gid(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) GID value to remap to when squashing a client GID (see identitySquash for more details.) If unspecified defaults to `65534`.
        """
        return pulumi.get(self, "anonymous_gid")

    @anonymous_gid.setter
    def anonymous_gid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "anonymous_gid", value)

    @property
    @pulumi.getter(name="anonymousUid")
    def anonymous_uid(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) UID value to remap to when squashing a client UID (see identitySquash for more details.) If unspecified, defaults to `65534`.
        """
        return pulumi.get(self, "anonymous_uid")

    @anonymous_uid.setter
    def anonymous_uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "anonymous_uid", value)

    @property
    @pulumi.getter(name="identitySquash")
    def identity_squash(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Used when clients accessing the file system through this export have their UID and GID remapped to 'anonymousUid' and 'anonymousGid'. If `ALL`, all users and groups are remapped; if `ROOT`, only the root user and group (UID/GID 0) are remapped; if `NONE`, no remapping is done. If unspecified, defaults to `ROOT`.
        """
        return pulumi.get(self, "identity_squash")

    @identity_squash.setter
    def identity_squash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_squash", value)

    @property
    @pulumi.getter(name="requirePrivilegedSourcePort")
    def require_privileged_source_port(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If `true`, clients accessing the file system through this export must connect from a privileged source port. If unspecified, defaults to `true`.
        """
        return pulumi.get(self, "require_privileged_source_port")

    @require_privileged_source_port.setter
    def require_privileged_source_port(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_privileged_source_port", value)


@pulumi.input_type
class FileSystemSourceDetailArgs:
    def __init__(__self__, *,
                 parent_file_system_id: Optional[pulumi.Input[str]] = None,
                 source_snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] parent_file_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the file system that contains the source snapshot of a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningFS.htm).
        :param pulumi.Input[str] source_snapshot_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the snapshot used to create a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningFS.htm). 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if parent_file_system_id is not None:
            pulumi.set(__self__, "parent_file_system_id", parent_file_system_id)
        if source_snapshot_id is not None:
            pulumi.set(__self__, "source_snapshot_id", source_snapshot_id)

    @property
    @pulumi.getter(name="parentFileSystemId")
    def parent_file_system_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the file system that contains the source snapshot of a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningFS.htm).
        """
        return pulumi.get(self, "parent_file_system_id")

    @parent_file_system_id.setter
    def parent_file_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_file_system_id", value)

    @property
    @pulumi.getter(name="sourceSnapshotId")
    def source_snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the snapshot used to create a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningFS.htm). 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source_snapshot_id")

    @source_snapshot_id.setter
    def source_snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_snapshot_id", value)


@pulumi.input_type
class FilesystemSnapshotPolicyScheduleArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 hour_of_day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 retention_duration_in_seconds: Optional[pulumi.Input[str]] = None,
                 schedule_prefix: Optional[pulumi.Input[str]] = None,
                 time_schedule_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] period: (Updatable) The frequency of scheduled snapshots.
        :param pulumi.Input[str] time_zone: (Updatable) Time zone used for scheduling the snapshot.
        :param pulumi.Input[int] day_of_month: (Updatable) The day of the month to create a scheduled snapshot. If the day does not exist for the month, snapshot creation will be skipped. Used for MONTHLY and YEARLY snapshot schedules.
        :param pulumi.Input[str] day_of_week: (Updatable) The day of the week to create a scheduled snapshot. Used for WEEKLY snapshot schedules.
        :param pulumi.Input[int] hour_of_day: (Updatable) The hour of the day to create a DAILY, WEEKLY, MONTHLY, or YEARLY snapshot. If not set, a value will be chosen at creation time.
        :param pulumi.Input[str] month: (Updatable) The month to create a scheduled snapshot. Used only for YEARLY snapshot schedules.
        :param pulumi.Input[str] retention_duration_in_seconds: (Updatable) The number of seconds to retain snapshots created with this schedule. Snapshot expiration time will not be set if this value is empty.
        :param pulumi.Input[str] schedule_prefix: (Updatable) A name prefix to be applied to snapshots created by this schedule.  Example: `compliance1`
        :param pulumi.Input[str] time_schedule_start: (Updatable) The starting point used to begin the scheduling of the snapshots based upon recurrence string in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format. If no `timeScheduleStart` is provided, the value will be set to the time when the schedule was created.
        """
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "time_zone", time_zone)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if retention_duration_in_seconds is not None:
            pulumi.set(__self__, "retention_duration_in_seconds", retention_duration_in_seconds)
        if schedule_prefix is not None:
            pulumi.set(__self__, "schedule_prefix", schedule_prefix)
        if time_schedule_start is not None:
            pulumi.set(__self__, "time_schedule_start", time_schedule_start)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        (Updatable) The frequency of scheduled snapshots.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        (Updatable) Time zone used for scheduling the snapshot.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The day of the month to create a scheduled snapshot. If the day does not exist for the month, snapshot creation will be skipped. Used for MONTHLY and YEARLY snapshot schedules.
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The day of the week to create a scheduled snapshot. Used for WEEKLY snapshot schedules.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The hour of the day to create a DAILY, WEEKLY, MONTHLY, or YEARLY snapshot. If not set, a value will be chosen at creation time.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The month to create a scheduled snapshot. Used only for YEARLY snapshot schedules.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="retentionDurationInSeconds")
    def retention_duration_in_seconds(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The number of seconds to retain snapshots created with this schedule. Snapshot expiration time will not be set if this value is empty.
        """
        return pulumi.get(self, "retention_duration_in_seconds")

    @retention_duration_in_seconds.setter
    def retention_duration_in_seconds(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_duration_in_seconds", value)

    @property
    @pulumi.getter(name="schedulePrefix")
    def schedule_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A name prefix to be applied to snapshots created by this schedule.  Example: `compliance1`
        """
        return pulumi.get(self, "schedule_prefix")

    @schedule_prefix.setter
    def schedule_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_prefix", value)

    @property
    @pulumi.getter(name="timeScheduleStart")
    def time_schedule_start(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The starting point used to begin the scheduling of the snapshots based upon recurrence string in [RFC 3339](https://tools.ietf.org/rfc/rfc3339) timestamp format. If no `timeScheduleStart` is provided, the value will be set to the time when the schedule was created.
        """
        return pulumi.get(self, "time_schedule_start")

    @time_schedule_start.setter
    def time_schedule_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_schedule_start", value)


@pulumi.input_type
class GetExportSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetExportsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFileSystemsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFilesystemSnapshotPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMountTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetReplicationTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetReplicationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetSnapshotsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the snapshot. This value is immutable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the snapshot. This value is immutable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


