# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CatalogItemCatalogResultPayloadArgs',
    'CatalogItemCatalogResultPayloadArgsDict',
    'CatalogItemCatalogSourcePayloadArgs',
    'CatalogItemCatalogSourcePayloadArgsDict',
    'CompliancePolicyRulePatchSelectionArgs',
    'CompliancePolicyRulePatchSelectionArgsDict',
    'CompliancePolicyRuleProductVersionArgs',
    'CompliancePolicyRuleProductVersionArgsDict',
    'FleetCredentialArgs',
    'FleetCredentialArgsDict',
    'FleetCredentialEntitySpecificsArgs',
    'FleetCredentialEntitySpecificsArgsDict',
    'FleetCredentialEntitySpecificsVariableArgs',
    'FleetCredentialEntitySpecificsVariableArgsDict',
    'FleetCredentialPasswordArgs',
    'FleetCredentialPasswordArgsDict',
    'FleetCredentialUserArgs',
    'FleetCredentialUserArgsDict',
    'FleetDetailsArgs',
    'FleetDetailsArgsDict',
    'FleetNotificationPreferenceArgs',
    'FleetNotificationPreferenceArgsDict',
    'FleetNotificationPreferencePreferencesArgs',
    'FleetNotificationPreferencePreferencesArgsDict',
    'FleetNotificationPreferencePreferencesUpcomingScheduleArgs',
    'FleetNotificationPreferencePreferencesUpcomingScheduleArgsDict',
    'FleetPropertyArgs',
    'FleetPropertyArgsDict',
    'FleetResourceArgs',
    'FleetResourceArgsDict',
    'FleetResourceSelectionArgs',
    'FleetResourceSelectionArgsDict',
    'FleetResourceSelectionRuleSelectionCriteriaArgs',
    'FleetResourceSelectionRuleSelectionCriteriaArgsDict',
    'FleetResourceSelectionRuleSelectionCriteriaRuleArgs',
    'FleetResourceSelectionRuleSelectionCriteriaRuleArgsDict',
    'FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgs',
    'FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgsDict',
    'OnboardingAppliedPolicyArgs',
    'OnboardingAppliedPolicyArgsDict',
    'PatchArtifactDetailsArgs',
    'PatchArtifactDetailsArgsDict',
    'PatchArtifactDetailsArtifactArgs',
    'PatchArtifactDetailsArtifactArgsDict',
    'PatchArtifactDetailsArtifactContentArgs',
    'PatchArtifactDetailsArtifactContentArgsDict',
    'PatchDependentPatchArgs',
    'PatchDependentPatchArgsDict',
    'PatchPatchTypeArgs',
    'PatchPatchTypeArgsDict',
    'PatchProductArgs',
    'PatchProductArgsDict',
    'PlatformConfigurationConfigCategoryDetailsArgs',
    'PlatformConfigurationConfigCategoryDetailsArgsDict',
    'PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs',
    'PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict',
    'PlatformConfigurationConfigCategoryDetailsCredentialArgs',
    'PlatformConfigurationConfigCategoryDetailsCredentialArgsDict',
    'PlatformConfigurationConfigCategoryDetailsPatchTypeArgs',
    'PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict',
    'PlatformConfigurationConfigCategoryDetailsProductArgs',
    'PlatformConfigurationConfigCategoryDetailsProductArgsDict',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict',
    'ProvisionDeployedResourceArgs',
    'ProvisionDeployedResourceArgsDict',
    'ProvisionDeployedResourceResourceInstanceListArgs',
    'ProvisionDeployedResourceResourceInstanceListArgsDict',
    'ProvisionTfOutputArgs',
    'ProvisionTfOutputArgsDict',
    'RunbookRunbookVersionArgs',
    'RunbookRunbookVersionArgsDict',
    'RunbookRunbookVersionExecutionWorkflowDetailsArgs',
    'RunbookRunbookVersionExecutionWorkflowDetailsArgsDict',
    'RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgs',
    'RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgsDict',
    'RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgs',
    'RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict',
    'RunbookRunbookVersionGroupArgs',
    'RunbookRunbookVersionGroupArgsDict',
    'RunbookRunbookVersionGroupPropertiesArgs',
    'RunbookRunbookVersionGroupPropertiesArgsDict',
    'RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgs',
    'RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgsDict',
    'RunbookRunbookVersionGroupPropertiesPauseDetailsArgs',
    'RunbookRunbookVersionGroupPropertiesPauseDetailsArgsDict',
    'RunbookRunbookVersionGroupPropertiesRunOnArgs',
    'RunbookRunbookVersionGroupPropertiesRunOnArgsDict',
    'RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs',
    'RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict',
    'RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs',
    'RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict',
    'RunbookRunbookVersionRollbackWorkflowDetailsArgs',
    'RunbookRunbookVersionRollbackWorkflowDetailsArgsDict',
    'RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgs',
    'RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgsDict',
    'RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgs',
    'RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict',
    'RunbookRunbookVersionTaskArgs',
    'RunbookRunbookVersionTaskArgsDict',
    'RunbookRunbookVersionTaskOutputVariableMappingArgs',
    'RunbookRunbookVersionTaskOutputVariableMappingArgsDict',
    'RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs',
    'RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict',
    'RunbookRunbookVersionTaskStepPropertiesArgs',
    'RunbookRunbookVersionTaskStepPropertiesArgsDict',
    'RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgs',
    'RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict',
    'RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgs',
    'RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgsDict',
    'RunbookRunbookVersionTaskStepPropertiesRunOnArgs',
    'RunbookRunbookVersionTaskStepPropertiesRunOnArgsDict',
    'RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs',
    'RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict',
    'RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs',
    'RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict',
    'RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgs',
    'RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgsDict',
    'RunbookVersionExecutionWorkflowDetailsArgs',
    'RunbookVersionExecutionWorkflowDetailsArgsDict',
    'RunbookVersionExecutionWorkflowDetailsWorkflowArgs',
    'RunbookVersionExecutionWorkflowDetailsWorkflowArgsDict',
    'RunbookVersionExecutionWorkflowDetailsWorkflowStepArgs',
    'RunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict',
    'RunbookVersionGroupArgs',
    'RunbookVersionGroupArgsDict',
    'RunbookVersionGroupPropertiesArgs',
    'RunbookVersionGroupPropertiesArgsDict',
    'RunbookVersionGroupPropertiesNotificationPreferencesArgs',
    'RunbookVersionGroupPropertiesNotificationPreferencesArgsDict',
    'RunbookVersionGroupPropertiesPauseDetailsArgs',
    'RunbookVersionGroupPropertiesPauseDetailsArgsDict',
    'RunbookVersionGroupPropertiesRunOnArgs',
    'RunbookVersionGroupPropertiesRunOnArgsDict',
    'RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs',
    'RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict',
    'RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs',
    'RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict',
    'RunbookVersionRollbackWorkflowDetailsArgs',
    'RunbookVersionRollbackWorkflowDetailsArgsDict',
    'RunbookVersionRollbackWorkflowDetailsWorkflowArgs',
    'RunbookVersionRollbackWorkflowDetailsWorkflowArgsDict',
    'RunbookVersionRollbackWorkflowDetailsWorkflowStepArgs',
    'RunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict',
    'RunbookVersionTaskArgs',
    'RunbookVersionTaskArgsDict',
    'RunbookVersionTaskOutputVariableMappingArgs',
    'RunbookVersionTaskOutputVariableMappingArgsDict',
    'RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs',
    'RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict',
    'RunbookVersionTaskStepPropertiesArgs',
    'RunbookVersionTaskStepPropertiesArgsDict',
    'RunbookVersionTaskStepPropertiesNotificationPreferencesArgs',
    'RunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict',
    'RunbookVersionTaskStepPropertiesPauseDetailsArgs',
    'RunbookVersionTaskStepPropertiesPauseDetailsArgsDict',
    'RunbookVersionTaskStepPropertiesRunOnArgs',
    'RunbookVersionTaskStepPropertiesRunOnArgsDict',
    'RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs',
    'RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict',
    'RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs',
    'RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict',
    'RunbookVersionTaskTaskRecordDetailsArgs',
    'RunbookVersionTaskTaskRecordDetailsArgsDict',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs',
    'RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict',
    'RunbookVersionTaskTaskRecordDetailsPropertiesArgs',
    'RunbookVersionTaskTaskRecordDetailsPropertiesArgsDict',
    'SchedulerDefinitionActionGroupArgs',
    'SchedulerDefinitionActionGroupArgsDict',
    'SchedulerDefinitionRunBookArgs',
    'SchedulerDefinitionRunBookArgsDict',
    'SchedulerDefinitionRunBookInputParameterArgs',
    'SchedulerDefinitionRunBookInputParameterArgsDict',
    'SchedulerDefinitionRunBookInputParameterArgumentArgs',
    'SchedulerDefinitionRunBookInputParameterArgumentArgsDict',
    'SchedulerDefinitionRunBookInputParameterArgumentContentArgs',
    'SchedulerDefinitionRunBookInputParameterArgumentContentArgsDict',
    'SchedulerDefinitionScheduleArgs',
    'SchedulerDefinitionScheduleArgsDict',
    'TaskRecordDetailsArgs',
    'TaskRecordDetailsArgsDict',
    'TaskRecordDetailsExecutionDetailsArgs',
    'TaskRecordDetailsExecutionDetailsArgsDict',
    'TaskRecordDetailsExecutionDetailsContentArgs',
    'TaskRecordDetailsExecutionDetailsContentArgsDict',
    'TaskRecordDetailsExecutionDetailsCredentialArgs',
    'TaskRecordDetailsExecutionDetailsCredentialArgsDict',
    'TaskRecordDetailsExecutionDetailsVariablesArgs',
    'TaskRecordDetailsExecutionDetailsVariablesArgsDict',
    'TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs',
    'TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict',
    'TaskRecordDetailsPropertiesArgs',
    'TaskRecordDetailsPropertiesArgsDict',
    'GetAnnouncementsFilterArgs',
    'GetAnnouncementsFilterArgsDict',
    'GetCatalogItemsFilterArgs',
    'GetCatalogItemsFilterArgsDict',
    'GetCompliancePoliciesFilterArgs',
    'GetCompliancePoliciesFilterArgsDict',
    'GetCompliancePolicyRulesFilterArgs',
    'GetCompliancePolicyRulesFilterArgsDict',
    'GetComplianceRecordCountsFilterArgs',
    'GetComplianceRecordCountsFilterArgsDict',
    'GetComplianceRecordsFilterArgs',
    'GetComplianceRecordsFilterArgsDict',
    'GetFleetCredentialsFilterArgs',
    'GetFleetCredentialsFilterArgsDict',
    'GetFleetProductsFilterArgs',
    'GetFleetProductsFilterArgsDict',
    'GetFleetPropertiesFilterArgs',
    'GetFleetPropertiesFilterArgsDict',
    'GetFleetResourcesFilterArgs',
    'GetFleetResourcesFilterArgsDict',
    'GetFleetTargetsFilterArgs',
    'GetFleetTargetsFilterArgsDict',
    'GetFleetsFilterArgs',
    'GetFleetsFilterArgsDict',
    'GetInventoryRecordsFilterArgs',
    'GetInventoryRecordsFilterArgsDict',
    'GetInventoryResourcesFilterArgs',
    'GetInventoryResourcesFilterArgsDict',
    'GetMaintenanceWindowsFilterArgs',
    'GetMaintenanceWindowsFilterArgsDict',
    'GetManagedEntityCountsFilterArgs',
    'GetManagedEntityCountsFilterArgsDict',
    'GetOnboardingPoliciesFilterArgs',
    'GetOnboardingPoliciesFilterArgsDict',
    'GetOnboardingsFilterArgs',
    'GetOnboardingsFilterArgsDict',
    'GetPatchesFilterArgs',
    'GetPatchesFilterArgsDict',
    'GetPlatformConfigurationsFilterArgs',
    'GetPlatformConfigurationsFilterArgsDict',
    'GetPropertiesFilterArgs',
    'GetPropertiesFilterArgsDict',
    'GetProvisionsFilterArgs',
    'GetProvisionsFilterArgsDict',
    'GetRunbookVersionsFilterArgs',
    'GetRunbookVersionsFilterArgsDict',
    'GetRunbooksFilterArgs',
    'GetRunbooksFilterArgsDict',
    'GetSchedulerDefinitionScheduledFleetsFilterArgs',
    'GetSchedulerDefinitionScheduledFleetsFilterArgsDict',
    'GetSchedulerDefinitionsFilterArgs',
    'GetSchedulerDefinitionsFilterArgsDict',
    'GetSchedulerExecutionsFilterArgs',
    'GetSchedulerExecutionsFilterArgsDict',
    'GetSchedulerJobCountsFilterArgs',
    'GetSchedulerJobCountsFilterArgsDict',
    'GetSchedulerJobJobActivityResourcesFilterArgs',
    'GetSchedulerJobJobActivityResourcesFilterArgsDict',
    'GetSchedulerJobJobActivityStepsFilterArgs',
    'GetSchedulerJobJobActivityStepsFilterArgsDict',
    'GetTaskRecordsFilterArgs',
    'GetTaskRecordsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CatalogItemCatalogResultPayloadArgsDict(TypedDict):
        branch_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        branch Name
        """
        config_result_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        config result type.
        """
        configuration_source_provider_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        configuration Source Provider [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        package_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        package url
        """
        repository_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        repository Url
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        template id
        """
        time_expires: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time expires, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogItemCatalogResultPayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogItemCatalogResultPayloadArgs:
    def __init__(__self__, *,
                 branch_name: Optional[pulumi.Input[_builtins.str]] = None,
                 config_result_type: Optional[pulumi.Input[_builtins.str]] = None,
                 configuration_source_provider_id: Optional[pulumi.Input[_builtins.str]] = None,
                 package_url: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_url: Optional[pulumi.Input[_builtins.str]] = None,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_expires: Optional[pulumi.Input[_builtins.str]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch_name: branch Name
        :param pulumi.Input[_builtins.str] config_result_type: config result type.
        :param pulumi.Input[_builtins.str] configuration_source_provider_id: configuration Source Provider [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input[_builtins.str] package_url: package url
        :param pulumi.Input[_builtins.str] repository_url: repository Url
        :param pulumi.Input[_builtins.str] template_id: template id
        :param pulumi.Input[_builtins.str] time_expires: The date and time expires, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if config_result_type is not None:
            pulumi.set(__self__, "config_result_type", config_result_type)
        if configuration_source_provider_id is not None:
            pulumi.set(__self__, "configuration_source_provider_id", configuration_source_provider_id)
        if package_url is not None:
            pulumi.set(__self__, "package_url", package_url)
        if repository_url is not None:
            pulumi.set(__self__, "repository_url", repository_url)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if time_expires is not None:
            pulumi.set(__self__, "time_expires", time_expires)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        branch Name
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @_builtins.property
    @pulumi.getter(name="configResultType")
    def config_result_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        config result type.
        """
        return pulumi.get(self, "config_result_type")

    @config_result_type.setter
    def config_result_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_result_type", value)

    @_builtins.property
    @pulumi.getter(name="configurationSourceProviderId")
    def configuration_source_provider_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        configuration Source Provider [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "configuration_source_provider_id")

    @configuration_source_provider_id.setter
    def configuration_source_provider_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "configuration_source_provider_id", value)

    @_builtins.property
    @pulumi.getter(name="packageUrl")
    def package_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        package url
        """
        return pulumi.get(self, "package_url")

    @package_url.setter
    def package_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package_url", value)

    @_builtins.property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        repository Url
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository_url", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        template id
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter(name="timeExpires")
    def time_expires(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time expires, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_expires")

    @time_expires.setter
    def time_expires(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_expires", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class CatalogItemCatalogSourcePayloadArgsDict(TypedDict):
        config_source_type: pulumi.Input[_builtins.str]
        """
        config source type.
        """
        access_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        access uri
        """
        branch_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        branch Name
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        bucket name
        """
        configuration_source_provider_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        configuration Source Provider [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Description
        """
        listing_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        This listing Id parameter of Payload.
        """
        long_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Long Description
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        nameSpace
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        object name
        """
        repository_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        repository Url
        """
        template_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Display Name
        """
        time_expires: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time expires, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        This version parameter of Payload.
        """
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
        zip_file_base64encoded: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Base64 encoded template. This payload will trigger CreateTemplate API, where the parameter will be passed.
        """
elif False:
    CatalogItemCatalogSourcePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogItemCatalogSourcePayloadArgs:
    def __init__(__self__, *,
                 config_source_type: pulumi.Input[_builtins.str],
                 access_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 branch_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 configuration_source_provider_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 listing_id: Optional[pulumi.Input[_builtins.str]] = None,
                 long_description: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_url: Optional[pulumi.Input[_builtins.str]] = None,
                 template_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 time_expires: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None,
                 zip_file_base64encoded: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config_source_type: config source type.
        :param pulumi.Input[_builtins.str] access_uri: access uri
        :param pulumi.Input[_builtins.str] branch_name: branch Name
        :param pulumi.Input[_builtins.str] bucket: bucket name
        :param pulumi.Input[_builtins.str] configuration_source_provider_id: configuration Source Provider [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input[_builtins.str] description: Template Description
        :param pulumi.Input[_builtins.str] listing_id: This listing Id parameter of Payload.
        :param pulumi.Input[_builtins.str] long_description: Template Long Description
        :param pulumi.Input[_builtins.str] namespace: nameSpace
        :param pulumi.Input[_builtins.str] object: object name
        :param pulumi.Input[_builtins.str] repository_url: repository Url
        :param pulumi.Input[_builtins.str] template_display_name: Template Display Name
        :param pulumi.Input[_builtins.str] time_expires: The date and time expires, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        :param pulumi.Input[_builtins.str] version: This version parameter of Payload.
        :param pulumi.Input[_builtins.str] zip_file_base64encoded: The Base64 encoded template. This payload will trigger CreateTemplate API, where the parameter will be passed.
        """
        pulumi.set(__self__, "config_source_type", config_source_type)
        if access_uri is not None:
            pulumi.set(__self__, "access_uri", access_uri)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if configuration_source_provider_id is not None:
            pulumi.set(__self__, "configuration_source_provider_id", configuration_source_provider_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if listing_id is not None:
            pulumi.set(__self__, "listing_id", listing_id)
        if long_description is not None:
            pulumi.set(__self__, "long_description", long_description)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if repository_url is not None:
            pulumi.set(__self__, "repository_url", repository_url)
        if template_display_name is not None:
            pulumi.set(__self__, "template_display_name", template_display_name)
        if time_expires is not None:
            pulumi.set(__self__, "time_expires", time_expires)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)
        if zip_file_base64encoded is not None:
            pulumi.set(__self__, "zip_file_base64encoded", zip_file_base64encoded)

    @_builtins.property
    @pulumi.getter(name="configSourceType")
    def config_source_type(self) -> pulumi.Input[_builtins.str]:
        """
        config source type.
        """
        return pulumi.get(self, "config_source_type")

    @config_source_type.setter
    def config_source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config_source_type", value)

    @_builtins.property
    @pulumi.getter(name="accessUri")
    def access_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        access uri
        """
        return pulumi.get(self, "access_uri")

    @access_uri.setter
    def access_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_uri", value)

    @_builtins.property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        branch Name
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        bucket name
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="configurationSourceProviderId")
    def configuration_source_provider_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        configuration Source Provider [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "configuration_source_provider_id")

    @configuration_source_provider_id.setter
    def configuration_source_provider_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "configuration_source_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="listingId")
    def listing_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This listing Id parameter of Payload.
        """
        return pulumi.get(self, "listing_id")

    @listing_id.setter
    def listing_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listing_id", value)

    @_builtins.property
    @pulumi.getter(name="longDescription")
    def long_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Long Description
        """
        return pulumi.get(self, "long_description")

    @long_description.setter
    def long_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "long_description", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        nameSpace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        object name
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        repository Url
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository_url", value)

    @_builtins.property
    @pulumi.getter(name="templateDisplayName")
    def template_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Display Name
        """
        return pulumi.get(self, "template_display_name")

    @template_display_name.setter
    def template_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_display_name", value)

    @_builtins.property
    @pulumi.getter(name="timeExpires")
    def time_expires(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time expires, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_expires")

    @time_expires.setter
    def time_expires(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_expires", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This version parameter of Payload.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)

    @_builtins.property
    @pulumi.getter(name="zipFileBase64encoded")
    def zip_file_base64encoded(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Base64 encoded template. This payload will trigger CreateTemplate API, where the parameter will be passed.
        """
        return pulumi.get(self, "zip_file_base64encoded")

    @zip_file_base64encoded.setter
    def zip_file_base64encoded(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zip_file_base64encoded", value)


if not MYPY:
    class CompliancePolicyRulePatchSelectionArgsDict(TypedDict):
        selection_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Selection type for the Patch.
        """
        days_since_release: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Days passed since patch release.
        """
        patch_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Patch Name.
        """
        patch_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Patch Name.
        """
elif False:
    CompliancePolicyRulePatchSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompliancePolicyRulePatchSelectionArgs:
    def __init__(__self__, *,
                 selection_type: pulumi.Input[_builtins.str],
                 days_since_release: Optional[pulumi.Input[_builtins.int]] = None,
                 patch_level: Optional[pulumi.Input[_builtins.str]] = None,
                 patch_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] selection_type: (Updatable) Selection type for the Patch.
        :param pulumi.Input[_builtins.int] days_since_release: (Updatable) Days passed since patch release.
        :param pulumi.Input[_builtins.str] patch_level: (Updatable) Patch Name.
        :param pulumi.Input[_builtins.str] patch_name: (Updatable) Patch Name.
        """
        pulumi.set(__self__, "selection_type", selection_type)
        if days_since_release is not None:
            pulumi.set(__self__, "days_since_release", days_since_release)
        if patch_level is not None:
            pulumi.set(__self__, "patch_level", patch_level)
        if patch_name is not None:
            pulumi.set(__self__, "patch_name", patch_name)

    @_builtins.property
    @pulumi.getter(name="selectionType")
    def selection_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Selection type for the Patch.
        """
        return pulumi.get(self, "selection_type")

    @selection_type.setter
    def selection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "selection_type", value)

    @_builtins.property
    @pulumi.getter(name="daysSinceRelease")
    def days_since_release(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Days passed since patch release.
        """
        return pulumi.get(self, "days_since_release")

    @days_since_release.setter
    def days_since_release(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days_since_release", value)

    @_builtins.property
    @pulumi.getter(name="patchLevel")
    def patch_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Patch Name.
        """
        return pulumi.get(self, "patch_level")

    @patch_level.setter
    def patch_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "patch_level", value)

    @_builtins.property
    @pulumi.getter(name="patchName")
    def patch_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Patch Name.
        """
        return pulumi.get(self, "patch_name")

    @patch_name.setter
    def patch_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "patch_name", value)


if not MYPY:
    class CompliancePolicyRuleProductVersionArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        """
        (Updatable) Product version the rule is applicable.
        """
        is_applicable_for_all_higher_versions: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is rule applicable to all higher versions also
        """
elif False:
    CompliancePolicyRuleProductVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompliancePolicyRuleProductVersionArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str],
                 is_applicable_for_all_higher_versions: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] version: (Updatable) Product version the rule is applicable.
        :param pulumi.Input[_builtins.bool] is_applicable_for_all_higher_versions: (Updatable) Is rule applicable to all higher versions also
        """
        pulumi.set(__self__, "version", version)
        if is_applicable_for_all_higher_versions is not None:
            pulumi.set(__self__, "is_applicable_for_all_higher_versions", is_applicable_for_all_higher_versions)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Product version the rule is applicable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="isApplicableForAllHigherVersions")
    def is_applicable_for_all_higher_versions(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is rule applicable to all higher versions also
        """
        return pulumi.get(self, "is_applicable_for_all_higher_versions")

    @is_applicable_for_all_higher_versions.setter
    def is_applicable_for_all_higher_versions(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_applicable_for_all_higher_versions", value)


if not MYPY:
    class FleetCredentialArgsDict(TypedDict):
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Compartment OCID
        """
        display_name: pulumi.Input[_builtins.str]
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        entity_specifics: pulumi.Input['FleetCredentialEntitySpecificsArgsDict']
        """
        Credential specific Details.
        """
        password: pulumi.Input['FleetCredentialPasswordArgsDict']
        """
        Credential Details.
        """
        user: pulumi.Input['FleetCredentialUserArgsDict']
        """
        Credential Details.
        """
elif False:
    FleetCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 entity_specifics: pulumi.Input['FleetCredentialEntitySpecificsArgs'],
                 password: pulumi.Input['FleetCredentialPasswordArgs'],
                 user: pulumi.Input['FleetCredentialUserArgs']):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) Compartment OCID
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input['FleetCredentialEntitySpecificsArgs'] entity_specifics: Credential specific Details.
        :param pulumi.Input['FleetCredentialPasswordArgs'] password: Credential Details.
        :param pulumi.Input['FleetCredentialUserArgs'] user: Credential Details.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "entity_specifics", entity_specifics)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Compartment OCID
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="entitySpecifics")
    def entity_specifics(self) -> pulumi.Input['FleetCredentialEntitySpecificsArgs']:
        """
        Credential specific Details.
        """
        return pulumi.get(self, "entity_specifics")

    @entity_specifics.setter
    def entity_specifics(self, value: pulumi.Input['FleetCredentialEntitySpecificsArgs']):
        pulumi.set(self, "entity_specifics", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input['FleetCredentialPasswordArgs']:
        """
        Credential Details.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input['FleetCredentialPasswordArgs']):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input['FleetCredentialUserArgs']:
        """
        Credential Details.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input['FleetCredentialUserArgs']):
        pulumi.set(self, "user", value)


if not MYPY:
    class FleetCredentialEntitySpecificsArgsDict(TypedDict):
        credential_level: pulumi.Input[_builtins.str]
        """
        (Updatable) At what level the credential is provided?
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the resource associated with the target for which the credential is created.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Target name for which the credential is provided.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgsDict']]]]
        """
        (Updatable) List of fleet credential variables.
        """
elif False:
    FleetCredentialEntitySpecificsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialEntitySpecificsArgs:
    def __init__(__self__, *,
                 credential_level: pulumi.Input[_builtins.str],
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] credential_level: (Updatable) At what level the credential is provided?
        :param pulumi.Input[_builtins.str] resource_id: (Updatable) OCID of the resource associated with the target for which the credential is created.
        :param pulumi.Input[_builtins.str] target: (Updatable) Target name for which the credential is provided.
        :param pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]] variables: (Updatable) List of fleet credential variables.
        """
        pulumi.set(__self__, "credential_level", credential_level)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter(name="credentialLevel")
    def credential_level(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) At what level the credential is provided?
        """
        return pulumi.get(self, "credential_level")

    @credential_level.setter
    def credential_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential_level", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the resource associated with the target for which the credential is created.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Target name for which the credential is provided.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]]]:
        """
        (Updatable) List of fleet credential variables.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FleetCredentialEntitySpecificsVariableArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the variable.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value corresponding to the variable name.
        """
elif False:
    FleetCredentialEntitySpecificsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialEntitySpecificsVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the variable.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value corresponding to the variable name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value corresponding to the variable name.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FleetCredentialPasswordArgsDict(TypedDict):
        credential_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Credential Type.
        """
        key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        key_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Vault Key version.
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The secret version.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value corresponding to the credential.
        """
        vault_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
        """
elif False:
    FleetCredentialPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialPasswordArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[_builtins.str],
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_version: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 vault_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] credential_type: (Updatable) Credential Type.
        :param pulumi.Input[_builtins.str] key_id: (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        :param pulumi.Input[_builtins.str] key_version: (Updatable) The Vault Key version.
        :param pulumi.Input[_builtins.str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        :param pulumi.Input[_builtins.str] secret_version: (Updatable) The secret version.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value corresponding to the credential.
        :param pulumi.Input[_builtins.str] vault_id: (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Credential Type.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential_type", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Vault Key version.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_version", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The secret version.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value corresponding to the credential.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class FleetCredentialUserArgsDict(TypedDict):
        credential_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Credential Type.
        """
        key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        key_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Vault Key version.
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The secret version.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value corresponding to the credential.
        """
        vault_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    FleetCredentialUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialUserArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[_builtins.str],
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_version: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 vault_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] credential_type: (Updatable) Credential Type.
        :param pulumi.Input[_builtins.str] key_id: (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        :param pulumi.Input[_builtins.str] key_version: (Updatable) The Vault Key version.
        :param pulumi.Input[_builtins.str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        :param pulumi.Input[_builtins.str] secret_version: (Updatable) The secret version.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value corresponding to the credential.
        :param pulumi.Input[_builtins.str] vault_id: (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Credential Type.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credential_type", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Vault Key version.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_version", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The secret version.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value corresponding to the credential.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class FleetDetailsArgsDict(TypedDict):
        fleet_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the Fleet. PRODUCT - A fleet of product-specific resources for a product type. ENVIRONMENT - A fleet of environment-specific resources for a product stack. GROUP - A fleet of a fleet of either environment or product fleets. GENERIC - A fleet of resources selected dynamically or manually for reporting purposes
        """
elif False:
    FleetDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetDetailsArgs:
    def __init__(__self__, *,
                 fleet_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fleet_type: Type of the Fleet. PRODUCT - A fleet of product-specific resources for a product type. ENVIRONMENT - A fleet of environment-specific resources for a product stack. GROUP - A fleet of a fleet of either environment or product fleets. GENERIC - A fleet of resources selected dynamically or manually for reporting purposes
        """
        if fleet_type is not None:
            pulumi.set(__self__, "fleet_type", fleet_type)

    @_builtins.property
    @pulumi.getter(name="fleetType")
    def fleet_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the Fleet. PRODUCT - A fleet of product-specific resources for a product type. ENVIRONMENT - A fleet of environment-specific resources for a product stack. GROUP - A fleet of a fleet of either environment or product fleets. GENERIC - A fleet of resources selected dynamically or manually for reporting purposes
        """
        return pulumi.get(self, "fleet_type")

    @fleet_type.setter
    def fleet_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fleet_type", value)


if not MYPY:
    class FleetNotificationPreferenceArgsDict(TypedDict):
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Compartment ID the topic belongs to.
        """
        topic_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Topic Id where the notifications will be directed. A topic is a communication channel for sending messages on chosen events to subscriptions.
        """
        preferences: NotRequired[pulumi.Input['FleetNotificationPreferencePreferencesArgsDict']]
        """
        (Updatable) Preferences to send notifications on the fleet activities.
        """
elif False:
    FleetNotificationPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetNotificationPreferenceArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[_builtins.str],
                 topic_id: pulumi.Input[_builtins.str],
                 preferences: Optional[pulumi.Input['FleetNotificationPreferencePreferencesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) Compartment ID the topic belongs to.
        :param pulumi.Input[_builtins.str] topic_id: (Updatable) Topic Id where the notifications will be directed. A topic is a communication channel for sending messages on chosen events to subscriptions.
        :param pulumi.Input['FleetNotificationPreferencePreferencesArgs'] preferences: (Updatable) Preferences to send notifications on the fleet activities.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "topic_id", topic_id)
        if preferences is not None:
            pulumi.set(__self__, "preferences", preferences)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Compartment ID the topic belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Topic Id where the notifications will be directed. A topic is a communication channel for sending messages on chosen events to subscriptions.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_id", value)

    @_builtins.property
    @pulumi.getter
    def preferences(self) -> Optional[pulumi.Input['FleetNotificationPreferencePreferencesArgs']]:
        """
        (Updatable) Preferences to send notifications on the fleet activities.
        """
        return pulumi.get(self, "preferences")

    @preferences.setter
    def preferences(self, value: Optional[pulumi.Input['FleetNotificationPreferencePreferencesArgs']]):
        pulumi.set(self, "preferences", value)


if not MYPY:
    class FleetNotificationPreferencePreferencesArgsDict(TypedDict):
        on_job_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on Job Failures.
        """
        on_resource_non_compliance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification when fleet resource becomes non compliant.
        """
        on_runbook_newer_version: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification when a newer version of runbook associated with a fleet is available
        """
        on_task_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on task failure.
        """
        on_task_pause: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification when a task is paused.
        """
        on_task_success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on task success.
        """
        on_topology_modification: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on Environment Fleet Topology Modification.
        """
        upcoming_schedule: NotRequired[pulumi.Input['FleetNotificationPreferencePreferencesUpcomingScheduleArgsDict']]
        """
        (Updatable) Enables notification on upcoming schedule.
        """
elif False:
    FleetNotificationPreferencePreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetNotificationPreferencePreferencesArgs:
    def __init__(__self__, *,
                 on_job_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_resource_non_compliance: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_runbook_newer_version: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_task_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_task_pause: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_task_success: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_topology_modification: Optional[pulumi.Input[_builtins.bool]] = None,
                 upcoming_schedule: Optional[pulumi.Input['FleetNotificationPreferencePreferencesUpcomingScheduleArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] on_job_failure: (Updatable) Enables or disables notification on Job Failures.
        :param pulumi.Input[_builtins.bool] on_resource_non_compliance: (Updatable) Enables or disables notification when fleet resource becomes non compliant.
        :param pulumi.Input[_builtins.bool] on_runbook_newer_version: (Updatable) Enables or disables notification when a newer version of runbook associated with a fleet is available
        :param pulumi.Input[_builtins.bool] on_task_failure: (Updatable) Enables or disables notification on task failure.
        :param pulumi.Input[_builtins.bool] on_task_pause: (Updatable) Enables or disables notification when a task is paused.
        :param pulumi.Input[_builtins.bool] on_task_success: (Updatable) Enables or disables notification on task success.
        :param pulumi.Input[_builtins.bool] on_topology_modification: (Updatable) Enables or disables notification on Environment Fleet Topology Modification.
        :param pulumi.Input['FleetNotificationPreferencePreferencesUpcomingScheduleArgs'] upcoming_schedule: (Updatable) Enables notification on upcoming schedule.
        """
        if on_job_failure is not None:
            pulumi.set(__self__, "on_job_failure", on_job_failure)
        if on_resource_non_compliance is not None:
            pulumi.set(__self__, "on_resource_non_compliance", on_resource_non_compliance)
        if on_runbook_newer_version is not None:
            pulumi.set(__self__, "on_runbook_newer_version", on_runbook_newer_version)
        if on_task_failure is not None:
            pulumi.set(__self__, "on_task_failure", on_task_failure)
        if on_task_pause is not None:
            pulumi.set(__self__, "on_task_pause", on_task_pause)
        if on_task_success is not None:
            pulumi.set(__self__, "on_task_success", on_task_success)
        if on_topology_modification is not None:
            pulumi.set(__self__, "on_topology_modification", on_topology_modification)
        if upcoming_schedule is not None:
            pulumi.set(__self__, "upcoming_schedule", upcoming_schedule)

    @_builtins.property
    @pulumi.getter(name="onJobFailure")
    def on_job_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on Job Failures.
        """
        return pulumi.get(self, "on_job_failure")

    @on_job_failure.setter
    def on_job_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_job_failure", value)

    @_builtins.property
    @pulumi.getter(name="onResourceNonCompliance")
    def on_resource_non_compliance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification when fleet resource becomes non compliant.
        """
        return pulumi.get(self, "on_resource_non_compliance")

    @on_resource_non_compliance.setter
    def on_resource_non_compliance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_resource_non_compliance", value)

    @_builtins.property
    @pulumi.getter(name="onRunbookNewerVersion")
    def on_runbook_newer_version(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification when a newer version of runbook associated with a fleet is available
        """
        return pulumi.get(self, "on_runbook_newer_version")

    @on_runbook_newer_version.setter
    def on_runbook_newer_version(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_runbook_newer_version", value)

    @_builtins.property
    @pulumi.getter(name="onTaskFailure")
    def on_task_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on task failure.
        """
        return pulumi.get(self, "on_task_failure")

    @on_task_failure.setter
    def on_task_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_task_failure", value)

    @_builtins.property
    @pulumi.getter(name="onTaskPause")
    def on_task_pause(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification when a task is paused.
        """
        return pulumi.get(self, "on_task_pause")

    @on_task_pause.setter
    def on_task_pause(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_task_pause", value)

    @_builtins.property
    @pulumi.getter(name="onTaskSuccess")
    def on_task_success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on task success.
        """
        return pulumi.get(self, "on_task_success")

    @on_task_success.setter
    def on_task_success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_task_success", value)

    @_builtins.property
    @pulumi.getter(name="onTopologyModification")
    def on_topology_modification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on Environment Fleet Topology Modification.
        """
        return pulumi.get(self, "on_topology_modification")

    @on_topology_modification.setter
    def on_topology_modification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_topology_modification", value)

    @_builtins.property
    @pulumi.getter(name="upcomingSchedule")
    def upcoming_schedule(self) -> Optional[pulumi.Input['FleetNotificationPreferencePreferencesUpcomingScheduleArgs']]:
        """
        (Updatable) Enables notification on upcoming schedule.
        """
        return pulumi.get(self, "upcoming_schedule")

    @upcoming_schedule.setter
    def upcoming_schedule(self, value: Optional[pulumi.Input['FleetNotificationPreferencePreferencesUpcomingScheduleArgs']]):
        pulumi.set(self, "upcoming_schedule", value)


if not MYPY:
    class FleetNotificationPreferencePreferencesUpcomingScheduleArgsDict(TypedDict):
        notify_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specify when the notification should be sent.
        """
        on_upcoming_schedule: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables notification on upcoming schedule.
        """
elif False:
    FleetNotificationPreferencePreferencesUpcomingScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetNotificationPreferencePreferencesUpcomingScheduleArgs:
    def __init__(__self__, *,
                 notify_before: Optional[pulumi.Input[_builtins.str]] = None,
                 on_upcoming_schedule: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] notify_before: (Updatable) Specify when the notification should be sent.
        :param pulumi.Input[_builtins.bool] on_upcoming_schedule: (Updatable) Enables notification on upcoming schedule.
        """
        if notify_before is not None:
            pulumi.set(__self__, "notify_before", notify_before)
        if on_upcoming_schedule is not None:
            pulumi.set(__self__, "on_upcoming_schedule", on_upcoming_schedule)

    @_builtins.property
    @pulumi.getter(name="notifyBefore")
    def notify_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specify when the notification should be sent.
        """
        return pulumi.get(self, "notify_before")

    @notify_before.setter
    def notify_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notify_before", value)

    @_builtins.property
    @pulumi.getter(name="onUpcomingSchedule")
    def on_upcoming_schedule(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables notification on upcoming schedule.
        """
        return pulumi.get(self, "on_upcoming_schedule")

    @on_upcoming_schedule.setter
    def on_upcoming_schedule(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_upcoming_schedule", value)


if not MYPY:
    class FleetPropertyArgsDict(TypedDict):
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) compartment OCID
        """
        fleet_property_type: pulumi.Input[_builtins.str]
        """
        Type of the FleetProperty.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        is_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Property is required or not.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the Property.
        """
elif False:
    FleetPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetPropertyArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[_builtins.str],
                 fleet_property_type: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) compartment OCID
        :param pulumi.Input[_builtins.str] fleet_property_type: Type of the FleetProperty.
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.bool] is_required: Property is required or not.
        :param pulumi.Input[_builtins.str] value: Value of the Property.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "fleet_property_type", fleet_property_type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) compartment OCID
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="fleetPropertyType")
    def fleet_property_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the FleetProperty.
        """
        return pulumi.get(self, "fleet_property_type")

    @fleet_property_type.setter
    def fleet_property_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fleet_property_type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Property is required or not.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_required", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the Property.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FleetResourceArgsDict(TypedDict):
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Compartment Identifier[OCID].
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        OCID of the resource.
        """
        tenancy_id: pulumi.Input[_builtins.str]
        """
        Tenancy Identifier[OCID].


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        fleet_resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the FleetResource.
        """
elif False:
    FleetResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetResourceArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[_builtins.str],
                 resource_id: pulumi.Input[_builtins.str],
                 tenancy_id: pulumi.Input[_builtins.str],
                 fleet_resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) Compartment Identifier[OCID].
        :param pulumi.Input[_builtins.str] resource_id: OCID of the resource.
        :param pulumi.Input[_builtins.str] tenancy_id: Tenancy Identifier[OCID].
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] fleet_resource_type: Type of the FleetResource.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "tenancy_id", tenancy_id)
        if fleet_resource_type is not None:
            pulumi.set(__self__, "fleet_resource_type", fleet_resource_type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Compartment Identifier[OCID].
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of the resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="tenancyId")
    def tenancy_id(self) -> pulumi.Input[_builtins.str]:
        """
        Tenancy Identifier[OCID].


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "tenancy_id")

    @tenancy_id.setter
    def tenancy_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenancy_id", value)

    @_builtins.property
    @pulumi.getter(name="fleetResourceType")
    def fleet_resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the FleetResource.
        """
        return pulumi.get(self, "fleet_resource_type")

    @fleet_resource_type.setter
    def fleet_resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fleet_resource_type", value)


if not MYPY:
    class FleetResourceSelectionArgsDict(TypedDict):
        resource_selection_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of resource selection in a Fleet. Select resources manually or select resources based on rules.
        """
        rule_selection_criteria: NotRequired[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaArgsDict']]
        """
        (Updatable) Rule Selection Criteria for DYNAMIC resource selection for a GENERIC fleet. Rules define what resources are members of this fleet. All resources that meet the criteria are added automatically.
        """
elif False:
    FleetResourceSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetResourceSelectionArgs:
    def __init__(__self__, *,
                 resource_selection_type: pulumi.Input[_builtins.str],
                 rule_selection_criteria: Optional[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] resource_selection_type: (Updatable) Type of resource selection in a Fleet. Select resources manually or select resources based on rules.
        :param pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaArgs'] rule_selection_criteria: (Updatable) Rule Selection Criteria for DYNAMIC resource selection for a GENERIC fleet. Rules define what resources are members of this fleet. All resources that meet the criteria are added automatically.
        """
        pulumi.set(__self__, "resource_selection_type", resource_selection_type)
        if rule_selection_criteria is not None:
            pulumi.set(__self__, "rule_selection_criteria", rule_selection_criteria)

    @_builtins.property
    @pulumi.getter(name="resourceSelectionType")
    def resource_selection_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of resource selection in a Fleet. Select resources manually or select resources based on rules.
        """
        return pulumi.get(self, "resource_selection_type")

    @resource_selection_type.setter
    def resource_selection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_selection_type", value)

    @_builtins.property
    @pulumi.getter(name="ruleSelectionCriteria")
    def rule_selection_criteria(self) -> Optional[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaArgs']]:
        """
        (Updatable) Rule Selection Criteria for DYNAMIC resource selection for a GENERIC fleet. Rules define what resources are members of this fleet. All resources that meet the criteria are added automatically.
        """
        return pulumi.get(self, "rule_selection_criteria")

    @rule_selection_criteria.setter
    def rule_selection_criteria(self, value: Optional[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaArgs']]):
        pulumi.set(self, "rule_selection_criteria", value)


if not MYPY:
    class FleetResourceSelectionRuleSelectionCriteriaArgsDict(TypedDict):
        match_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Match condition for the rule selection. Include resources that match all rules or any of the rules.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleArgsDict']]]]
        """
        (Updatable) Rules.
        """
elif False:
    FleetResourceSelectionRuleSelectionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetResourceSelectionRuleSelectionCriteriaArgs:
    def __init__(__self__, *,
                 match_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] match_condition: (Updatable) Match condition for the rule selection. Include resources that match all rules or any of the rules.
        :param pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleArgs']]] rules: (Updatable) Rules.
        """
        if match_condition is not None:
            pulumi.set(__self__, "match_condition", match_condition)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="matchCondition")
    def match_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Match condition for the rule selection. Include resources that match all rules or any of the rules.
        """
        return pulumi.get(self, "match_condition")

    @match_condition.setter
    def match_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_condition", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleArgs']]]]:
        """
        (Updatable) Rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FleetResourceSelectionRuleSelectionCriteriaRuleArgsDict(TypedDict):
        basis: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Based on what the rule is created. It can be based on a resourceProperty or a tag.   If based on a tag, basis will be 'definedTagEquals' If based on a resource property, basis will be 'inventoryProperties'
        """
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Compartment Id for which the rule is created.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgsDict']]]]
        """
        (Updatable) Rule Conditions
        """
        resource_compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Compartment ID to dynamically search resources. Provide the compartment ID to which the rule is applicable.
        """
elif False:
    FleetResourceSelectionRuleSelectionCriteriaRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetResourceSelectionRuleSelectionCriteriaRuleArgs:
    def __init__(__self__, *,
                 basis: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgs']]]] = None,
                 resource_compartment_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] basis: (Updatable) Based on what the rule is created. It can be based on a resourceProperty or a tag.   If based on a tag, basis will be 'definedTagEquals' If based on a resource property, basis will be 'inventoryProperties'
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) Compartment Id for which the rule is created.
        :param pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgs']]] conditions: (Updatable) Rule Conditions
        :param pulumi.Input[_builtins.str] resource_compartment_id: (Updatable) The Compartment ID to dynamically search resources. Provide the compartment ID to which the rule is applicable.
        """
        if basis is not None:
            pulumi.set(__self__, "basis", basis)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if resource_compartment_id is not None:
            pulumi.set(__self__, "resource_compartment_id", resource_compartment_id)

    @_builtins.property
    @pulumi.getter
    def basis(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Based on what the rule is created. It can be based on a resourceProperty or a tag.   If based on a tag, basis will be 'definedTagEquals' If based on a resource property, basis will be 'inventoryProperties'
        """
        return pulumi.get(self, "basis")

    @basis.setter
    def basis(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basis", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Compartment Id for which the rule is created.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgs']]]]:
        """
        (Updatable) Rule Conditions
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="resourceCompartmentId")
    def resource_compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Compartment ID to dynamically search resources. Provide the compartment ID to which the rule is applicable.
        """
        return pulumi.get(self, "resource_compartment_id")

    @resource_compartment_id.setter
    def resource_compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_compartment_id", value)


if not MYPY:
    class FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgsDict(TypedDict):
        attr_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Attribute Group. Provide a Tag namespace if the rule is based on a tag. Provide resource type if the rule is based on a resource property.
        """
        attr_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Attribute Key.Provide Tag key if the rule is based on a tag. Provide resource property name if the rule is based on a resource property.
        """
        attr_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Attribute Value.Provide Tag value if the rule is based on a tag. Provide resource property value if the rule is based on a resource property.
        """
elif False:
    FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetResourceSelectionRuleSelectionCriteriaRuleConditionArgs:
    def __init__(__self__, *,
                 attr_group: Optional[pulumi.Input[_builtins.str]] = None,
                 attr_key: Optional[pulumi.Input[_builtins.str]] = None,
                 attr_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attr_group: (Updatable) Attribute Group. Provide a Tag namespace if the rule is based on a tag. Provide resource type if the rule is based on a resource property.
        :param pulumi.Input[_builtins.str] attr_key: (Updatable) Attribute Key.Provide Tag key if the rule is based on a tag. Provide resource property name if the rule is based on a resource property.
        :param pulumi.Input[_builtins.str] attr_value: (Updatable) Attribute Value.Provide Tag value if the rule is based on a tag. Provide resource property value if the rule is based on a resource property.
        """
        if attr_group is not None:
            pulumi.set(__self__, "attr_group", attr_group)
        if attr_key is not None:
            pulumi.set(__self__, "attr_key", attr_key)
        if attr_value is not None:
            pulumi.set(__self__, "attr_value", attr_value)

    @_builtins.property
    @pulumi.getter(name="attrGroup")
    def attr_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Attribute Group. Provide a Tag namespace if the rule is based on a tag. Provide resource type if the rule is based on a resource property.
        """
        return pulumi.get(self, "attr_group")

    @attr_group.setter
    def attr_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attr_group", value)

    @_builtins.property
    @pulumi.getter(name="attrKey")
    def attr_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Attribute Key.Provide Tag key if the rule is based on a tag. Provide resource property name if the rule is based on a resource property.
        """
        return pulumi.get(self, "attr_key")

    @attr_key.setter
    def attr_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attr_key", value)

    @_builtins.property
    @pulumi.getter(name="attrValue")
    def attr_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Attribute Value.Provide Tag value if the rule is based on a tag. Provide resource property value if the rule is based on a resource property.
        """
        return pulumi.get(self, "attr_value")

    @attr_value.setter
    def attr_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attr_value", value)


if not MYPY:
    class OnboardingAppliedPolicyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique id of the resource.
        """
        statements: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Policy statements.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example:
        `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        time_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
elif False:
    OnboardingAppliedPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnboardingAppliedPolicyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 statements: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 time_updated: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The unique id of the resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] statements: Policy statements.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. Example:
               `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        :param pulumi.Input[_builtins.str] time_updated: The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if statements is not None:
            pulumi.set(__self__, "statements", statements)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique id of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Policy statements.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "statements", value)

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example:
        `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_tags", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class PatchArtifactDetailsArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        """
        (Updatable) Artifact category details.
        """
        artifact: NotRequired[pulumi.Input['PatchArtifactDetailsArtifactArgsDict']]
        """
        (Updatable) Patch artifact metadata Details which is common for all platforms.
        """
        artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgsDict']]]]
        """
        (Updatable) Artifacts.
        """
elif False:
    PatchArtifactDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchArtifactDetailsArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 artifact: Optional[pulumi.Input['PatchArtifactDetailsArtifactArgs']] = None,
                 artifacts: Optional[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] category: (Updatable) Artifact category details.
        :param pulumi.Input['PatchArtifactDetailsArtifactArgs'] artifact: (Updatable) Patch artifact metadata Details which is common for all platforms.
        :param pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]] artifacts: (Updatable) Artifacts.
        """
        pulumi.set(__self__, "category", category)
        if artifact is not None:
            pulumi.set(__self__, "artifact", artifact)
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Artifact category details.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def artifact(self) -> Optional[pulumi.Input['PatchArtifactDetailsArtifactArgs']]:
        """
        (Updatable) Patch artifact metadata Details which is common for all platforms.
        """
        return pulumi.get(self, "artifact")

    @artifact.setter
    def artifact(self, value: Optional[pulumi.Input['PatchArtifactDetailsArtifactArgs']]):
        pulumi.set(self, "artifact", value)

    @_builtins.property
    @pulumi.getter
    def artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]]]:
        """
        (Updatable) Artifacts.
        """
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]]]):
        pulumi.set(self, "artifacts", value)


if not MYPY:
    class PatchArtifactDetailsArtifactArgsDict(TypedDict):
        architecture: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) System architecture.
        """
        content: NotRequired[pulumi.Input['PatchArtifactDetailsArtifactContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        os_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OS type the patch is applicable for.
        """
elif False:
    PatchArtifactDetailsArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchArtifactDetailsArtifactArgs:
    def __init__(__self__, *,
                 architecture: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input['PatchArtifactDetailsArtifactContentArgs']] = None,
                 os_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] architecture: (Updatable) System architecture.
        :param pulumi.Input['PatchArtifactDetailsArtifactContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[_builtins.str] os_type: (Updatable) The OS type the patch is applicable for.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) System architecture.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "architecture", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['PatchArtifactDetailsArtifactContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['PatchArtifactDetailsArtifactContentArgs']]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OS type the patch is applicable for.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_type", value)


if not MYPY:
    class PatchArtifactDetailsArtifactContentArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) Bucket Name.
        """
        checksum: pulumi.Input[_builtins.str]
        """
        (Updatable) md5 checksum of the artifact.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) Namespace.
        """
        object: pulumi.Input[_builtins.str]
        """
        (Updatable) Object Name.
        """
        source_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Content Source type details.
        """
elif False:
    PatchArtifactDetailsArtifactContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchArtifactDetailsArtifactContentArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 checksum: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 object: pulumi.Input[_builtins.str],
                 source_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[_builtins.str] checksum: (Updatable) md5 checksum of the artifact.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) Namespace.
        :param pulumi.Input[_builtins.str] object: (Updatable) Object Name.
        :param pulumi.Input[_builtins.str] source_type: (Updatable) Content Source type details.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "source_type", source_type)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "checksum", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class PatchDependentPatchArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PatchDependentPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchDependentPatchArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PatchPatchTypeArgsDict(TypedDict):
        platform_configuration_id: pulumi.Input[_builtins.str]
        """
        (Updatable) PlatformConfiguration Id corresponding to the Patch Type
        """
elif False:
    PatchPatchTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchPatchTypeArgs:
    def __init__(__self__, *,
                 platform_configuration_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] platform_configuration_id: (Updatable) PlatformConfiguration Id corresponding to the Patch Type
        """
        pulumi.set(__self__, "platform_configuration_id", platform_configuration_id)

    @_builtins.property
    @pulumi.getter(name="platformConfigurationId")
    def platform_configuration_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) PlatformConfiguration Id corresponding to the Patch Type
        """
        return pulumi.get(self, "platform_configuration_id")

    @platform_configuration_id.setter
    def platform_configuration_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "platform_configuration_id", value)


if not MYPY:
    class PatchProductArgsDict(TypedDict):
        platform_configuration_id: pulumi.Input[_builtins.str]
        """
        (Updatable) PlatformConfiguration Id corresponding to the Product
        """
        version: pulumi.Input[_builtins.str]
        """
        (Updatable) product version.
        """
elif False:
    PatchProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchProductArgs:
    def __init__(__self__, *,
                 platform_configuration_id: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] platform_configuration_id: (Updatable) PlatformConfiguration Id corresponding to the Product
        :param pulumi.Input[_builtins.str] version: (Updatable) product version.
        """
        pulumi.set(__self__, "platform_configuration_id", platform_configuration_id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="platformConfigurationId")
    def platform_configuration_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) PlatformConfiguration Id corresponding to the Product
        """
        return pulumi.get(self, "platform_configuration_id")

    @platform_configuration_id.setter
    def platform_configuration_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "platform_configuration_id", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) product version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsArgsDict(TypedDict):
        config_category: pulumi.Input[_builtins.str]
        """
        (Updatable) Category of configuration
        """
        compatible_products: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict']]]]
        """
        (Updatable) Products compatible with this Product. Provide products from the list of other products you have created that are compatible with the present one
        """
        components: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgsDict']]]]
        """
        (Updatable) OCID for the Credential name to be associated with the Product. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
        instance_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        patch_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict']]]]
        """
        (Updatable) Patch Types associated with this Product.
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgsDict']]]]
        """
        (Updatable) Products that belong to the stack. For example, Oracle WebLogic and Java for the Oracle Fusion Middleware product stack.
        """
        sub_category_details: NotRequired[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict']]
        """
        (Updatable) ProductStack Config Category Details.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Versions associated with the PRODUCT .
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsArgs:
    def __init__(__self__, *,
                 config_category: pulumi.Input[_builtins.str],
                 compatible_products: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_name: Optional[pulumi.Input[_builtins.str]] = None,
                 patch_types: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]]] = None,
                 sub_category_details: Optional[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs']] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] config_category: (Updatable) Category of configuration
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]] compatible_products: (Updatable) Products compatible with this Product. Provide products from the list of other products you have created that are compatible with the present one
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] components: (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]] credentials: (Updatable) OCID for the Credential name to be associated with the Product. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        :param pulumi.Input[_builtins.str] instance_id: (Updatable) The OCID of the resource.
        :param pulumi.Input[_builtins.str] instance_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]] patch_types: (Updatable) Patch Types associated with this Product.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]] products: (Updatable) Products that belong to the stack. For example, Oracle WebLogic and Java for the Oracle Fusion Middleware product stack.
        :param pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs'] sub_category_details: (Updatable) ProductStack Config Category Details.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] versions: (Updatable) Versions associated with the PRODUCT .
        """
        pulumi.set(__self__, "config_category", config_category)
        if compatible_products is not None:
            pulumi.set(__self__, "compatible_products", compatible_products)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if patch_types is not None:
            pulumi.set(__self__, "patch_types", patch_types)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if sub_category_details is not None:
            pulumi.set(__self__, "sub_category_details", sub_category_details)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="configCategory")
    def config_category(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Category of configuration
        """
        return pulumi.get(self, "config_category")

    @config_category.setter
    def config_category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config_category", value)

    @_builtins.property
    @pulumi.getter(name="compatibleProducts")
    def compatible_products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]]]:
        """
        (Updatable) Products compatible with this Product. Provide products from the list of other products you have created that are compatible with the present one
        """
        return pulumi.get(self, "compatible_products")

    @compatible_products.setter
    def compatible_products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]]]):
        pulumi.set(self, "compatible_products", value)

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "components", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]]]:
        """
        (Updatable) OCID for the Credential name to be associated with the Product. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_name", value)

    @_builtins.property
    @pulumi.getter(name="patchTypes")
    def patch_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]]]:
        """
        (Updatable) Patch Types associated with this Product.
        """
        return pulumi.get(self, "patch_types")

    @patch_types.setter
    def patch_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]]]):
        pulumi.set(self, "patch_types", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]]]:
        """
        (Updatable) Products that belong to the stack. For example, Oracle WebLogic and Java for the Oracle Fusion Middleware product stack.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]]]):
        pulumi.set(self, "products", value)

    @_builtins.property
    @pulumi.getter(name="subCategoryDetails")
    def sub_category_details(self) -> Optional[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs']]:
        """
        (Updatable) ProductStack Config Category Details.
        """
        return pulumi.get(self, "sub_category_details")

    @sub_category_details.setter
    def sub_category_details(self, value: Optional[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs']]):
        pulumi.set(self, "sub_category_details", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Versions associated with the PRODUCT .
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsPatchTypeArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsProductArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsProductArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict(TypedDict):
        sub_category: pulumi.Input[_builtins.str]
        """
        (Updatable) SubCategory of Product Stack.
        """
        components: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict']]]]
        """
        (Updatable) OCID for the Credential name to be associated with the Product Stack. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        patch_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict']]]]
        """
        (Updatable) Patch Types associated with this Product Stack which will be considered as Product.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Versions associated with the PRODUCT .
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs:
    def __init__(__self__, *,
                 sub_category: pulumi.Input[_builtins.str],
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]]] = None,
                 patch_types: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] sub_category: (Updatable) SubCategory of Product Stack.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] components: (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]] credentials: (Updatable) OCID for the Credential name to be associated with the Product Stack. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]] patch_types: (Updatable) Patch Types associated with this Product Stack which will be considered as Product.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] versions: (Updatable) Versions associated with the PRODUCT .
        """
        pulumi.set(__self__, "sub_category", sub_category)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if patch_types is not None:
            pulumi.set(__self__, "patch_types", patch_types)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="subCategory")
    def sub_category(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) SubCategory of Product Stack.
        """
        return pulumi.get(self, "sub_category")

    @sub_category.setter
    def sub_category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sub_category", value)

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "components", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]]]:
        """
        (Updatable) OCID for the Credential name to be associated with the Product Stack. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="patchTypes")
    def patch_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]]]:
        """
        (Updatable) Patch Types associated with this Product Stack which will be considered as Product.
        """
        return pulumi.get(self, "patch_types")

    @patch_types.setter
    def patch_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]]]):
        pulumi.set(self, "patch_types", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Versions associated with the PRODUCT .
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProvisionDeployedResourceArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mode of the resource. Example: "managed"
        """
        resource_instance_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProvisionDeployedResourceResourceInstanceListArgsDict']]]]
        """
        Collection of InstanceSummary
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource
        """
        resource_provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Provider
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The provider resource type. Must be supported by the Oracle Cloud Infrastructure provider. Example: Core.Instance
        """
elif False:
    ProvisionDeployedResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionDeployedResourceArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_instance_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProvisionDeployedResourceResourceInstanceListArgs']]]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The mode of the resource. Example: "managed"
        :param pulumi.Input[Sequence[pulumi.Input['ProvisionDeployedResourceResourceInstanceListArgs']]] resource_instance_lists: Collection of InstanceSummary
        :param pulumi.Input[_builtins.str] resource_name: The name of the resource
        :param pulumi.Input[_builtins.str] resource_provider: The name of the Provider
        :param pulumi.Input[_builtins.str] resource_type: The provider resource type. Must be supported by the Oracle Cloud Infrastructure provider. Example: Core.Instance
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_instance_lists is not None:
            pulumi.set(__self__, "resource_instance_lists", resource_instance_lists)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mode of the resource. Example: "managed"
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceInstanceLists")
    def resource_instance_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProvisionDeployedResourceResourceInstanceListArgs']]]]:
        """
        Collection of InstanceSummary
        """
        return pulumi.get(self, "resource_instance_lists")

    @resource_instance_lists.setter
    def resource_instance_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProvisionDeployedResourceResourceInstanceListArgs']]]]):
        pulumi.set(self, "resource_instance_lists", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Provider
        """
        return pulumi.get(self, "resource_provider")

    @resource_provider.setter
    def resource_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_provider", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The provider resource type. Must be supported by the Oracle Cloud Infrastructure provider. Example: Core.Instance
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class ProvisionDeployedResourceResourceInstanceListArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to create the FamProvision in.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the FamProvision.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of the FamProvision.
        """
elif False:
    ProvisionDeployedResourceResourceInstanceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionDeployedResourceResourceInstanceListArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to create the FamProvision in.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the FamProvision.
        :param pulumi.Input[_builtins.str] state: The current state of the FamProvision.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to create the FamProvision in.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the FamProvision.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of the FamProvision.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ProvisionTfOutputArgsDict(TypedDict):
        is_sensitive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The indicator if the data for this parameter is sensitive (e.g. should the data be hidden in UI, encrypted if stored, etc.)
        """
        output_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output description
        """
        output_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output name
        """
        output_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output type
        """
        output_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output value
        """
elif False:
    ProvisionTfOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionTfOutputArgs:
    def __init__(__self__, *,
                 is_sensitive: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_description: Optional[pulumi.Input[_builtins.str]] = None,
                 output_name: Optional[pulumi.Input[_builtins.str]] = None,
                 output_type: Optional[pulumi.Input[_builtins.str]] = None,
                 output_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_sensitive: The indicator if the data for this parameter is sensitive (e.g. should the data be hidden in UI, encrypted if stored, etc.)
        :param pulumi.Input[_builtins.str] output_description: The output description
        :param pulumi.Input[_builtins.str] output_name: The output name
        :param pulumi.Input[_builtins.str] output_type: The output type
        :param pulumi.Input[_builtins.str] output_value: The output value
        """
        if is_sensitive is not None:
            pulumi.set(__self__, "is_sensitive", is_sensitive)
        if output_description is not None:
            pulumi.set(__self__, "output_description", output_description)
        if output_name is not None:
            pulumi.set(__self__, "output_name", output_name)
        if output_type is not None:
            pulumi.set(__self__, "output_type", output_type)
        if output_value is not None:
            pulumi.set(__self__, "output_value", output_value)

    @_builtins.property
    @pulumi.getter(name="isSensitive")
    def is_sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The indicator if the data for this parameter is sensitive (e.g. should the data be hidden in UI, encrypted if stored, etc.)
        """
        return pulumi.get(self, "is_sensitive")

    @is_sensitive.setter
    def is_sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="outputDescription")
    def output_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output description
        """
        return pulumi.get(self, "output_description")

    @output_description.setter
    def output_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_description", value)

    @_builtins.property
    @pulumi.getter(name="outputName")
    def output_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output name
        """
        return pulumi.get(self, "output_name")

    @output_name.setter
    def output_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_name", value)

    @_builtins.property
    @pulumi.getter(name="outputType")
    def output_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output type
        """
        return pulumi.get(self, "output_type")

    @output_type.setter
    def output_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_type", value)

    @_builtins.property
    @pulumi.getter(name="outputValue")
    def output_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output value
        """
        return pulumi.get(self, "output_value")

    @output_value.setter
    def output_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_value", value)


if not MYPY:
    class RunbookRunbookVersionArgsDict(TypedDict):
        execution_workflow_details: pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsArgsDict']
        """
        Execution Workflow details.
        """
        groups: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupArgsDict']]]
        """
        The groups of the runbook.
        """
        tasks: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskArgsDict']]]
        """
        A set of tasks to execute in the runbook.
        """
        is_latest: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is this version the latest?
        """
        rollback_workflow_details: NotRequired[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsArgsDict']]
        """
        Rollback Workflow details.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the runbook.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    RunbookRunbookVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionArgs:
    def __init__(__self__, *,
                 execution_workflow_details: pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsArgs'],
                 groups: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupArgs']]],
                 tasks: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskArgs']]],
                 is_latest: Optional[pulumi.Input[_builtins.bool]] = None,
                 rollback_workflow_details: Optional[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsArgs']] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsArgs'] execution_workflow_details: Execution Workflow details.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupArgs']]] groups: The groups of the runbook.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskArgs']]] tasks: A set of tasks to execute in the runbook.
        :param pulumi.Input[_builtins.bool] is_latest: Is this version the latest?
        :param pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsArgs'] rollback_workflow_details: Rollback Workflow details.
        :param pulumi.Input[_builtins.str] version: The version of the runbook.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "execution_workflow_details", execution_workflow_details)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "tasks", tasks)
        if is_latest is not None:
            pulumi.set(__self__, "is_latest", is_latest)
        if rollback_workflow_details is not None:
            pulumi.set(__self__, "rollback_workflow_details", rollback_workflow_details)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="executionWorkflowDetails")
    def execution_workflow_details(self) -> pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsArgs']:
        """
        Execution Workflow details.
        """
        return pulumi.get(self, "execution_workflow_details")

    @execution_workflow_details.setter
    def execution_workflow_details(self, value: pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsArgs']):
        pulumi.set(self, "execution_workflow_details", value)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupArgs']]]:
        """
        The groups of the runbook.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def tasks(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskArgs']]]:
        """
        A set of tasks to execute in the runbook.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskArgs']]]):
        pulumi.set(self, "tasks", value)

    @_builtins.property
    @pulumi.getter(name="isLatest")
    def is_latest(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is this version the latest?
        """
        return pulumi.get(self, "is_latest")

    @is_latest.setter
    def is_latest(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_latest", value)

    @_builtins.property
    @pulumi.getter(name="rollbackWorkflowDetails")
    def rollback_workflow_details(self) -> Optional[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsArgs']]:
        """
        Rollback Workflow details.
        """
        return pulumi.get(self, "rollback_workflow_details")

    @rollback_workflow_details.setter
    def rollback_workflow_details(self, value: Optional[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsArgs']]):
        pulumi.set(self, "rollback_workflow_details", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the runbook.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RunbookRunbookVersionExecutionWorkflowDetailsArgsDict(TypedDict):
        workflows: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgsDict']]]
        """
        Execution Workflow for the runbook.
        """
elif False:
    RunbookRunbookVersionExecutionWorkflowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionExecutionWorkflowDetailsArgs:
    def __init__(__self__, *,
                 workflows: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgs']]] workflows: Execution Workflow for the runbook.
        """
        pulumi.set(__self__, "workflows", workflows)

    @_builtins.property
    @pulumi.getter
    def workflows(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgs']]]:
        """
        Execution Workflow for the runbook.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgs']]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        Name of the group.
        """
        steps: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict']]]
        """
        Steps within the Group.
        """
        type: pulumi.Input[_builtins.str]
        """
        Workflow Group  Details.
        """
elif False:
    RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionExecutionWorkflowDetailsWorkflowArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 steps: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group_name: Name of the group.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]] steps: Steps within the Group.
        :param pulumi.Input[_builtins.str] type: Workflow Group  Details.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]]:
        """
        Steps within the Group.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Workflow Group  Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Content Source Details.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the group.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provide StepName for the Task.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tasks within the Group. Provide the stepName for all applicable tasks.
        """
elif False:
    RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionExecutionWorkflowDetailsWorkflowStepArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Content Source Details.
        :param pulumi.Input[_builtins.str] group_name: Name of the group.
        :param pulumi.Input[_builtins.str] step_name: Provide StepName for the Task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] steps: Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Content Source Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provide StepName for the Task.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class RunbookRunbookVersionGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the group.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP : Executes tasks across resources in a rolling order.
        """
        properties: NotRequired[pulumi.Input['RunbookRunbookVersionGroupPropertiesArgsDict']]
        """
        The properties of the component.
        """
elif False:
    RunbookRunbookVersionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 properties: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the group.
        :param pulumi.Input[_builtins.str] type: The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP : Executes tasks across resources in a rolling order.
        :param pulumi.Input['RunbookRunbookVersionGroupPropertiesArgs'] properties: The properties of the component.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP : Executes tasks across resources in a rolling order.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesArgs']]:
        """
        The properties of the component.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class RunbookRunbookVersionGroupPropertiesArgsDict(TypedDict):
        action_on_failure: pulumi.Input[_builtins.str]
        """
        The action to be taken in case of a failure.
        """
        notification_preferences: NotRequired[pulumi.Input['RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgsDict']]
        """
        Preferences to send notifications on the task activities.
        """
        pause_details: NotRequired[pulumi.Input['RunbookRunbookVersionGroupPropertiesPauseDetailsArgsDict']]
        """
        Pause Details
        """
        pre_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        run_on: NotRequired[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnArgsDict']]
        """
        The runon conditions
        """
elif False:
    RunbookRunbookVersionGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupPropertiesArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[_builtins.str],
                 notification_preferences: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgs']] = None,
                 pause_details: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesPauseDetailsArgs']] = None,
                 pre_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 run_on: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action_on_failure: The action to be taken in case of a failure.
        :param pulumi.Input['RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgs'] notification_preferences: Preferences to send notifications on the task activities.
        :param pulumi.Input['RunbookRunbookVersionGroupPropertiesPauseDetailsArgs'] pause_details: Pause Details
        :param pulumi.Input[_builtins.str] pre_condition: Build control flow conditions that determine the relevance of the task execution.
        :param pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnArgs'] run_on: The runon conditions
        """
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        if notification_preferences is not None:
            pulumi.set(__self__, "notification_preferences", notification_preferences)
        if pause_details is not None:
            pulumi.set(__self__, "pause_details", pause_details)
        if pre_condition is not None:
            pulumi.set(__self__, "pre_condition", pre_condition)
        if run_on is not None:
            pulumi.set(__self__, "run_on", run_on)

    @_builtins.property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[_builtins.str]:
        """
        The action to be taken in case of a failure.
        """
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_on_failure", value)

    @_builtins.property
    @pulumi.getter(name="notificationPreferences")
    def notification_preferences(self) -> Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgs']]:
        """
        Preferences to send notifications on the task activities.
        """
        return pulumi.get(self, "notification_preferences")

    @notification_preferences.setter
    def notification_preferences(self, value: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgs']]):
        pulumi.set(self, "notification_preferences", value)

    @_builtins.property
    @pulumi.getter(name="pauseDetails")
    def pause_details(self) -> Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesPauseDetailsArgs']]:
        """
        Pause Details
        """
        return pulumi.get(self, "pause_details")

    @pause_details.setter
    def pause_details(self, value: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesPauseDetailsArgs']]):
        pulumi.set(self, "pause_details", value)

    @_builtins.property
    @pulumi.getter(name="preCondition")
    def pre_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        return pulumi.get(self, "pre_condition")

    @pre_condition.setter
    def pre_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_condition", value)

    @_builtins.property
    @pulumi.getter(name="runOn")
    def run_on(self) -> Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnArgs']]:
        """
        The runon conditions
        """
        return pulumi.get(self, "run_on")

    @run_on.setter
    def run_on(self, value: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnArgs']]):
        pulumi.set(self, "run_on", value)


if not MYPY:
    class RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgsDict(TypedDict):
        should_notify_on_pause: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables notification on pause.
        """
        should_notify_on_task_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables or disables notification on Task Failures.
        """
        should_notify_on_task_success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables or disables notification on Task Success.
        """
elif False:
    RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupPropertiesNotificationPreferencesArgs:
    def __init__(__self__, *,
                 should_notify_on_pause: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_success: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] should_notify_on_pause: Enables notification on pause.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_failure: Enables or disables notification on Task Failures.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_success: Enables or disables notification on Task Success.
        """
        if should_notify_on_pause is not None:
            pulumi.set(__self__, "should_notify_on_pause", should_notify_on_pause)
        if should_notify_on_task_failure is not None:
            pulumi.set(__self__, "should_notify_on_task_failure", should_notify_on_task_failure)
        if should_notify_on_task_success is not None:
            pulumi.set(__self__, "should_notify_on_task_success", should_notify_on_task_success)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnPause")
    def should_notify_on_pause(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables notification on pause.
        """
        return pulumi.get(self, "should_notify_on_pause")

    @should_notify_on_pause.setter
    def should_notify_on_pause(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_pause", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskFailure")
    def should_notify_on_task_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables or disables notification on Task Failures.
        """
        return pulumi.get(self, "should_notify_on_task_failure")

    @should_notify_on_task_failure.setter
    def should_notify_on_task_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_failure", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskSuccess")
    def should_notify_on_task_success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables or disables notification on Task Success.
        """
        return pulumi.get(self, "should_notify_on_task_success")

    @should_notify_on_task_success.setter
    def should_notify_on_task_success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_success", value)


if not MYPY:
    class RunbookRunbookVersionGroupPropertiesPauseDetailsArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        Pause based On.
        """
        duration_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in minutes to apply Pause.
        """
elif False:
    RunbookRunbookVersionGroupPropertiesPauseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupPropertiesPauseDetailsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: Pause based On.
        :param pulumi.Input[_builtins.int] duration_in_minutes: Time in minutes to apply Pause.
        """
        pulumi.set(__self__, "kind", kind)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Pause based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in minutes to apply Pause.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)


if not MYPY:
    class RunbookRunbookVersionGroupPropertiesRunOnArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        Run on based On.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the self hosted instance.
        """
        previous_task_instance_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict']]]]
        """
        Previous Task Instance Details
        """
elif False:
    RunbookRunbookVersionGroupPropertiesRunOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupPropertiesRunOnArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 previous_task_instance_details: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: Run on based On.
        :param pulumi.Input[_builtins.str] condition: Build control flow conditions that determine the relevance of the task execution.
        :param pulumi.Input[_builtins.str] host: OCID of the self hosted instance.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]] previous_task_instance_details: Previous Task Instance Details
        """
        pulumi.set(__self__, "kind", kind)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if previous_task_instance_details is not None:
            pulumi.set(__self__, "previous_task_instance_details", previous_task_instance_details)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Run on based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the self hosted instance.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="previousTaskInstanceDetails")
    def previous_task_instance_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]:
        """
        Previous Task Instance Details
        """
        return pulumi.get(self, "previous_task_instance_details")

    @previous_task_instance_details.setter
    def previous_task_instance_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]):
        pulumi.set(self, "previous_task_instance_details", value)


if not MYPY:
    class RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict(TypedDict):
        output_variable_details: NotRequired[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict']]
        """
        The details of the output variable that will be used for mapping.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Ocid.
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Type.
        """
elif False:
    RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs:
    def __init__(__self__, *,
                 output_variable_details: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs'] output_variable_details: The details of the output variable that will be used for mapping.
        :param pulumi.Input[_builtins.str] resource_id: Resource Ocid.
        :param pulumi.Input[_builtins.str] resource_type: Resource Type.
        """
        if output_variable_details is not None:
            pulumi.set(__self__, "output_variable_details", output_variable_details)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]:
        """
        The details of the output variable that will be used for mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: Optional[pulumi.Input['RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]):
        pulumi.set(self, "output_variable_details", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Ocid.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the output variable whose value has to be mapped.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the task step the output variable belongs to.
        """
elif False:
    RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] output_variable_name: The name of the output variable whose value has to be mapped.
        :param pulumi.Input[_builtins.str] step_name: The name of the task step the output variable belongs to.
        """
        if output_variable_name is not None:
            pulumi.set(__self__, "output_variable_name", output_variable_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the output variable whose value has to be mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_variable_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the task step the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookRunbookVersionRollbackWorkflowDetailsArgsDict(TypedDict):
        scope: pulumi.Input[_builtins.str]
        """
        rollback Scope
        """
        workflows: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgsDict']]]
        """
        Rollback Workflow for the runbook.
        """
elif False:
    RunbookRunbookVersionRollbackWorkflowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionRollbackWorkflowDetailsArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[_builtins.str],
                 workflows: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgs']]]):
        """
        :param pulumi.Input[_builtins.str] scope: rollback Scope
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgs']]] workflows: Rollback Workflow for the runbook.
        """
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "workflows", workflows)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        rollback Scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def workflows(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgs']]]:
        """
        Rollback Workflow for the runbook.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgs']]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        Name of the group.
        """
        steps: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict']]]
        """
        Steps within the Group.
        """
        type: pulumi.Input[_builtins.str]
        """
        Workflow Group  Details.
        """
elif False:
    RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionRollbackWorkflowDetailsWorkflowArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 steps: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group_name: Name of the group.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]] steps: Steps within the Group.
        :param pulumi.Input[_builtins.str] type: Workflow Group  Details.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]]:
        """
        Steps within the Group.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Workflow Group  Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Content Source Details.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the group.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provide StepName for the Task.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tasks within the Group. Provide the stepName for all applicable tasks.
        """
elif False:
    RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionRollbackWorkflowDetailsWorkflowStepArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Content Source Details.
        :param pulumi.Input[_builtins.str] group_name: Name of the group.
        :param pulumi.Input[_builtins.str] step_name: Provide StepName for the Task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] steps: Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Content Source Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provide StepName for the Task.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class RunbookRunbookVersionTaskArgsDict(TypedDict):
        step_name: pulumi.Input[_builtins.str]
        """
        The name of the task step.
        """
        task_record_details: pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsArgsDict']
        """
        The details of the task.
        """
        output_variable_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingArgsDict']]]]
        """
        Mapping output variables of previous tasks to the input variables of the current task.
        """
        step_properties: NotRequired[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesArgsDict']]
        """
        The properties of the component.
        """
elif False:
    RunbookRunbookVersionTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskArgs:
    def __init__(__self__, *,
                 step_name: pulumi.Input[_builtins.str],
                 task_record_details: pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsArgs'],
                 output_variable_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingArgs']]]] = None,
                 step_properties: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] step_name: The name of the task step.
        :param pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsArgs'] task_record_details: The details of the task.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingArgs']]] output_variable_mappings: Mapping output variables of previous tasks to the input variables of the current task.
        :param pulumi.Input['RunbookRunbookVersionTaskStepPropertiesArgs'] step_properties: The properties of the component.
        """
        pulumi.set(__self__, "step_name", step_name)
        pulumi.set(__self__, "task_record_details", task_record_details)
        if output_variable_mappings is not None:
            pulumi.set(__self__, "output_variable_mappings", output_variable_mappings)
        if step_properties is not None:
            pulumi.set(__self__, "step_properties", step_properties)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the task step.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter(name="taskRecordDetails")
    def task_record_details(self) -> pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsArgs']:
        """
        The details of the task.
        """
        return pulumi.get(self, "task_record_details")

    @task_record_details.setter
    def task_record_details(self, value: pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsArgs']):
        pulumi.set(self, "task_record_details", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableMappings")
    def output_variable_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingArgs']]]]:
        """
        Mapping output variables of previous tasks to the input variables of the current task.
        """
        return pulumi.get(self, "output_variable_mappings")

    @output_variable_mappings.setter
    def output_variable_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingArgs']]]]):
        pulumi.set(self, "output_variable_mappings", value)

    @_builtins.property
    @pulumi.getter(name="stepProperties")
    def step_properties(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesArgs']]:
        """
        The properties of the component.
        """
        return pulumi.get(self, "step_properties")

    @step_properties.setter
    def step_properties(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesArgs']]):
        pulumi.set(self, "step_properties", value)


if not MYPY:
    class RunbookRunbookVersionTaskOutputVariableMappingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the input variable.
        """
        output_variable_details: pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict']
        """
        The details of the output variable that will be used for mapping.
        """
elif False:
    RunbookRunbookVersionTaskOutputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskOutputVariableMappingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 output_variable_details: pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs']):
        """
        :param pulumi.Input[_builtins.str] name: The name of the input variable.
        :param pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs'] output_variable_details: The details of the output variable that will be used for mapping.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_variable_details", output_variable_details)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the input variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs']:
        """
        The details of the output variable that will be used for mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: pulumi.Input['RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs']):
        pulumi.set(self, "output_variable_details", value)


if not MYPY:
    class RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: pulumi.Input[_builtins.str]
        """
        The name of the output variable whose value has to be mapped.
        """
        step_name: pulumi.Input[_builtins.str]
        """
        The name of the task step the output variable belongs to.
        """
elif False:
    RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: pulumi.Input[_builtins.str],
                 step_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] output_variable_name: The name of the output variable whose value has to be mapped.
        :param pulumi.Input[_builtins.str] step_name: The name of the task step the output variable belongs to.
        """
        pulumi.set(__self__, "output_variable_name", output_variable_name)
        pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the output variable whose value has to be mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the task step the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookRunbookVersionTaskStepPropertiesArgsDict(TypedDict):
        action_on_failure: pulumi.Input[_builtins.str]
        """
        The action to be taken in case of a failure.
        """
        notification_preferences: NotRequired[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict']]
        """
        Preferences to send notifications on the task activities.
        """
        pause_details: NotRequired[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgsDict']]
        """
        Pause Details
        """
        pre_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        run_on: NotRequired[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnArgsDict']]
        """
        The runon conditions
        """
elif False:
    RunbookRunbookVersionTaskStepPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskStepPropertiesArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[_builtins.str],
                 notification_preferences: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgs']] = None,
                 pause_details: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgs']] = None,
                 pre_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 run_on: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action_on_failure: The action to be taken in case of a failure.
        :param pulumi.Input['RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgs'] notification_preferences: Preferences to send notifications on the task activities.
        :param pulumi.Input['RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgs'] pause_details: Pause Details
        :param pulumi.Input[_builtins.str] pre_condition: Build control flow conditions that determine the relevance of the task execution.
        :param pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnArgs'] run_on: The runon conditions
        """
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        if notification_preferences is not None:
            pulumi.set(__self__, "notification_preferences", notification_preferences)
        if pause_details is not None:
            pulumi.set(__self__, "pause_details", pause_details)
        if pre_condition is not None:
            pulumi.set(__self__, "pre_condition", pre_condition)
        if run_on is not None:
            pulumi.set(__self__, "run_on", run_on)

    @_builtins.property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[_builtins.str]:
        """
        The action to be taken in case of a failure.
        """
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_on_failure", value)

    @_builtins.property
    @pulumi.getter(name="notificationPreferences")
    def notification_preferences(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgs']]:
        """
        Preferences to send notifications on the task activities.
        """
        return pulumi.get(self, "notification_preferences")

    @notification_preferences.setter
    def notification_preferences(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgs']]):
        pulumi.set(self, "notification_preferences", value)

    @_builtins.property
    @pulumi.getter(name="pauseDetails")
    def pause_details(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgs']]:
        """
        Pause Details
        """
        return pulumi.get(self, "pause_details")

    @pause_details.setter
    def pause_details(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgs']]):
        pulumi.set(self, "pause_details", value)

    @_builtins.property
    @pulumi.getter(name="preCondition")
    def pre_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        return pulumi.get(self, "pre_condition")

    @pre_condition.setter
    def pre_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_condition", value)

    @_builtins.property
    @pulumi.getter(name="runOn")
    def run_on(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnArgs']]:
        """
        The runon conditions
        """
        return pulumi.get(self, "run_on")

    @run_on.setter
    def run_on(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnArgs']]):
        pulumi.set(self, "run_on", value)


if not MYPY:
    class RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict(TypedDict):
        should_notify_on_pause: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables notification on pause.
        """
        should_notify_on_task_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables or disables notification on Task Failures.
        """
        should_notify_on_task_success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables or disables notification on Task Success.
        """
elif False:
    RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskStepPropertiesNotificationPreferencesArgs:
    def __init__(__self__, *,
                 should_notify_on_pause: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_success: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] should_notify_on_pause: Enables notification on pause.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_failure: Enables or disables notification on Task Failures.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_success: Enables or disables notification on Task Success.
        """
        if should_notify_on_pause is not None:
            pulumi.set(__self__, "should_notify_on_pause", should_notify_on_pause)
        if should_notify_on_task_failure is not None:
            pulumi.set(__self__, "should_notify_on_task_failure", should_notify_on_task_failure)
        if should_notify_on_task_success is not None:
            pulumi.set(__self__, "should_notify_on_task_success", should_notify_on_task_success)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnPause")
    def should_notify_on_pause(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables notification on pause.
        """
        return pulumi.get(self, "should_notify_on_pause")

    @should_notify_on_pause.setter
    def should_notify_on_pause(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_pause", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskFailure")
    def should_notify_on_task_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables or disables notification on Task Failures.
        """
        return pulumi.get(self, "should_notify_on_task_failure")

    @should_notify_on_task_failure.setter
    def should_notify_on_task_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_failure", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskSuccess")
    def should_notify_on_task_success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables or disables notification on Task Success.
        """
        return pulumi.get(self, "should_notify_on_task_success")

    @should_notify_on_task_success.setter
    def should_notify_on_task_success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_success", value)


if not MYPY:
    class RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        Pause based On.
        """
        duration_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in minutes to apply Pause.
        """
elif False:
    RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskStepPropertiesPauseDetailsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: Pause based On.
        :param pulumi.Input[_builtins.int] duration_in_minutes: Time in minutes to apply Pause.
        """
        pulumi.set(__self__, "kind", kind)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Pause based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in minutes to apply Pause.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)


if not MYPY:
    class RunbookRunbookVersionTaskStepPropertiesRunOnArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        Run on based On.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the self hosted instance.
        """
        previous_task_instance_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict']]]]
        """
        Previous Task Instance Details
        """
elif False:
    RunbookRunbookVersionTaskStepPropertiesRunOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskStepPropertiesRunOnArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 previous_task_instance_details: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: Run on based On.
        :param pulumi.Input[_builtins.str] condition: Build control flow conditions that determine the relevance of the task execution.
        :param pulumi.Input[_builtins.str] host: OCID of the self hosted instance.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]] previous_task_instance_details: Previous Task Instance Details
        """
        pulumi.set(__self__, "kind", kind)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if previous_task_instance_details is not None:
            pulumi.set(__self__, "previous_task_instance_details", previous_task_instance_details)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Run on based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Build control flow conditions that determine the relevance of the task execution.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the self hosted instance.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="previousTaskInstanceDetails")
    def previous_task_instance_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]:
        """
        Previous Task Instance Details
        """
        return pulumi.get(self, "previous_task_instance_details")

    @previous_task_instance_details.setter
    def previous_task_instance_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]):
        pulumi.set(self, "previous_task_instance_details", value)


if not MYPY:
    class RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict(TypedDict):
        output_variable_details: NotRequired[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict']]
        """
        The details of the output variable that will be used for mapping.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Ocid.
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Type.
        """
elif False:
    RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs:
    def __init__(__self__, *,
                 output_variable_details: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs'] output_variable_details: The details of the output variable that will be used for mapping.
        :param pulumi.Input[_builtins.str] resource_id: Resource Ocid.
        :param pulumi.Input[_builtins.str] resource_type: Resource Type.
        """
        if output_variable_details is not None:
            pulumi.set(__self__, "output_variable_details", output_variable_details)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]:
        """
        The details of the output variable that will be used for mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]):
        pulumi.set(self, "output_variable_details", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Ocid.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the output variable whose value has to be mapped.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the task step the output variable belongs to.
        """
elif False:
    RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] output_variable_name: The name of the output variable whose value has to be mapped.
        :param pulumi.Input[_builtins.str] step_name: The name of the task step the output variable belongs to.
        """
        if output_variable_name is not None:
            pulumi.set(__self__, "output_variable_name", output_variable_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the output variable whose value has to be mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_variable_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the task step the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsArgsDict(TypedDict):
        scope: pulumi.Input[_builtins.str]
        """
        The scope of the task.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the task.
        """
        execution_details: NotRequired[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict']]
        """
        Execution details.
        """
        is_apply_subject_task: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is this an Apply Subject Task? Ex. Patch Execution Task
        """
        is_copy_to_library_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Make a copy of this task in Library
        """
        is_discovery_output_task: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is this a discovery output task?
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the task
        """
        os_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OS for the task.
        """
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        The platform of the runbook.
        """
        properties: NotRequired[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgsDict']]
        """
        The properties of the task.
        """
        task_record_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of taskRecord.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_details: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs']] = None,
                 is_apply_subject_task: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_copy_to_library_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_discovery_output_task: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 os_type: Optional[pulumi.Input[_builtins.str]] = None,
                 platform: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgs']] = None,
                 task_record_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scope: The scope of the task.
        :param pulumi.Input[_builtins.str] description: The description of the task.
        :param pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs'] execution_details: Execution details.
        :param pulumi.Input[_builtins.bool] is_apply_subject_task: Is this an Apply Subject Task? Ex. Patch Execution Task
        :param pulumi.Input[_builtins.bool] is_copy_to_library_enabled: Make a copy of this task in Library
        :param pulumi.Input[_builtins.bool] is_discovery_output_task: Is this a discovery output task?
        :param pulumi.Input[_builtins.str] name: The name of the task
        :param pulumi.Input[_builtins.str] os_type: The OS for the task.
        :param pulumi.Input[_builtins.str] platform: The platform of the runbook.
        :param pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgs'] properties: The properties of the task.
        :param pulumi.Input[_builtins.str] task_record_id: The ID of taskRecord.
        """
        pulumi.set(__self__, "scope", scope)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if execution_details is not None:
            pulumi.set(__self__, "execution_details", execution_details)
        if is_apply_subject_task is not None:
            pulumi.set(__self__, "is_apply_subject_task", is_apply_subject_task)
        if is_copy_to_library_enabled is not None:
            pulumi.set(__self__, "is_copy_to_library_enabled", is_copy_to_library_enabled)
        if is_discovery_output_task is not None:
            pulumi.set(__self__, "is_discovery_output_task", is_discovery_output_task)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if task_record_id is not None:
            pulumi.set(__self__, "task_record_id", task_record_id)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        The scope of the task.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the task.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="executionDetails")
    def execution_details(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs']]:
        """
        Execution details.
        """
        return pulumi.get(self, "execution_details")

    @execution_details.setter
    def execution_details(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs']]):
        pulumi.set(self, "execution_details", value)

    @_builtins.property
    @pulumi.getter(name="isApplySubjectTask")
    def is_apply_subject_task(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is this an Apply Subject Task? Ex. Patch Execution Task
        """
        return pulumi.get(self, "is_apply_subject_task")

    @is_apply_subject_task.setter
    def is_apply_subject_task(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_apply_subject_task", value)

    @_builtins.property
    @pulumi.getter(name="isCopyToLibraryEnabled")
    def is_copy_to_library_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Make a copy of this task in Library
        """
        return pulumi.get(self, "is_copy_to_library_enabled")

    @is_copy_to_library_enabled.setter
    def is_copy_to_library_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_copy_to_library_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isDiscoveryOutputTask")
    def is_discovery_output_task(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is this a discovery output task?
        """
        return pulumi.get(self, "is_discovery_output_task")

    @is_discovery_output_task.setter
    def is_discovery_output_task(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_discovery_output_task", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the task
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OS for the task.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_type", value)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The platform of the runbook.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgs']]:
        """
        The properties of the task.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="taskRecordId")
    def task_record_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of taskRecord.
        """
        return pulumi.get(self, "task_record_id")

    @task_record_id.setter
    def task_record_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_record_id", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict(TypedDict):
        execution_type: pulumi.Input[_builtins.str]
        """
        The action type of the task
        """
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        config_file: NotRequired[pulumi.Input[_builtins.str]]
        """
        Catalog Id having config file.
        """
        content: NotRequired[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict']]
        """
        Content Source details.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict']]]]
        """
        Credentials required for executing the task.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint to be invoked.
        """
        is_executable_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is the Content an executable file?
        """
        is_locked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is the script locked to prevent changes directly in Object Storage?
        """
        is_read_output_variable_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is read output variable enabled
        """
        target_compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the compartment to which the resource belongs to.
        """
        variables: NotRequired[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict']]
        """
        The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs:
    def __init__(__self__, *,
                 execution_type: pulumi.Input[_builtins.str],
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 config_file: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs']] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 is_executable_content: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_locked: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_read_output_variable_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 variables: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] execution_type: The action type of the task
        :param pulumi.Input[_builtins.str] command: Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        :param pulumi.Input[_builtins.str] config_file: Catalog Id having config file.
        :param pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs'] content: Content Source details.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]] credentials: Credentials required for executing the task.
        :param pulumi.Input[_builtins.str] endpoint: Endpoint to be invoked.
        :param pulumi.Input[_builtins.bool] is_executable_content: Is the Content an executable file?
        :param pulumi.Input[_builtins.bool] is_locked: Is the script locked to prevent changes directly in Object Storage?
        :param pulumi.Input[_builtins.bool] is_read_output_variable_enabled: Is read output variable enabled
        :param pulumi.Input[_builtins.str] target_compartment_id: OCID of the compartment to which the resource belongs to.
        :param pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs'] variables: The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        pulumi.set(__self__, "execution_type", execution_type)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_executable_content is not None:
            pulumi.set(__self__, "is_executable_content", is_executable_content)
        if is_locked is not None:
            pulumi.set(__self__, "is_locked", is_locked)
        if is_read_output_variable_enabled is not None:
            pulumi.set(__self__, "is_read_output_variable_enabled", is_read_output_variable_enabled)
        if target_compartment_id is not None:
            pulumi.set(__self__, "target_compartment_id", target_compartment_id)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type of the task
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_type", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Catalog Id having config file.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_file", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs']]:
        """
        Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs']]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]]:
        """
        Credentials required for executing the task.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint to be invoked.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="isExecutableContent")
    def is_executable_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is the Content an executable file?
        """
        return pulumi.get(self, "is_executable_content")

    @is_executable_content.setter
    def is_executable_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_executable_content", value)

    @_builtins.property
    @pulumi.getter(name="isLocked")
    def is_locked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is the script locked to prevent changes directly in Object Storage?
        """
        return pulumi.get(self, "is_locked")

    @is_locked.setter
    def is_locked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_locked", value)

    @_builtins.property
    @pulumi.getter(name="isReadOutputVariableEnabled")
    def is_read_output_variable_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is read output variable enabled
        """
        return pulumi.get(self, "is_read_output_variable_enabled")

    @is_read_output_variable_enabled.setter
    def is_read_output_variable_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_read_output_variable_enabled", value)

    @_builtins.property
    @pulumi.getter(name="targetCompartmentId")
    def target_compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the compartment to which the resource belongs to.
        """
        return pulumi.get(self, "target_compartment_id")

    @target_compartment_id.setter
    def target_compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs']]:
        """
        The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict(TypedDict):
        source_type: pulumi.Input[_builtins.str]
        """
        Content Source type details.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bucket Name.
        """
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        checksum: NotRequired[pulumi.Input[_builtins.str]]
        """
        md5 checksum of the artifact.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace.
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object Name.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 checksum: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_type: Content Source type details.
        :param pulumi.Input[_builtins.str] bucket: Bucket Name.
        :param pulumi.Input[_builtins.str] checksum: md5 checksum of the artifact.
        :param pulumi.Input[_builtins.str] namespace: Namespace.
        :param pulumi.Input[_builtins.str] object: Object Name.
        """
        pulumi.set(__self__, "source_type", source_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if checksum is not None:
            pulumi.set(__self__, "checksum", checksum)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter
    def checksum(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "checksum", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the resource.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict']]]]
        """
        The input variables for the task.
        """
        output_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of output variables.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]] = None,
                 output_variables: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]] input_variables: The input variables for the task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] output_variables: The list of output variables.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if output_variables is not None:
            pulumi.set(__self__, "output_variables", output_variables)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]:
        """
        The input variables for the task.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter(name="outputVariables")
    def output_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of output variables.
        """
        return pulumi.get(self, "output_variables")

    @output_variables.setter
    def output_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_variables", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the argument.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the argument.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Input argument Type.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the argument.
        :param pulumi.Input[_builtins.str] name: The name of the argument.
        :param pulumi.Input[_builtins.str] type: Input argument Type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the argument.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Input argument Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgsDict(TypedDict):
        num_retries: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of retries allowed.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout in seconds for the task.
        """
elif False:
    RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookRunbookVersionTaskTaskRecordDetailsPropertiesArgs:
    def __init__(__self__, *,
                 num_retries: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] num_retries: The number of retries allowed.
        :param pulumi.Input[_builtins.int] timeout_in_seconds: The timeout in seconds for the task.
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of retries allowed.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_retries", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout in seconds for the task.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class RunbookVersionExecutionWorkflowDetailsArgsDict(TypedDict):
        workflows: pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowArgsDict']]]
        """
        (Updatable) Execution Workflow for the runbook.
        """
elif False:
    RunbookVersionExecutionWorkflowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionExecutionWorkflowDetailsArgs:
    def __init__(__self__, *,
                 workflows: pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowArgs']]] workflows: (Updatable) Execution Workflow for the runbook.
        """
        pulumi.set(__self__, "workflows", workflows)

    @_builtins.property
    @pulumi.getter
    def workflows(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowArgs']]]:
        """
        (Updatable) Execution Workflow for the runbook.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowArgs']]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class RunbookVersionExecutionWorkflowDetailsWorkflowArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the group.
        """
        steps: pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict']]]
        """
        (Updatable) Steps within the Group.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Workflow Group Details.
        """
elif False:
    RunbookVersionExecutionWorkflowDetailsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionExecutionWorkflowDetailsWorkflowArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 steps: pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]] steps: (Updatable) Steps within the Group.
        :param pulumi.Input[_builtins.str] type: (Updatable) Workflow Group Details.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]]:
        """
        (Updatable) Steps within the Group.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookVersionExecutionWorkflowDetailsWorkflowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Workflow Group Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Content Source Details.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the group.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Provide StepName for the Task.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Tasks within the Group. Provide the
        stepName for all applicable tasks.
        """
elif False:
    RunbookVersionExecutionWorkflowDetailsWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionExecutionWorkflowDetailsWorkflowStepArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Content Source Details.
        :param pulumi.Input[_builtins.str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[_builtins.str] step_name: (Updatable) Provide StepName for the Task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] steps: (Updatable) Tasks within the Group. Provide the
               stepName for all applicable tasks.
        """
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content Source Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Provide StepName for the Task.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Tasks within the Group. Provide the
        stepName for all applicable tasks.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class RunbookVersionGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the group.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly
        inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP :
        Executes tasks across resources in a rolling order.
        """
        properties: NotRequired[pulumi.Input['RunbookVersionGroupPropertiesArgsDict']]
        """
        (Updatable) The properties of the component.
        """
elif False:
    RunbookVersionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 properties: Optional[pulumi.Input['RunbookVersionGroupPropertiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the group.
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly
               inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP :
               Executes tasks across resources in a rolling order.
        :param pulumi.Input['RunbookVersionGroupPropertiesArgs'] properties: (Updatable) The properties of the component.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly
        inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP :
        Executes tasks across resources in a rolling order.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['RunbookVersionGroupPropertiesArgs']]:
        """
        (Updatable) The properties of the component.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['RunbookVersionGroupPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class RunbookVersionGroupPropertiesArgsDict(TypedDict):
        action_on_failure: pulumi.Input[_builtins.str]
        """
        (Updatable) The action to be taken in case of a failure.
        """
        notification_preferences: NotRequired[pulumi.Input['RunbookVersionGroupPropertiesNotificationPreferencesArgsDict']]
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        pause_details: NotRequired[pulumi.Input['RunbookVersionGroupPropertiesPauseDetailsArgsDict']]
        """
        (Updatable) Pause Details
        """
        pre_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Build control flow conditions that determine the relevance of the
        task execution.
        """
        run_on: NotRequired[pulumi.Input['RunbookVersionGroupPropertiesRunOnArgsDict']]
        """
        (Updatable) The runon conditions
        """
elif False:
    RunbookVersionGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupPropertiesArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[_builtins.str],
                 notification_preferences: Optional[pulumi.Input['RunbookVersionGroupPropertiesNotificationPreferencesArgs']] = None,
                 pause_details: Optional[pulumi.Input['RunbookVersionGroupPropertiesPauseDetailsArgs']] = None,
                 pre_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 run_on: Optional[pulumi.Input['RunbookVersionGroupPropertiesRunOnArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action_on_failure: (Updatable) The action to be taken in case of a failure.
        :param pulumi.Input['RunbookVersionGroupPropertiesNotificationPreferencesArgs'] notification_preferences: (Updatable) Preferences to send notifications on the task activities.
        :param pulumi.Input['RunbookVersionGroupPropertiesPauseDetailsArgs'] pause_details: (Updatable) Pause Details
        :param pulumi.Input[_builtins.str] pre_condition: (Updatable) Build control flow conditions that determine the relevance of the
               task execution.
        :param pulumi.Input['RunbookVersionGroupPropertiesRunOnArgs'] run_on: (Updatable) The runon conditions
        """
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        if notification_preferences is not None:
            pulumi.set(__self__, "notification_preferences", notification_preferences)
        if pause_details is not None:
            pulumi.set(__self__, "pause_details", pause_details)
        if pre_condition is not None:
            pulumi.set(__self__, "pre_condition", pre_condition)
        if run_on is not None:
            pulumi.set(__self__, "run_on", run_on)

    @_builtins.property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The action to be taken in case of a failure.
        """
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_on_failure", value)

    @_builtins.property
    @pulumi.getter(name="notificationPreferences")
    def notification_preferences(self) -> Optional[pulumi.Input['RunbookVersionGroupPropertiesNotificationPreferencesArgs']]:
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        return pulumi.get(self, "notification_preferences")

    @notification_preferences.setter
    def notification_preferences(self, value: Optional[pulumi.Input['RunbookVersionGroupPropertiesNotificationPreferencesArgs']]):
        pulumi.set(self, "notification_preferences", value)

    @_builtins.property
    @pulumi.getter(name="pauseDetails")
    def pause_details(self) -> Optional[pulumi.Input['RunbookVersionGroupPropertiesPauseDetailsArgs']]:
        """
        (Updatable) Pause Details
        """
        return pulumi.get(self, "pause_details")

    @pause_details.setter
    def pause_details(self, value: Optional[pulumi.Input['RunbookVersionGroupPropertiesPauseDetailsArgs']]):
        pulumi.set(self, "pause_details", value)

    @_builtins.property
    @pulumi.getter(name="preCondition")
    def pre_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Build control flow conditions that determine the relevance of the
        task execution.
        """
        return pulumi.get(self, "pre_condition")

    @pre_condition.setter
    def pre_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_condition", value)

    @_builtins.property
    @pulumi.getter(name="runOn")
    def run_on(self) -> Optional[pulumi.Input['RunbookVersionGroupPropertiesRunOnArgs']]:
        """
        (Updatable) The runon conditions
        """
        return pulumi.get(self, "run_on")

    @run_on.setter
    def run_on(self, value: Optional[pulumi.Input['RunbookVersionGroupPropertiesRunOnArgs']]):
        pulumi.set(self, "run_on", value)


if not MYPY:
    class RunbookVersionGroupPropertiesNotificationPreferencesArgsDict(TypedDict):
        should_notify_on_pause: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables notification on pause.
        """
        should_notify_on_task_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on Task
        Failures.
        """
        should_notify_on_task_success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on Task Success.
        """
elif False:
    RunbookVersionGroupPropertiesNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupPropertiesNotificationPreferencesArgs:
    def __init__(__self__, *,
                 should_notify_on_pause: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_success: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] should_notify_on_pause: (Updatable) Enables notification on pause.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_failure: (Updatable) Enables or disables notification on Task
               Failures.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_success: (Updatable) Enables or disables notification on Task Success.
        """
        if should_notify_on_pause is not None:
            pulumi.set(__self__, "should_notify_on_pause", should_notify_on_pause)
        if should_notify_on_task_failure is not None:
            pulumi.set(__self__, "should_notify_on_task_failure", should_notify_on_task_failure)
        if should_notify_on_task_success is not None:
            pulumi.set(__self__, "should_notify_on_task_success", should_notify_on_task_success)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnPause")
    def should_notify_on_pause(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables notification on pause.
        """
        return pulumi.get(self, "should_notify_on_pause")

    @should_notify_on_pause.setter
    def should_notify_on_pause(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_pause", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskFailure")
    def should_notify_on_task_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on Task
        Failures.
        """
        return pulumi.get(self, "should_notify_on_task_failure")

    @should_notify_on_task_failure.setter
    def should_notify_on_task_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_failure", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskSuccess")
    def should_notify_on_task_success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on Task Success.
        """
        return pulumi.get(self, "should_notify_on_task_success")

    @should_notify_on_task_success.setter
    def should_notify_on_task_success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_success", value)


if not MYPY:
    class RunbookVersionGroupPropertiesPauseDetailsArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Pause based On.
        """
        duration_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Time in minutes to apply Pause.
        """
elif False:
    RunbookVersionGroupPropertiesPauseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupPropertiesPauseDetailsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: (Updatable) Pause based On.
        :param pulumi.Input[_builtins.int] duration_in_minutes: (Updatable) Time in minutes to apply Pause.
        """
        pulumi.set(__self__, "kind", kind)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Pause based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Time in minutes to apply Pause.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)


if not MYPY:
    class RunbookVersionGroupPropertiesRunOnArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Run on based On.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Build control flow conditions that
        determine the relevance of the task execution.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the self hosted instance.
        """
        previous_task_instance_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict']]]]
        """
        (Updatable) Previous Task
        Instance Details
        """
elif False:
    RunbookVersionGroupPropertiesRunOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupPropertiesRunOnArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 previous_task_instance_details: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: (Updatable) Run on based On.
        :param pulumi.Input[_builtins.str] condition: (Updatable) Build control flow conditions that
               determine the relevance of the task execution.
        :param pulumi.Input[_builtins.str] host: (Updatable) OCID of the self hosted instance.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]] previous_task_instance_details: (Updatable) Previous Task
               Instance Details
        """
        pulumi.set(__self__, "kind", kind)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if previous_task_instance_details is not None:
            pulumi.set(__self__, "previous_task_instance_details", previous_task_instance_details)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Run on based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Build control flow conditions that
        determine the relevance of the task execution.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the self hosted instance.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="previousTaskInstanceDetails")
    def previous_task_instance_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]:
        """
        (Updatable) Previous Task
        Instance Details
        """
        return pulumi.get(self, "previous_task_instance_details")

    @previous_task_instance_details.setter
    def previous_task_instance_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]):
        pulumi.set(self, "previous_task_instance_details", value)


if not MYPY:
    class RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict(TypedDict):
        output_variable_details: NotRequired[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict']]
        """
        (Updatable) The details of
        the output variable that will be used for mapping.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Resource Ocid.
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Resource Type.
        """
elif False:
    RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailArgs:
    def __init__(__self__, *,
                 output_variable_details: Optional[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs'] output_variable_details: (Updatable) The details of
               the output variable that will be used for mapping.
        :param pulumi.Input[_builtins.str] resource_id: (Updatable) Resource Ocid.
        :param pulumi.Input[_builtins.str] resource_type: (Updatable) Resource Type.
        """
        if output_variable_details is not None:
            pulumi.set(__self__, "output_variable_details", output_variable_details)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> Optional[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]:
        """
        (Updatable) The details of
        the output variable that will be used for mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: Optional[pulumi.Input['RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]):
        pulumi.set(self, "output_variable_details", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Resource Ocid.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Resource Type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the
        output variable whose value has to be mapped.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the task step
        the output variable belongs to.
        """
elif False:
    RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionGroupPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] output_variable_name: (Updatable) The name of the
               output variable whose value has to be mapped.
        :param pulumi.Input[_builtins.str] step_name: (Updatable) The name of the task step
               the output variable belongs to.
        """
        if output_variable_name is not None:
            pulumi.set(__self__, "output_variable_name", output_variable_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the
        output variable whose value has to be mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_variable_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the task step
        the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookVersionRollbackWorkflowDetailsArgsDict(TypedDict):
        scope: pulumi.Input[_builtins.str]
        """
        (Updatable) rollback Scope
        """
        workflows: pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowArgsDict']]]
        """
        (Updatable) Rollback Workflow for the runbook.
        """
elif False:
    RunbookVersionRollbackWorkflowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionRollbackWorkflowDetailsArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[_builtins.str],
                 workflows: pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowArgs']]]):
        """
        :param pulumi.Input[_builtins.str] scope: (Updatable) rollback Scope
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowArgs']]] workflows: (Updatable) Rollback Workflow for the runbook.
        """
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "workflows", workflows)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) rollback Scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def workflows(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowArgs']]]:
        """
        (Updatable) Rollback Workflow for the runbook.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowArgs']]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class RunbookVersionRollbackWorkflowDetailsWorkflowArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the group.
        """
        steps: pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict']]]
        """
        (Updatable) Steps within the Group.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Workflow Group Details.
        """
elif False:
    RunbookVersionRollbackWorkflowDetailsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionRollbackWorkflowDetailsWorkflowArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 steps: pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]] steps: (Updatable) Steps within the Group.
        :param pulumi.Input[_builtins.str] type: (Updatable) Workflow Group Details.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]]:
        """
        (Updatable) Steps within the Group.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookVersionRollbackWorkflowDetailsWorkflowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Workflow Group Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Content Source Details.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the group.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Provide StepName for the Task.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Tasks within the Group. Provide the
        stepName for all applicable tasks.
        """
elif False:
    RunbookVersionRollbackWorkflowDetailsWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionRollbackWorkflowDetailsWorkflowStepArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Content Source Details.
        :param pulumi.Input[_builtins.str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[_builtins.str] step_name: (Updatable) Provide StepName for the Task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] steps: (Updatable) Tasks within the Group. Provide the
               stepName for all applicable tasks.
        """
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content Source Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Provide StepName for the Task.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Tasks within the Group. Provide the
        stepName for all applicable tasks.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class RunbookVersionTaskArgsDict(TypedDict):
        step_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the task step.
        """
        task_record_details: pulumi.Input['RunbookVersionTaskTaskRecordDetailsArgsDict']
        """
        (Updatable) The details of the task.
        """
        output_variable_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskOutputVariableMappingArgsDict']]]]
        """
        (Updatable) Mapping output variables of previous tasks to the input
        variables of the current task.
        """
        step_properties: NotRequired[pulumi.Input['RunbookVersionTaskStepPropertiesArgsDict']]
        """
        (Updatable) The properties of the component.
        """
elif False:
    RunbookVersionTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskArgs:
    def __init__(__self__, *,
                 step_name: pulumi.Input[_builtins.str],
                 task_record_details: pulumi.Input['RunbookVersionTaskTaskRecordDetailsArgs'],
                 output_variable_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskOutputVariableMappingArgs']]]] = None,
                 step_properties: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] step_name: (Updatable) The name of the task step.
        :param pulumi.Input['RunbookVersionTaskTaskRecordDetailsArgs'] task_record_details: (Updatable) The details of the task.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskOutputVariableMappingArgs']]] output_variable_mappings: (Updatable) Mapping output variables of previous tasks to the input
               variables of the current task.
        :param pulumi.Input['RunbookVersionTaskStepPropertiesArgs'] step_properties: (Updatable) The properties of the component.
        """
        pulumi.set(__self__, "step_name", step_name)
        pulumi.set(__self__, "task_record_details", task_record_details)
        if output_variable_mappings is not None:
            pulumi.set(__self__, "output_variable_mappings", output_variable_mappings)
        if step_properties is not None:
            pulumi.set(__self__, "step_properties", step_properties)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the task step.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter(name="taskRecordDetails")
    def task_record_details(self) -> pulumi.Input['RunbookVersionTaskTaskRecordDetailsArgs']:
        """
        (Updatable) The details of the task.
        """
        return pulumi.get(self, "task_record_details")

    @task_record_details.setter
    def task_record_details(self, value: pulumi.Input['RunbookVersionTaskTaskRecordDetailsArgs']):
        pulumi.set(self, "task_record_details", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableMappings")
    def output_variable_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskOutputVariableMappingArgs']]]]:
        """
        (Updatable) Mapping output variables of previous tasks to the input
        variables of the current task.
        """
        return pulumi.get(self, "output_variable_mappings")

    @output_variable_mappings.setter
    def output_variable_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskOutputVariableMappingArgs']]]]):
        pulumi.set(self, "output_variable_mappings", value)

    @_builtins.property
    @pulumi.getter(name="stepProperties")
    def step_properties(self) -> Optional[pulumi.Input['RunbookVersionTaskStepPropertiesArgs']]:
        """
        (Updatable) The properties of the component.
        """
        return pulumi.get(self, "step_properties")

    @step_properties.setter
    def step_properties(self, value: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesArgs']]):
        pulumi.set(self, "step_properties", value)


if not MYPY:
    class RunbookVersionTaskOutputVariableMappingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the input variable.
        """
        output_variable_details: pulumi.Input['RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict']
        """
        (Updatable) The details of the output variable that will be used for
        mapping.
        """
elif False:
    RunbookVersionTaskOutputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskOutputVariableMappingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 output_variable_details: pulumi.Input['RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs']):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the input variable.
        :param pulumi.Input['RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs'] output_variable_details: (Updatable) The details of the output variable that will be used for
               mapping.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_variable_details", output_variable_details)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the input variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> pulumi.Input['RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs']:
        """
        (Updatable) The details of the output variable that will be used for
        mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: pulumi.Input['RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs']):
        pulumi.set(self, "output_variable_details", value)


if not MYPY:
    class RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the output variable whose value has to be
        mapped.
        """
        step_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the task step the output variable belongs to.
        """
elif False:
    RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskOutputVariableMappingOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: pulumi.Input[_builtins.str],
                 step_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] output_variable_name: (Updatable) The name of the output variable whose value has to be
               mapped.
        :param pulumi.Input[_builtins.str] step_name: (Updatable) The name of the task step the output variable belongs to.
        """
        pulumi.set(__self__, "output_variable_name", output_variable_name)
        pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the output variable whose value has to be
        mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the task step the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookVersionTaskStepPropertiesArgsDict(TypedDict):
        action_on_failure: pulumi.Input[_builtins.str]
        """
        (Updatable) The action to be taken in case of a failure.
        """
        notification_preferences: NotRequired[pulumi.Input['RunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict']]
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        pause_details: NotRequired[pulumi.Input['RunbookVersionTaskStepPropertiesPauseDetailsArgsDict']]
        """
        (Updatable) Pause Details
        """
        pre_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Build control flow conditions that determine the relevance of the
        task execution.
        """
        run_on: NotRequired[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnArgsDict']]
        """
        (Updatable) The runon conditions
        """
elif False:
    RunbookVersionTaskStepPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskStepPropertiesArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[_builtins.str],
                 notification_preferences: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesNotificationPreferencesArgs']] = None,
                 pause_details: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesPauseDetailsArgs']] = None,
                 pre_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 run_on: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action_on_failure: (Updatable) The action to be taken in case of a failure.
        :param pulumi.Input['RunbookVersionTaskStepPropertiesNotificationPreferencesArgs'] notification_preferences: (Updatable) Preferences to send notifications on the task activities.
        :param pulumi.Input['RunbookVersionTaskStepPropertiesPauseDetailsArgs'] pause_details: (Updatable) Pause Details
        :param pulumi.Input[_builtins.str] pre_condition: (Updatable) Build control flow conditions that determine the relevance of the
               task execution.
        :param pulumi.Input['RunbookVersionTaskStepPropertiesRunOnArgs'] run_on: (Updatable) The runon conditions
        """
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        if notification_preferences is not None:
            pulumi.set(__self__, "notification_preferences", notification_preferences)
        if pause_details is not None:
            pulumi.set(__self__, "pause_details", pause_details)
        if pre_condition is not None:
            pulumi.set(__self__, "pre_condition", pre_condition)
        if run_on is not None:
            pulumi.set(__self__, "run_on", run_on)

    @_builtins.property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The action to be taken in case of a failure.
        """
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_on_failure", value)

    @_builtins.property
    @pulumi.getter(name="notificationPreferences")
    def notification_preferences(self) -> Optional[pulumi.Input['RunbookVersionTaskStepPropertiesNotificationPreferencesArgs']]:
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        return pulumi.get(self, "notification_preferences")

    @notification_preferences.setter
    def notification_preferences(self, value: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesNotificationPreferencesArgs']]):
        pulumi.set(self, "notification_preferences", value)

    @_builtins.property
    @pulumi.getter(name="pauseDetails")
    def pause_details(self) -> Optional[pulumi.Input['RunbookVersionTaskStepPropertiesPauseDetailsArgs']]:
        """
        (Updatable) Pause Details
        """
        return pulumi.get(self, "pause_details")

    @pause_details.setter
    def pause_details(self, value: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesPauseDetailsArgs']]):
        pulumi.set(self, "pause_details", value)

    @_builtins.property
    @pulumi.getter(name="preCondition")
    def pre_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Build control flow conditions that determine the relevance of the
        task execution.
        """
        return pulumi.get(self, "pre_condition")

    @pre_condition.setter
    def pre_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_condition", value)

    @_builtins.property
    @pulumi.getter(name="runOn")
    def run_on(self) -> Optional[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnArgs']]:
        """
        (Updatable) The runon conditions
        """
        return pulumi.get(self, "run_on")

    @run_on.setter
    def run_on(self, value: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnArgs']]):
        pulumi.set(self, "run_on", value)


if not MYPY:
    class RunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict(TypedDict):
        should_notify_on_pause: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables notification on pause.
        """
        should_notify_on_task_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on Task
        Failures.
        """
        should_notify_on_task_success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables or disables notification on Task Success.
        """
elif False:
    RunbookVersionTaskStepPropertiesNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskStepPropertiesNotificationPreferencesArgs:
    def __init__(__self__, *,
                 should_notify_on_pause: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_notify_on_task_success: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] should_notify_on_pause: (Updatable) Enables notification on pause.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_failure: (Updatable) Enables or disables notification on Task
               Failures.
        :param pulumi.Input[_builtins.bool] should_notify_on_task_success: (Updatable) Enables or disables notification on Task Success.
        """
        if should_notify_on_pause is not None:
            pulumi.set(__self__, "should_notify_on_pause", should_notify_on_pause)
        if should_notify_on_task_failure is not None:
            pulumi.set(__self__, "should_notify_on_task_failure", should_notify_on_task_failure)
        if should_notify_on_task_success is not None:
            pulumi.set(__self__, "should_notify_on_task_success", should_notify_on_task_success)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnPause")
    def should_notify_on_pause(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables notification on pause.
        """
        return pulumi.get(self, "should_notify_on_pause")

    @should_notify_on_pause.setter
    def should_notify_on_pause(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_pause", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskFailure")
    def should_notify_on_task_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on Task
        Failures.
        """
        return pulumi.get(self, "should_notify_on_task_failure")

    @should_notify_on_task_failure.setter
    def should_notify_on_task_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_failure", value)

    @_builtins.property
    @pulumi.getter(name="shouldNotifyOnTaskSuccess")
    def should_notify_on_task_success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables or disables notification on Task Success.
        """
        return pulumi.get(self, "should_notify_on_task_success")

    @should_notify_on_task_success.setter
    def should_notify_on_task_success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_notify_on_task_success", value)


if not MYPY:
    class RunbookVersionTaskStepPropertiesPauseDetailsArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Pause based On.
        """
        duration_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Time in minutes to apply Pause.
        """
elif False:
    RunbookVersionTaskStepPropertiesPauseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskStepPropertiesPauseDetailsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: (Updatable) Pause based On.
        :param pulumi.Input[_builtins.int] duration_in_minutes: (Updatable) Time in minutes to apply Pause.
        """
        pulumi.set(__self__, "kind", kind)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Pause based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Time in minutes to apply Pause.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)


if not MYPY:
    class RunbookVersionTaskStepPropertiesRunOnArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Run on based On.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Build control flow conditions that
        determine the relevance of the task execution.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the self hosted instance.
        """
        previous_task_instance_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict']]]]
        """
        (Updatable) Previous Task
        Instance Details
        """
elif False:
    RunbookVersionTaskStepPropertiesRunOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskStepPropertiesRunOnArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 previous_task_instance_details: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: (Updatable) Run on based On.
        :param pulumi.Input[_builtins.str] condition: (Updatable) Build control flow conditions that
               determine the relevance of the task execution.
        :param pulumi.Input[_builtins.str] host: (Updatable) OCID of the self hosted instance.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]] previous_task_instance_details: (Updatable) Previous Task
               Instance Details
        """
        pulumi.set(__self__, "kind", kind)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if previous_task_instance_details is not None:
            pulumi.set(__self__, "previous_task_instance_details", previous_task_instance_details)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Run on based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Build control flow conditions that
        determine the relevance of the task execution.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the self hosted instance.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="previousTaskInstanceDetails")
    def previous_task_instance_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]:
        """
        (Updatable) Previous Task
        Instance Details
        """
        return pulumi.get(self, "previous_task_instance_details")

    @previous_task_instance_details.setter
    def previous_task_instance_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs']]]]):
        pulumi.set(self, "previous_task_instance_details", value)


if not MYPY:
    class RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict(TypedDict):
        output_variable_details: NotRequired[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict']]
        """
        (Updatable) The details of
        the output variable that will be used for mapping.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Resource Ocid.
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Resource Type.
        """
elif False:
    RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailArgs:
    def __init__(__self__, *,
                 output_variable_details: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs'] output_variable_details: (Updatable) The details of
               the output variable that will be used for mapping.
        :param pulumi.Input[_builtins.str] resource_id: (Updatable) Resource Ocid.
        :param pulumi.Input[_builtins.str] resource_type: (Updatable) Resource Type.
        """
        if output_variable_details is not None:
            pulumi.set(__self__, "output_variable_details", output_variable_details)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> Optional[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]:
        """
        (Updatable) The details of
        the output variable that will be used for mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: Optional[pulumi.Input['RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs']]):
        pulumi.set(self, "output_variable_details", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Resource Ocid.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Resource Type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the
        output variable whose value has to be mapped.
        """
        step_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the task step
        the output variable belongs to.
        """
elif False:
    RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskStepPropertiesRunOnPreviousTaskInstanceDetailOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: Optional[pulumi.Input[_builtins.str]] = None,
                 step_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] output_variable_name: (Updatable) The name of the
               output variable whose value has to be mapped.
        :param pulumi.Input[_builtins.str] step_name: (Updatable) The name of the task step
               the output variable belongs to.
        """
        if output_variable_name is not None:
            pulumi.set(__self__, "output_variable_name", output_variable_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)

    @_builtins.property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the
        output variable whose value has to be mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_variable_name", value)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the task step
        the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsArgsDict(TypedDict):
        scope: pulumi.Input[_builtins.str]
        """
        (Updatable) The scope of the task.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the task.
        """
        execution_details: NotRequired[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict']]
        """
        (Updatable) Execution details.
        """
        is_apply_subject_task: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is this an Apply Subject Task? Ex. Patch
        Execution Task
        """
        is_copy_to_library_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Make a copy of this task in Library
        """
        is_discovery_output_task: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is this a discovery output task?
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the task
        """
        os_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OS for the task.
        """
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The platform of the runbook.
        """
        properties: NotRequired[pulumi.Input['RunbookVersionTaskTaskRecordDetailsPropertiesArgsDict']]
        """
        (Updatable) The properties of the task.
        """
        task_record_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The ID of taskRecord.

        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the
        new property values
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_details: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs']] = None,
                 is_apply_subject_task: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_copy_to_library_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_discovery_output_task: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 os_type: Optional[pulumi.Input[_builtins.str]] = None,
                 platform: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsPropertiesArgs']] = None,
                 task_record_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scope: (Updatable) The scope of the task.
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the task.
        :param pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs'] execution_details: (Updatable) Execution details.
        :param pulumi.Input[_builtins.bool] is_apply_subject_task: (Updatable) Is this an Apply Subject Task? Ex. Patch
               Execution Task
        :param pulumi.Input[_builtins.bool] is_copy_to_library_enabled: (Updatable) Make a copy of this task in Library
        :param pulumi.Input[_builtins.bool] is_discovery_output_task: (Updatable) Is this a discovery output task?
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the task
        :param pulumi.Input[_builtins.str] os_type: (Updatable) The OS for the task.
        :param pulumi.Input[_builtins.str] platform: (Updatable) The platform of the runbook.
        :param pulumi.Input['RunbookVersionTaskTaskRecordDetailsPropertiesArgs'] properties: (Updatable) The properties of the task.
        :param pulumi.Input[_builtins.str] task_record_id: (Updatable) The ID of taskRecord.
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the
               new property values
        """
        pulumi.set(__self__, "scope", scope)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if execution_details is not None:
            pulumi.set(__self__, "execution_details", execution_details)
        if is_apply_subject_task is not None:
            pulumi.set(__self__, "is_apply_subject_task", is_apply_subject_task)
        if is_copy_to_library_enabled is not None:
            pulumi.set(__self__, "is_copy_to_library_enabled", is_copy_to_library_enabled)
        if is_discovery_output_task is not None:
            pulumi.set(__self__, "is_discovery_output_task", is_discovery_output_task)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if task_record_id is not None:
            pulumi.set(__self__, "task_record_id", task_record_id)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The scope of the task.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the task.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="executionDetails")
    def execution_details(self) -> Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs']]:
        """
        (Updatable) Execution details.
        """
        return pulumi.get(self, "execution_details")

    @execution_details.setter
    def execution_details(self, value: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs']]):
        pulumi.set(self, "execution_details", value)

    @_builtins.property
    @pulumi.getter(name="isApplySubjectTask")
    def is_apply_subject_task(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is this an Apply Subject Task? Ex. Patch
        Execution Task
        """
        return pulumi.get(self, "is_apply_subject_task")

    @is_apply_subject_task.setter
    def is_apply_subject_task(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_apply_subject_task", value)

    @_builtins.property
    @pulumi.getter(name="isCopyToLibraryEnabled")
    def is_copy_to_library_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Make a copy of this task in Library
        """
        return pulumi.get(self, "is_copy_to_library_enabled")

    @is_copy_to_library_enabled.setter
    def is_copy_to_library_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_copy_to_library_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isDiscoveryOutputTask")
    def is_discovery_output_task(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is this a discovery output task?
        """
        return pulumi.get(self, "is_discovery_output_task")

    @is_discovery_output_task.setter
    def is_discovery_output_task(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_discovery_output_task", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the task
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OS for the task.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_type", value)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The platform of the runbook.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsPropertiesArgs']]:
        """
        (Updatable) The properties of the task.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="taskRecordId")
    def task_record_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The ID of taskRecord.

        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the
        new property values
        """
        return pulumi.get(self, "task_record_id")

    @task_record_id.setter
    def task_record_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "task_record_id", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict(TypedDict):
        execution_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The action type of the task
        """
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Optional command to execute the content.
        You can provide any commands/arguments that can't be part of the script.
        """
        config_file: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Catalog Id having config file.
        """
        content: NotRequired[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict']]]]
        """
        (Updatable) Credentials required for executing the
        task.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Endpoint to be invoked.
        """
        is_executable_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is the Content an executable
        file?
        """
        is_locked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is the script locked to prevent changes
        directly in Object Storage?
        """
        is_read_output_variable_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is read output
        variable enabled
        """
        target_compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the compartment to
        which the resource belongs to.
        """
        variables: NotRequired[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict']]
        """
        (Updatable) The variable of the task. At least one
        of the dynamicArguments or output needs to be provided.
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsExecutionDetailsArgs:
    def __init__(__self__, *,
                 execution_type: pulumi.Input[_builtins.str],
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 config_file: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs']] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 is_executable_content: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_locked: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_read_output_variable_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 variables: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] execution_type: (Updatable) The action type of the task
        :param pulumi.Input[_builtins.str] command: (Updatable) Optional command to execute the content.
               You can provide any commands/arguments that can't be part of the script.
        :param pulumi.Input[_builtins.str] config_file: (Updatable) Catalog Id having config file.
        :param pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]] credentials: (Updatable) Credentials required for executing the
               task.
        :param pulumi.Input[_builtins.str] endpoint: (Updatable) Endpoint to be invoked.
        :param pulumi.Input[_builtins.bool] is_executable_content: (Updatable) Is the Content an executable
               file?
        :param pulumi.Input[_builtins.bool] is_locked: (Updatable) Is the script locked to prevent changes
               directly in Object Storage?
        :param pulumi.Input[_builtins.bool] is_read_output_variable_enabled: (Updatable) Is read output
               variable enabled
        :param pulumi.Input[_builtins.str] target_compartment_id: (Updatable) OCID of the compartment to
               which the resource belongs to.
        :param pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs'] variables: (Updatable) The variable of the task. At least one
               of the dynamicArguments or output needs to be provided.
        """
        pulumi.set(__self__, "execution_type", execution_type)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_executable_content is not None:
            pulumi.set(__self__, "is_executable_content", is_executable_content)
        if is_locked is not None:
            pulumi.set(__self__, "is_locked", is_locked)
        if is_read_output_variable_enabled is not None:
            pulumi.set(__self__, "is_read_output_variable_enabled", is_read_output_variable_enabled)
        if target_compartment_id is not None:
            pulumi.set(__self__, "target_compartment_id", target_compartment_id)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The action type of the task
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_type", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Optional command to execute the content.
        You can provide any commands/arguments that can't be part of the script.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Catalog Id having config file.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_file", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs']]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]]:
        """
        (Updatable) Credentials required for executing the
        task.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Endpoint to be invoked.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="isExecutableContent")
    def is_executable_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is the Content an executable
        file?
        """
        return pulumi.get(self, "is_executable_content")

    @is_executable_content.setter
    def is_executable_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_executable_content", value)

    @_builtins.property
    @pulumi.getter(name="isLocked")
    def is_locked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is the script locked to prevent changes
        directly in Object Storage?
        """
        return pulumi.get(self, "is_locked")

    @is_locked.setter
    def is_locked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_locked", value)

    @_builtins.property
    @pulumi.getter(name="isReadOutputVariableEnabled")
    def is_read_output_variable_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is read output
        variable enabled
        """
        return pulumi.get(self, "is_read_output_variable_enabled")

    @is_read_output_variable_enabled.setter
    def is_read_output_variable_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_read_output_variable_enabled", value)

    @_builtins.property
    @pulumi.getter(name="targetCompartmentId")
    def target_compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the compartment to
        which the resource belongs to.
        """
        return pulumi.get(self, "target_compartment_id")

    @target_compartment_id.setter
    def target_compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs']]:
        """
        (Updatable) The variable of the task. At least one
        of the dynamicArguments or output needs to be provided.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict(TypedDict):
        source_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Content Source type details.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Bucket Name.
        """
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        checksum: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) md5 checksum of the
        artifact.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Namespace.
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Object Name.
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsExecutionDetailsContentArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 checksum: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_type: (Updatable) Content Source type details.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[_builtins.str] checksum: (Updatable) md5 checksum of the
               artifact.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) Namespace.
        :param pulumi.Input[_builtins.str] object: (Updatable) Object Name.
        """
        pulumi.set(__self__, "source_type", source_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if checksum is not None:
            pulumi.set(__self__, "checksum", checksum)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter
    def checksum(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) md5 checksum of the
        artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "checksum", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not
        have to be unique, and it's changeable. Avoid entering confidential information. Example:
        `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsExecutionDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not
               have to be unique, and it's changeable. Avoid entering confidential information. Example:
               `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not
        have to be unique, and it's changeable. Avoid entering confidential information. Example:
        `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict']]]]
        """
        (Updatable) The input variables for the
        task.
        """
        output_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of output variables.
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]] = None,
                 output_variables: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]] input_variables: (Updatable) The input variables for the
               task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] output_variables: (Updatable) The list of output variables.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if output_variables is not None:
            pulumi.set(__self__, "output_variables", output_variables)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]:
        """
        (Updatable) The input variables for the
        task.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter(name="outputVariables")
    def output_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of output variables.
        """
        return pulumi.get(self, "output_variables")

    @output_variables.setter
    def output_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_variables", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the
        argument.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the argument.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Input argument Type.
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the
               argument.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the argument.
        :param pulumi.Input[_builtins.str] type: (Updatable) Input argument Type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the
        argument.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Input argument Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookVersionTaskTaskRecordDetailsPropertiesArgsDict(TypedDict):
        num_retries: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The number of retries allowed.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The timeout in seconds for the task.
        """
elif False:
    RunbookVersionTaskTaskRecordDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookVersionTaskTaskRecordDetailsPropertiesArgs:
    def __init__(__self__, *,
                 num_retries: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] num_retries: (Updatable) The number of retries allowed.
        :param pulumi.Input[_builtins.int] timeout_in_seconds: (Updatable) The timeout in seconds for the task.
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The number of retries allowed.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_retries", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The timeout in seconds for the task.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class SchedulerDefinitionActionGroupArgsDict(TypedDict):
        fleet_id: pulumi.Input[_builtins.str]
        """
        (Updatable) ID of the fleet
        """
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Action Group kind
        """
        runbook_id: pulumi.Input[_builtins.str]
        """
        (Updatable) ID of the runbook
        """
        runbook_version_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the runbook version
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        sequence: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Sequence of the Action Group. Action groups will be executed in a seuential order. All Action Groups having the same sequence will be executed parallely. If no value is provided a default value of 1 will be given.
        """
elif False:
    SchedulerDefinitionActionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionActionGroupArgs:
    def __init__(__self__, *,
                 fleet_id: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str],
                 runbook_id: pulumi.Input[_builtins.str],
                 runbook_version_name: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sequence: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] fleet_id: (Updatable) ID of the fleet
        :param pulumi.Input[_builtins.str] kind: (Updatable) Action Group kind
        :param pulumi.Input[_builtins.str] runbook_id: (Updatable) ID of the runbook
        :param pulumi.Input[_builtins.str] runbook_version_name: (Updatable) Name of the runbook version
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.int] sequence: (Updatable) Sequence of the Action Group. Action groups will be executed in a seuential order. All Action Groups having the same sequence will be executed parallely. If no value is provided a default value of 1 will be given.
        """
        pulumi.set(__self__, "fleet_id", fleet_id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "runbook_id", runbook_id)
        pulumi.set(__self__, "runbook_version_name", runbook_version_name)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if sequence is not None:
            pulumi.set(__self__, "sequence", sequence)

    @_builtins.property
    @pulumi.getter(name="fleetId")
    def fleet_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) ID of the fleet
        """
        return pulumi.get(self, "fleet_id")

    @fleet_id.setter
    def fleet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fleet_id", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Action Group kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="runbookId")
    def runbook_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) ID of the runbook
        """
        return pulumi.get(self, "runbook_id")

    @runbook_id.setter
    def runbook_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runbook_id", value)

    @_builtins.property
    @pulumi.getter(name="runbookVersionName")
    def runbook_version_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the runbook version
        """
        return pulumi.get(self, "runbook_version_name")

    @runbook_version_name.setter
    def runbook_version_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runbook_version_name", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def sequence(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Sequence of the Action Group. Action groups will be executed in a seuential order. All Action Groups having the same sequence will be executed parallely. If no value is provided a default value of 1 will be given.
        """
        return pulumi.get(self, "sequence")

    @sequence.setter
    def sequence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sequence", value)


if not MYPY:
    class SchedulerDefinitionRunBookArgsDict(TypedDict):
        runbook_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The ID of the Runbook
        """
        runbook_version_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The runbook version name
        """
        input_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgsDict']]]]
        """
        (Updatable) Input Parameters for the Task
        """
elif False:
    SchedulerDefinitionRunBookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookArgs:
    def __init__(__self__, *,
                 runbook_id: pulumi.Input[_builtins.str],
                 runbook_version_name: pulumi.Input[_builtins.str],
                 input_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] runbook_id: (Updatable) The ID of the Runbook
        :param pulumi.Input[_builtins.str] runbook_version_name: (Updatable) The runbook version name
        :param pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]] input_parameters: (Updatable) Input Parameters for the Task
        """
        pulumi.set(__self__, "runbook_id", runbook_id)
        pulumi.set(__self__, "runbook_version_name", runbook_version_name)
        if input_parameters is not None:
            pulumi.set(__self__, "input_parameters", input_parameters)

    @_builtins.property
    @pulumi.getter(name="runbookId")
    def runbook_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The ID of the Runbook
        """
        return pulumi.get(self, "runbook_id")

    @runbook_id.setter
    def runbook_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runbook_id", value)

    @_builtins.property
    @pulumi.getter(name="runbookVersionName")
    def runbook_version_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The runbook version name
        """
        return pulumi.get(self, "runbook_version_name")

    @runbook_version_name.setter
    def runbook_version_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runbook_version_name", value)

    @_builtins.property
    @pulumi.getter(name="inputParameters")
    def input_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]]]:
        """
        (Updatable) Input Parameters for the Task
        """
        return pulumi.get(self, "input_parameters")

    @input_parameters.setter
    def input_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]]]):
        pulumi.set(self, "input_parameters", value)


if not MYPY:
    class SchedulerDefinitionRunBookInputParameterArgsDict(TypedDict):
        step_name: pulumi.Input[_builtins.str]
        """
        (Updatable) stepName for which the input parameters are provided
        """
        arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgsDict']]]]
        """
        (Updatable) Arguments for the Task
        """
elif False:
    SchedulerDefinitionRunBookInputParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookInputParameterArgs:
    def __init__(__self__, *,
                 step_name: pulumi.Input[_builtins.str],
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] step_name: (Updatable) stepName for which the input parameters are provided
        :param pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]] arguments: (Updatable) Arguments for the Task
        """
        pulumi.set(__self__, "step_name", step_name)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)

    @_builtins.property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) stepName for which the input parameters are provided
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_name", value)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]]]:
        """
        (Updatable) Arguments for the Task
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]]]):
        pulumi.set(self, "arguments", value)


if not MYPY:
    class SchedulerDefinitionRunBookInputParameterArgumentArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Task argument kind
        """
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the input variable
        """
        content: NotRequired[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The task input
        """
elif False:
    SchedulerDefinitionRunBookInputParameterArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookInputParameterArgumentArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentContentArgs']] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: (Updatable) Task argument kind
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the input variable
        :param pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[_builtins.str] value: (Updatable) The task input
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Task argument kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the input variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentContentArgs']]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The task input
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SchedulerDefinitionRunBookInputParameterArgumentContentArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) Bucket Name.
        """
        checksum: pulumi.Input[_builtins.str]
        """
        (Updatable) md5 checksum of the artifact.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) Namespace.
        """
        object: pulumi.Input[_builtins.str]
        """
        (Updatable) Object Name.
        """
        source_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Content Source type details.
        """
elif False:
    SchedulerDefinitionRunBookInputParameterArgumentContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookInputParameterArgumentContentArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 checksum: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 object: pulumi.Input[_builtins.str],
                 source_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[_builtins.str] checksum: (Updatable) md5 checksum of the artifact.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) Namespace.
        :param pulumi.Input[_builtins.str] object: (Updatable) Object Name.
        :param pulumi.Input[_builtins.str] source_type: (Updatable) Content Source type details.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "source_type", source_type)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "checksum", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class SchedulerDefinitionScheduleArgsDict(TypedDict):
        execution_startdate: pulumi.Input[_builtins.str]
        """
        (Updatable) Start Date for the schedule. An RFC3339 formatted datetime string
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Schedule Type


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Duration of the schedule.
        """
        maintenance_window_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Provide MaintenanceWindowId
        """
        recurrences: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Recurrence rule specification if recurring
        """
elif False:
    SchedulerDefinitionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionScheduleArgs:
    def __init__(__self__, *,
                 execution_startdate: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 maintenance_window_id: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrences: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] execution_startdate: (Updatable) Start Date for the schedule. An RFC3339 formatted datetime string
        :param pulumi.Input[_builtins.str] type: (Updatable) Schedule Type
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] duration: (Updatable) Duration of the schedule.
        :param pulumi.Input[_builtins.str] maintenance_window_id: (Updatable) Provide MaintenanceWindowId
        :param pulumi.Input[_builtins.str] recurrences: (Updatable) Recurrence rule specification if recurring
        """
        pulumi.set(__self__, "execution_startdate", execution_startdate)
        pulumi.set(__self__, "type", type)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if maintenance_window_id is not None:
            pulumi.set(__self__, "maintenance_window_id", maintenance_window_id)
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)

    @_builtins.property
    @pulumi.getter(name="executionStartdate")
    def execution_startdate(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Start Date for the schedule. An RFC3339 formatted datetime string
        """
        return pulumi.get(self, "execution_startdate")

    @execution_startdate.setter
    def execution_startdate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_startdate", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Schedule Type


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Duration of the schedule.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowId")
    def maintenance_window_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Provide MaintenanceWindowId
        """
        return pulumi.get(self, "maintenance_window_id")

    @maintenance_window_id.setter
    def maintenance_window_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maintenance_window_id", value)

    @_builtins.property
    @pulumi.getter
    def recurrences(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Recurrence rule specification if recurring
        """
        return pulumi.get(self, "recurrences")

    @recurrences.setter
    def recurrences(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrences", value)


if not MYPY:
    class TaskRecordDetailsArgsDict(TypedDict):
        execution_details: pulumi.Input['TaskRecordDetailsExecutionDetailsArgsDict']
        """
        (Updatable) Execution details.
        """
        scope: pulumi.Input[_builtins.str]
        """
        (Updatable) The scope of the task
        """
        is_apply_subject_task: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is this an Apply Subject Task?  Set this to true for a Patch Execution Task which applies patches(subjects) on a target.
        """
        is_discovery_output_task: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is this a discovery output task?
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The lifecycle operation performed by the runbook.
        """
        os_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OS for the task
        """
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The platform of the runbook.
        """
        properties: NotRequired[pulumi.Input['TaskRecordDetailsPropertiesArgsDict']]
        """
        (Updatable) The properties of the task.
        """
elif False:
    TaskRecordDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsArgs:
    def __init__(__self__, *,
                 execution_details: pulumi.Input['TaskRecordDetailsExecutionDetailsArgs'],
                 scope: pulumi.Input[_builtins.str],
                 is_apply_subject_task: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_discovery_output_task: Optional[pulumi.Input[_builtins.bool]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 os_type: Optional[pulumi.Input[_builtins.str]] = None,
                 platform: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input['TaskRecordDetailsPropertiesArgs']] = None):
        """
        :param pulumi.Input['TaskRecordDetailsExecutionDetailsArgs'] execution_details: (Updatable) Execution details.
        :param pulumi.Input[_builtins.str] scope: (Updatable) The scope of the task
        :param pulumi.Input[_builtins.bool] is_apply_subject_task: (Updatable) Is this an Apply Subject Task?  Set this to true for a Patch Execution Task which applies patches(subjects) on a target.
        :param pulumi.Input[_builtins.bool] is_discovery_output_task: (Updatable) Is this a discovery output task?
        :param pulumi.Input[_builtins.str] operation: (Updatable) The lifecycle operation performed by the runbook.
        :param pulumi.Input[_builtins.str] os_type: (Updatable) The OS for the task
        :param pulumi.Input[_builtins.str] platform: (Updatable) The platform of the runbook.
        :param pulumi.Input['TaskRecordDetailsPropertiesArgs'] properties: (Updatable) The properties of the task.
        """
        pulumi.set(__self__, "execution_details", execution_details)
        pulumi.set(__self__, "scope", scope)
        if is_apply_subject_task is not None:
            pulumi.set(__self__, "is_apply_subject_task", is_apply_subject_task)
        if is_discovery_output_task is not None:
            pulumi.set(__self__, "is_discovery_output_task", is_discovery_output_task)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter(name="executionDetails")
    def execution_details(self) -> pulumi.Input['TaskRecordDetailsExecutionDetailsArgs']:
        """
        (Updatable) Execution details.
        """
        return pulumi.get(self, "execution_details")

    @execution_details.setter
    def execution_details(self, value: pulumi.Input['TaskRecordDetailsExecutionDetailsArgs']):
        pulumi.set(self, "execution_details", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The scope of the task
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="isApplySubjectTask")
    def is_apply_subject_task(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is this an Apply Subject Task?  Set this to true for a Patch Execution Task which applies patches(subjects) on a target.
        """
        return pulumi.get(self, "is_apply_subject_task")

    @is_apply_subject_task.setter
    def is_apply_subject_task(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_apply_subject_task", value)

    @_builtins.property
    @pulumi.getter(name="isDiscoveryOutputTask")
    def is_discovery_output_task(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is this a discovery output task?
        """
        return pulumi.get(self, "is_discovery_output_task")

    @is_discovery_output_task.setter
    def is_discovery_output_task(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_discovery_output_task", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The lifecycle operation performed by the runbook.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OS for the task
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_type", value)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The platform of the runbook.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['TaskRecordDetailsPropertiesArgs']]:
        """
        (Updatable) The properties of the task.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['TaskRecordDetailsPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsArgsDict(TypedDict):
        execution_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The action type of the task
        """
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        config_file: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Catalog Id having config file.
        """
        content: NotRequired[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgsDict']]]]
        """
        (Updatable) Credentials required for executing the task.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Endpoint to be invoked.
        """
        is_executable_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is the Content an executable file?
        """
        is_locked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is the script locked to prevent changes directly in Object Storage?
        """
        is_read_output_variable_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Is read output variable enabled
        """
        target_compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the compartment to which the resource belongs to.
        """
        variables: NotRequired[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgsDict']]
        """
        (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
elif False:
    TaskRecordDetailsExecutionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsArgs:
    def __init__(__self__, *,
                 execution_type: pulumi.Input[_builtins.str],
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 config_file: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs']] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 is_executable_content: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_locked: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_read_output_variable_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 variables: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] execution_type: (Updatable) The action type of the task
        :param pulumi.Input[_builtins.str] command: (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        :param pulumi.Input[_builtins.str] config_file: (Updatable) Catalog Id having config file.
        :param pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]] credentials: (Updatable) Credentials required for executing the task.
        :param pulumi.Input[_builtins.str] endpoint: (Updatable) Endpoint to be invoked.
        :param pulumi.Input[_builtins.bool] is_executable_content: (Updatable) Is the Content an executable file?
        :param pulumi.Input[_builtins.bool] is_locked: (Updatable) Is the script locked to prevent changes directly in Object Storage?
        :param pulumi.Input[_builtins.bool] is_read_output_variable_enabled: (Updatable) Is read output variable enabled
        :param pulumi.Input[_builtins.str] target_compartment_id: (Updatable) OCID of the compartment to which the resource belongs to.
        :param pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs'] variables: (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        pulumi.set(__self__, "execution_type", execution_type)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_executable_content is not None:
            pulumi.set(__self__, "is_executable_content", is_executable_content)
        if is_locked is not None:
            pulumi.set(__self__, "is_locked", is_locked)
        if is_read_output_variable_enabled is not None:
            pulumi.set(__self__, "is_read_output_variable_enabled", is_read_output_variable_enabled)
        if target_compartment_id is not None:
            pulumi.set(__self__, "target_compartment_id", target_compartment_id)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The action type of the task
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_type", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Catalog Id having config file.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_file", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs']]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]]]:
        """
        (Updatable) Credentials required for executing the task.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Endpoint to be invoked.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="isExecutableContent")
    def is_executable_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is the Content an executable file?
        """
        return pulumi.get(self, "is_executable_content")

    @is_executable_content.setter
    def is_executable_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_executable_content", value)

    @_builtins.property
    @pulumi.getter(name="isLocked")
    def is_locked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is the script locked to prevent changes directly in Object Storage?
        """
        return pulumi.get(self, "is_locked")

    @is_locked.setter
    def is_locked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_locked", value)

    @_builtins.property
    @pulumi.getter(name="isReadOutputVariableEnabled")
    def is_read_output_variable_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Is read output variable enabled
        """
        return pulumi.get(self, "is_read_output_variable_enabled")

    @is_read_output_variable_enabled.setter
    def is_read_output_variable_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_read_output_variable_enabled", value)

    @_builtins.property
    @pulumi.getter(name="targetCompartmentId")
    def target_compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the compartment to which the resource belongs to.
        """
        return pulumi.get(self, "target_compartment_id")

    @target_compartment_id.setter
    def target_compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_compartment_id", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs']]:
        """
        (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsContentArgsDict(TypedDict):
        source_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Content Source type details.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Bucket Name.
        """
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        checksum: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) md5 checksum of the artifact.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Namespace.
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Object Name.
        """
elif False:
    TaskRecordDetailsExecutionDetailsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsContentArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 checksum: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_type: (Updatable) Content Source type details.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[_builtins.str] checksum: (Updatable) md5 checksum of the artifact.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) Namespace.
        :param pulumi.Input[_builtins.str] object: (Updatable) Object Name.
        """
        pulumi.set(__self__, "source_type", source_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if checksum is not None:
            pulumi.set(__self__, "checksum", checksum)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter
    def checksum(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "checksum", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    TaskRecordDetailsExecutionDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[_builtins.str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsVariablesArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict']]]]
        """
        (Updatable) The input variables for the task.
        """
        output_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of output variables.
        """
elif False:
    TaskRecordDetailsExecutionDetailsVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsVariablesArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]] = None,
                 output_variables: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]] input_variables: (Updatable) The input variables for the task.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] output_variables: (Updatable) The list of output variables.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if output_variables is not None:
            pulumi.set(__self__, "output_variables", output_variables)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]:
        """
        (Updatable) The input variables for the task.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter(name="outputVariables")
    def output_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of output variables.
        """
        return pulumi.get(self, "output_variables")

    @output_variables.setter
    def output_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_variables", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The description of the argument.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the argument.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Input argument Type.
        """
elif False:
    TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) The description of the argument.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the argument.
        :param pulumi.Input[_builtins.str] type: (Updatable) Input argument Type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The description of the argument.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Input argument Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TaskRecordDetailsPropertiesArgsDict(TypedDict):
        num_retries: pulumi.Input[_builtins.int]
        """
        (Updatable) The number of retries allowed.
        """
        timeout_in_seconds: pulumi.Input[_builtins.int]
        """
        (Updatable) The timeout in seconds for the task.
        """
elif False:
    TaskRecordDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsPropertiesArgs:
    def __init__(__self__, *,
                 num_retries: pulumi.Input[_builtins.int],
                 timeout_in_seconds: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] num_retries: (Updatable) The number of retries allowed.
        :param pulumi.Input[_builtins.int] timeout_in_seconds: (Updatable) The timeout in seconds for the task.
        """
        pulumi.set(__self__, "num_retries", num_retries)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The number of retries allowed.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "num_retries", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The timeout in seconds for the task.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class GetAnnouncementsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAnnouncementsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAnnouncementsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCatalogItemsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetCatalogItemsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogItemsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCompliancePoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetCompliancePoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCompliancePoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCompliancePolicyRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetCompliancePolicyRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCompliancePolicyRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetComplianceRecordCountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetComplianceRecordCountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComplianceRecordCountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetComplianceRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetComplianceRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComplianceRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetCredentialsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the variable.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFleetCredentialsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetCredentialsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetProductsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFleetProductsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetProductsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetPropertiesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFleetPropertiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetPropertiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetResourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFleetResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetResourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetTargetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFleetTargetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetTargetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the variable.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetFleetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetInventoryRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the inventory target property.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetInventoryRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInventoryRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the inventory target property.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the inventory target property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetInventoryResourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetInventoryResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInventoryResourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaintenanceWindowsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMaintenanceWindowsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaintenanceWindowsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedEntityCountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedEntityCountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedEntityCountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetOnboardingPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetOnboardingPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOnboardingPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetOnboardingsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetOnboardingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOnboardingsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPlatformConfigurationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPlatformConfigurationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPlatformConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPropertiesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        """
        Values of the property (must be a single value if selection = 'SINGLE_CHOICE').
        """
        regex: NotRequired[_builtins.bool]
elif False:
    GetPropertiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] values: Values of the property (must be a single value if selection = 'SINGLE_CHOICE').
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values of the property (must be a single value if selection = 'SINGLE_CHOICE').
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProvisionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProvisionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProvisionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRunbookVersionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRunbookVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRunbookVersionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRunbooksFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the task
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRunbooksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRunbooksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the task
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the task
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerDefinitionScheduledFleetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulerDefinitionScheduledFleetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerDefinitionScheduledFleetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerDefinitionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the input variable
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulerDefinitionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerDefinitionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the input variable
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the input variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerExecutionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulerExecutionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerExecutionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerJobCountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulerJobCountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerJobCountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerJobJobActivityResourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulerJobJobActivityResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerJobJobActivityResourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerJobJobActivityStepsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulerJobJobActivityStepsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerJobJobActivityStepsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTaskRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the argument.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTaskRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the argument.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


