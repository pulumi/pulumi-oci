# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CompliancePolicyRulePatchSelectionArgs',
    'CompliancePolicyRulePatchSelectionArgsDict',
    'CompliancePolicyRuleProductVersionArgs',
    'CompliancePolicyRuleProductVersionArgsDict',
    'FleetCredentialArgs',
    'FleetCredentialArgsDict',
    'FleetCredentialEntitySpecificsArgs',
    'FleetCredentialEntitySpecificsArgsDict',
    'FleetCredentialEntitySpecificsVariableArgs',
    'FleetCredentialEntitySpecificsVariableArgsDict',
    'FleetCredentialPasswordArgs',
    'FleetCredentialPasswordArgsDict',
    'FleetCredentialUserArgs',
    'FleetCredentialUserArgsDict',
    'FleetNotificationPreferencesArgs',
    'FleetNotificationPreferencesArgsDict',
    'FleetNotificationPreferencesPreferencesArgs',
    'FleetNotificationPreferencesPreferencesArgsDict',
    'FleetRuleSelectionCriteriaArgs',
    'FleetRuleSelectionCriteriaArgsDict',
    'FleetRuleSelectionCriteriaRuleArgs',
    'FleetRuleSelectionCriteriaRuleArgsDict',
    'FleetRuleSelectionCriteriaRuleConditionArgs',
    'FleetRuleSelectionCriteriaRuleConditionArgsDict',
    'OnboardingAppliedPolicyArgs',
    'OnboardingAppliedPolicyArgsDict',
    'OnboardingItemArgs',
    'OnboardingItemArgsDict',
    'OnboardingItemAppliedPolicyArgs',
    'OnboardingItemAppliedPolicyArgsDict',
    'PatchArtifactDetailsArgs',
    'PatchArtifactDetailsArgsDict',
    'PatchArtifactDetailsArtifactArgs',
    'PatchArtifactDetailsArtifactArgsDict',
    'PatchArtifactDetailsArtifactContentArgs',
    'PatchArtifactDetailsArtifactContentArgsDict',
    'PatchDependentPatchArgs',
    'PatchDependentPatchArgsDict',
    'PatchPatchTypeArgs',
    'PatchPatchTypeArgsDict',
    'PatchProductArgs',
    'PatchProductArgsDict',
    'PlatformConfigurationConfigCategoryDetailsArgs',
    'PlatformConfigurationConfigCategoryDetailsArgsDict',
    'PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs',
    'PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict',
    'PlatformConfigurationConfigCategoryDetailsCredentialArgs',
    'PlatformConfigurationConfigCategoryDetailsCredentialArgsDict',
    'PlatformConfigurationConfigCategoryDetailsPatchTypeArgs',
    'PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict',
    'PlatformConfigurationConfigCategoryDetailsProductArgs',
    'PlatformConfigurationConfigCategoryDetailsProductArgsDict',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs',
    'PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict',
    'RunbookAssociationsArgs',
    'RunbookAssociationsArgsDict',
    'RunbookAssociationsExecutionWorkflowDetailsArgs',
    'RunbookAssociationsExecutionWorkflowDetailsArgsDict',
    'RunbookAssociationsExecutionWorkflowDetailsWorkflowArgs',
    'RunbookAssociationsExecutionWorkflowDetailsWorkflowArgsDict',
    'RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgs',
    'RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgsDict',
    'RunbookAssociationsGroupArgs',
    'RunbookAssociationsGroupArgsDict',
    'RunbookAssociationsGroupPropertiesArgs',
    'RunbookAssociationsGroupPropertiesArgsDict',
    'RunbookAssociationsGroupPropertiesNotificationPreferencesArgs',
    'RunbookAssociationsGroupPropertiesNotificationPreferencesArgsDict',
    'RunbookAssociationsGroupPropertiesPauseDetailsArgs',
    'RunbookAssociationsGroupPropertiesPauseDetailsArgsDict',
    'RunbookAssociationsRollbackWorkflowDetailsArgs',
    'RunbookAssociationsRollbackWorkflowDetailsArgsDict',
    'RunbookAssociationsRollbackWorkflowDetailsWorkflowArgs',
    'RunbookAssociationsRollbackWorkflowDetailsWorkflowArgsDict',
    'RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgs',
    'RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgsDict',
    'RunbookAssociationsTaskArgs',
    'RunbookAssociationsTaskArgsDict',
    'RunbookAssociationsTaskOutputVariableMappingArgs',
    'RunbookAssociationsTaskOutputVariableMappingArgsDict',
    'RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgs',
    'RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgsDict',
    'RunbookAssociationsTaskStepPropertiesArgs',
    'RunbookAssociationsTaskStepPropertiesArgsDict',
    'RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgs',
    'RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgsDict',
    'RunbookAssociationsTaskStepPropertiesPauseDetailsArgs',
    'RunbookAssociationsTaskStepPropertiesPauseDetailsArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsArgs',
    'RunbookAssociationsTaskTaskRecordDetailsArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgs',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgs',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgs',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgs',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs',
    'RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict',
    'RunbookAssociationsTaskTaskRecordDetailsPropertiesArgs',
    'RunbookAssociationsTaskTaskRecordDetailsPropertiesArgsDict',
    'SchedulerDefinitionActionGroupArgs',
    'SchedulerDefinitionActionGroupArgsDict',
    'SchedulerDefinitionRunBookArgs',
    'SchedulerDefinitionRunBookArgsDict',
    'SchedulerDefinitionRunBookInputParameterArgs',
    'SchedulerDefinitionRunBookInputParameterArgsDict',
    'SchedulerDefinitionRunBookInputParameterArgumentArgs',
    'SchedulerDefinitionRunBookInputParameterArgumentArgsDict',
    'SchedulerDefinitionScheduleArgs',
    'SchedulerDefinitionScheduleArgsDict',
    'TaskRecordDetailsArgs',
    'TaskRecordDetailsArgsDict',
    'TaskRecordDetailsExecutionDetailsArgs',
    'TaskRecordDetailsExecutionDetailsArgsDict',
    'TaskRecordDetailsExecutionDetailsContentArgs',
    'TaskRecordDetailsExecutionDetailsContentArgsDict',
    'TaskRecordDetailsExecutionDetailsCredentialArgs',
    'TaskRecordDetailsExecutionDetailsCredentialArgsDict',
    'TaskRecordDetailsExecutionDetailsVariablesArgs',
    'TaskRecordDetailsExecutionDetailsVariablesArgsDict',
    'TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs',
    'TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict',
    'TaskRecordDetailsPropertiesArgs',
    'TaskRecordDetailsPropertiesArgsDict',
    'GetAnnouncementsFilterArgs',
    'GetAnnouncementsFilterArgsDict',
    'GetCompliancePoliciesFilterArgs',
    'GetCompliancePoliciesFilterArgsDict',
    'GetCompliancePolicyRulesFilterArgs',
    'GetCompliancePolicyRulesFilterArgsDict',
    'GetComplianceRecordCountsFilterArgs',
    'GetComplianceRecordCountsFilterArgsDict',
    'GetComplianceRecordsFilterArgs',
    'GetComplianceRecordsFilterArgsDict',
    'GetFleetCredentialsFilterArgs',
    'GetFleetCredentialsFilterArgsDict',
    'GetFleetProductsFilterArgs',
    'GetFleetProductsFilterArgsDict',
    'GetFleetPropertiesFilterArgs',
    'GetFleetPropertiesFilterArgsDict',
    'GetFleetResourcesFilterArgs',
    'GetFleetResourcesFilterArgsDict',
    'GetFleetTargetsFilterArgs',
    'GetFleetTargetsFilterArgsDict',
    'GetFleetsFilterArgs',
    'GetFleetsFilterArgsDict',
    'GetInventoryResourcesFilterArgs',
    'GetInventoryResourcesFilterArgsDict',
    'GetMaintenanceWindowsFilterArgs',
    'GetMaintenanceWindowsFilterArgsDict',
    'GetManagedEntityCountsFilterArgs',
    'GetManagedEntityCountsFilterArgsDict',
    'GetOnboardingPoliciesFilterArgs',
    'GetOnboardingPoliciesFilterArgsDict',
    'GetOnboardingsFilterArgs',
    'GetOnboardingsFilterArgsDict',
    'GetPatchesFilterArgs',
    'GetPatchesFilterArgsDict',
    'GetPlatformConfigurationsFilterArgs',
    'GetPlatformConfigurationsFilterArgsDict',
    'GetPropertiesFilterArgs',
    'GetPropertiesFilterArgsDict',
    'GetRunbooksFilterArgs',
    'GetRunbooksFilterArgsDict',
    'GetSchedulerDefinitionScheduledFleetsFilterArgs',
    'GetSchedulerDefinitionScheduledFleetsFilterArgsDict',
    'GetSchedulerDefinitionsFilterArgs',
    'GetSchedulerDefinitionsFilterArgsDict',
    'GetSchedulerJobCountsFilterArgs',
    'GetSchedulerJobCountsFilterArgsDict',
    'GetSchedulerJobJobActivityResourcesFilterArgs',
    'GetSchedulerJobJobActivityResourcesFilterArgsDict',
    'GetSchedulerJobJobActivityStepsFilterArgs',
    'GetSchedulerJobJobActivityStepsFilterArgsDict',
    'GetTaskRecordsFilterArgs',
    'GetTaskRecordsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CompliancePolicyRulePatchSelectionArgsDict(TypedDict):
        selection_type: pulumi.Input[str]
        """
        (Updatable) Selection type for the Patch.
        """
        days_since_release: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Days passed since patch release.
        """
        patch_level: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Patch Name.
        """
        patch_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Patch Name.
        """
elif False:
    CompliancePolicyRulePatchSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompliancePolicyRulePatchSelectionArgs:
    def __init__(__self__, *,
                 selection_type: pulumi.Input[str],
                 days_since_release: Optional[pulumi.Input[int]] = None,
                 patch_level: Optional[pulumi.Input[str]] = None,
                 patch_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] selection_type: (Updatable) Selection type for the Patch.
        :param pulumi.Input[int] days_since_release: (Updatable) Days passed since patch release.
        :param pulumi.Input[str] patch_level: (Updatable) Patch Name.
        :param pulumi.Input[str] patch_name: (Updatable) Patch Name.
        """
        pulumi.set(__self__, "selection_type", selection_type)
        if days_since_release is not None:
            pulumi.set(__self__, "days_since_release", days_since_release)
        if patch_level is not None:
            pulumi.set(__self__, "patch_level", patch_level)
        if patch_name is not None:
            pulumi.set(__self__, "patch_name", patch_name)

    @property
    @pulumi.getter(name="selectionType")
    def selection_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Selection type for the Patch.
        """
        return pulumi.get(self, "selection_type")

    @selection_type.setter
    def selection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "selection_type", value)

    @property
    @pulumi.getter(name="daysSinceRelease")
    def days_since_release(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Days passed since patch release.
        """
        return pulumi.get(self, "days_since_release")

    @days_since_release.setter
    def days_since_release(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_since_release", value)

    @property
    @pulumi.getter(name="patchLevel")
    def patch_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Patch Name.
        """
        return pulumi.get(self, "patch_level")

    @patch_level.setter
    def patch_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_level", value)

    @property
    @pulumi.getter(name="patchName")
    def patch_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Patch Name.
        """
        return pulumi.get(self, "patch_name")

    @patch_name.setter
    def patch_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_name", value)


if not MYPY:
    class CompliancePolicyRuleProductVersionArgsDict(TypedDict):
        version: pulumi.Input[str]
        """
        (Updatable) Product version the rule is applicable.
        """
        is_applicable_for_all_higher_versions: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Is rule applicable to all higher versions also
        """
elif False:
    CompliancePolicyRuleProductVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompliancePolicyRuleProductVersionArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 is_applicable_for_all_higher_versions: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] version: (Updatable) Product version the rule is applicable.
        :param pulumi.Input[bool] is_applicable_for_all_higher_versions: (Updatable) Is rule applicable to all higher versions also
        """
        pulumi.set(__self__, "version", version)
        if is_applicable_for_all_higher_versions is not None:
            pulumi.set(__self__, "is_applicable_for_all_higher_versions", is_applicable_for_all_higher_versions)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        (Updatable) Product version the rule is applicable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="isApplicableForAllHigherVersions")
    def is_applicable_for_all_higher_versions(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Is rule applicable to all higher versions also
        """
        return pulumi.get(self, "is_applicable_for_all_higher_versions")

    @is_applicable_for_all_higher_versions.setter
    def is_applicable_for_all_higher_versions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_applicable_for_all_higher_versions", value)


if not MYPY:
    class FleetCredentialArgsDict(TypedDict):
        compartment_id: pulumi.Input[str]
        """
        Tenancy OCID
        """
        display_name: pulumi.Input[str]
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        entity_specifics: pulumi.Input['FleetCredentialEntitySpecificsArgsDict']
        """
        Credential specific Details.
        """
        password: pulumi.Input['FleetCredentialPasswordArgsDict']
        """
        Credential Details.
        """
        user: pulumi.Input['FleetCredentialUserArgsDict']
        """
        Credential Details.
        """
elif False:
    FleetCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 display_name: pulumi.Input[str],
                 entity_specifics: pulumi.Input['FleetCredentialEntitySpecificsArgs'],
                 password: pulumi.Input['FleetCredentialPasswordArgs'],
                 user: pulumi.Input['FleetCredentialUserArgs']):
        """
        :param pulumi.Input[str] compartment_id: Tenancy OCID
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input['FleetCredentialEntitySpecificsArgs'] entity_specifics: Credential specific Details.
        :param pulumi.Input['FleetCredentialPasswordArgs'] password: Credential Details.
        :param pulumi.Input['FleetCredentialUserArgs'] user: Credential Details.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "entity_specifics", entity_specifics)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        Tenancy OCID
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entitySpecifics")
    def entity_specifics(self) -> pulumi.Input['FleetCredentialEntitySpecificsArgs']:
        """
        Credential specific Details.
        """
        return pulumi.get(self, "entity_specifics")

    @entity_specifics.setter
    def entity_specifics(self, value: pulumi.Input['FleetCredentialEntitySpecificsArgs']):
        pulumi.set(self, "entity_specifics", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input['FleetCredentialPasswordArgs']:
        """
        Credential Details.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input['FleetCredentialPasswordArgs']):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input['FleetCredentialUserArgs']:
        """
        Credential Details.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input['FleetCredentialUserArgs']):
        pulumi.set(self, "user", value)


if not MYPY:
    class FleetCredentialEntitySpecificsArgsDict(TypedDict):
        credential_level: pulumi.Input[str]
        """
        (Updatable) At what level the credential is provided?
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OCID of the resource associated with the target for which the credential is created.
        """
        target: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Target name for which the credential is provided.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgsDict']]]]
        """
        (Updatable) List of fleet credential variables.
        """
elif False:
    FleetCredentialEntitySpecificsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialEntitySpecificsArgs:
    def __init__(__self__, *,
                 credential_level: pulumi.Input[str],
                 resource_id: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] credential_level: (Updatable) At what level the credential is provided?
        :param pulumi.Input[str] resource_id: (Updatable) OCID of the resource associated with the target for which the credential is created.
        :param pulumi.Input[str] target: (Updatable) Target name for which the credential is provided.
        :param pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]] variables: (Updatable) List of fleet credential variables.
        """
        pulumi.set(__self__, "credential_level", credential_level)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="credentialLevel")
    def credential_level(self) -> pulumi.Input[str]:
        """
        (Updatable) At what level the credential is provided?
        """
        return pulumi.get(self, "credential_level")

    @credential_level.setter
    def credential_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential_level", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OCID of the resource associated with the target for which the credential is created.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Target name for which the credential is provided.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]]]:
        """
        (Updatable) List of fleet credential variables.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetCredentialEntitySpecificsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FleetCredentialEntitySpecificsVariableArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the variable.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The value corresponding to the variable name.
        """
elif False:
    FleetCredentialEntitySpecificsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialEntitySpecificsVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the variable.
        :param pulumi.Input[str] value: (Updatable) The value corresponding to the variable name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value corresponding to the variable name.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FleetCredentialPasswordArgsDict(TypedDict):
        credential_type: pulumi.Input[str]
        """
        (Updatable) Credential Type.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        key_version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The Vault Key version.
        """
        secret_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        secret_version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The secret version.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The value corresponding to the credential.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
        """
elif False:
    FleetCredentialPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialPasswordArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None,
                 key_version: Optional[pulumi.Input[str]] = None,
                 secret_id: Optional[pulumi.Input[str]] = None,
                 secret_version: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_type: (Updatable) Credential Type.
        :param pulumi.Input[str] key_id: (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        :param pulumi.Input[str] key_version: (Updatable) The Vault Key version.
        :param pulumi.Input[str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        :param pulumi.Input[str] secret_version: (Updatable) The secret version.
        :param pulumi.Input[str] value: (Updatable) The value corresponding to the credential.
        :param pulumi.Input[str] vault_id: (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Credential Type.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The Vault Key version.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_id", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The secret version.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value corresponding to the credential.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class FleetCredentialUserArgsDict(TypedDict):
        credential_type: pulumi.Input[str]
        """
        (Updatable) Credential Type.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        key_version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The Vault Key version.
        """
        secret_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        secret_version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The secret version.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The value corresponding to the credential.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    FleetCredentialUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCredentialUserArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None,
                 key_version: Optional[pulumi.Input[str]] = None,
                 secret_id: Optional[pulumi.Input[str]] = None,
                 secret_version: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_type: (Updatable) Credential Type.
        :param pulumi.Input[str] key_id: (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        :param pulumi.Input[str] key_version: (Updatable) The Vault Key version.
        :param pulumi.Input[str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        :param pulumi.Input[str] secret_version: (Updatable) The secret version.
        :param pulumi.Input[str] value: (Updatable) The value corresponding to the credential.
        :param pulumi.Input[str] vault_id: (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Credential Type.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OCID for the Vault Key that will be used to encrypt/decrypt the value given.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The Vault Key version.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_id", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The secret version.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value corresponding to the credential.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OCID for the Vault that will be used to fetch the key to encrypt/decrypt the value given.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class FleetNotificationPreferencesArgsDict(TypedDict):
        compartment_id: pulumi.Input[str]
        """
        (Updatable) Compartment ID the topic belongs to.
        """
        topic_id: pulumi.Input[str]
        """
        (Updatable) Topic Id where the notifications will be directed. A topic is a communication channel for sending messages on chosen events to subscriptions.
        """
        preferences: NotRequired[pulumi.Input['FleetNotificationPreferencesPreferencesArgsDict']]
        """
        (Updatable) Preferences to send notifications on the fleet activities.
        """
elif False:
    FleetNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetNotificationPreferencesArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 topic_id: pulumi.Input[str],
                 preferences: Optional[pulumi.Input['FleetNotificationPreferencesPreferencesArgs']] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) Compartment ID the topic belongs to.
        :param pulumi.Input[str] topic_id: (Updatable) Topic Id where the notifications will be directed. A topic is a communication channel for sending messages on chosen events to subscriptions.
        :param pulumi.Input['FleetNotificationPreferencesPreferencesArgs'] preferences: (Updatable) Preferences to send notifications on the fleet activities.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "topic_id", topic_id)
        if preferences is not None:
            pulumi.set(__self__, "preferences", preferences)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Compartment ID the topic belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Topic Id where the notifications will be directed. A topic is a communication channel for sending messages on chosen events to subscriptions.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_id", value)

    @property
    @pulumi.getter
    def preferences(self) -> Optional[pulumi.Input['FleetNotificationPreferencesPreferencesArgs']]:
        """
        (Updatable) Preferences to send notifications on the fleet activities.
        """
        return pulumi.get(self, "preferences")

    @preferences.setter
    def preferences(self, value: Optional[pulumi.Input['FleetNotificationPreferencesPreferencesArgs']]):
        pulumi.set(self, "preferences", value)


if not MYPY:
    class FleetNotificationPreferencesPreferencesArgsDict(TypedDict):
        on_job_failure: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables or disables notification on Job Failures.
        """
        on_topology_modification: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables or disables notification on Environment Fleet Topology Modification.
        """
        on_upcoming_schedule: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables notification on upcoming schedule.
        """
elif False:
    FleetNotificationPreferencesPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetNotificationPreferencesPreferencesArgs:
    def __init__(__self__, *,
                 on_job_failure: Optional[pulumi.Input[bool]] = None,
                 on_topology_modification: Optional[pulumi.Input[bool]] = None,
                 on_upcoming_schedule: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] on_job_failure: (Updatable) Enables or disables notification on Job Failures.
        :param pulumi.Input[bool] on_topology_modification: (Updatable) Enables or disables notification on Environment Fleet Topology Modification.
        :param pulumi.Input[bool] on_upcoming_schedule: (Updatable) Enables notification on upcoming schedule.
        """
        if on_job_failure is not None:
            pulumi.set(__self__, "on_job_failure", on_job_failure)
        if on_topology_modification is not None:
            pulumi.set(__self__, "on_topology_modification", on_topology_modification)
        if on_upcoming_schedule is not None:
            pulumi.set(__self__, "on_upcoming_schedule", on_upcoming_schedule)

    @property
    @pulumi.getter(name="onJobFailure")
    def on_job_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables notification on Job Failures.
        """
        return pulumi.get(self, "on_job_failure")

    @on_job_failure.setter
    def on_job_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_job_failure", value)

    @property
    @pulumi.getter(name="onTopologyModification")
    def on_topology_modification(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables notification on Environment Fleet Topology Modification.
        """
        return pulumi.get(self, "on_topology_modification")

    @on_topology_modification.setter
    def on_topology_modification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_topology_modification", value)

    @property
    @pulumi.getter(name="onUpcomingSchedule")
    def on_upcoming_schedule(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables notification on upcoming schedule.
        """
        return pulumi.get(self, "on_upcoming_schedule")

    @on_upcoming_schedule.setter
    def on_upcoming_schedule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_upcoming_schedule", value)


if not MYPY:
    class FleetRuleSelectionCriteriaArgsDict(TypedDict):
        match_condition: pulumi.Input[str]
        """
        (Updatable) Match condition for the rule selection. Include resources that match all rules or any of the rules.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleArgsDict']]]
        """
        (Updatable) Rules.
        """
elif False:
    FleetRuleSelectionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetRuleSelectionCriteriaArgs:
    def __init__(__self__, *,
                 match_condition: pulumi.Input[str],
                 rules: pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleArgs']]]):
        """
        :param pulumi.Input[str] match_condition: (Updatable) Match condition for the rule selection. Include resources that match all rules or any of the rules.
        :param pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleArgs']]] rules: (Updatable) Rules.
        """
        pulumi.set(__self__, "match_condition", match_condition)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="matchCondition")
    def match_condition(self) -> pulumi.Input[str]:
        """
        (Updatable) Match condition for the rule selection. Include resources that match all rules or any of the rules.
        """
        return pulumi.get(self, "match_condition")

    @match_condition.setter
    def match_condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_condition", value)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleArgs']]]:
        """
        (Updatable) Rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FleetRuleSelectionCriteriaRuleArgsDict(TypedDict):
        compartment_id: pulumi.Input[str]
        """
        (Updatable) Tenancy Id (Root Compartment Id)for which the rule is created.
        """
        conditions: pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleConditionArgsDict']]]
        """
        (Updatable) Rule Conditions
        """
        resource_compartment_id: pulumi.Input[str]
        """
        (Updatable) The Compartment ID to dynamically search resources. Provide the compartment ID to which the rule is applicable. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        basis: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Based on what the rule is created. It can be based on a resourceProperty or a tag.   If based on a tag, basis will be 'definedTagEquals' If based on a resource property, basis will be 'inventoryProperties'
        """
elif False:
    FleetRuleSelectionCriteriaRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetRuleSelectionCriteriaRuleArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 conditions: pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleConditionArgs']]],
                 resource_compartment_id: pulumi.Input[str],
                 basis: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) Tenancy Id (Root Compartment Id)for which the rule is created.
        :param pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleConditionArgs']]] conditions: (Updatable) Rule Conditions
        :param pulumi.Input[str] resource_compartment_id: (Updatable) The Compartment ID to dynamically search resources. Provide the compartment ID to which the rule is applicable. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] basis: (Updatable) Based on what the rule is created. It can be based on a resourceProperty or a tag.   If based on a tag, basis will be 'definedTagEquals' If based on a resource property, basis will be 'inventoryProperties'
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "resource_compartment_id", resource_compartment_id)
        if basis is not None:
            pulumi.set(__self__, "basis", basis)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Tenancy Id (Root Compartment Id)for which the rule is created.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleConditionArgs']]]:
        """
        (Updatable) Rule Conditions
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['FleetRuleSelectionCriteriaRuleConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="resourceCompartmentId")
    def resource_compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The Compartment ID to dynamically search resources. Provide the compartment ID to which the rule is applicable. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "resource_compartment_id")

    @resource_compartment_id.setter
    def resource_compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_compartment_id", value)

    @property
    @pulumi.getter
    def basis(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Based on what the rule is created. It can be based on a resourceProperty or a tag.   If based on a tag, basis will be 'definedTagEquals' If based on a resource property, basis will be 'inventoryProperties'
        """
        return pulumi.get(self, "basis")

    @basis.setter
    def basis(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basis", value)


if not MYPY:
    class FleetRuleSelectionCriteriaRuleConditionArgsDict(TypedDict):
        attr_group: pulumi.Input[str]
        """
        (Updatable) Attribute Group. Provide a Tag namespace if the rule is based on a tag. Provide resource type if the rule is based on a resource property.
        """
        attr_key: pulumi.Input[str]
        """
        (Updatable) Attribute Key.Provide Tag key if the rule is based on a tag. Provide resource property name if the rule is based on a resource property.
        """
        attr_value: pulumi.Input[str]
        """
        (Updatable) Attribute Value.Provide Tag value if the rule is based on a tag. Provide resource property value if the rule is based on a resource property.
        """
elif False:
    FleetRuleSelectionCriteriaRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetRuleSelectionCriteriaRuleConditionArgs:
    def __init__(__self__, *,
                 attr_group: pulumi.Input[str],
                 attr_key: pulumi.Input[str],
                 attr_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attr_group: (Updatable) Attribute Group. Provide a Tag namespace if the rule is based on a tag. Provide resource type if the rule is based on a resource property.
        :param pulumi.Input[str] attr_key: (Updatable) Attribute Key.Provide Tag key if the rule is based on a tag. Provide resource property name if the rule is based on a resource property.
        :param pulumi.Input[str] attr_value: (Updatable) Attribute Value.Provide Tag value if the rule is based on a tag. Provide resource property value if the rule is based on a resource property.
        """
        pulumi.set(__self__, "attr_group", attr_group)
        pulumi.set(__self__, "attr_key", attr_key)
        pulumi.set(__self__, "attr_value", attr_value)

    @property
    @pulumi.getter(name="attrGroup")
    def attr_group(self) -> pulumi.Input[str]:
        """
        (Updatable) Attribute Group. Provide a Tag namespace if the rule is based on a tag. Provide resource type if the rule is based on a resource property.
        """
        return pulumi.get(self, "attr_group")

    @attr_group.setter
    def attr_group(self, value: pulumi.Input[str]):
        pulumi.set(self, "attr_group", value)

    @property
    @pulumi.getter(name="attrKey")
    def attr_key(self) -> pulumi.Input[str]:
        """
        (Updatable) Attribute Key.Provide Tag key if the rule is based on a tag. Provide resource property name if the rule is based on a resource property.
        """
        return pulumi.get(self, "attr_key")

    @attr_key.setter
    def attr_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "attr_key", value)

    @property
    @pulumi.getter(name="attrValue")
    def attr_value(self) -> pulumi.Input[str]:
        """
        (Updatable) Attribute Value.Provide Tag value if the rule is based on a tag. Provide resource property value if the rule is based on a resource property.
        """
        return pulumi.get(self, "attr_value")

    @attr_value.setter
    def attr_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attr_value", value)


if not MYPY:
    class OnboardingAppliedPolicyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The unique id of the resource.
        """
        statements: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy statements.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
elif False:
    OnboardingAppliedPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnboardingAppliedPolicyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 statements: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The unique id of the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statements: Policy statements.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        :param pulumi.Input[str] time_updated: The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if statements is not None:
            pulumi.set(__self__, "statements", statements)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def statements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy statements.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statements", value)

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "system_tags", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class OnboardingItemArgsDict(TypedDict):
        applied_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['OnboardingItemAppliedPolicyArgsDict']]]]
        """
        Summary of the Fleet Application Management Onboard Policy.
        """
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Tenancy OCID
        """
        discovery_frequency: NotRequired[pulumi.Input[str]]
        """
        Provide discovery frequency.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The unique id of the resource.
        """
        is_cost_tracking_tag_enabled: NotRequired[pulumi.Input[bool]]
        """
        A value determining if the cost tracking tag is enabled or not. Allow Fleet Application Management to tag resources with cost tracking tag using "Oracle$FAMS-Tags.FAMSManaged" tag.
        """
        is_fams_tag_enabled: NotRequired[pulumi.Input[bool]]
        """
        A value determining if the Fleet Application Management tagging is enabled or not. Allow Fleet Application Management to tag resources with fleet name using "Oracle$FAMS-Tags.FleetName" tag. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        resource_region: NotRequired[pulumi.Input[str]]
        """
        Associated region
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the Onboarding.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The version of Fleet Application Management that the tenant is onboarded to.
        """
elif False:
    OnboardingItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnboardingItemArgs:
    def __init__(__self__, *,
                 applied_policies: Optional[pulumi.Input[Sequence[pulumi.Input['OnboardingItemAppliedPolicyArgs']]]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 discovery_frequency: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_cost_tracking_tag_enabled: Optional[pulumi.Input[bool]] = None,
                 is_fams_tag_enabled: Optional[pulumi.Input[bool]] = None,
                 resource_region: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OnboardingItemAppliedPolicyArgs']]] applied_policies: Summary of the Fleet Application Management Onboard Policy.
        :param pulumi.Input[str] compartment_id: Tenancy OCID
        :param pulumi.Input[str] discovery_frequency: Provide discovery frequency.
        :param pulumi.Input[str] id: The unique id of the resource.
        :param pulumi.Input[bool] is_cost_tracking_tag_enabled: A value determining if the cost tracking tag is enabled or not. Allow Fleet Application Management to tag resources with cost tracking tag using "Oracle$FAMS-Tags.FAMSManaged" tag.
        :param pulumi.Input[bool] is_fams_tag_enabled: A value determining if the Fleet Application Management tagging is enabled or not. Allow Fleet Application Management to tag resources with fleet name using "Oracle$FAMS-Tags.FleetName" tag. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] resource_region: Associated region
        :param pulumi.Input[str] state: The current state of the Onboarding.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        :param pulumi.Input[str] time_updated: The time this resource was last updated. An RFC3339 formatted datetime string.
        :param pulumi.Input[str] version: The version of Fleet Application Management that the tenant is onboarded to.
        """
        if applied_policies is not None:
            pulumi.set(__self__, "applied_policies", applied_policies)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if discovery_frequency is not None:
            pulumi.set(__self__, "discovery_frequency", discovery_frequency)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_cost_tracking_tag_enabled is not None:
            pulumi.set(__self__, "is_cost_tracking_tag_enabled", is_cost_tracking_tag_enabled)
        if is_fams_tag_enabled is not None:
            pulumi.set(__self__, "is_fams_tag_enabled", is_fams_tag_enabled)
        if resource_region is not None:
            pulumi.set(__self__, "resource_region", resource_region)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="appliedPolicies")
    def applied_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OnboardingItemAppliedPolicyArgs']]]]:
        """
        Summary of the Fleet Application Management Onboard Policy.
        """
        return pulumi.get(self, "applied_policies")

    @applied_policies.setter
    def applied_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OnboardingItemAppliedPolicyArgs']]]]):
        pulumi.set(self, "applied_policies", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Tenancy OCID
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="discoveryFrequency")
    def discovery_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        Provide discovery frequency.
        """
        return pulumi.get(self, "discovery_frequency")

    @discovery_frequency.setter
    def discovery_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discovery_frequency", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isCostTrackingTagEnabled")
    def is_cost_tracking_tag_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A value determining if the cost tracking tag is enabled or not. Allow Fleet Application Management to tag resources with cost tracking tag using "Oracle$FAMS-Tags.FAMSManaged" tag.
        """
        return pulumi.get(self, "is_cost_tracking_tag_enabled")

    @is_cost_tracking_tag_enabled.setter
    def is_cost_tracking_tag_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cost_tracking_tag_enabled", value)

    @property
    @pulumi.getter(name="isFamsTagEnabled")
    def is_fams_tag_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A value determining if the Fleet Application Management tagging is enabled or not. Allow Fleet Application Management to tag resources with fleet name using "Oracle$FAMS-Tags.FleetName" tag. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "is_fams_tag_enabled")

    @is_fams_tag_enabled.setter
    def is_fams_tag_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_fams_tag_enabled", value)

    @property
    @pulumi.getter(name="resourceRegion")
    def resource_region(self) -> Optional[pulumi.Input[str]]:
        """
        Associated region
        """
        return pulumi.get(self, "resource_region")

    @resource_region.setter
    def resource_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_region", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Onboarding.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "system_tags", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Fleet Application Management that the tenant is onboarded to.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class OnboardingItemAppliedPolicyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The unique id of the resource.
        """
        statements: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy statements.
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
elif False:
    OnboardingItemAppliedPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnboardingItemAppliedPolicyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 statements: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The unique id of the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statements: Policy statements.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        :param pulumi.Input[str] time_updated: The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if statements is not None:
            pulumi.set(__self__, "statements", statements)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def statements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy statements.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statements", value)

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "system_tags", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time this resource was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class PatchArtifactDetailsArgsDict(TypedDict):
        category: pulumi.Input[str]
        """
        (Updatable) Artifact category details.
        """
        artifact: NotRequired[pulumi.Input['PatchArtifactDetailsArtifactArgsDict']]
        """
        (Updatable) Patch artifact metadata Details which is common for all platforms.
        """
        artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgsDict']]]]
        """
        (Updatable) Artifacts.
        """
elif False:
    PatchArtifactDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchArtifactDetailsArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 artifact: Optional[pulumi.Input['PatchArtifactDetailsArtifactArgs']] = None,
                 artifacts: Optional[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]]] = None):
        """
        :param pulumi.Input[str] category: (Updatable) Artifact category details.
        :param pulumi.Input['PatchArtifactDetailsArtifactArgs'] artifact: (Updatable) Patch artifact metadata Details which is common for all platforms.
        :param pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]] artifacts: (Updatable) Artifacts.
        """
        pulumi.set(__self__, "category", category)
        if artifact is not None:
            pulumi.set(__self__, "artifact", artifact)
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        (Updatable) Artifact category details.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def artifact(self) -> Optional[pulumi.Input['PatchArtifactDetailsArtifactArgs']]:
        """
        (Updatable) Patch artifact metadata Details which is common for all platforms.
        """
        return pulumi.get(self, "artifact")

    @artifact.setter
    def artifact(self, value: Optional[pulumi.Input['PatchArtifactDetailsArtifactArgs']]):
        pulumi.set(self, "artifact", value)

    @property
    @pulumi.getter
    def artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]]]:
        """
        (Updatable) Artifacts.
        """
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PatchArtifactDetailsArtifactArgs']]]]):
        pulumi.set(self, "artifacts", value)


if not MYPY:
    class PatchArtifactDetailsArtifactArgsDict(TypedDict):
        architecture: NotRequired[pulumi.Input[str]]
        """
        (Updatable) System architecture.
        """
        content: NotRequired[pulumi.Input['PatchArtifactDetailsArtifactContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        os_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OS type the patch is applicable for.
        """
elif False:
    PatchArtifactDetailsArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchArtifactDetailsArtifactArgs:
    def __init__(__self__, *,
                 architecture: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input['PatchArtifactDetailsArtifactContentArgs']] = None,
                 os_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] architecture: (Updatable) System architecture.
        :param pulumi.Input['PatchArtifactDetailsArtifactContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[str] os_type: (Updatable) The OS type the patch is applicable for.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) System architecture.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['PatchArtifactDetailsArtifactContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['PatchArtifactDetailsArtifactContentArgs']]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OS type the patch is applicable for.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_type", value)


if not MYPY:
    class PatchArtifactDetailsArtifactContentArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        (Updatable) Bucket Name.
        """
        checksum: pulumi.Input[str]
        """
        (Updatable) md5 checksum of the artifact.
        """
        namespace: pulumi.Input[str]
        """
        (Updatable) Namespace.
        """
        object: pulumi.Input[str]
        """
        (Updatable) Object Name.
        """
        source_type: pulumi.Input[str]
        """
        (Updatable) Content Source type details.
        """
elif False:
    PatchArtifactDetailsArtifactContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchArtifactDetailsArtifactContentArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 checksum: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 object: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[str] checksum: (Updatable) md5 checksum of the artifact.
        :param pulumi.Input[str] namespace: (Updatable) Namespace.
        :param pulumi.Input[str] object: (Updatable) Object Name.
        :param pulumi.Input[str] source_type: (Updatable) Content Source type details.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        (Updatable) md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class PatchDependentPatchArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PatchDependentPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchDependentPatchArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PatchPatchTypeArgsDict(TypedDict):
        platform_configuration_id: pulumi.Input[str]
        """
        (Updatable) PlatformConfiguration Id corresponding to the Patch Type
        """
elif False:
    PatchPatchTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchPatchTypeArgs:
    def __init__(__self__, *,
                 platform_configuration_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] platform_configuration_id: (Updatable) PlatformConfiguration Id corresponding to the Patch Type
        """
        pulumi.set(__self__, "platform_configuration_id", platform_configuration_id)

    @property
    @pulumi.getter(name="platformConfigurationId")
    def platform_configuration_id(self) -> pulumi.Input[str]:
        """
        (Updatable) PlatformConfiguration Id corresponding to the Patch Type
        """
        return pulumi.get(self, "platform_configuration_id")

    @platform_configuration_id.setter
    def platform_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform_configuration_id", value)


if not MYPY:
    class PatchProductArgsDict(TypedDict):
        platform_configuration_id: pulumi.Input[str]
        """
        (Updatable) PlatformConfiguration Id corresponding to the Product
        """
        version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) product version.
        """
elif False:
    PatchProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchProductArgs:
    def __init__(__self__, *,
                 platform_configuration_id: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] platform_configuration_id: (Updatable) PlatformConfiguration Id corresponding to the Product
        :param pulumi.Input[str] version: (Updatable) product version.
        """
        pulumi.set(__self__, "platform_configuration_id", platform_configuration_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="platformConfigurationId")
    def platform_configuration_id(self) -> pulumi.Input[str]:
        """
        (Updatable) PlatformConfiguration Id corresponding to the Product
        """
        return pulumi.get(self, "platform_configuration_id")

    @platform_configuration_id.setter
    def platform_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform_configuration_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) product version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsArgsDict(TypedDict):
        config_category: pulumi.Input[str]
        """
        (Updatable) Category of configuration
        """
        compatible_products: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict']]]]
        """
        (Updatable) Products compatible with this Product. Provide products from the list of other products you have created that are compatible with the present one
        """
        components: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgsDict']]]]
        """
        (Updatable) OCID for the Credential name to be associated with the Product. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        patch_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict']]]]
        """
        (Updatable) Patch Types associated with this Product.
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgsDict']]]]
        """
        (Updatable) Products that belong to the stack. For example, Oracle WebLogic and Java for the Oracle Fusion Middleware product stack.
        """
        sub_category_details: NotRequired[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict']]
        """
        (Updatable) ProductStack Config Category Details.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Versions associated with the PRODUCT .
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsArgs:
    def __init__(__self__, *,
                 config_category: pulumi.Input[str],
                 compatible_products: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]]] = None,
                 patch_types: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]]] = None,
                 sub_category_details: Optional[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs']] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] config_category: (Updatable) Category of configuration
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]] compatible_products: (Updatable) Products compatible with this Product. Provide products from the list of other products you have created that are compatible with the present one
        :param pulumi.Input[Sequence[pulumi.Input[str]]] components: (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]] credentials: (Updatable) OCID for the Credential name to be associated with the Product. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]] patch_types: (Updatable) Patch Types associated with this Product.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]] products: (Updatable) Products that belong to the stack. For example, Oracle WebLogic and Java for the Oracle Fusion Middleware product stack.
        :param pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs'] sub_category_details: (Updatable) ProductStack Config Category Details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] versions: (Updatable) Versions associated with the PRODUCT .
        """
        pulumi.set(__self__, "config_category", config_category)
        if compatible_products is not None:
            pulumi.set(__self__, "compatible_products", compatible_products)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if patch_types is not None:
            pulumi.set(__self__, "patch_types", patch_types)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if sub_category_details is not None:
            pulumi.set(__self__, "sub_category_details", sub_category_details)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter(name="configCategory")
    def config_category(self) -> pulumi.Input[str]:
        """
        (Updatable) Category of configuration
        """
        return pulumi.get(self, "config_category")

    @config_category.setter
    def config_category(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_category", value)

    @property
    @pulumi.getter(name="compatibleProducts")
    def compatible_products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]]]:
        """
        (Updatable) Products compatible with this Product. Provide products from the list of other products you have created that are compatible with the present one
        """
        return pulumi.get(self, "compatible_products")

    @compatible_products.setter
    def compatible_products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs']]]]):
        pulumi.set(self, "compatible_products", value)

    @property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "components", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]]]:
        """
        (Updatable) OCID for the Credential name to be associated with the Product. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="patchTypes")
    def patch_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]]]:
        """
        (Updatable) Patch Types associated with this Product.
        """
        return pulumi.get(self, "patch_types")

    @patch_types.setter
    def patch_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsPatchTypeArgs']]]]):
        pulumi.set(self, "patch_types", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]]]:
        """
        (Updatable) Products that belong to the stack. For example, Oracle WebLogic and Java for the Oracle Fusion Middleware product stack.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsProductArgs']]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="subCategoryDetails")
    def sub_category_details(self) -> Optional[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs']]:
        """
        (Updatable) ProductStack Config Category Details.
        """
        return pulumi.get(self, "sub_category_details")

    @sub_category_details.setter
    def sub_category_details(self, value: Optional[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs']]):
        pulumi.set(self, "sub_category_details", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Versions associated with the PRODUCT .
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsCompatibleProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsCompatibleProductArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsPatchTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsPatchTypeArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsProductArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsProductArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict(TypedDict):
        sub_category: pulumi.Input[str]
        """
        (Updatable) SubCategory of Product Stack.
        """
        components: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict']]]]
        """
        (Updatable) OCID for the Credential name to be associated with the Product Stack. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        patch_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict']]]]
        """
        (Updatable) Patch Types associated with this Product Stack which will be considered as Product.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Versions associated with the PRODUCT .
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsArgs:
    def __init__(__self__, *,
                 sub_category: pulumi.Input[str],
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]]] = None,
                 patch_types: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] sub_category: (Updatable) SubCategory of Product Stack.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] components: (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]] credentials: (Updatable) OCID for the Credential name to be associated with the Product Stack. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]] patch_types: (Updatable) Patch Types associated with this Product Stack which will be considered as Product.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] versions: (Updatable) Versions associated with the PRODUCT .
        """
        pulumi.set(__self__, "sub_category", sub_category)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if patch_types is not None:
            pulumi.set(__self__, "patch_types", patch_types)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter(name="subCategory")
    def sub_category(self) -> pulumi.Input[str]:
        """
        (Updatable) SubCategory of Product Stack.
        """
        return pulumi.get(self, "sub_category")

    @sub_category.setter
    def sub_category(self, value: pulumi.Input[str]):
        pulumi.set(self, "sub_category", value)

    @property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Various components of the Product. For example:The administration server or node manager can be the components of the Oracle WebLogic Application server. Forms server or concurrent manager can be the components of the Oracle E-Business Suite.
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "components", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]]]:
        """
        (Updatable) OCID for the Credential name to be associated with the Product Stack. These are useful for target discovery or lifecycle management activities, for example, Oracle WebLogic admin credentials for Oracle WebLogic Application server.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="patchTypes")
    def patch_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]]]:
        """
        (Updatable) Patch Types associated with this Product Stack which will be considered as Product.
        """
        return pulumi.get(self, "patch_types")

    @patch_types.setter
    def patch_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs']]]]):
        pulumi.set(self, "patch_types", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Versions associated with the PRODUCT .
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformConfigurationConfigCategoryDetailsSubCategoryDetailsPatchTypeArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RunbookAssociationsArgsDict(TypedDict):
        execution_workflow_details: pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsArgsDict']
        """
        (Updatable) Execution Workflow details.
        """
        groups: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsGroupArgsDict']]]
        """
        (Updatable) The groups of the runbook.
        """
        tasks: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskArgsDict']]]
        """
        (Updatable) A set of tasks to execute in the runbook.
        """
        rollback_workflow_details: NotRequired[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsArgsDict']]
        """
        (Updatable) Rollback Workflow details.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The version of the runbook.
        """
elif False:
    RunbookAssociationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsArgs:
    def __init__(__self__, *,
                 execution_workflow_details: pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsArgs'],
                 groups: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsGroupArgs']]],
                 tasks: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskArgs']]],
                 rollback_workflow_details: Optional[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsArgs'] execution_workflow_details: (Updatable) Execution Workflow details.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsGroupArgs']]] groups: (Updatable) The groups of the runbook.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskArgs']]] tasks: (Updatable) A set of tasks to execute in the runbook.
        :param pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsArgs'] rollback_workflow_details: (Updatable) Rollback Workflow details.
        :param pulumi.Input[str] version: (Updatable) The version of the runbook.
        """
        pulumi.set(__self__, "execution_workflow_details", execution_workflow_details)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "tasks", tasks)
        if rollback_workflow_details is not None:
            pulumi.set(__self__, "rollback_workflow_details", rollback_workflow_details)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="executionWorkflowDetails")
    def execution_workflow_details(self) -> pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsArgs']:
        """
        (Updatable) Execution Workflow details.
        """
        return pulumi.get(self, "execution_workflow_details")

    @execution_workflow_details.setter
    def execution_workflow_details(self, value: pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsArgs']):
        pulumi.set(self, "execution_workflow_details", value)

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsGroupArgs']]]:
        """
        (Updatable) The groups of the runbook.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def tasks(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskArgs']]]:
        """
        (Updatable) A set of tasks to execute in the runbook.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskArgs']]]):
        pulumi.set(self, "tasks", value)

    @property
    @pulumi.getter(name="rollbackWorkflowDetails")
    def rollback_workflow_details(self) -> Optional[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsArgs']]:
        """
        (Updatable) Rollback Workflow details.
        """
        return pulumi.get(self, "rollback_workflow_details")

    @rollback_workflow_details.setter
    def rollback_workflow_details(self, value: Optional[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsArgs']]):
        pulumi.set(self, "rollback_workflow_details", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The version of the runbook.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RunbookAssociationsExecutionWorkflowDetailsArgsDict(TypedDict):
        workflows: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowArgsDict']]]
        """
        (Updatable) Execution Workflow for the runbook.
        """
elif False:
    RunbookAssociationsExecutionWorkflowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsExecutionWorkflowDetailsArgs:
    def __init__(__self__, *,
                 workflows: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowArgs']]] workflows: (Updatable) Execution Workflow for the runbook.
        """
        pulumi.set(__self__, "workflows", workflows)

    @property
    @pulumi.getter
    def workflows(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowArgs']]]:
        """
        (Updatable) Execution Workflow for the runbook.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowArgs']]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class RunbookAssociationsExecutionWorkflowDetailsWorkflowArgsDict(TypedDict):
        group_name: pulumi.Input[str]
        """
        (Updatable) Name of the group.
        """
        steps: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgsDict']]]
        """
        (Updatable) Steps within the Group.
        """
        type: pulumi.Input[str]
        """
        (Updatable) Workflow Group  Details.
        """
elif False:
    RunbookAssociationsExecutionWorkflowDetailsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsExecutionWorkflowDetailsWorkflowArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[str],
                 steps: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgs']]] steps: (Updatable) Steps within the Group.
        :param pulumi.Input[str] type: (Updatable) Workflow Group  Details.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgs']]]:
        """
        (Updatable) Steps within the Group.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Workflow Group  Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        (Updatable) Content Source Details.
        """
        group_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the group.
        """
        step_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Provide StepName for the Task.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Tasks within the Group. Provide the stepName for all applicable tasks.
        """
elif False:
    RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsExecutionWorkflowDetailsWorkflowStepArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 group_name: Optional[pulumi.Input[str]] = None,
                 step_name: Optional[pulumi.Input[str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Content Source Details.
        :param pulumi.Input[str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[str] step_name: (Updatable) Provide StepName for the Task.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] steps: (Updatable) Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Content Source Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Provide StepName for the Task.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "step_name", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class RunbookAssociationsGroupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) The name of the group.
        """
        type: pulumi.Input[str]
        """
        (Updatable) The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP : Executes tasks across resources in a rolling order.
        """
        properties: NotRequired[pulumi.Input['RunbookAssociationsGroupPropertiesArgsDict']]
        """
        (Updatable) The properties of the component.
        """
elif False:
    RunbookAssociationsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 properties: Optional[pulumi.Input['RunbookAssociationsGroupPropertiesArgs']] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the group.
        :param pulumi.Input[str] type: (Updatable) The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP : Executes tasks across resources in a rolling order.
        :param pulumi.Input['RunbookAssociationsGroupPropertiesArgs'] properties: (Updatable) The properties of the component.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of the group. PARALLEL_TASK_GROUP : Helps to execute tasks parallelly inside a resource. PARALLEL_RESOURCE_GROUP : Executes tasks across resources parallelly. ROLLING_RESOURCE_GROUP : Executes tasks across resources in a rolling order.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['RunbookAssociationsGroupPropertiesArgs']]:
        """
        (Updatable) The properties of the component.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['RunbookAssociationsGroupPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class RunbookAssociationsGroupPropertiesArgsDict(TypedDict):
        action_on_failure: pulumi.Input[str]
        """
        (Updatable) The action to be taken in case of a failure.
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Build control flow conditions that determine the relevance of the task execution.
        """
        notification_preferences: NotRequired[pulumi.Input['RunbookAssociationsGroupPropertiesNotificationPreferencesArgsDict']]
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        pause_details: NotRequired[pulumi.Input['RunbookAssociationsGroupPropertiesPauseDetailsArgsDict']]
        """
        (Updatable) Pause Details
        """
        run_on: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The runOn condition for the task/group/container. Build task execution conditions if applicable to product and product-specific components. This condition is relevant when handling product stack workflows. Example: target.product.name = Oracle WebLogic Server OR target.product.name = Oracle HTTP Server
        """
elif False:
    RunbookAssociationsGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsGroupPropertiesArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 notification_preferences: Optional[pulumi.Input['RunbookAssociationsGroupPropertiesNotificationPreferencesArgs']] = None,
                 pause_details: Optional[pulumi.Input['RunbookAssociationsGroupPropertiesPauseDetailsArgs']] = None,
                 run_on: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_on_failure: (Updatable) The action to be taken in case of a failure.
        :param pulumi.Input[str] condition: (Updatable) Build control flow conditions that determine the relevance of the task execution.
        :param pulumi.Input['RunbookAssociationsGroupPropertiesNotificationPreferencesArgs'] notification_preferences: (Updatable) Preferences to send notifications on the task activities.
        :param pulumi.Input['RunbookAssociationsGroupPropertiesPauseDetailsArgs'] pause_details: (Updatable) Pause Details
        :param pulumi.Input[str] run_on: (Updatable) The runOn condition for the task/group/container. Build task execution conditions if applicable to product and product-specific components. This condition is relevant when handling product stack workflows. Example: target.product.name = Oracle WebLogic Server OR target.product.name = Oracle HTTP Server
        """
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if notification_preferences is not None:
            pulumi.set(__self__, "notification_preferences", notification_preferences)
        if pause_details is not None:
            pulumi.set(__self__, "pause_details", pause_details)
        if run_on is not None:
            pulumi.set(__self__, "run_on", run_on)

    @property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[str]:
        """
        (Updatable) The action to be taken in case of a failure.
        """
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_on_failure", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Build control flow conditions that determine the relevance of the task execution.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="notificationPreferences")
    def notification_preferences(self) -> Optional[pulumi.Input['RunbookAssociationsGroupPropertiesNotificationPreferencesArgs']]:
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        return pulumi.get(self, "notification_preferences")

    @notification_preferences.setter
    def notification_preferences(self, value: Optional[pulumi.Input['RunbookAssociationsGroupPropertiesNotificationPreferencesArgs']]):
        pulumi.set(self, "notification_preferences", value)

    @property
    @pulumi.getter(name="pauseDetails")
    def pause_details(self) -> Optional[pulumi.Input['RunbookAssociationsGroupPropertiesPauseDetailsArgs']]:
        """
        (Updatable) Pause Details
        """
        return pulumi.get(self, "pause_details")

    @pause_details.setter
    def pause_details(self, value: Optional[pulumi.Input['RunbookAssociationsGroupPropertiesPauseDetailsArgs']]):
        pulumi.set(self, "pause_details", value)

    @property
    @pulumi.getter(name="runOn")
    def run_on(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The runOn condition for the task/group/container. Build task execution conditions if applicable to product and product-specific components. This condition is relevant when handling product stack workflows. Example: target.product.name = Oracle WebLogic Server OR target.product.name = Oracle HTTP Server
        """
        return pulumi.get(self, "run_on")

    @run_on.setter
    def run_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_on", value)


if not MYPY:
    class RunbookAssociationsGroupPropertiesNotificationPreferencesArgsDict(TypedDict):
        should_notify_on_pause: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables notification on pause.
        """
        should_notify_on_task_failure: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables or disables notification on Task Failures.
        """
        should_notify_on_task_success: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables or disables notification on Task Success.
        """
elif False:
    RunbookAssociationsGroupPropertiesNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsGroupPropertiesNotificationPreferencesArgs:
    def __init__(__self__, *,
                 should_notify_on_pause: Optional[pulumi.Input[bool]] = None,
                 should_notify_on_task_failure: Optional[pulumi.Input[bool]] = None,
                 should_notify_on_task_success: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_notify_on_pause: (Updatable) Enables notification on pause.
        :param pulumi.Input[bool] should_notify_on_task_failure: (Updatable) Enables or disables notification on Task Failures.
        :param pulumi.Input[bool] should_notify_on_task_success: (Updatable) Enables or disables notification on Task Success.
        """
        if should_notify_on_pause is not None:
            pulumi.set(__self__, "should_notify_on_pause", should_notify_on_pause)
        if should_notify_on_task_failure is not None:
            pulumi.set(__self__, "should_notify_on_task_failure", should_notify_on_task_failure)
        if should_notify_on_task_success is not None:
            pulumi.set(__self__, "should_notify_on_task_success", should_notify_on_task_success)

    @property
    @pulumi.getter(name="shouldNotifyOnPause")
    def should_notify_on_pause(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables notification on pause.
        """
        return pulumi.get(self, "should_notify_on_pause")

    @should_notify_on_pause.setter
    def should_notify_on_pause(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_notify_on_pause", value)

    @property
    @pulumi.getter(name="shouldNotifyOnTaskFailure")
    def should_notify_on_task_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables notification on Task Failures.
        """
        return pulumi.get(self, "should_notify_on_task_failure")

    @should_notify_on_task_failure.setter
    def should_notify_on_task_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_notify_on_task_failure", value)

    @property
    @pulumi.getter(name="shouldNotifyOnTaskSuccess")
    def should_notify_on_task_success(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables notification on Task Success.
        """
        return pulumi.get(self, "should_notify_on_task_success")

    @should_notify_on_task_success.setter
    def should_notify_on_task_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_notify_on_task_success", value)


if not MYPY:
    class RunbookAssociationsGroupPropertiesPauseDetailsArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Updatable) Pause based On.
        """
        duration_in_minutes: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Time in minutes to apply Pause.
        """
elif False:
    RunbookAssociationsGroupPropertiesPauseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsGroupPropertiesPauseDetailsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 duration_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) Pause based On.
        :param pulumi.Input[int] duration_in_minutes: (Updatable) Time in minutes to apply Pause.
        """
        pulumi.set(__self__, "kind", kind)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) Pause based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Time in minutes to apply Pause.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_in_minutes", value)


if not MYPY:
    class RunbookAssociationsRollbackWorkflowDetailsArgsDict(TypedDict):
        scope: pulumi.Input[str]
        """
        (Updatable) rollback Scope
        """
        workflows: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowArgsDict']]]
        """
        (Updatable) Rollback Workflow for the runbook.
        """
elif False:
    RunbookAssociationsRollbackWorkflowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsRollbackWorkflowDetailsArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[str],
                 workflows: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowArgs']]]):
        """
        :param pulumi.Input[str] scope: (Updatable) rollback Scope
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowArgs']]] workflows: (Updatable) Rollback Workflow for the runbook.
        """
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "workflows", workflows)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        (Updatable) rollback Scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def workflows(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowArgs']]]:
        """
        (Updatable) Rollback Workflow for the runbook.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowArgs']]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class RunbookAssociationsRollbackWorkflowDetailsWorkflowArgsDict(TypedDict):
        group_name: pulumi.Input[str]
        """
        (Updatable) Name of the group.
        """
        steps: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgsDict']]]
        """
        (Updatable) Steps within the Group.
        """
        type: pulumi.Input[str]
        """
        (Updatable) Workflow Group  Details.
        """
elif False:
    RunbookAssociationsRollbackWorkflowDetailsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsRollbackWorkflowDetailsWorkflowArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[str],
                 steps: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgs']]] steps: (Updatable) Steps within the Group.
        :param pulumi.Input[str] type: (Updatable) Workflow Group  Details.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgs']]]:
        """
        (Updatable) Steps within the Group.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Workflow Group  Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        (Updatable) Content Source Details.
        """
        group_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the group.
        """
        step_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Provide StepName for the Task.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Tasks within the Group. Provide the stepName for all applicable tasks.
        """
elif False:
    RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsRollbackWorkflowDetailsWorkflowStepArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 group_name: Optional[pulumi.Input[str]] = None,
                 step_name: Optional[pulumi.Input[str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Content Source Details.
        :param pulumi.Input[str] group_name: (Updatable) Name of the group.
        :param pulumi.Input[str] step_name: (Updatable) Provide StepName for the Task.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] steps: (Updatable) Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if step_name is not None:
            pulumi.set(__self__, "step_name", step_name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Content Source Details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="stepName")
    def step_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Provide StepName for the Task.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "step_name", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Tasks within the Group. Provide the stepName for all applicable tasks.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class RunbookAssociationsTaskArgsDict(TypedDict):
        association_type: pulumi.Input[str]
        """
        (Updatable) The association type of the task
        """
        step_name: pulumi.Input[str]
        """
        (Updatable) The name of the task step.
        """
        task_record_details: pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsArgsDict']
        """
        (Updatable) The details of the task.
        """
        output_variable_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskOutputVariableMappingArgsDict']]]]
        """
        (Updatable) Mapping output variables of previous tasks to the input variables of the current task.
        """
        step_properties: NotRequired[pulumi.Input['RunbookAssociationsTaskStepPropertiesArgsDict']]
        """
        (Updatable) The properties of the component.
        """
elif False:
    RunbookAssociationsTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskArgs:
    def __init__(__self__, *,
                 association_type: pulumi.Input[str],
                 step_name: pulumi.Input[str],
                 task_record_details: pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsArgs'],
                 output_variable_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskOutputVariableMappingArgs']]]] = None,
                 step_properties: Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesArgs']] = None):
        """
        :param pulumi.Input[str] association_type: (Updatable) The association type of the task
        :param pulumi.Input[str] step_name: (Updatable) The name of the task step.
        :param pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsArgs'] task_record_details: (Updatable) The details of the task.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskOutputVariableMappingArgs']]] output_variable_mappings: (Updatable) Mapping output variables of previous tasks to the input variables of the current task.
        :param pulumi.Input['RunbookAssociationsTaskStepPropertiesArgs'] step_properties: (Updatable) The properties of the component.
        """
        pulumi.set(__self__, "association_type", association_type)
        pulumi.set(__self__, "step_name", step_name)
        pulumi.set(__self__, "task_record_details", task_record_details)
        if output_variable_mappings is not None:
            pulumi.set(__self__, "output_variable_mappings", output_variable_mappings)
        if step_properties is not None:
            pulumi.set(__self__, "step_properties", step_properties)

    @property
    @pulumi.getter(name="associationType")
    def association_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The association type of the task
        """
        return pulumi.get(self, "association_type")

    @association_type.setter
    def association_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "association_type", value)

    @property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the task step.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "step_name", value)

    @property
    @pulumi.getter(name="taskRecordDetails")
    def task_record_details(self) -> pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsArgs']:
        """
        (Updatable) The details of the task.
        """
        return pulumi.get(self, "task_record_details")

    @task_record_details.setter
    def task_record_details(self, value: pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsArgs']):
        pulumi.set(self, "task_record_details", value)

    @property
    @pulumi.getter(name="outputVariableMappings")
    def output_variable_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskOutputVariableMappingArgs']]]]:
        """
        (Updatable) Mapping output variables of previous tasks to the input variables of the current task.
        """
        return pulumi.get(self, "output_variable_mappings")

    @output_variable_mappings.setter
    def output_variable_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskOutputVariableMappingArgs']]]]):
        pulumi.set(self, "output_variable_mappings", value)

    @property
    @pulumi.getter(name="stepProperties")
    def step_properties(self) -> Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesArgs']]:
        """
        (Updatable) The properties of the component.
        """
        return pulumi.get(self, "step_properties")

    @step_properties.setter
    def step_properties(self, value: Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesArgs']]):
        pulumi.set(self, "step_properties", value)


if not MYPY:
    class RunbookAssociationsTaskOutputVariableMappingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) The name of the input variable.
        """
        output_variable_details: pulumi.Input['RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgsDict']
        """
        (Updatable) The details of the output variable that will be used for mapping.
        """
elif False:
    RunbookAssociationsTaskOutputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskOutputVariableMappingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 output_variable_details: pulumi.Input['RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgs']):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the input variable.
        :param pulumi.Input['RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgs'] output_variable_details: (Updatable) The details of the output variable that will be used for mapping.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_variable_details", output_variable_details)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the input variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="outputVariableDetails")
    def output_variable_details(self) -> pulumi.Input['RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgs']:
        """
        (Updatable) The details of the output variable that will be used for mapping.
        """
        return pulumi.get(self, "output_variable_details")

    @output_variable_details.setter
    def output_variable_details(self, value: pulumi.Input['RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgs']):
        pulumi.set(self, "output_variable_details", value)


if not MYPY:
    class RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgsDict(TypedDict):
        output_variable_name: pulumi.Input[str]
        """
        (Updatable) The name of the output variable whose value has to be mapped.
        """
        step_name: pulumi.Input[str]
        """
        (Updatable) The name of the task step the output variable belongs to.
        """
elif False:
    RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskOutputVariableMappingOutputVariableDetailsArgs:
    def __init__(__self__, *,
                 output_variable_name: pulumi.Input[str],
                 step_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] output_variable_name: (Updatable) The name of the output variable whose value has to be mapped.
        :param pulumi.Input[str] step_name: (Updatable) The name of the task step the output variable belongs to.
        """
        pulumi.set(__self__, "output_variable_name", output_variable_name)
        pulumi.set(__self__, "step_name", step_name)

    @property
    @pulumi.getter(name="outputVariableName")
    def output_variable_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the output variable whose value has to be mapped.
        """
        return pulumi.get(self, "output_variable_name")

    @output_variable_name.setter
    def output_variable_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_variable_name", value)

    @property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the task step the output variable belongs to.
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "step_name", value)


if not MYPY:
    class RunbookAssociationsTaskStepPropertiesArgsDict(TypedDict):
        action_on_failure: pulumi.Input[str]
        """
        (Updatable) The action to be taken in case of a failure.
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Build control flow conditions that determine the relevance of the task execution.
        """
        notification_preferences: NotRequired[pulumi.Input['RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgsDict']]
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        pause_details: NotRequired[pulumi.Input['RunbookAssociationsTaskStepPropertiesPauseDetailsArgsDict']]
        """
        (Updatable) Pause Details
        """
        run_on: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The runOn condition for the task/group/container. Build task execution conditions if applicable to product and product-specific components. This condition is relevant when handling product stack workflows. Example: target.product.name = Oracle WebLogic Server OR target.product.name = Oracle HTTP Server
        """
elif False:
    RunbookAssociationsTaskStepPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskStepPropertiesArgs:
    def __init__(__self__, *,
                 action_on_failure: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 notification_preferences: Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgs']] = None,
                 pause_details: Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesPauseDetailsArgs']] = None,
                 run_on: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_on_failure: (Updatable) The action to be taken in case of a failure.
        :param pulumi.Input[str] condition: (Updatable) Build control flow conditions that determine the relevance of the task execution.
        :param pulumi.Input['RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgs'] notification_preferences: (Updatable) Preferences to send notifications on the task activities.
        :param pulumi.Input['RunbookAssociationsTaskStepPropertiesPauseDetailsArgs'] pause_details: (Updatable) Pause Details
        :param pulumi.Input[str] run_on: (Updatable) The runOn condition for the task/group/container. Build task execution conditions if applicable to product and product-specific components. This condition is relevant when handling product stack workflows. Example: target.product.name = Oracle WebLogic Server OR target.product.name = Oracle HTTP Server
        """
        pulumi.set(__self__, "action_on_failure", action_on_failure)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if notification_preferences is not None:
            pulumi.set(__self__, "notification_preferences", notification_preferences)
        if pause_details is not None:
            pulumi.set(__self__, "pause_details", pause_details)
        if run_on is not None:
            pulumi.set(__self__, "run_on", run_on)

    @property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> pulumi.Input[str]:
        """
        (Updatable) The action to be taken in case of a failure.
        """
        return pulumi.get(self, "action_on_failure")

    @action_on_failure.setter
    def action_on_failure(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_on_failure", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Build control flow conditions that determine the relevance of the task execution.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="notificationPreferences")
    def notification_preferences(self) -> Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgs']]:
        """
        (Updatable) Preferences to send notifications on the task activities.
        """
        return pulumi.get(self, "notification_preferences")

    @notification_preferences.setter
    def notification_preferences(self, value: Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgs']]):
        pulumi.set(self, "notification_preferences", value)

    @property
    @pulumi.getter(name="pauseDetails")
    def pause_details(self) -> Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesPauseDetailsArgs']]:
        """
        (Updatable) Pause Details
        """
        return pulumi.get(self, "pause_details")

    @pause_details.setter
    def pause_details(self, value: Optional[pulumi.Input['RunbookAssociationsTaskStepPropertiesPauseDetailsArgs']]):
        pulumi.set(self, "pause_details", value)

    @property
    @pulumi.getter(name="runOn")
    def run_on(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The runOn condition for the task/group/container. Build task execution conditions if applicable to product and product-specific components. This condition is relevant when handling product stack workflows. Example: target.product.name = Oracle WebLogic Server OR target.product.name = Oracle HTTP Server
        """
        return pulumi.get(self, "run_on")

    @run_on.setter
    def run_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_on", value)


if not MYPY:
    class RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgsDict(TypedDict):
        should_notify_on_pause: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables notification on pause.
        """
        should_notify_on_task_failure: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables or disables notification on Task Failures.
        """
        should_notify_on_task_success: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Enables or disables notification on Task Success.
        """
elif False:
    RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskStepPropertiesNotificationPreferencesArgs:
    def __init__(__self__, *,
                 should_notify_on_pause: Optional[pulumi.Input[bool]] = None,
                 should_notify_on_task_failure: Optional[pulumi.Input[bool]] = None,
                 should_notify_on_task_success: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_notify_on_pause: (Updatable) Enables notification on pause.
        :param pulumi.Input[bool] should_notify_on_task_failure: (Updatable) Enables or disables notification on Task Failures.
        :param pulumi.Input[bool] should_notify_on_task_success: (Updatable) Enables or disables notification on Task Success.
        """
        if should_notify_on_pause is not None:
            pulumi.set(__self__, "should_notify_on_pause", should_notify_on_pause)
        if should_notify_on_task_failure is not None:
            pulumi.set(__self__, "should_notify_on_task_failure", should_notify_on_task_failure)
        if should_notify_on_task_success is not None:
            pulumi.set(__self__, "should_notify_on_task_success", should_notify_on_task_success)

    @property
    @pulumi.getter(name="shouldNotifyOnPause")
    def should_notify_on_pause(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables notification on pause.
        """
        return pulumi.get(self, "should_notify_on_pause")

    @should_notify_on_pause.setter
    def should_notify_on_pause(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_notify_on_pause", value)

    @property
    @pulumi.getter(name="shouldNotifyOnTaskFailure")
    def should_notify_on_task_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables notification on Task Failures.
        """
        return pulumi.get(self, "should_notify_on_task_failure")

    @should_notify_on_task_failure.setter
    def should_notify_on_task_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_notify_on_task_failure", value)

    @property
    @pulumi.getter(name="shouldNotifyOnTaskSuccess")
    def should_notify_on_task_success(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables notification on Task Success.
        """
        return pulumi.get(self, "should_notify_on_task_success")

    @should_notify_on_task_success.setter
    def should_notify_on_task_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_notify_on_task_success", value)


if not MYPY:
    class RunbookAssociationsTaskStepPropertiesPauseDetailsArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Updatable) Pause based On.
        """
        duration_in_minutes: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Time in minutes to apply Pause.
        """
elif False:
    RunbookAssociationsTaskStepPropertiesPauseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskStepPropertiesPauseDetailsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 duration_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) Pause based On.
        :param pulumi.Input[int] duration_in_minutes: (Updatable) Time in minutes to apply Pause.
        """
        pulumi.set(__self__, "kind", kind)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) Pause based On.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Time in minutes to apply Pause.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_in_minutes", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsArgsDict(TypedDict):
        scope: pulumi.Input[str]
        """
        (Updatable) The scope of the task.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The description of the task.
        """
        execution_details: NotRequired[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgsDict']]
        """
        (Updatable) Execution details.
        """
        is_apply_subject_task: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Is this an Apply Subject Task? Ex. Patch Execution Task
        """
        is_copy_to_library_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Make a copy of this task in Library
        """
        is_discovery_output_task: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Is this a discovery output task?
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the task
        """
        os_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OS for the task.
        """
        platform: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The platform of the runbook.
        """
        properties: NotRequired[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsPropertiesArgsDict']]
        """
        (Updatable) The properties of the task.
        """
        task_record_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The ID of taskRecord.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 execution_details: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgs']] = None,
                 is_apply_subject_task: Optional[pulumi.Input[bool]] = None,
                 is_copy_to_library_enabled: Optional[pulumi.Input[bool]] = None,
                 is_discovery_output_task: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 os_type: Optional[pulumi.Input[str]] = None,
                 platform: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsPropertiesArgs']] = None,
                 task_record_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scope: (Updatable) The scope of the task.
        :param pulumi.Input[str] description: (Updatable) The description of the task.
        :param pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgs'] execution_details: (Updatable) Execution details.
        :param pulumi.Input[bool] is_apply_subject_task: (Updatable) Is this an Apply Subject Task? Ex. Patch Execution Task
        :param pulumi.Input[bool] is_copy_to_library_enabled: (Updatable) Make a copy of this task in Library
        :param pulumi.Input[bool] is_discovery_output_task: (Updatable) Is this a discovery output task?
        :param pulumi.Input[str] name: (Updatable) The name of the task
        :param pulumi.Input[str] os_type: (Updatable) The OS for the task.
        :param pulumi.Input[str] platform: (Updatable) The platform of the runbook.
        :param pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsPropertiesArgs'] properties: (Updatable) The properties of the task.
        :param pulumi.Input[str] task_record_id: (Updatable) The ID of taskRecord.
        """
        pulumi.set(__self__, "scope", scope)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if execution_details is not None:
            pulumi.set(__self__, "execution_details", execution_details)
        if is_apply_subject_task is not None:
            pulumi.set(__self__, "is_apply_subject_task", is_apply_subject_task)
        if is_copy_to_library_enabled is not None:
            pulumi.set(__self__, "is_copy_to_library_enabled", is_copy_to_library_enabled)
        if is_discovery_output_task is not None:
            pulumi.set(__self__, "is_discovery_output_task", is_discovery_output_task)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if task_record_id is not None:
            pulumi.set(__self__, "task_record_id", task_record_id)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        (Updatable) The scope of the task.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description of the task.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="executionDetails")
    def execution_details(self) -> Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgs']]:
        """
        (Updatable) Execution details.
        """
        return pulumi.get(self, "execution_details")

    @execution_details.setter
    def execution_details(self, value: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgs']]):
        pulumi.set(self, "execution_details", value)

    @property
    @pulumi.getter(name="isApplySubjectTask")
    def is_apply_subject_task(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Is this an Apply Subject Task? Ex. Patch Execution Task
        """
        return pulumi.get(self, "is_apply_subject_task")

    @is_apply_subject_task.setter
    def is_apply_subject_task(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_apply_subject_task", value)

    @property
    @pulumi.getter(name="isCopyToLibraryEnabled")
    def is_copy_to_library_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Make a copy of this task in Library
        """
        return pulumi.get(self, "is_copy_to_library_enabled")

    @is_copy_to_library_enabled.setter
    def is_copy_to_library_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_copy_to_library_enabled", value)

    @property
    @pulumi.getter(name="isDiscoveryOutputTask")
    def is_discovery_output_task(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Is this a discovery output task?
        """
        return pulumi.get(self, "is_discovery_output_task")

    @is_discovery_output_task.setter
    def is_discovery_output_task(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_discovery_output_task", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the task
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OS for the task.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The platform of the runbook.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsPropertiesArgs']]:
        """
        (Updatable) The properties of the task.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="taskRecordId")
    def task_record_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The ID of taskRecord.
        """
        return pulumi.get(self, "task_record_id")

    @task_record_id.setter
    def task_record_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_record_id", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgsDict(TypedDict):
        execution_type: pulumi.Input[str]
        """
        (Updatable) The action type of the task
        """
        command: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        content: NotRequired[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict']]]]
        """
        (Updatable) Credentials required for executing the task.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Endpoint to be invoked.
        """
        variables: NotRequired[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict']]
        """
        (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsArgs:
    def __init__(__self__, *,
                 execution_type: pulumi.Input[str],
                 command: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgs']] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 variables: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgs']] = None):
        """
        :param pulumi.Input[str] execution_type: (Updatable) The action type of the task
        :param pulumi.Input[str] command: (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        :param pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]] credentials: (Updatable) Credentials required for executing the task.
        :param pulumi.Input[str] endpoint: (Updatable) Endpoint to be invoked.
        :param pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgs'] variables: (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        pulumi.set(__self__, "execution_type", execution_type)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The action type of the task
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "execution_type", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgs']]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]]:
        """
        (Updatable) Credentials required for executing the task.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Endpoint to be invoked.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgs']]:
        """
        (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        (Updatable) Bucket Name.
        """
        checksum: pulumi.Input[str]
        """
        (Updatable) md5 checksum of the artifact.
        """
        namespace: pulumi.Input[str]
        """
        (Updatable) Namespace.
        """
        object: pulumi.Input[str]
        """
        (Updatable) Object Name.
        """
        source_type: pulumi.Input[str]
        """
        (Updatable) Content Source type details.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsContentArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 checksum: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 object: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[str] checksum: (Updatable) md5 checksum of the artifact.
        :param pulumi.Input[str] namespace: (Updatable) Namespace.
        :param pulumi.Input[str] object: (Updatable) Object Name.
        :param pulumi.Input[str] source_type: (Updatable) Content Source type details.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        (Updatable) md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict']]]]
        """
        (Updatable) The input variables for the task.
        """
        output_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) The list of output variables.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]] = None,
                 output_variables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]] input_variables: (Updatable) The input variables for the task.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] output_variables: (Updatable) The list of output variables.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if output_variables is not None:
            pulumi.set(__self__, "output_variables", output_variables)

    @property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]:
        """
        (Updatable) The input variables for the task.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @property
    @pulumi.getter(name="outputVariables")
    def output_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of output variables.
        """
        return pulumi.get(self, "output_variables")

    @output_variables.setter
    def output_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "output_variables", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The description of the argument.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the argument.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Input argument Type.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsExecutionDetailsVariablesInputVariableArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: (Updatable) The description of the argument.
        :param pulumi.Input[str] name: (Updatable) The name of the argument.
        :param pulumi.Input[str] type: (Updatable) Input argument Type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description of the argument.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Input argument Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RunbookAssociationsTaskTaskRecordDetailsPropertiesArgsDict(TypedDict):
        num_retries: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The number of retries allowed.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The timeout in seconds for the task.
        """
elif False:
    RunbookAssociationsTaskTaskRecordDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunbookAssociationsTaskTaskRecordDetailsPropertiesArgs:
    def __init__(__self__, *,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_retries: (Updatable) The number of retries allowed.
        :param pulumi.Input[int] timeout_in_seconds: (Updatable) The timeout in seconds for the task.
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of retries allowed.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The timeout in seconds for the task.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class SchedulerDefinitionActionGroupArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        """
        (Updatable) Provide the ID of the resource. Example fleet ID.
        """
        runbook_id: pulumi.Input[str]
        """
        (Updatable) ID of the runbook
        """
        application_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Application Type associated. Only applicable if type is ENVIRONMENT.
        """
        lifecycle_operation: NotRequired[pulumi.Input[str]]
        """
        (Updatable) LifeCycle Operation
        """
        product: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Product associated. Only applicable if type is PRODUCT.
        """
        subjects: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Provide subjects that need to be considered for the schedule.
        """
        target_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Provide the target if schedule is created against the target
        """
        type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) ActionGroup Type associated.
        """
elif False:
    SchedulerDefinitionActionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionActionGroupArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 runbook_id: pulumi.Input[str],
                 application_type: Optional[pulumi.Input[str]] = None,
                 lifecycle_operation: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 subjects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_id: (Updatable) Provide the ID of the resource. Example fleet ID.
        :param pulumi.Input[str] runbook_id: (Updatable) ID of the runbook
        :param pulumi.Input[str] application_type: (Updatable) Application Type associated. Only applicable if type is ENVIRONMENT.
        :param pulumi.Input[str] lifecycle_operation: (Updatable) LifeCycle Operation
        :param pulumi.Input[str] product: (Updatable) Product associated. Only applicable if type is PRODUCT.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subjects: (Updatable) Provide subjects that need to be considered for the schedule.
        :param pulumi.Input[str] target_id: (Updatable) Provide the target if schedule is created against the target
        :param pulumi.Input[str] type: (Updatable) ActionGroup Type associated.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "runbook_id", runbook_id)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if lifecycle_operation is not None:
            pulumi.set(__self__, "lifecycle_operation", lifecycle_operation)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if subjects is not None:
            pulumi.set(__self__, "subjects", subjects)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Provide the ID of the resource. Example fleet ID.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="runbookId")
    def runbook_id(self) -> pulumi.Input[str]:
        """
        (Updatable) ID of the runbook
        """
        return pulumi.get(self, "runbook_id")

    @runbook_id.setter
    def runbook_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "runbook_id", value)

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Application Type associated. Only applicable if type is ENVIRONMENT.
        """
        return pulumi.get(self, "application_type")

    @application_type.setter
    def application_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_type", value)

    @property
    @pulumi.getter(name="lifecycleOperation")
    def lifecycle_operation(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) LifeCycle Operation
        """
        return pulumi.get(self, "lifecycle_operation")

    @lifecycle_operation.setter
    def lifecycle_operation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_operation", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Product associated. Only applicable if type is PRODUCT.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def subjects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Provide subjects that need to be considered for the schedule.
        """
        return pulumi.get(self, "subjects")

    @subjects.setter
    def subjects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subjects", value)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Provide the target if schedule is created against the target
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) ActionGroup Type associated.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SchedulerDefinitionRunBookArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        (Updatable) The ID of the Runbook
        """
        input_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgsDict']]]]
        """
        (Updatable) Input Parameters for the Task
        """
elif False:
    SchedulerDefinitionRunBookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 input_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] id: (Updatable) The ID of the Runbook
        :param pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]] input_parameters: (Updatable) Input Parameters for the Task
        """
        pulumi.set(__self__, "id", id)
        if input_parameters is not None:
            pulumi.set(__self__, "input_parameters", input_parameters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Updatable) The ID of the Runbook
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="inputParameters")
    def input_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]]]:
        """
        (Updatable) Input Parameters for the Task
        """
        return pulumi.get(self, "input_parameters")

    @input_parameters.setter
    def input_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgs']]]]):
        pulumi.set(self, "input_parameters", value)


if not MYPY:
    class SchedulerDefinitionRunBookInputParameterArgsDict(TypedDict):
        step_name: pulumi.Input[str]
        """
        (Updatable) stepName for which the input parameters are provided
        """
        arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgsDict']]]]
        """
        (Updatable) Arguments for the Task
        """
elif False:
    SchedulerDefinitionRunBookInputParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookInputParameterArgs:
    def __init__(__self__, *,
                 step_name: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]]] = None):
        """
        :param pulumi.Input[str] step_name: (Updatable) stepName for which the input parameters are provided
        :param pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]] arguments: (Updatable) Arguments for the Task
        """
        pulumi.set(__self__, "step_name", step_name)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)

    @property
    @pulumi.getter(name="stepName")
    def step_name(self) -> pulumi.Input[str]:
        """
        (Updatable) stepName for which the input parameters are provided
        """
        return pulumi.get(self, "step_name")

    @step_name.setter
    def step_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "step_name", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]]]:
        """
        (Updatable) Arguments for the Task
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchedulerDefinitionRunBookInputParameterArgumentArgs']]]]):
        pulumi.set(self, "arguments", value)


if not MYPY:
    class SchedulerDefinitionRunBookInputParameterArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the output variable
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The task output
        """
elif False:
    SchedulerDefinitionRunBookInputParameterArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionRunBookInputParameterArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the output variable
        :param pulumi.Input[str] value: (Updatable) The task output
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the output variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The task output
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SchedulerDefinitionScheduleArgsDict(TypedDict):
        execution_startdate: pulumi.Input[str]
        """
        (Updatable) Start Date for the schedule. An RFC3339 formatted datetime string
        """
        type: pulumi.Input[str]
        """
        (Updatable) Schedule Type


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Duration if schedule type is Custom
        """
        maintenance_window_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Provide MaintenanceWindowId if Schedule Type is Maintenance Window
        """
        recurrences: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Recurrence rule specification if Schedule Type is Custom and Recurring
        """
elif False:
    SchedulerDefinitionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchedulerDefinitionScheduleArgs:
    def __init__(__self__, *,
                 execution_startdate: pulumi.Input[str],
                 type: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None,
                 maintenance_window_id: Optional[pulumi.Input[str]] = None,
                 recurrences: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] execution_startdate: (Updatable) Start Date for the schedule. An RFC3339 formatted datetime string
        :param pulumi.Input[str] type: (Updatable) Schedule Type
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] duration: (Updatable) Duration if schedule type is Custom
        :param pulumi.Input[str] maintenance_window_id: (Updatable) Provide MaintenanceWindowId if Schedule Type is Maintenance Window
        :param pulumi.Input[str] recurrences: (Updatable) Recurrence rule specification if Schedule Type is Custom and Recurring
        """
        pulumi.set(__self__, "execution_startdate", execution_startdate)
        pulumi.set(__self__, "type", type)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if maintenance_window_id is not None:
            pulumi.set(__self__, "maintenance_window_id", maintenance_window_id)
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)

    @property
    @pulumi.getter(name="executionStartdate")
    def execution_startdate(self) -> pulumi.Input[str]:
        """
        (Updatable) Start Date for the schedule. An RFC3339 formatted datetime string
        """
        return pulumi.get(self, "execution_startdate")

    @execution_startdate.setter
    def execution_startdate(self, value: pulumi.Input[str]):
        pulumi.set(self, "execution_startdate", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Schedule Type


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Duration if schedule type is Custom
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="maintenanceWindowId")
    def maintenance_window_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Provide MaintenanceWindowId if Schedule Type is Maintenance Window
        """
        return pulumi.get(self, "maintenance_window_id")

    @maintenance_window_id.setter
    def maintenance_window_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_id", value)

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Recurrence rule specification if Schedule Type is Custom and Recurring
        """
        return pulumi.get(self, "recurrences")

    @recurrences.setter
    def recurrences(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recurrences", value)


if not MYPY:
    class TaskRecordDetailsArgsDict(TypedDict):
        execution_details: pulumi.Input['TaskRecordDetailsExecutionDetailsArgsDict']
        """
        (Updatable) Execution details.
        """
        os_type: pulumi.Input[str]
        """
        (Updatable) The OS for the task
        """
        scope: pulumi.Input[str]
        """
        (Updatable) The scope of the task
        """
        is_apply_subject_task: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Is this an Apply Subject Task?  Set this to true for a Patch Execution Task which applies patches(subjects) on a target.
        """
        is_discovery_output_task: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Is this a discovery output task?
        """
        platform: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The platform of the runbook.
        """
        properties: NotRequired[pulumi.Input['TaskRecordDetailsPropertiesArgsDict']]
        """
        (Updatable) The properties of the task.
        """
elif False:
    TaskRecordDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsArgs:
    def __init__(__self__, *,
                 execution_details: pulumi.Input['TaskRecordDetailsExecutionDetailsArgs'],
                 os_type: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 is_apply_subject_task: Optional[pulumi.Input[bool]] = None,
                 is_discovery_output_task: Optional[pulumi.Input[bool]] = None,
                 platform: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input['TaskRecordDetailsPropertiesArgs']] = None):
        """
        :param pulumi.Input['TaskRecordDetailsExecutionDetailsArgs'] execution_details: (Updatable) Execution details.
        :param pulumi.Input[str] os_type: (Updatable) The OS for the task
        :param pulumi.Input[str] scope: (Updatable) The scope of the task
        :param pulumi.Input[bool] is_apply_subject_task: (Updatable) Is this an Apply Subject Task?  Set this to true for a Patch Execution Task which applies patches(subjects) on a target.
        :param pulumi.Input[bool] is_discovery_output_task: (Updatable) Is this a discovery output task?
        :param pulumi.Input[str] platform: (Updatable) The platform of the runbook.
        :param pulumi.Input['TaskRecordDetailsPropertiesArgs'] properties: (Updatable) The properties of the task.
        """
        pulumi.set(__self__, "execution_details", execution_details)
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "scope", scope)
        if is_apply_subject_task is not None:
            pulumi.set(__self__, "is_apply_subject_task", is_apply_subject_task)
        if is_discovery_output_task is not None:
            pulumi.set(__self__, "is_discovery_output_task", is_discovery_output_task)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="executionDetails")
    def execution_details(self) -> pulumi.Input['TaskRecordDetailsExecutionDetailsArgs']:
        """
        (Updatable) Execution details.
        """
        return pulumi.get(self, "execution_details")

    @execution_details.setter
    def execution_details(self, value: pulumi.Input['TaskRecordDetailsExecutionDetailsArgs']):
        pulumi.set(self, "execution_details", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The OS for the task
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        (Updatable) The scope of the task
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="isApplySubjectTask")
    def is_apply_subject_task(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Is this an Apply Subject Task?  Set this to true for a Patch Execution Task which applies patches(subjects) on a target.
        """
        return pulumi.get(self, "is_apply_subject_task")

    @is_apply_subject_task.setter
    def is_apply_subject_task(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_apply_subject_task", value)

    @property
    @pulumi.getter(name="isDiscoveryOutputTask")
    def is_discovery_output_task(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Is this a discovery output task?
        """
        return pulumi.get(self, "is_discovery_output_task")

    @is_discovery_output_task.setter
    def is_discovery_output_task(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_discovery_output_task", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The platform of the runbook.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['TaskRecordDetailsPropertiesArgs']]:
        """
        (Updatable) The properties of the task.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['TaskRecordDetailsPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsArgsDict(TypedDict):
        execution_type: pulumi.Input[str]
        """
        (Updatable) The action type of the task
        """
        command: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        content: NotRequired[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgsDict']]
        """
        (Updatable) Content Source details.
        """
        credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgsDict']]]]
        """
        (Updatable) Credentials required for executing the task.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Endpoint to be invoked.
        """
        variables: NotRequired[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgsDict']]
        """
        (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
elif False:
    TaskRecordDetailsExecutionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsArgs:
    def __init__(__self__, *,
                 execution_type: pulumi.Input[str],
                 command: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs']] = None,
                 credentials: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 variables: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs']] = None):
        """
        :param pulumi.Input[str] execution_type: (Updatable) The action type of the task
        :param pulumi.Input[str] command: (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        :param pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs'] content: (Updatable) Content Source details.
        :param pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]] credentials: (Updatable) Credentials required for executing the task.
        :param pulumi.Input[str] endpoint: (Updatable) Endpoint to be invoked.
        :param pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs'] variables: (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        pulumi.set(__self__, "execution_type", execution_type)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The action type of the task
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "execution_type", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional command to execute the content. You can provide any commands/arguments that can't be part of the script.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs']]:
        """
        (Updatable) Content Source details.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsContentArgs']]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]]]:
        """
        (Updatable) Credentials required for executing the task.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsCredentialArgs']]]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Endpoint to be invoked.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs']]:
        """
        (Updatable) The variable of the task. At least one of the dynamicArguments or output needs to be provided.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsContentArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        (Updatable) Bucket Name.
        """
        checksum: pulumi.Input[str]
        """
        (Updatable) md5 checksum of the artifact.
        """
        namespace: pulumi.Input[str]
        """
        (Updatable) Namespace.
        """
        object: pulumi.Input[str]
        """
        (Updatable) Object Name.
        """
        source_type: pulumi.Input[str]
        """
        (Updatable) Content Source type details.
        """
elif False:
    TaskRecordDetailsExecutionDetailsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsContentArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 checksum: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 object: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: (Updatable) Bucket Name.
        :param pulumi.Input[str] checksum: (Updatable) md5 checksum of the artifact.
        :param pulumi.Input[str] namespace: (Updatable) Namespace.
        :param pulumi.Input[str] object: (Updatable) Object Name.
        :param pulumi.Input[str] source_type: (Updatable) Content Source type details.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        (Updatable) Bucket Name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        (Updatable) md5 checksum of the artifact.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        (Updatable) Namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        (Updatable) Object Name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Content Source type details.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsCredentialArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the resource.
        """
elif False:
    TaskRecordDetailsExecutionDetailsCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsCredentialArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        :param pulumi.Input[str] id: (Updatable) The OCID of the resource.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsVariablesArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict']]]]
        """
        (Updatable) The input variables for the task.
        """
        output_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) The list of output variables.
        """
elif False:
    TaskRecordDetailsExecutionDetailsVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsVariablesArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]] = None,
                 output_variables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]] input_variables: (Updatable) The input variables for the task.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] output_variables: (Updatable) The list of output variables.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if output_variables is not None:
            pulumi.set(__self__, "output_variables", output_variables)

    @property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]:
        """
        (Updatable) The input variables for the task.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @property
    @pulumi.getter(name="outputVariables")
    def output_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of output variables.
        """
        return pulumi.get(self, "output_variables")

    @output_variables.setter
    def output_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "output_variables", value)


if not MYPY:
    class TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The description of the argument.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the argument.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Input argument Type.
        """
elif False:
    TaskRecordDetailsExecutionDetailsVariablesInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsExecutionDetailsVariablesInputVariableArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: (Updatable) The description of the argument.
        :param pulumi.Input[str] name: (Updatable) The name of the argument.
        :param pulumi.Input[str] type: (Updatable) Input argument Type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description of the argument.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Input argument Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TaskRecordDetailsPropertiesArgsDict(TypedDict):
        num_retries: pulumi.Input[int]
        """
        (Updatable) The number of retries allowed.
        """
        timeout_in_seconds: pulumi.Input[int]
        """
        (Updatable) The timeout in seconds for the task.
        """
elif False:
    TaskRecordDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskRecordDetailsPropertiesArgs:
    def __init__(__self__, *,
                 num_retries: pulumi.Input[int],
                 timeout_in_seconds: pulumi.Input[int]):
        """
        :param pulumi.Input[int] num_retries: (Updatable) The number of retries allowed.
        :param pulumi.Input[int] timeout_in_seconds: (Updatable) The timeout in seconds for the task.
        """
        pulumi.set(__self__, "num_retries", num_retries)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of retries allowed.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> pulumi.Input[int]:
        """
        (Updatable) The timeout in seconds for the task.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class GetAnnouncementsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAnnouncementsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAnnouncementsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCompliancePoliciesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetCompliancePoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCompliancePoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCompliancePolicyRulesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetCompliancePolicyRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCompliancePolicyRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetComplianceRecordCountsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetComplianceRecordCountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComplianceRecordCountsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetComplianceRecordsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetComplianceRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComplianceRecordsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetCredentialsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the variable.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFleetCredentialsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetCredentialsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetProductsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFleetProductsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetProductsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetPropertiesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFleetPropertiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetPropertiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetResourcesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFleetResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetResourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetTargetsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFleetTargetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFleetsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the variable.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFleetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFleetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetInventoryResourcesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetInventoryResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInventoryResourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaintenanceWindowsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetMaintenanceWindowsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaintenanceWindowsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedEntityCountsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetManagedEntityCountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedEntityCountsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetOnboardingPoliciesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetOnboardingPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOnboardingPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetOnboardingsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetOnboardingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOnboardingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPatchesFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the entire name given.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPlatformConfigurationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetPlatformConfigurationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPlatformConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPropertiesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        """
        Values of the property (must be a single value if selection = 'SINGLE_CHOICE').
        """
        regex: NotRequired[bool]
elif False:
    GetPropertiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param Sequence[str] values: Values of the property (must be a single value if selection = 'SINGLE_CHOICE').
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Values of the property (must be a single value if selection = 'SINGLE_CHOICE').
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRunbooksFilterArgsDict(TypedDict):
        name: str
        """
        The name of the task
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetRunbooksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRunbooksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the task
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the task
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerDefinitionScheduledFleetsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSchedulerDefinitionScheduledFleetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerDefinitionScheduledFleetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerDefinitionsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the output variable
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSchedulerDefinitionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerDefinitionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the output variable
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the output variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerJobCountsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSchedulerJobCountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerJobCountsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerJobJobActivityResourcesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSchedulerJobJobActivityResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerJobJobActivityResourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulerJobJobActivityStepsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSchedulerJobJobActivityStepsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulerJobJobActivityStepsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTaskRecordsFilterArgsDict(TypedDict):
        name: str
        """
        The name of the argument.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetTaskRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskRecordsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the argument.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


