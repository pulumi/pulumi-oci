# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FsuCollectionActiveFsuCycleArgs',
    'FsuCollectionActiveFsuCycleArgsDict',
    'FsuCollectionFleetDiscoveryArgs',
    'FsuCollectionFleetDiscoveryArgsDict',
    'FsuCollectionFleetDiscoveryFilterArgs',
    'FsuCollectionFleetDiscoveryFilterArgsDict',
    'FsuCollectionFleetDiscoveryFilterTagArgs',
    'FsuCollectionFleetDiscoveryFilterTagArgsDict',
    'FsuCycleApplyActionScheduleArgs',
    'FsuCycleApplyActionScheduleArgsDict',
    'FsuCycleBatchingStrategyArgs',
    'FsuCycleBatchingStrategyArgsDict',
    'FsuCycleDiagnosticsCollectionArgs',
    'FsuCycleDiagnosticsCollectionArgsDict',
    'FsuCycleGoalVersionDetailsArgs',
    'FsuCycleGoalVersionDetailsArgsDict',
    'FsuCycleNextActionToExecuteArgs',
    'FsuCycleNextActionToExecuteArgsDict',
    'FsuCycleStageActionScheduleArgs',
    'FsuCycleStageActionScheduleArgsDict',
    'GetFsuCollectionsFilterArgs',
    'GetFsuCollectionsFilterArgsDict',
    'GetFsuCyclesFilterArgs',
    'GetFsuCyclesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class FsuCollectionActiveFsuCycleArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Exadata Fleet Update Collection Identifier.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        OCID identifier for the Exadata Fleet Update Collection.
        """
elif False:
    FsuCollectionActiveFsuCycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCollectionActiveFsuCycleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Exadata Fleet Update Collection Identifier.
        :param pulumi.Input[str] id: OCID identifier for the Exadata Fleet Update Collection.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Exadata Fleet Update Collection Identifier.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID identifier for the Exadata Fleet Update Collection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FsuCollectionFleetDiscoveryArgsDict(TypedDict):
        strategy: pulumi.Input[str]
        """
        Possible fleet discovery strategies.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterArgsDict']]]]
        """
        Filters to perform the target discovery.
        """
        fsu_discovery_id: NotRequired[pulumi.Input[str]]
        """
        OCIDs of Fleet Software Update Discovery.
        """
        query: NotRequired[pulumi.Input[str]]
        """
        Oracle Cloud Infrastructure Search Service query string.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        OCIDs of target resources to include. For EXACC service type Collections only VMClusters are allowed. For EXACS service type Collections only CloudVMClusters are allowed.
        """
elif False:
    FsuCollectionFleetDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCollectionFleetDiscoveryArgs:
    def __init__(__self__, *,
                 strategy: pulumi.Input[str],
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterArgs']]]] = None,
                 fsu_discovery_id: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] strategy: Possible fleet discovery strategies.
        :param pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterArgs']]] filters: Filters to perform the target discovery.
        :param pulumi.Input[str] fsu_discovery_id: OCIDs of Fleet Software Update Discovery.
        :param pulumi.Input[str] query: Oracle Cloud Infrastructure Search Service query string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: OCIDs of target resources to include. For EXACC service type Collections only VMClusters are allowed. For EXACS service type Collections only CloudVMClusters are allowed.
        """
        pulumi.set(__self__, "strategy", strategy)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if fsu_discovery_id is not None:
            pulumi.set(__self__, "fsu_discovery_id", fsu_discovery_id)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def strategy(self) -> pulumi.Input[str]:
        """
        Possible fleet discovery strategies.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterArgs']]]]:
        """
        Filters to perform the target discovery.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter(name="fsuDiscoveryId")
    def fsu_discovery_id(self) -> Optional[pulumi.Input[str]]:
        """
        OCIDs of Fleet Software Update Discovery.
        """
        return pulumi.get(self, "fsu_discovery_id")

    @fsu_discovery_id.setter
    def fsu_discovery_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fsu_discovery_id", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Cloud Infrastructure Search Service query string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        OCIDs of target resources to include. For EXACC service type Collections only VMClusters are allowed. For EXACS service type Collections only CloudVMClusters are allowed.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class FsuCollectionFleetDiscoveryFilterArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of filters supported for Database targets discovery.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        Type of resource to match in the discovery.
        """
        identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Related resource Ids to include in the discovery.  All must match the specified entityType.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        INCLUDE or EXCLUDE the filter results in the discovery for DB targets. Supported for 'FSUCOLLECTION' RESOURCE_ID filter only.
        """
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Database unique names to include in the discovery.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Type of join for each element in this filter.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterTagArgsDict']]]]
        """
        Freeform tags to include in the discovery.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Versions strings to include in the discovery.
        """
elif False:
    FsuCollectionFleetDiscoveryFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCollectionFleetDiscoveryFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 entity_type: Optional[pulumi.Input[str]] = None,
                 identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterTagArgs']]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Type of filters supported for Database targets discovery.
        :param pulumi.Input[str] entity_type: Type of resource to match in the discovery.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identifiers: Related resource Ids to include in the discovery.  All must match the specified entityType.
        :param pulumi.Input[str] mode: INCLUDE or EXCLUDE the filter results in the discovery for DB targets. Supported for 'FSUCOLLECTION' RESOURCE_ID filter only.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: List of Database unique names to include in the discovery.
        :param pulumi.Input[str] operator: Type of join for each element in this filter.
        :param pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterTagArgs']]] tags: Freeform tags to include in the discovery.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] versions: List of Versions strings to include in the discovery.
        """
        pulumi.set(__self__, "type", type)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of filters supported for Database targets discovery.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource to match in the discovery.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Related resource Ids to include in the discovery.  All must match the specified entityType.
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identifiers", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        INCLUDE or EXCLUDE the filter results in the discovery for DB targets. Supported for 'FSUCOLLECTION' RESOURCE_ID filter only.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Database unique names to include in the discovery.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of join for each element in this filter.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterTagArgs']]]]:
        """
        Freeform tags to include in the discovery.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FsuCollectionFleetDiscoveryFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Versions strings to include in the discovery.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class FsuCollectionFleetDiscoveryFilterTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Freeform tag key.
        """
        value: pulumi.Input[str]
        """
        Freeform tag value.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Defined tag namespace.
        """
elif False:
    FsuCollectionFleetDiscoveryFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCollectionFleetDiscoveryFilterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Freeform tag key.
        :param pulumi.Input[str] value: Freeform tag value.
        :param pulumi.Input[str] namespace: Defined tag namespace.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Freeform tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Freeform tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Defined tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class FsuCycleApplyActionScheduleArgsDict(TypedDict):
        time_to_start: pulumi.Input[str]
        """
        The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        type: pulumi.Input[str]
        """
        Type of scheduling strategy to use for Fleet Patching Update Action execution.
        """
elif False:
    FsuCycleApplyActionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCycleApplyActionScheduleArgs:
    def __init__(__self__, *,
                 time_to_start: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] time_to_start: The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        :param pulumi.Input[str] type: Type of scheduling strategy to use for Fleet Patching Update Action execution.
        """
        pulumi.set(__self__, "time_to_start", time_to_start)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="timeToStart")
    def time_to_start(self) -> pulumi.Input[str]:
        """
        The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        return pulumi.get(self, "time_to_start")

    @time_to_start.setter
    def time_to_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_to_start", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of scheduling strategy to use for Fleet Patching Update Action execution.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FsuCycleBatchingStrategyArgsDict(TypedDict):
        is_force_rolling: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) True to force rolling patching.
        """
        is_wait_for_batch_resume: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) True to wait for customer to resume the Apply Action once the first half is done. False to automatically patch the second half.
        """
        percentage: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Percentage of availability in the service during the Patch operation.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Supported batching strategies.
        """
elif False:
    FsuCycleBatchingStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCycleBatchingStrategyArgs:
    def __init__(__self__, *,
                 is_force_rolling: Optional[pulumi.Input[bool]] = None,
                 is_wait_for_batch_resume: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_force_rolling: (Updatable) True to force rolling patching.
        :param pulumi.Input[bool] is_wait_for_batch_resume: (Updatable) True to wait for customer to resume the Apply Action once the first half is done. False to automatically patch the second half.
        :param pulumi.Input[int] percentage: (Updatable) Percentage of availability in the service during the Patch operation.
        :param pulumi.Input[str] type: (Updatable) Supported batching strategies.
        """
        if is_force_rolling is not None:
            pulumi.set(__self__, "is_force_rolling", is_force_rolling)
        if is_wait_for_batch_resume is not None:
            pulumi.set(__self__, "is_wait_for_batch_resume", is_wait_for_batch_resume)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="isForceRolling")
    def is_force_rolling(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) True to force rolling patching.
        """
        return pulumi.get(self, "is_force_rolling")

    @is_force_rolling.setter
    def is_force_rolling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_force_rolling", value)

    @property
    @pulumi.getter(name="isWaitForBatchResume")
    def is_wait_for_batch_resume(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) True to wait for customer to resume the Apply Action once the first half is done. False to automatically patch the second half.
        """
        return pulumi.get(self, "is_wait_for_batch_resume")

    @is_wait_for_batch_resume.setter
    def is_wait_for_batch_resume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_wait_for_batch_resume", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Percentage of availability in the service during the Patch operation.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Supported batching strategies.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FsuCycleDiagnosticsCollectionArgsDict(TypedDict):
        log_collection_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Enable incident logs and trace collection.  Allow Oracle to collect incident logs and traces to enable fault diagnosis and issue resolution according to the selected mode.
        """
elif False:
    FsuCycleDiagnosticsCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCycleDiagnosticsCollectionArgs:
    def __init__(__self__, *,
                 log_collection_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] log_collection_mode: (Updatable) Enable incident logs and trace collection.  Allow Oracle to collect incident logs and traces to enable fault diagnosis and issue resolution according to the selected mode.
        """
        if log_collection_mode is not None:
            pulumi.set(__self__, "log_collection_mode", log_collection_mode)

    @property
    @pulumi.getter(name="logCollectionMode")
    def log_collection_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Enable incident logs and trace collection.  Allow Oracle to collect incident logs and traces to enable fault diagnosis and issue resolution according to the selected mode.
        """
        return pulumi.get(self, "log_collection_mode")

    @log_collection_mode.setter
    def log_collection_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_collection_mode", value)


if not MYPY:
    class FsuCycleGoalVersionDetailsArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        (Updatable) Type of goal target version specified
        """
        home_policy: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Goal home policy to use when Staging the Goal Version during patching. CREATE_NEW: Create a new DBHome (for Database Collections) for the specified image or version. USE_EXISTING: All database targets in the same VMCluster or CloudVmCluster will be moved to a shared database home.  If an existing home for the selected image or version is not found in the VM Cluster for a target database, then a new home will be created.  If more than one existing home for the selected image is found, then the home with the least number of databases will be used.  If multiple homes have the least number of databases, then a home will be selected at random.
        """
        new_home_prefix: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Prefix name used for new DB home resources created as part of the Stage Action. Format: <specified_prefix>_<timestamp> If not specified, a default Oracle Cloud Infrastructure DB home resource will be generated for the new DB home resources created.
        """
        software_image_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Target database software image OCID.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Target DB or GI version string for the Exadata Fleet Update Cycle.
        """
elif False:
    FsuCycleGoalVersionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCycleGoalVersionDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 home_policy: Optional[pulumi.Input[str]] = None,
                 new_home_prefix: Optional[pulumi.Input[str]] = None,
                 software_image_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of goal target version specified
        :param pulumi.Input[str] home_policy: (Updatable) Goal home policy to use when Staging the Goal Version during patching. CREATE_NEW: Create a new DBHome (for Database Collections) for the specified image or version. USE_EXISTING: All database targets in the same VMCluster or CloudVmCluster will be moved to a shared database home.  If an existing home for the selected image or version is not found in the VM Cluster for a target database, then a new home will be created.  If more than one existing home for the selected image is found, then the home with the least number of databases will be used.  If multiple homes have the least number of databases, then a home will be selected at random.
        :param pulumi.Input[str] new_home_prefix: (Updatable) Prefix name used for new DB home resources created as part of the Stage Action. Format: <specified_prefix>_<timestamp> If not specified, a default Oracle Cloud Infrastructure DB home resource will be generated for the new DB home resources created.
        :param pulumi.Input[str] software_image_id: (Updatable) Target database software image OCID.
        :param pulumi.Input[str] version: (Updatable) Target DB or GI version string for the Exadata Fleet Update Cycle.
        """
        pulumi.set(__self__, "type", type)
        if home_policy is not None:
            pulumi.set(__self__, "home_policy", home_policy)
        if new_home_prefix is not None:
            pulumi.set(__self__, "new_home_prefix", new_home_prefix)
        if software_image_id is not None:
            pulumi.set(__self__, "software_image_id", software_image_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of goal target version specified
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="homePolicy")
    def home_policy(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Goal home policy to use when Staging the Goal Version during patching. CREATE_NEW: Create a new DBHome (for Database Collections) for the specified image or version. USE_EXISTING: All database targets in the same VMCluster or CloudVmCluster will be moved to a shared database home.  If an existing home for the selected image or version is not found in the VM Cluster for a target database, then a new home will be created.  If more than one existing home for the selected image is found, then the home with the least number of databases will be used.  If multiple homes have the least number of databases, then a home will be selected at random.
        """
        return pulumi.get(self, "home_policy")

    @home_policy.setter
    def home_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "home_policy", value)

    @property
    @pulumi.getter(name="newHomePrefix")
    def new_home_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Prefix name used for new DB home resources created as part of the Stage Action. Format: <specified_prefix>_<timestamp> If not specified, a default Oracle Cloud Infrastructure DB home resource will be generated for the new DB home resources created.
        """
        return pulumi.get(self, "new_home_prefix")

    @new_home_prefix.setter
    def new_home_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_home_prefix", value)

    @property
    @pulumi.getter(name="softwareImageId")
    def software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Target database software image OCID.
        """
        return pulumi.get(self, "software_image_id")

    @software_image_id.setter
    def software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_image_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Target DB or GI version string for the Exadata Fleet Update Cycle.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FsuCycleNextActionToExecuteArgsDict(TypedDict):
        time_to_start: NotRequired[pulumi.Input[str]]
        """
        The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Type of Exadata Fleet Update Cycle. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    FsuCycleNextActionToExecuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCycleNextActionToExecuteArgs:
    def __init__(__self__, *,
                 time_to_start: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_to_start: The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        :param pulumi.Input[str] type: (Updatable) Type of Exadata Fleet Update Cycle. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if time_to_start is not None:
            pulumi.set(__self__, "time_to_start", time_to_start)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="timeToStart")
    def time_to_start(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        return pulumi.get(self, "time_to_start")

    @time_to_start.setter
    def time_to_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_to_start", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of Exadata Fleet Update Cycle. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FsuCycleStageActionScheduleArgsDict(TypedDict):
        time_to_start: pulumi.Input[str]
        """
        The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        type: pulumi.Input[str]
        """
        Type of scheduling strategy to use for Fleet Patching Update Action execution.
        """
elif False:
    FsuCycleStageActionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FsuCycleStageActionScheduleArgs:
    def __init__(__self__, *,
                 time_to_start: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] time_to_start: The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        :param pulumi.Input[str] type: Type of scheduling strategy to use for Fleet Patching Update Action execution.
        """
        pulumi.set(__self__, "time_to_start", time_to_start)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="timeToStart")
    def time_to_start(self) -> pulumi.Input[str]:
        """
        The date and time the Exadata Fleet Update Action is expected to start. [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        return pulumi.get(self, "time_to_start")

    @time_to_start.setter
    def time_to_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_to_start", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of scheduling strategy to use for Fleet Patching Update Action execution.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetFsuCollectionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFsuCollectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFsuCollectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFsuCyclesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFsuCyclesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFsuCyclesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


