# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplicationImagePolicyConfigArgs',
    'ApplicationImagePolicyConfigArgsDict',
    'ApplicationImagePolicyConfigKeyDetailArgs',
    'ApplicationImagePolicyConfigKeyDetailArgsDict',
    'ApplicationTraceConfigArgs',
    'ApplicationTraceConfigArgsDict',
    'FunctionProvisionedConcurrencyConfigArgs',
    'FunctionProvisionedConcurrencyConfigArgsDict',
    'FunctionSourceDetailsArgs',
    'FunctionSourceDetailsArgsDict',
    'FunctionTraceConfigArgs',
    'FunctionTraceConfigArgsDict',
    'GetApplicationsFilterArgs',
    'GetApplicationsFilterArgsDict',
    'GetFunctionsFilterArgs',
    'GetFunctionsFilterArgsDict',
    'GetFusionEnvironmentAdminUsersFilterArgs',
    'GetFusionEnvironmentAdminUsersFilterArgsDict',
    'GetFusionEnvironmentDataMaskingActivitiesFilterArgs',
    'GetFusionEnvironmentDataMaskingActivitiesFilterArgsDict',
    'GetFusionEnvironmentFamiliesFilterArgs',
    'GetFusionEnvironmentFamiliesFilterArgsDict',
    'GetFusionEnvironmentRefreshActivitiesFilterArgs',
    'GetFusionEnvironmentRefreshActivitiesFilterArgsDict',
    'GetFusionEnvironmentScheduledActivitiesFilterArgs',
    'GetFusionEnvironmentScheduledActivitiesFilterArgsDict',
    'GetFusionEnvironmentServiceAttachmentsFilterArgs',
    'GetFusionEnvironmentServiceAttachmentsFilterArgsDict',
    'GetFusionEnvironmentTimeAvailableForRefreshsFilterArgs',
    'GetFusionEnvironmentTimeAvailableForRefreshsFilterArgsDict',
    'GetFusionEnvironmentsFilterArgs',
    'GetFusionEnvironmentsFilterArgsDict',
    'GetPbfListingTriggersFilterArgs',
    'GetPbfListingTriggersFilterArgsDict',
    'GetPbfListingVersionsFilterArgs',
    'GetPbfListingVersionsFilterArgsDict',
    'GetPbfListingsFilterArgs',
    'GetPbfListingsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationImagePolicyConfigArgsDict(TypedDict):
        is_policy_enabled: pulumi.Input[bool]
        """
        (Updatable) Define if image signature verification policy is enabled for the application.
        """
        key_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationImagePolicyConfigKeyDetailArgsDict']]]]
        """
        (Updatable) A list of KMS key details.
        """
elif False:
    ApplicationImagePolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationImagePolicyConfigArgs:
    def __init__(__self__, *,
                 is_policy_enabled: pulumi.Input[bool],
                 key_details: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationImagePolicyConfigKeyDetailArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_policy_enabled: (Updatable) Define if image signature verification policy is enabled for the application.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationImagePolicyConfigKeyDetailArgs']]] key_details: (Updatable) A list of KMS key details.
        """
        pulumi.set(__self__, "is_policy_enabled", is_policy_enabled)
        if key_details is not None:
            pulumi.set(__self__, "key_details", key_details)

    @property
    @pulumi.getter(name="isPolicyEnabled")
    def is_policy_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Define if image signature verification policy is enabled for the application.
        """
        return pulumi.get(self, "is_policy_enabled")

    @is_policy_enabled.setter
    def is_policy_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_policy_enabled", value)

    @property
    @pulumi.getter(name="keyDetails")
    def key_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationImagePolicyConfigKeyDetailArgs']]]]:
        """
        (Updatable) A list of KMS key details.
        """
        return pulumi.get(self, "key_details")

    @key_details.setter
    def key_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationImagePolicyConfigKeyDetailArgs']]]]):
        pulumi.set(self, "key_details", value)


if not MYPY:
    class ApplicationImagePolicyConfigKeyDetailArgsDict(TypedDict):
        kms_key_id: pulumi.Input[str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s of the KMS key that will be used to verify the image signature.
        """
elif False:
    ApplicationImagePolicyConfigKeyDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationImagePolicyConfigKeyDetailArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_key_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s of the KMS key that will be used to verify the image signature.
        """
        pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s of the KMS key that will be used to verify the image signature.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ApplicationTraceConfigArgsDict(TypedDict):
        domain_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the collector (e.g. an APM Domain) trace events will be sent to.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Define if tracing is enabled for the resource. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ApplicationTraceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationTraceConfigArgs:
    def __init__(__self__, *,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] domain_id: (Updatable) The OCID of the collector (e.g. an APM Domain) trace events will be sent to.
        :param pulumi.Input[bool] is_enabled: (Updatable) Define if tracing is enabled for the resource. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the collector (e.g. an APM Domain) trace events will be sent to.
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Define if tracing is enabled for the resource. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class FunctionProvisionedConcurrencyConfigArgsDict(TypedDict):
        strategy: pulumi.Input[str]
        """
        (Updatable) The strategy for provisioned concurrency to be used.
        """
        count: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Configuration specifying a constant amount of provisioned concurrency.
        """
elif False:
    FunctionProvisionedConcurrencyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionProvisionedConcurrencyConfigArgs:
    def __init__(__self__, *,
                 strategy: pulumi.Input[str],
                 count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] strategy: (Updatable) The strategy for provisioned concurrency to be used.
        :param pulumi.Input[int] count: (Updatable) Configuration specifying a constant amount of provisioned concurrency.
        """
        pulumi.set(__self__, "strategy", strategy)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def strategy(self) -> pulumi.Input[str]:
        """
        (Updatable) The strategy for provisioned concurrency to be used.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Configuration specifying a constant amount of provisioned concurrency.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class FunctionSourceDetailsArgsDict(TypedDict):
        pbf_listing_id: pulumi.Input[str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the PbfListing this function is sourced from.
        """
        source_type: pulumi.Input[str]
        """
        Type of the Function Source. Possible values: PRE_BUILT_FUNCTIONS.
        """
elif False:
    FunctionSourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSourceDetailsArgs:
    def __init__(__self__, *,
                 pbf_listing_id: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] pbf_listing_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the PbfListing this function is sourced from.
        :param pulumi.Input[str] source_type: Type of the Function Source. Possible values: PRE_BUILT_FUNCTIONS.
        """
        pulumi.set(__self__, "pbf_listing_id", pbf_listing_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="pbfListingId")
    def pbf_listing_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the PbfListing this function is sourced from.
        """
        return pulumi.get(self, "pbf_listing_id")

    @pbf_listing_id.setter
    def pbf_listing_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pbf_listing_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        Type of the Function Source. Possible values: PRE_BUILT_FUNCTIONS.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class FunctionTraceConfigArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Define if tracing is enabled for the resource. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    FunctionTraceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTraceConfigArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Define if tracing is enabled for the resource. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Define if tracing is enabled for the resource. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class GetApplicationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetApplicationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApplicationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFunctionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFunctionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentAdminUsersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentAdminUsersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentAdminUsersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentDataMaskingActivitiesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentDataMaskingActivitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentDataMaskingActivitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentFamiliesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentFamiliesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentFamiliesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentRefreshActivitiesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentRefreshActivitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentRefreshActivitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentScheduledActivitiesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentScheduledActivitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentScheduledActivitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentServiceAttachmentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentServiceAttachmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentServiceAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentTimeAvailableForRefreshsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentTimeAvailableForRefreshsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentTimeAvailableForRefreshsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFusionEnvironmentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFusionEnvironmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFusionEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPbfListingTriggersFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the service trigger source of a PBF.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetPbfListingTriggersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPbfListingTriggersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the service trigger source of a PBF.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the service trigger source of a PBF.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPbfListingVersionsFilterArgsDict(TypedDict):
        name: str
        """
        Matches a PbfListingVersion based on a provided semantic version name for a PbfListingVersion.  Each PbfListingVersion name is unique with respect to its associated PbfListing.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetPbfListingVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPbfListingVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Matches a PbfListingVersion based on a provided semantic version name for a PbfListingVersion.  Each PbfListingVersion name is unique with respect to its associated PbfListing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Matches a PbfListingVersion based on a provided semantic version name for a PbfListingVersion.  Each PbfListingVersion name is unique with respect to its associated PbfListing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPbfListingsFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the entire PBF name given.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetPbfListingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPbfListingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire PBF name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire PBF name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


