# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FusionEnvironmentAdminUserItemArgs',
    'FusionEnvironmentAdminUserItemArgsDict',
    'FusionEnvironmentCreateFusionEnvironmentAdminUserDetailsArgs',
    'FusionEnvironmentCreateFusionEnvironmentAdminUserDetailsArgsDict',
    'FusionEnvironmentFamilyFamilyMaintenancePolicyArgs',
    'FusionEnvironmentFamilyFamilyMaintenancePolicyArgsDict',
    'FusionEnvironmentKmsKeyInfoArgs',
    'FusionEnvironmentKmsKeyInfoArgsDict',
    'FusionEnvironmentMaintenancePolicyArgs',
    'FusionEnvironmentMaintenancePolicyArgsDict',
    'FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgs',
    'FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgsDict',
    'FusionEnvironmentRefreshArgs',
    'FusionEnvironmentRefreshArgsDict',
    'FusionEnvironmentRefreshActivityRefreshIssueDetailsListArgs',
    'FusionEnvironmentRefreshActivityRefreshIssueDetailsListArgsDict',
    'FusionEnvironmentRuleArgs',
    'FusionEnvironmentRuleArgsDict',
    'FusionEnvironmentRuleConditionArgs',
    'FusionEnvironmentRuleConditionArgsDict',
]

MYPY = False

if not MYPY:
    class FusionEnvironmentAdminUserItemArgsDict(TypedDict):
        email_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email address for the administrator.
        """
        first_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The administrator's first name.
        """
        last_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The administrator's last name.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username for the administrator.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    FusionEnvironmentAdminUserItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentAdminUserItemArgs:
    def __init__(__self__, *,
                 email_address: Optional[pulumi.Input[_builtins.str]] = None,
                 first_name: Optional[pulumi.Input[_builtins.str]] = None,
                 last_name: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email_address: The email address for the administrator.
        :param pulumi.Input[_builtins.str] first_name: The administrator's first name.
        :param pulumi.Input[_builtins.str] last_name: The administrator's last name.
        :param pulumi.Input[_builtins.str] username: The username for the administrator.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email address for the administrator.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The administrator's first name.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The administrator's last name.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username for the administrator.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class FusionEnvironmentCreateFusionEnvironmentAdminUserDetailsArgsDict(TypedDict):
        email_address: pulumi.Input[_builtins.str]
        """
        The email address for the administrator.
        """
        first_name: pulumi.Input[_builtins.str]
        """
        The administrator's first name.
        """
        last_name: pulumi.Input[_builtins.str]
        """
        The administrator's last name.
        """
        username: pulumi.Input[_builtins.str]
        """
        The username for the administrator.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password for the administrator.
        """
elif False:
    FusionEnvironmentCreateFusionEnvironmentAdminUserDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentCreateFusionEnvironmentAdminUserDetailsArgs:
    def __init__(__self__, *,
                 email_address: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email_address: The email address for the administrator.
        :param pulumi.Input[_builtins.str] first_name: The administrator's first name.
        :param pulumi.Input[_builtins.str] last_name: The administrator's last name.
        :param pulumi.Input[_builtins.str] username: The username for the administrator.
        :param pulumi.Input[_builtins.str] password: The password for the administrator.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> pulumi.Input[_builtins.str]:
        """
        The email address for the administrator.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        The administrator's first name.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        The administrator's last name.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        The username for the administrator.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password for the administrator.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class FusionEnvironmentFamilyFamilyMaintenancePolicyArgsDict(TypedDict):
        concurrent_maintenance: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Option to upgrade both production and non-production environments at the same time. When set to PROD both types of environnments are upgraded on the production schedule. When set to NON_PROD both types of environments are upgraded on the non-production schedule.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) When True, monthly patching is enabled for the environment family.
        """
        quarterly_upgrade_begin_times: NotRequired[pulumi.Input[_builtins.str]]
        """
        The quarterly maintenance month group schedule of the Fusion environment family.
        """
elif False:
    FusionEnvironmentFamilyFamilyMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentFamilyFamilyMaintenancePolicyArgs:
    def __init__(__self__, *,
                 concurrent_maintenance: Optional[pulumi.Input[_builtins.str]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 quarterly_upgrade_begin_times: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] concurrent_maintenance: (Updatable) Option to upgrade both production and non-production environments at the same time. When set to PROD both types of environnments are upgraded on the production schedule. When set to NON_PROD both types of environments are upgraded on the non-production schedule.
        :param pulumi.Input[_builtins.bool] is_monthly_patching_enabled: (Updatable) When True, monthly patching is enabled for the environment family.
        :param pulumi.Input[_builtins.str] quarterly_upgrade_begin_times: The quarterly maintenance month group schedule of the Fusion environment family.
        """
        if concurrent_maintenance is not None:
            pulumi.set(__self__, "concurrent_maintenance", concurrent_maintenance)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if quarterly_upgrade_begin_times is not None:
            pulumi.set(__self__, "quarterly_upgrade_begin_times", quarterly_upgrade_begin_times)

    @_builtins.property
    @pulumi.getter(name="concurrentMaintenance")
    def concurrent_maintenance(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Option to upgrade both production and non-production environments at the same time. When set to PROD both types of environnments are upgraded on the production schedule. When set to NON_PROD both types of environments are upgraded on the non-production schedule.
        """
        return pulumi.get(self, "concurrent_maintenance")

    @concurrent_maintenance.setter
    def concurrent_maintenance(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "concurrent_maintenance", value)

    @_builtins.property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) When True, monthly patching is enabled for the environment family.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @_builtins.property
    @pulumi.getter(name="quarterlyUpgradeBeginTimes")
    def quarterly_upgrade_begin_times(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The quarterly maintenance month group schedule of the Fusion environment family.
        """
        return pulumi.get(self, "quarterly_upgrade_begin_times")

    @quarterly_upgrade_begin_times.setter
    def quarterly_upgrade_begin_times(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quarterly_upgrade_begin_times", value)


if not MYPY:
    class FusionEnvironmentKmsKeyInfoArgsDict(TypedDict):
        active_key_id: NotRequired[pulumi.Input[_builtins.str]]
        active_key_version: NotRequired[pulumi.Input[_builtins.str]]
        current_key_lifecycle_state: NotRequired[pulumi.Input[_builtins.str]]
        scheduled_key_id: NotRequired[pulumi.Input[_builtins.str]]
        scheduled_key_status: NotRequired[pulumi.Input[_builtins.str]]
        scheduled_key_version: NotRequired[pulumi.Input[_builtins.str]]
        scheduled_lifecycle_state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FusionEnvironmentKmsKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentKmsKeyInfoArgs:
    def __init__(__self__, *,
                 active_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 active_key_version: Optional[pulumi.Input[_builtins.str]] = None,
                 current_key_lifecycle_state: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_key_status: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_key_version: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_lifecycle_state: Optional[pulumi.Input[_builtins.str]] = None):
        if active_key_id is not None:
            pulumi.set(__self__, "active_key_id", active_key_id)
        if active_key_version is not None:
            pulumi.set(__self__, "active_key_version", active_key_version)
        if current_key_lifecycle_state is not None:
            pulumi.set(__self__, "current_key_lifecycle_state", current_key_lifecycle_state)
        if scheduled_key_id is not None:
            pulumi.set(__self__, "scheduled_key_id", scheduled_key_id)
        if scheduled_key_status is not None:
            pulumi.set(__self__, "scheduled_key_status", scheduled_key_status)
        if scheduled_key_version is not None:
            pulumi.set(__self__, "scheduled_key_version", scheduled_key_version)
        if scheduled_lifecycle_state is not None:
            pulumi.set(__self__, "scheduled_lifecycle_state", scheduled_lifecycle_state)

    @_builtins.property
    @pulumi.getter(name="activeKeyId")
    def active_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "active_key_id")

    @active_key_id.setter
    def active_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active_key_id", value)

    @_builtins.property
    @pulumi.getter(name="activeKeyVersion")
    def active_key_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "active_key_version")

    @active_key_version.setter
    def active_key_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active_key_version", value)

    @_builtins.property
    @pulumi.getter(name="currentKeyLifecycleState")
    def current_key_lifecycle_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "current_key_lifecycle_state")

    @current_key_lifecycle_state.setter
    def current_key_lifecycle_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_key_lifecycle_state", value)

    @_builtins.property
    @pulumi.getter(name="scheduledKeyId")
    def scheduled_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheduled_key_id")

    @scheduled_key_id.setter
    def scheduled_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_key_id", value)

    @_builtins.property
    @pulumi.getter(name="scheduledKeyStatus")
    def scheduled_key_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheduled_key_status")

    @scheduled_key_status.setter
    def scheduled_key_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_key_status", value)

    @_builtins.property
    @pulumi.getter(name="scheduledKeyVersion")
    def scheduled_key_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheduled_key_version")

    @scheduled_key_version.setter
    def scheduled_key_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_key_version", value)

    @_builtins.property
    @pulumi.getter(name="scheduledLifecycleState")
    def scheduled_lifecycle_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheduled_lifecycle_state")

    @scheduled_lifecycle_state.setter
    def scheduled_lifecycle_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_lifecycle_state", value)


if not MYPY:
    class FusionEnvironmentMaintenancePolicyArgsDict(TypedDict):
        environment_maintenance_override: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) User choice to upgrade both test and prod pods at the same time. Overrides fusion environment families'.
        """
        monthly_patching_override: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) When "ENABLED", the Fusion environment is patched monthly. When "DISABLED", the Fusion environment is not patched monthly. This setting overrides the environment family setting. When not set, the environment follows the environment family policy.
        """
        quarterly_upgrade_begin_times: NotRequired[pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgsDict']]]]
        """
        Determines the quarterly upgrade begin times (monthly maintenance group schedule ) of the Fusion environment.
        """
elif False:
    FusionEnvironmentMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentMaintenancePolicyArgs:
    def __init__(__self__, *,
                 environment_maintenance_override: Optional[pulumi.Input[_builtins.str]] = None,
                 monthly_patching_override: Optional[pulumi.Input[_builtins.str]] = None,
                 quarterly_upgrade_begin_times: Optional[pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] environment_maintenance_override: (Updatable) User choice to upgrade both test and prod pods at the same time. Overrides fusion environment families'.
        :param pulumi.Input[_builtins.str] monthly_patching_override: (Updatable) When "ENABLED", the Fusion environment is patched monthly. When "DISABLED", the Fusion environment is not patched monthly. This setting overrides the environment family setting. When not set, the environment follows the environment family policy.
        :param pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgs']]] quarterly_upgrade_begin_times: Determines the quarterly upgrade begin times (monthly maintenance group schedule ) of the Fusion environment.
        """
        if environment_maintenance_override is not None:
            pulumi.set(__self__, "environment_maintenance_override", environment_maintenance_override)
        if monthly_patching_override is not None:
            pulumi.set(__self__, "monthly_patching_override", monthly_patching_override)
        if quarterly_upgrade_begin_times is not None:
            pulumi.set(__self__, "quarterly_upgrade_begin_times", quarterly_upgrade_begin_times)

    @_builtins.property
    @pulumi.getter(name="environmentMaintenanceOverride")
    def environment_maintenance_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) User choice to upgrade both test and prod pods at the same time. Overrides fusion environment families'.
        """
        return pulumi.get(self, "environment_maintenance_override")

    @environment_maintenance_override.setter
    def environment_maintenance_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_maintenance_override", value)

    @_builtins.property
    @pulumi.getter(name="monthlyPatchingOverride")
    def monthly_patching_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) When "ENABLED", the Fusion environment is patched monthly. When "DISABLED", the Fusion environment is not patched monthly. This setting overrides the environment family setting. When not set, the environment follows the environment family policy.
        """
        return pulumi.get(self, "monthly_patching_override")

    @monthly_patching_override.setter
    def monthly_patching_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monthly_patching_override", value)

    @_builtins.property
    @pulumi.getter(name="quarterlyUpgradeBeginTimes")
    def quarterly_upgrade_begin_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgs']]]]:
        """
        Determines the quarterly upgrade begin times (monthly maintenance group schedule ) of the Fusion environment.
        """
        return pulumi.get(self, "quarterly_upgrade_begin_times")

    @quarterly_upgrade_begin_times.setter
    def quarterly_upgrade_begin_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgs']]]]):
        pulumi.set(self, "quarterly_upgrade_begin_times", value)


if not MYPY:
    class FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgsDict(TypedDict):
        begin_times_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The frequency and month when maintenance occurs for the Fusion environment.
        """
        override_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines if the maintenance schedule of the Fusion environment is inherited from the Fusion environment family.
        """
elif False:
    FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentMaintenancePolicyQuarterlyUpgradeBeginTimeArgs:
    def __init__(__self__, *,
                 begin_times_value: Optional[pulumi.Input[_builtins.str]] = None,
                 override_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] begin_times_value: The frequency and month when maintenance occurs for the Fusion environment.
        :param pulumi.Input[_builtins.str] override_type: Determines if the maintenance schedule of the Fusion environment is inherited from the Fusion environment family.
        """
        if begin_times_value is not None:
            pulumi.set(__self__, "begin_times_value", begin_times_value)
        if override_type is not None:
            pulumi.set(__self__, "override_type", override_type)

    @_builtins.property
    @pulumi.getter(name="beginTimesValue")
    def begin_times_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The frequency and month when maintenance occurs for the Fusion environment.
        """
        return pulumi.get(self, "begin_times_value")

    @begin_times_value.setter
    def begin_times_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "begin_times_value", value)

    @_builtins.property
    @pulumi.getter(name="overrideType")
    def override_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines if the maintenance schedule of the Fusion environment is inherited from the Fusion environment family.
        """
        return pulumi.get(self, "override_type")

    @override_type.setter
    def override_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_type", value)


if not MYPY:
    class FusionEnvironmentRefreshArgsDict(TypedDict):
        source_fusion_environment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source environment id for the last refresh
        """
        time_finished: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time of when the last refresh finish
        """
        time_of_restoration_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        The point of time of the latest DB backup for the last refresh
        """
elif False:
    FusionEnvironmentRefreshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentRefreshArgs:
    def __init__(__self__, *,
                 source_fusion_environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_finished: Optional[pulumi.Input[_builtins.str]] = None,
                 time_of_restoration_point: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_fusion_environment_id: The source environment id for the last refresh
        :param pulumi.Input[_builtins.str] time_finished: The time of when the last refresh finish
        :param pulumi.Input[_builtins.str] time_of_restoration_point: The point of time of the latest DB backup for the last refresh
        """
        if source_fusion_environment_id is not None:
            pulumi.set(__self__, "source_fusion_environment_id", source_fusion_environment_id)
        if time_finished is not None:
            pulumi.set(__self__, "time_finished", time_finished)
        if time_of_restoration_point is not None:
            pulumi.set(__self__, "time_of_restoration_point", time_of_restoration_point)

    @_builtins.property
    @pulumi.getter(name="sourceFusionEnvironmentId")
    def source_fusion_environment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source environment id for the last refresh
        """
        return pulumi.get(self, "source_fusion_environment_id")

    @source_fusion_environment_id.setter
    def source_fusion_environment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_fusion_environment_id", value)

    @_builtins.property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time of when the last refresh finish
        """
        return pulumi.get(self, "time_finished")

    @time_finished.setter
    def time_finished(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_finished", value)

    @_builtins.property
    @pulumi.getter(name="timeOfRestorationPoint")
    def time_of_restoration_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The point of time of the latest DB backup for the last refresh
        """
        return pulumi.get(self, "time_of_restoration_point")

    @time_of_restoration_point.setter
    def time_of_restoration_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_of_restoration_point", value)


if not MYPY:
    class FusionEnvironmentRefreshActivityRefreshIssueDetailsListArgsDict(TypedDict):
        refresh_issues: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detail reasons of refresh failure or validation failure that needs to be shown to customer.
        """
elif False:
    FusionEnvironmentRefreshActivityRefreshIssueDetailsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentRefreshActivityRefreshIssueDetailsListArgs:
    def __init__(__self__, *,
                 refresh_issues: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] refresh_issues: Detail reasons of refresh failure or validation failure that needs to be shown to customer.
        """
        if refresh_issues is not None:
            pulumi.set(__self__, "refresh_issues", refresh_issues)

    @_builtins.property
    @pulumi.getter(name="refreshIssues")
    def refresh_issues(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detail reasons of refresh failure or validation failure that needs to be shown to customer.
        """
        return pulumi.get(self, "refresh_issues")

    @refresh_issues.setter
    def refresh_issues(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_issues", value)


if not MYPY:
    class FusionEnvironmentRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        (Updatable) Rule type
        """
        conditions: pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentRuleConditionArgsDict']]]
        """
        (Updatable)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A brief description of the access control rule. Avoid entering confidential information. example: `192.168.0.0/16 and 2001:db8::/32 are trusted clients. Whitelist them.` 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    FusionEnvironmentRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 conditions: pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentRuleConditionArgs']]],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: (Updatable) Rule type
        :param pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentRuleConditionArgs']]] conditions: (Updatable)
        :param pulumi.Input[_builtins.str] description: (Updatable) A brief description of the access control rule. Avoid entering confidential information. example: `192.168.0.0/16 and 2001:db8::/32 are trusted clients. Whitelist them.` 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Rule type
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentRuleConditionArgs']]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['FusionEnvironmentRuleConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A brief description of the access control rule. Avoid entering confidential information. example: `192.168.0.0/16 and 2001:db8::/32 are trusted clients. Whitelist them.` 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FusionEnvironmentRuleConditionArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        (Updatable) RuleCondition type
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        (Updatable) The OCID of the originating VCN that an incoming packet must match. You can use this condition in conjunction with `SourceVcnIpAddressCondition`. **NOTE:** If you define this condition for a rule without a `SourceVcnIpAddressCondition`, this condition matches all incoming traffic in the specified VCN.
        """
elif False:
    FusionEnvironmentRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionEnvironmentRuleConditionArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: (Updatable) RuleCondition type
        :param pulumi.Input[_builtins.str] attribute_value: (Updatable) The OCID of the originating VCN that an incoming packet must match. You can use this condition in conjunction with `SourceVcnIpAddressCondition`. **NOTE:** If you define this condition for a rule without a `SourceVcnIpAddressCondition`, this condition matches all incoming traffic in the specified VCN.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) RuleCondition type
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The OCID of the originating VCN that an incoming packet must match. You can use this condition in conjunction with `SourceVcnIpAddressCondition`. **NOTE:** If you define this condition for a rule without a `SourceVcnIpAddressCondition`, this condition matches all incoming traffic in the specified VCN.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)


