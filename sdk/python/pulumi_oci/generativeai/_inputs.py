# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAgentEndpointContentModerationConfigArgs',
    'AgentAgentEndpointContentModerationConfigArgsDict',
    'AgentAgentEndpointGuardrailConfigArgs',
    'AgentAgentEndpointGuardrailConfigArgsDict',
    'AgentAgentEndpointGuardrailConfigContentModerationConfigArgs',
    'AgentAgentEndpointGuardrailConfigContentModerationConfigArgsDict',
    'AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgs',
    'AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgsDict',
    'AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgs',
    'AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgsDict',
    'AgentAgentEndpointHumanInputConfigArgs',
    'AgentAgentEndpointHumanInputConfigArgsDict',
    'AgentAgentEndpointOutputConfigArgs',
    'AgentAgentEndpointOutputConfigArgsDict',
    'AgentAgentEndpointOutputConfigOutputLocationArgs',
    'AgentAgentEndpointOutputConfigOutputLocationArgsDict',
    'AgentAgentEndpointSessionConfigArgs',
    'AgentAgentEndpointSessionConfigArgsDict',
    'AgentAgentLlmConfigArgs',
    'AgentAgentLlmConfigArgsDict',
    'AgentAgentLlmConfigRoutingLlmCustomizationArgs',
    'AgentAgentLlmConfigRoutingLlmCustomizationArgsDict',
    'AgentDataIngestionJobDataIngestionJobStatisticArgs',
    'AgentDataIngestionJobDataIngestionJobStatisticArgsDict',
    'AgentDataSourceDataSourceConfigArgs',
    'AgentDataSourceDataSourceConfigArgsDict',
    'AgentDataSourceDataSourceConfigObjectStoragePrefixArgs',
    'AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict',
    'AgentKnowledgeBaseIndexConfigArgs',
    'AgentKnowledgeBaseIndexConfigArgsDict',
    'AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs',
    'AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict',
    'AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs',
    'AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict',
    'AgentKnowledgeBaseIndexConfigIndexArgs',
    'AgentKnowledgeBaseIndexConfigIndexArgsDict',
    'AgentKnowledgeBaseIndexConfigIndexSchemaArgs',
    'AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict',
    'AgentKnowledgeBaseIndexConfigSecretDetailArgs',
    'AgentKnowledgeBaseIndexConfigSecretDetailArgsDict',
    'AgentToolToolConfigArgs',
    'AgentToolToolConfigArgsDict',
    'AgentToolToolConfigDatabaseConnectionArgs',
    'AgentToolToolConfigDatabaseConnectionArgsDict',
    'AgentToolToolConfigDatabaseSchemaArgs',
    'AgentToolToolConfigDatabaseSchemaArgsDict',
    'AgentToolToolConfigFunctionArgs',
    'AgentToolToolConfigFunctionArgsDict',
    'AgentToolToolConfigGenerationLlmCustomizationArgs',
    'AgentToolToolConfigGenerationLlmCustomizationArgsDict',
    'AgentToolToolConfigIclExamplesArgs',
    'AgentToolToolConfigIclExamplesArgsDict',
    'AgentToolToolConfigKnowledgeBaseConfigArgs',
    'AgentToolToolConfigKnowledgeBaseConfigArgsDict',
    'AgentToolToolConfigTableAndColumnDescriptionArgs',
    'AgentToolToolConfigTableAndColumnDescriptionArgsDict',
    'DedicatedAiClusterCapacityArgs',
    'DedicatedAiClusterCapacityArgsDict',
    'EndpointContentModerationConfigArgs',
    'EndpointContentModerationConfigArgsDict',
    'ModelFineTuneDetailsArgs',
    'ModelFineTuneDetailsArgsDict',
    'ModelFineTuneDetailsTrainingConfigArgs',
    'ModelFineTuneDetailsTrainingConfigArgsDict',
    'ModelFineTuneDetailsTrainingDatasetArgs',
    'ModelFineTuneDetailsTrainingDatasetArgsDict',
    'ModelModelMetricArgs',
    'ModelModelMetricArgsDict',
    'GetAgentAgentEndpointsFilterArgs',
    'GetAgentAgentEndpointsFilterArgsDict',
    'GetAgentAgentsFilterArgs',
    'GetAgentAgentsFilterArgsDict',
    'GetAgentDataIngestionJobsFilterArgs',
    'GetAgentDataIngestionJobsFilterArgsDict',
    'GetAgentDataSourcesFilterArgs',
    'GetAgentDataSourcesFilterArgsDict',
    'GetAgentKnowledgeBasesFilterArgs',
    'GetAgentKnowledgeBasesFilterArgsDict',
    'GetAgentToolsFilterArgs',
    'GetAgentToolsFilterArgsDict',
    'GetDedicatedAiClustersFilterArgs',
    'GetDedicatedAiClustersFilterArgsDict',
    'GetEndpointsFilterArgs',
    'GetEndpointsFilterArgsDict',
    'GetModelsFilterArgs',
    'GetModelsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAgentEndpointContentModerationConfigArgsDict(TypedDict):
        should_enable_on_input: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) A flag to enable or disable content moderation on input.
        """
        should_enable_on_output: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) A flag to enable or disable content moderation on output.
        """
elif False:
    AgentAgentEndpointContentModerationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointContentModerationConfigArgs:
    def __init__(__self__, *,
                 should_enable_on_input: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_enable_on_output: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] should_enable_on_input: (Updatable) A flag to enable or disable content moderation on input.
        :param pulumi.Input[_builtins.bool] should_enable_on_output: (Updatable) A flag to enable or disable content moderation on output.
        """
        if should_enable_on_input is not None:
            pulumi.set(__self__, "should_enable_on_input", should_enable_on_input)
        if should_enable_on_output is not None:
            pulumi.set(__self__, "should_enable_on_output", should_enable_on_output)

    @_builtins.property
    @pulumi.getter(name="shouldEnableOnInput")
    def should_enable_on_input(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) A flag to enable or disable content moderation on input.
        """
        return pulumi.get(self, "should_enable_on_input")

    @should_enable_on_input.setter
    def should_enable_on_input(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_enable_on_input", value)

    @_builtins.property
    @pulumi.getter(name="shouldEnableOnOutput")
    def should_enable_on_output(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) A flag to enable or disable content moderation on output.
        """
        return pulumi.get(self, "should_enable_on_output")

    @should_enable_on_output.setter
    def should_enable_on_output(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_enable_on_output", value)


if not MYPY:
    class AgentAgentEndpointGuardrailConfigArgsDict(TypedDict):
        content_moderation_config: NotRequired[pulumi.Input['AgentAgentEndpointGuardrailConfigContentModerationConfigArgsDict']]
        """
        (Updatable) The configuration details about whether to apply the content moderation feature to input and output. Content moderation removes toxic and biased content from responses. It is recommended to use content moderation.
        """
        personally_identifiable_information_config: NotRequired[pulumi.Input['AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgsDict']]
        """
        (Updatable) The configuration details for Personally Identifiable Information.
        """
        prompt_injection_config: NotRequired[pulumi.Input['AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgsDict']]
        """
        (Updatable) The configuration details for Prompt Injection.
        """
elif False:
    AgentAgentEndpointGuardrailConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointGuardrailConfigArgs:
    def __init__(__self__, *,
                 content_moderation_config: Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigContentModerationConfigArgs']] = None,
                 personally_identifiable_information_config: Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgs']] = None,
                 prompt_injection_config: Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgs']] = None):
        """
        :param pulumi.Input['AgentAgentEndpointGuardrailConfigContentModerationConfigArgs'] content_moderation_config: (Updatable) The configuration details about whether to apply the content moderation feature to input and output. Content moderation removes toxic and biased content from responses. It is recommended to use content moderation.
        :param pulumi.Input['AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgs'] personally_identifiable_information_config: (Updatable) The configuration details for Personally Identifiable Information.
        :param pulumi.Input['AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgs'] prompt_injection_config: (Updatable) The configuration details for Prompt Injection.
        """
        if content_moderation_config is not None:
            pulumi.set(__self__, "content_moderation_config", content_moderation_config)
        if personally_identifiable_information_config is not None:
            pulumi.set(__self__, "personally_identifiable_information_config", personally_identifiable_information_config)
        if prompt_injection_config is not None:
            pulumi.set(__self__, "prompt_injection_config", prompt_injection_config)

    @_builtins.property
    @pulumi.getter(name="contentModerationConfig")
    def content_moderation_config(self) -> Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigContentModerationConfigArgs']]:
        """
        (Updatable) The configuration details about whether to apply the content moderation feature to input and output. Content moderation removes toxic and biased content from responses. It is recommended to use content moderation.
        """
        return pulumi.get(self, "content_moderation_config")

    @content_moderation_config.setter
    def content_moderation_config(self, value: Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigContentModerationConfigArgs']]):
        pulumi.set(self, "content_moderation_config", value)

    @_builtins.property
    @pulumi.getter(name="personallyIdentifiableInformationConfig")
    def personally_identifiable_information_config(self) -> Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgs']]:
        """
        (Updatable) The configuration details for Personally Identifiable Information.
        """
        return pulumi.get(self, "personally_identifiable_information_config")

    @personally_identifiable_information_config.setter
    def personally_identifiable_information_config(self, value: Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgs']]):
        pulumi.set(self, "personally_identifiable_information_config", value)

    @_builtins.property
    @pulumi.getter(name="promptInjectionConfig")
    def prompt_injection_config(self) -> Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgs']]:
        """
        (Updatable) The configuration details for Prompt Injection.
        """
        return pulumi.get(self, "prompt_injection_config")

    @prompt_injection_config.setter
    def prompt_injection_config(self, value: Optional[pulumi.Input['AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgs']]):
        pulumi.set(self, "prompt_injection_config", value)


if not MYPY:
    class AgentAgentEndpointGuardrailConfigContentModerationConfigArgsDict(TypedDict):
        input_guardrail_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An input guardrail mode for content moderation.
        """
        output_guardrail_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An output guardrail mode for content moderation.
        """
elif False:
    AgentAgentEndpointGuardrailConfigContentModerationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointGuardrailConfigContentModerationConfigArgs:
    def __init__(__self__, *,
                 input_guardrail_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 output_guardrail_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_guardrail_mode: (Updatable) An input guardrail mode for content moderation.
        :param pulumi.Input[_builtins.str] output_guardrail_mode: (Updatable) An output guardrail mode for content moderation.
        """
        if input_guardrail_mode is not None:
            pulumi.set(__self__, "input_guardrail_mode", input_guardrail_mode)
        if output_guardrail_mode is not None:
            pulumi.set(__self__, "output_guardrail_mode", output_guardrail_mode)

    @_builtins.property
    @pulumi.getter(name="inputGuardrailMode")
    def input_guardrail_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An input guardrail mode for content moderation.
        """
        return pulumi.get(self, "input_guardrail_mode")

    @input_guardrail_mode.setter
    def input_guardrail_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_guardrail_mode", value)

    @_builtins.property
    @pulumi.getter(name="outputGuardrailMode")
    def output_guardrail_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An output guardrail mode for content moderation.
        """
        return pulumi.get(self, "output_guardrail_mode")

    @output_guardrail_mode.setter
    def output_guardrail_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_guardrail_mode", value)


if not MYPY:
    class AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgsDict(TypedDict):
        input_guardrail_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An input guardrail mode for personally identifiable information.
        """
        output_guardrail_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An output guardrail mode for personally identifiable information.
        """
elif False:
    AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointGuardrailConfigPersonallyIdentifiableInformationConfigArgs:
    def __init__(__self__, *,
                 input_guardrail_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 output_guardrail_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_guardrail_mode: (Updatable) An input guardrail mode for personally identifiable information.
        :param pulumi.Input[_builtins.str] output_guardrail_mode: (Updatable) An output guardrail mode for personally identifiable information.
        """
        if input_guardrail_mode is not None:
            pulumi.set(__self__, "input_guardrail_mode", input_guardrail_mode)
        if output_guardrail_mode is not None:
            pulumi.set(__self__, "output_guardrail_mode", output_guardrail_mode)

    @_builtins.property
    @pulumi.getter(name="inputGuardrailMode")
    def input_guardrail_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An input guardrail mode for personally identifiable information.
        """
        return pulumi.get(self, "input_guardrail_mode")

    @input_guardrail_mode.setter
    def input_guardrail_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_guardrail_mode", value)

    @_builtins.property
    @pulumi.getter(name="outputGuardrailMode")
    def output_guardrail_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An output guardrail mode for personally identifiable information.
        """
        return pulumi.get(self, "output_guardrail_mode")

    @output_guardrail_mode.setter
    def output_guardrail_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_guardrail_mode", value)


if not MYPY:
    class AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgsDict(TypedDict):
        input_guardrail_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An input guardrail mode for prompt injection.
        """
elif False:
    AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointGuardrailConfigPromptInjectionConfigArgs:
    def __init__(__self__, *,
                 input_guardrail_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_guardrail_mode: (Updatable) An input guardrail mode for prompt injection.
        """
        if input_guardrail_mode is not None:
            pulumi.set(__self__, "input_guardrail_mode", input_guardrail_mode)

    @_builtins.property
    @pulumi.getter(name="inputGuardrailMode")
    def input_guardrail_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An input guardrail mode for prompt injection.
        """
        return pulumi.get(self, "input_guardrail_mode")

    @input_guardrail_mode.setter
    def input_guardrail_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_guardrail_mode", value)


if not MYPY:
    class AgentAgentEndpointHumanInputConfigArgsDict(TypedDict):
        should_enable_human_input: pulumi.Input[_builtins.bool]
        """
        (Updatable) The Agent will request for human input for disambiguation or additional information gathering if this is enabled.
        """
elif False:
    AgentAgentEndpointHumanInputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointHumanInputConfigArgs:
    def __init__(__self__, *,
                 should_enable_human_input: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] should_enable_human_input: (Updatable) The Agent will request for human input for disambiguation or additional information gathering if this is enabled.
        """
        pulumi.set(__self__, "should_enable_human_input", should_enable_human_input)

    @_builtins.property
    @pulumi.getter(name="shouldEnableHumanInput")
    def should_enable_human_input(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) The Agent will request for human input for disambiguation or additional information gathering if this is enabled.
        """
        return pulumi.get(self, "should_enable_human_input")

    @should_enable_human_input.setter
    def should_enable_human_input(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "should_enable_human_input", value)


if not MYPY:
    class AgentAgentEndpointOutputConfigArgsDict(TypedDict):
        output_location: pulumi.Input['AgentAgentEndpointOutputConfigOutputLocationArgsDict']
        """
        (Updatable) Location of the output.
        """
        retention_period_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Retention duration of the output data.
        """
elif False:
    AgentAgentEndpointOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointOutputConfigArgs:
    def __init__(__self__, *,
                 output_location: pulumi.Input['AgentAgentEndpointOutputConfigOutputLocationArgs'],
                 retention_period_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['AgentAgentEndpointOutputConfigOutputLocationArgs'] output_location: (Updatable) Location of the output.
        :param pulumi.Input[_builtins.int] retention_period_in_minutes: (Updatable) Retention duration of the output data.
        """
        pulumi.set(__self__, "output_location", output_location)
        if retention_period_in_minutes is not None:
            pulumi.set(__self__, "retention_period_in_minutes", retention_period_in_minutes)

    @_builtins.property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> pulumi.Input['AgentAgentEndpointOutputConfigOutputLocationArgs']:
        """
        (Updatable) Location of the output.
        """
        return pulumi.get(self, "output_location")

    @output_location.setter
    def output_location(self, value: pulumi.Input['AgentAgentEndpointOutputConfigOutputLocationArgs']):
        pulumi.set(self, "output_location", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInMinutes")
    def retention_period_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Retention duration of the output data.
        """
        return pulumi.get(self, "retention_period_in_minutes")

    @retention_period_in_minutes.setter
    def retention_period_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_period_in_minutes", value)


if not MYPY:
    class AgentAgentEndpointOutputConfigOutputLocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the bucket.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) The namespace of the object storage.
        """
        output_location_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of OutputLocation.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The prefix of the object storage.
        """
elif False:
    AgentAgentEndpointOutputConfigOutputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointOutputConfigOutputLocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 output_location_type: pulumi.Input[_builtins.str],
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The name of the bucket.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace of the object storage.
        :param pulumi.Input[_builtins.str] output_location_type: (Updatable) Type of OutputLocation.
        :param pulumi.Input[_builtins.str] prefix: (Updatable) The prefix of the object storage.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "output_location_type", output_location_type)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The namespace of the object storage.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="outputLocationType")
    def output_location_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of OutputLocation.
        """
        return pulumi.get(self, "output_location_type")

    @output_location_type.setter
    def output_location_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_location_type", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The prefix of the object storage.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AgentAgentEndpointSessionConfigArgsDict(TypedDict):
        idle_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The session will become inactive after this timeout.
        """
elif False:
    AgentAgentEndpointSessionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointSessionConfigArgs:
    def __init__(__self__, *,
                 idle_timeout_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] idle_timeout_in_seconds: (Updatable) The session will become inactive after this timeout.
        """
        if idle_timeout_in_seconds is not None:
            pulumi.set(__self__, "idle_timeout_in_seconds", idle_timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="idleTimeoutInSeconds")
    def idle_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The session will become inactive after this timeout.
        """
        return pulumi.get(self, "idle_timeout_in_seconds")

    @idle_timeout_in_seconds.setter
    def idle_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_timeout_in_seconds", value)


if not MYPY:
    class AgentAgentLlmConfigArgsDict(TypedDict):
        routing_llm_customization: NotRequired[pulumi.Input['AgentAgentLlmConfigRoutingLlmCustomizationArgsDict']]
        """
        (Updatable) Configuration to customize LLM.
        """
elif False:
    AgentAgentLlmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentLlmConfigArgs:
    def __init__(__self__, *,
                 routing_llm_customization: Optional[pulumi.Input['AgentAgentLlmConfigRoutingLlmCustomizationArgs']] = None):
        """
        :param pulumi.Input['AgentAgentLlmConfigRoutingLlmCustomizationArgs'] routing_llm_customization: (Updatable) Configuration to customize LLM.
        """
        if routing_llm_customization is not None:
            pulumi.set(__self__, "routing_llm_customization", routing_llm_customization)

    @_builtins.property
    @pulumi.getter(name="routingLlmCustomization")
    def routing_llm_customization(self) -> Optional[pulumi.Input['AgentAgentLlmConfigRoutingLlmCustomizationArgs']]:
        """
        (Updatable) Configuration to customize LLM.
        """
        return pulumi.get(self, "routing_llm_customization")

    @routing_llm_customization.setter
    def routing_llm_customization(self, value: Optional[pulumi.Input['AgentAgentLlmConfigRoutingLlmCustomizationArgs']]):
        pulumi.set(self, "routing_llm_customization", value)


if not MYPY:
    class AgentAgentLlmConfigRoutingLlmCustomizationArgsDict(TypedDict):
        instruction: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If specified, the default instruction is replaced with provided instruction.
        """
elif False:
    AgentAgentLlmConfigRoutingLlmCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentLlmConfigRoutingLlmCustomizationArgs:
    def __init__(__self__, *,
                 instruction: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instruction: (Updatable) If specified, the default instruction is replaced with provided instruction.
        """
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If specified, the default instruction is replaced with provided instruction.
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instruction", value)


if not MYPY:
    class AgentDataIngestionJobDataIngestionJobStatisticArgsDict(TypedDict):
        duration_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of this ingestion job.
        """
        number_of_failed_files: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of files that have failed during the ingestion.
        """
        number_of_ingested_files: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of files that have been successfully ingested during the ingestion.
        """
elif False:
    AgentDataIngestionJobDataIngestionJobStatisticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataIngestionJobDataIngestionJobStatisticArgs:
    def __init__(__self__, *,
                 duration_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 number_of_failed_files: Optional[pulumi.Input[_builtins.int]] = None,
                 number_of_ingested_files: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration_in_seconds: The duration of this ingestion job.
        :param pulumi.Input[_builtins.int] number_of_failed_files: The number of files that have failed during the ingestion.
        :param pulumi.Input[_builtins.int] number_of_ingested_files: The number of files that have been successfully ingested during the ingestion.
        """
        if duration_in_seconds is not None:
            pulumi.set(__self__, "duration_in_seconds", duration_in_seconds)
        if number_of_failed_files is not None:
            pulumi.set(__self__, "number_of_failed_files", number_of_failed_files)
        if number_of_ingested_files is not None:
            pulumi.set(__self__, "number_of_ingested_files", number_of_ingested_files)

    @_builtins.property
    @pulumi.getter(name="durationInSeconds")
    def duration_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of this ingestion job.
        """
        return pulumi.get(self, "duration_in_seconds")

    @duration_in_seconds.setter
    def duration_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="numberOfFailedFiles")
    def number_of_failed_files(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of files that have failed during the ingestion.
        """
        return pulumi.get(self, "number_of_failed_files")

    @number_of_failed_files.setter
    def number_of_failed_files(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_failed_files", value)

    @_builtins.property
    @pulumi.getter(name="numberOfIngestedFiles")
    def number_of_ingested_files(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of files that have been successfully ingested during the ingestion.
        """
        return pulumi.get(self, "number_of_ingested_files")

    @number_of_ingested_files.setter
    def number_of_ingested_files(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_ingested_files", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigArgsDict(TypedDict):
        data_source_config_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of the tool. The allowed values are:
        * `OCI_OBJECT_STORAGE`: The data source is Oracle Cloud Infrastructure Object Storage.
        """
        object_storage_prefixes: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict']]]
        """
        (Updatable) The locations of data items in Object Storage, can either be an object (File) or a prefix (folder).
        """
elif False:
    AgentDataSourceDataSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigArgs:
    def __init__(__self__, *,
                 data_source_config_type: pulumi.Input[_builtins.str],
                 object_storage_prefixes: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]]):
        """
        :param pulumi.Input[_builtins.str] data_source_config_type: (Updatable) The type of the tool. The allowed values are:
               * `OCI_OBJECT_STORAGE`: The data source is Oracle Cloud Infrastructure Object Storage.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]] object_storage_prefixes: (Updatable) The locations of data items in Object Storage, can either be an object (File) or a prefix (folder).
        """
        pulumi.set(__self__, "data_source_config_type", data_source_config_type)
        pulumi.set(__self__, "object_storage_prefixes", object_storage_prefixes)

    @_builtins.property
    @pulumi.getter(name="dataSourceConfigType")
    def data_source_config_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of the tool. The allowed values are:
        * `OCI_OBJECT_STORAGE`: The data source is Oracle Cloud Infrastructure Object Storage.
        """
        return pulumi.get(self, "data_source_config_type")

    @data_source_config_type.setter
    def data_source_config_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_source_config_type", value)

    @_builtins.property
    @pulumi.getter(name="objectStoragePrefixes")
    def object_storage_prefixes(self) -> pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]]:
        """
        (Updatable) The locations of data items in Object Storage, can either be an object (File) or a prefix (folder).
        """
        return pulumi.get(self, "object_storage_prefixes")

    @object_storage_prefixes.setter
    def object_storage_prefixes(self, value: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]]):
        pulumi.set(self, "object_storage_prefixes", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) The bucket name of an object.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) The namespace name of an object.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the object (file) or prefix (folder).
        """
elif False:
    AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigObjectStoragePrefixArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The bucket name of an object.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace name of an object.
        :param pulumi.Input[_builtins.str] prefix: (Updatable) The name of the object (file) or prefix (folder).
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The bucket name of an object.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The namespace name of an object.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the object (file) or prefix (folder).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigArgsDict(TypedDict):
        index_config_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of index. The allowed values are:
        * `DEFAULT_INDEX_CONFIG`: DefaultIndexConfig allows the service to create and manage vector store on behalf of the customer.
        * `OCI_OPEN_SEARCH_INDEX_CONFIG`: OciOpenSearchIndexConfig allows customer to configure their OpenSearch cluster.
        * `OCI_DATABASE_CONFIG`: OciDatabaseConfig allows customer to configure their Database.
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the OpenSearch Cluster.
        """
        database_connection: NotRequired[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict']]
        """
        (Updatable) **DatabaseConnection**

        The connection type for Databases.
        """
        database_functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict']]]]
        """
        (Updatable) Array of Database functions to be used.
        """
        indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgsDict']]]]
        """
        (Updatable) Index configuration for open search.
        """
        secret_detail: NotRequired[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgsDict']]
        """
        (Updatable) **SecretDetail**

        The details of configured security configuration on OpenSearch.
        """
        should_enable_hybrid_search: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether to enable Hybrid search in service managed OpenSearch.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    AgentKnowledgeBaseIndexConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigArgs:
    def __init__(__self__, *,
                 index_config_type: pulumi.Input[_builtins.str],
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 database_connection: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs']] = None,
                 database_functions: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]]] = None,
                 secret_detail: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs']] = None,
                 should_enable_hybrid_search: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] index_config_type: (Updatable) The type of index. The allowed values are:
               * `DEFAULT_INDEX_CONFIG`: DefaultIndexConfig allows the service to create and manage vector store on behalf of the customer.
               * `OCI_OPEN_SEARCH_INDEX_CONFIG`: OciOpenSearchIndexConfig allows customer to configure their OpenSearch cluster.
               * `OCI_DATABASE_CONFIG`: OciDatabaseConfig allows customer to configure their Database.
        :param pulumi.Input[_builtins.str] cluster_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the OpenSearch Cluster.
        :param pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs'] database_connection: (Updatable) **DatabaseConnection**
               
               The connection type for Databases.
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]] database_functions: (Updatable) Array of Database functions to be used.
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]] indexes: (Updatable) Index configuration for open search.
        :param pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs'] secret_detail: (Updatable) **SecretDetail**
               
               The details of configured security configuration on OpenSearch.
        :param pulumi.Input[_builtins.bool] should_enable_hybrid_search: (Updatable) Whether to enable Hybrid search in service managed OpenSearch.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "index_config_type", index_config_type)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if database_connection is not None:
            pulumi.set(__self__, "database_connection", database_connection)
        if database_functions is not None:
            pulumi.set(__self__, "database_functions", database_functions)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if secret_detail is not None:
            pulumi.set(__self__, "secret_detail", secret_detail)
        if should_enable_hybrid_search is not None:
            pulumi.set(__self__, "should_enable_hybrid_search", should_enable_hybrid_search)

    @_builtins.property
    @pulumi.getter(name="indexConfigType")
    def index_config_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of index. The allowed values are:
        * `DEFAULT_INDEX_CONFIG`: DefaultIndexConfig allows the service to create and manage vector store on behalf of the customer.
        * `OCI_OPEN_SEARCH_INDEX_CONFIG`: OciOpenSearchIndexConfig allows customer to configure their OpenSearch cluster.
        * `OCI_DATABASE_CONFIG`: OciDatabaseConfig allows customer to configure their Database.
        """
        return pulumi.get(self, "index_config_type")

    @index_config_type.setter
    def index_config_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_config_type", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the OpenSearch Cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="databaseConnection")
    def database_connection(self) -> Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs']]:
        """
        (Updatable) **DatabaseConnection**

        The connection type for Databases.
        """
        return pulumi.get(self, "database_connection")

    @database_connection.setter
    def database_connection(self, value: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs']]):
        pulumi.set(self, "database_connection", value)

    @_builtins.property
    @pulumi.getter(name="databaseFunctions")
    def database_functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]]]:
        """
        (Updatable) Array of Database functions to be used.
        """
        return pulumi.get(self, "database_functions")

    @database_functions.setter
    def database_functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]]]):
        pulumi.set(self, "database_functions", value)

    @_builtins.property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]]]:
        """
        (Updatable) Index configuration for open search.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]]]):
        pulumi.set(self, "indexes", value)

    @_builtins.property
    @pulumi.getter(name="secretDetail")
    def secret_detail(self) -> Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs']]:
        """
        (Updatable) **SecretDetail**

        The details of configured security configuration on OpenSearch.
        """
        return pulumi.get(self, "secret_detail")

    @secret_detail.setter
    def secret_detail(self, value: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs']]):
        pulumi.set(self, "secret_detail", value)

    @_builtins.property
    @pulumi.getter(name="shouldEnableHybridSearch")
    def should_enable_hybrid_search(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether to enable Hybrid search in service managed OpenSearch.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "should_enable_hybrid_search")

    @should_enable_hybrid_search.setter
    def should_enable_hybrid_search(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_enable_hybrid_search", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict(TypedDict):
        connection_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        """
        connection_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of Database connection. The allowed values are:
        * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
elif False:
    AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[_builtins.str],
                 connection_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] connection_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        :param pulumi.Input[_builtins.str] connection_type: (Updatable) The type of Database connection. The allowed values are:
               * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "connection_type", connection_type)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of Database connection. The allowed values are:
        * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_type", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the Database function.
        """
elif False:
    AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the Database function.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the Database function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigIndexArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The index name in opensearch.
        """
        schema: NotRequired[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict']]
        """
        (Updatable) **IndexSchema**

        The index schema details.
        """
elif False:
    AgentKnowledgeBaseIndexConfigIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigIndexArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The index name in opensearch.
        :param pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs'] schema: (Updatable) **IndexSchema**
               
               The index schema details.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The index name in opensearch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs']]:
        """
        (Updatable) **IndexSchema**

        The index schema details.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs']]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict(TypedDict):
        body_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Body key name.
        """
        embedding_body_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Field within customer managed Oracle Cloud Infrastructure OpenSearch document containing the vector embedding for queries.
        """
        title_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Title key that stores the Title of a document, if available.
        """
        url_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) URL key that stores the URL of a document, if available.
        """
elif False:
    AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigIndexSchemaArgs:
    def __init__(__self__, *,
                 body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 embedding_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 title_key: Optional[pulumi.Input[_builtins.str]] = None,
                 url_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body_key: (Updatable) Body key name.
        :param pulumi.Input[_builtins.str] embedding_body_key: (Updatable) Field within customer managed Oracle Cloud Infrastructure OpenSearch document containing the vector embedding for queries.
        :param pulumi.Input[_builtins.str] title_key: (Updatable) Title key that stores the Title of a document, if available.
        :param pulumi.Input[_builtins.str] url_key: (Updatable) URL key that stores the URL of a document, if available.
        """
        if body_key is not None:
            pulumi.set(__self__, "body_key", body_key)
        if embedding_body_key is not None:
            pulumi.set(__self__, "embedding_body_key", embedding_body_key)
        if title_key is not None:
            pulumi.set(__self__, "title_key", title_key)
        if url_key is not None:
            pulumi.set(__self__, "url_key", url_key)

    @_builtins.property
    @pulumi.getter(name="bodyKey")
    def body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Body key name.
        """
        return pulumi.get(self, "body_key")

    @body_key.setter
    def body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body_key", value)

    @_builtins.property
    @pulumi.getter(name="embeddingBodyKey")
    def embedding_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Field within customer managed Oracle Cloud Infrastructure OpenSearch document containing the vector embedding for queries.
        """
        return pulumi.get(self, "embedding_body_key")

    @embedding_body_key.setter
    def embedding_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "embedding_body_key", value)

    @_builtins.property
    @pulumi.getter(name="titleKey")
    def title_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Title key that stores the Title of a document, if available.
        """
        return pulumi.get(self, "title_key")

    @title_key.setter
    def title_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title_key", value)

    @_builtins.property
    @pulumi.getter(name="urlKey")
    def url_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) URL key that stores the URL of a document, if available.
        """
        return pulumi.get(self, "url_key")

    @url_key.setter
    def url_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_key", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigSecretDetailArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of OpenID. The allowed values are:
        * `IDCS_SECRET`: The OpenID configuration used is OpenSearch is IDCS.
        * `BASIC_AUTH_SECRET`: Basic authentication use for OpenSearch
        """
        vault_secret_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret for basic authentication.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The IDCS Connect clientId.
        """
        idcs_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The URL represent authentication url of the IDCS.
        """
        scope_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Fully qualified scope url
        """
elif False:
    AgentKnowledgeBaseIndexConfigSecretDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigSecretDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 vault_secret_id: pulumi.Input[_builtins.str],
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 idcs_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scope_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) The type of OpenID. The allowed values are:
               * `IDCS_SECRET`: The OpenID configuration used is OpenSearch is IDCS.
               * `BASIC_AUTH_SECRET`: Basic authentication use for OpenSearch
        :param pulumi.Input[_builtins.str] vault_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret for basic authentication.
        :param pulumi.Input[_builtins.str] client_id: (Updatable) The IDCS Connect clientId.
        :param pulumi.Input[_builtins.str] idcs_url: (Updatable) The URL represent authentication url of the IDCS.
        :param pulumi.Input[_builtins.str] scope_url: (Updatable) Fully qualified scope url
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_secret_id", vault_secret_id)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if idcs_url is not None:
            pulumi.set(__self__, "idcs_url", idcs_url)
        if scope_url is not None:
            pulumi.set(__self__, "scope_url", scope_url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of OpenID. The allowed values are:
        * `IDCS_SECRET`: The OpenID configuration used is OpenSearch is IDCS.
        * `BASIC_AUTH_SECRET`: Basic authentication use for OpenSearch
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vaultSecretId")
    def vault_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret for basic authentication.
        """
        return pulumi.get(self, "vault_secret_id")

    @vault_secret_id.setter
    def vault_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vault_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The IDCS Connect clientId.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="idcsUrl")
    def idcs_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The URL represent authentication url of the IDCS.
        """
        return pulumi.get(self, "idcs_url")

    @idcs_url.setter
    def idcs_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idcs_url", value)

    @_builtins.property
    @pulumi.getter(name="scopeUrl")
    def scope_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Fully qualified scope url
        """
        return pulumi.get(self, "scope_url")

    @scope_url.setter
    def scope_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope_url", value)


if not MYPY:
    class AgentToolToolConfigArgsDict(TypedDict):
        tool_config_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of the Tool config. The allowed values are:
        * `SQL_TOOL_CONFIG`: The config for sql Tool.
        * `RAG_TOOL_CONFIG`: The config for rag Tool.
        * FUNCTION_CALLING_TOOL_CONFIG: The config for Function calling Tool.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        database_connection: NotRequired[pulumi.Input['AgentToolToolConfigDatabaseConnectionArgsDict']]
        """
        (Updatable) The connection type for Databases.
        """
        database_schema: NotRequired[pulumi.Input['AgentToolToolConfigDatabaseSchemaArgsDict']]
        """
        (Updatable) The input location definition.
        """
        dialect: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Dialect to be used for SQL generation.
        """
        function: NotRequired[pulumi.Input['AgentToolToolConfigFunctionArgsDict']]
        """
        (Updatable) Details of Function for Function calling tool.
        """
        generation_llm_customization: NotRequired[pulumi.Input['AgentToolToolConfigGenerationLlmCustomizationArgsDict']]
        """
        (Updatable) Configuration to customize LLM.
        """
        icl_examples: NotRequired[pulumi.Input['AgentToolToolConfigIclExamplesArgsDict']]
        """
        (Updatable) The input location definition.
        """
        knowledge_base_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentToolToolConfigKnowledgeBaseConfigArgsDict']]]]
        """
        (Updatable) The KnowledgeBase configurations that this RAG Tool uses
        """
        model_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Size of the model.
        """
        should_enable_self_correction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) To enable/disable self correction.
        """
        should_enable_sql_execution: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) To enable/disable SQL execution.
        """
        table_and_column_description: NotRequired[pulumi.Input['AgentToolToolConfigTableAndColumnDescriptionArgsDict']]
        """
        (Updatable) The input location definition.
        """
elif False:
    AgentToolToolConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigArgs:
    def __init__(__self__, *,
                 tool_config_type: pulumi.Input[_builtins.str],
                 database_connection: Optional[pulumi.Input['AgentToolToolConfigDatabaseConnectionArgs']] = None,
                 database_schema: Optional[pulumi.Input['AgentToolToolConfigDatabaseSchemaArgs']] = None,
                 dialect: Optional[pulumi.Input[_builtins.str]] = None,
                 function: Optional[pulumi.Input['AgentToolToolConfigFunctionArgs']] = None,
                 generation_llm_customization: Optional[pulumi.Input['AgentToolToolConfigGenerationLlmCustomizationArgs']] = None,
                 icl_examples: Optional[pulumi.Input['AgentToolToolConfigIclExamplesArgs']] = None,
                 knowledge_base_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AgentToolToolConfigKnowledgeBaseConfigArgs']]]] = None,
                 model_size: Optional[pulumi.Input[_builtins.str]] = None,
                 should_enable_self_correction: Optional[pulumi.Input[_builtins.bool]] = None,
                 should_enable_sql_execution: Optional[pulumi.Input[_builtins.bool]] = None,
                 table_and_column_description: Optional[pulumi.Input['AgentToolToolConfigTableAndColumnDescriptionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] tool_config_type: (Updatable) The type of the Tool config. The allowed values are:
               * `SQL_TOOL_CONFIG`: The config for sql Tool.
               * `RAG_TOOL_CONFIG`: The config for rag Tool.
               * FUNCTION_CALLING_TOOL_CONFIG: The config for Function calling Tool.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input['AgentToolToolConfigDatabaseConnectionArgs'] database_connection: (Updatable) The connection type for Databases.
        :param pulumi.Input['AgentToolToolConfigDatabaseSchemaArgs'] database_schema: (Updatable) The input location definition.
        :param pulumi.Input[_builtins.str] dialect: (Updatable) Dialect to be used for SQL generation.
        :param pulumi.Input['AgentToolToolConfigFunctionArgs'] function: (Updatable) Details of Function for Function calling tool.
        :param pulumi.Input['AgentToolToolConfigGenerationLlmCustomizationArgs'] generation_llm_customization: (Updatable) Configuration to customize LLM.
        :param pulumi.Input['AgentToolToolConfigIclExamplesArgs'] icl_examples: (Updatable) The input location definition.
        :param pulumi.Input[Sequence[pulumi.Input['AgentToolToolConfigKnowledgeBaseConfigArgs']]] knowledge_base_configs: (Updatable) The KnowledgeBase configurations that this RAG Tool uses
        :param pulumi.Input[_builtins.str] model_size: (Updatable) Size of the model.
        :param pulumi.Input[_builtins.bool] should_enable_self_correction: (Updatable) To enable/disable self correction.
        :param pulumi.Input[_builtins.bool] should_enable_sql_execution: (Updatable) To enable/disable SQL execution.
        :param pulumi.Input['AgentToolToolConfigTableAndColumnDescriptionArgs'] table_and_column_description: (Updatable) The input location definition.
        """
        pulumi.set(__self__, "tool_config_type", tool_config_type)
        if database_connection is not None:
            pulumi.set(__self__, "database_connection", database_connection)
        if database_schema is not None:
            pulumi.set(__self__, "database_schema", database_schema)
        if dialect is not None:
            pulumi.set(__self__, "dialect", dialect)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if generation_llm_customization is not None:
            pulumi.set(__self__, "generation_llm_customization", generation_llm_customization)
        if icl_examples is not None:
            pulumi.set(__self__, "icl_examples", icl_examples)
        if knowledge_base_configs is not None:
            pulumi.set(__self__, "knowledge_base_configs", knowledge_base_configs)
        if model_size is not None:
            pulumi.set(__self__, "model_size", model_size)
        if should_enable_self_correction is not None:
            pulumi.set(__self__, "should_enable_self_correction", should_enable_self_correction)
        if should_enable_sql_execution is not None:
            pulumi.set(__self__, "should_enable_sql_execution", should_enable_sql_execution)
        if table_and_column_description is not None:
            pulumi.set(__self__, "table_and_column_description", table_and_column_description)

    @_builtins.property
    @pulumi.getter(name="toolConfigType")
    def tool_config_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of the Tool config. The allowed values are:
        * `SQL_TOOL_CONFIG`: The config for sql Tool.
        * `RAG_TOOL_CONFIG`: The config for rag Tool.
        * FUNCTION_CALLING_TOOL_CONFIG: The config for Function calling Tool.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "tool_config_type")

    @tool_config_type.setter
    def tool_config_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tool_config_type", value)

    @_builtins.property
    @pulumi.getter(name="databaseConnection")
    def database_connection(self) -> Optional[pulumi.Input['AgentToolToolConfigDatabaseConnectionArgs']]:
        """
        (Updatable) The connection type for Databases.
        """
        return pulumi.get(self, "database_connection")

    @database_connection.setter
    def database_connection(self, value: Optional[pulumi.Input['AgentToolToolConfigDatabaseConnectionArgs']]):
        pulumi.set(self, "database_connection", value)

    @_builtins.property
    @pulumi.getter(name="databaseSchema")
    def database_schema(self) -> Optional[pulumi.Input['AgentToolToolConfigDatabaseSchemaArgs']]:
        """
        (Updatable) The input location definition.
        """
        return pulumi.get(self, "database_schema")

    @database_schema.setter
    def database_schema(self, value: Optional[pulumi.Input['AgentToolToolConfigDatabaseSchemaArgs']]):
        pulumi.set(self, "database_schema", value)

    @_builtins.property
    @pulumi.getter
    def dialect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Dialect to be used for SQL generation.
        """
        return pulumi.get(self, "dialect")

    @dialect.setter
    def dialect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dialect", value)

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input['AgentToolToolConfigFunctionArgs']]:
        """
        (Updatable) Details of Function for Function calling tool.
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input['AgentToolToolConfigFunctionArgs']]):
        pulumi.set(self, "function", value)

    @_builtins.property
    @pulumi.getter(name="generationLlmCustomization")
    def generation_llm_customization(self) -> Optional[pulumi.Input['AgentToolToolConfigGenerationLlmCustomizationArgs']]:
        """
        (Updatable) Configuration to customize LLM.
        """
        return pulumi.get(self, "generation_llm_customization")

    @generation_llm_customization.setter
    def generation_llm_customization(self, value: Optional[pulumi.Input['AgentToolToolConfigGenerationLlmCustomizationArgs']]):
        pulumi.set(self, "generation_llm_customization", value)

    @_builtins.property
    @pulumi.getter(name="iclExamples")
    def icl_examples(self) -> Optional[pulumi.Input['AgentToolToolConfigIclExamplesArgs']]:
        """
        (Updatable) The input location definition.
        """
        return pulumi.get(self, "icl_examples")

    @icl_examples.setter
    def icl_examples(self, value: Optional[pulumi.Input['AgentToolToolConfigIclExamplesArgs']]):
        pulumi.set(self, "icl_examples", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseConfigs")
    def knowledge_base_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentToolToolConfigKnowledgeBaseConfigArgs']]]]:
        """
        (Updatable) The KnowledgeBase configurations that this RAG Tool uses
        """
        return pulumi.get(self, "knowledge_base_configs")

    @knowledge_base_configs.setter
    def knowledge_base_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentToolToolConfigKnowledgeBaseConfigArgs']]]]):
        pulumi.set(self, "knowledge_base_configs", value)

    @_builtins.property
    @pulumi.getter(name="modelSize")
    def model_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Size of the model.
        """
        return pulumi.get(self, "model_size")

    @model_size.setter
    def model_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_size", value)

    @_builtins.property
    @pulumi.getter(name="shouldEnableSelfCorrection")
    def should_enable_self_correction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) To enable/disable self correction.
        """
        return pulumi.get(self, "should_enable_self_correction")

    @should_enable_self_correction.setter
    def should_enable_self_correction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_enable_self_correction", value)

    @_builtins.property
    @pulumi.getter(name="shouldEnableSqlExecution")
    def should_enable_sql_execution(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) To enable/disable SQL execution.
        """
        return pulumi.get(self, "should_enable_sql_execution")

    @should_enable_sql_execution.setter
    def should_enable_sql_execution(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_enable_sql_execution", value)

    @_builtins.property
    @pulumi.getter(name="tableAndColumnDescription")
    def table_and_column_description(self) -> Optional[pulumi.Input['AgentToolToolConfigTableAndColumnDescriptionArgs']]:
        """
        (Updatable) The input location definition.
        """
        return pulumi.get(self, "table_and_column_description")

    @table_and_column_description.setter
    def table_and_column_description(self, value: Optional[pulumi.Input['AgentToolToolConfigTableAndColumnDescriptionArgs']]):
        pulumi.set(self, "table_and_column_description", value)


if not MYPY:
    class AgentToolToolConfigDatabaseConnectionArgsDict(TypedDict):
        connection_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        """
        connection_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of Database connection. The allowed values are:
        * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
elif False:
    AgentToolToolConfigDatabaseConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigDatabaseConnectionArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[_builtins.str],
                 connection_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] connection_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        :param pulumi.Input[_builtins.str] connection_type: (Updatable) The type of Database connection. The allowed values are:
               * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "connection_type", connection_type)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of Database connection. The allowed values are:
        * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_type", value)


if not MYPY:
    class AgentToolToolConfigDatabaseSchemaArgsDict(TypedDict):
        input_location_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of InputLocation. The allowed values are:
        * `INLINE`: The input location is inline.
        * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The bucket name of an object.
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Inline content as input.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The namespace name of an object.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The prefix of file object(s) or folder prefix.
        """
elif False:
    AgentToolToolConfigDatabaseSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigDatabaseSchemaArgs:
    def __init__(__self__, *,
                 input_location_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_location_type: (Updatable) Type of InputLocation. The allowed values are:
               * `INLINE`: The input location is inline.
               * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The bucket name of an object.
        :param pulumi.Input[_builtins.str] content: (Updatable) Inline content as input.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace name of an object.
        :param pulumi.Input[_builtins.str] prefix: (Updatable) The prefix of file object(s) or folder prefix.
        """
        pulumi.set(__self__, "input_location_type", input_location_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="inputLocationType")
    def input_location_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of InputLocation. The allowed values are:
        * `INLINE`: The input location is inline.
        * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        """
        return pulumi.get(self, "input_location_type")

    @input_location_type.setter
    def input_location_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_location_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The bucket name of an object.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Inline content as input.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The namespace name of an object.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The prefix of file object(s) or folder prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AgentToolToolConfigFunctionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A description of the function.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the function to invoke.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The parameters the function accepts, defined using a JSON Schema object.  Refer to the guide for examples and the JSON Schema documentation for details on the format.
        """
elif False:
    AgentToolToolConfigFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigFunctionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) A description of the function.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the function to invoke.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameters: (Updatable) The parameters the function accepts, defined using a JSON Schema object.  Refer to the guide for examples and the JSON Schema documentation for details on the format.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A description of the function.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the function to invoke.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The parameters the function accepts, defined using a JSON Schema object.  Refer to the guide for examples and the JSON Schema documentation for details on the format.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class AgentToolToolConfigGenerationLlmCustomizationArgsDict(TypedDict):
        instruction: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If specified, the default instruction is replaced with provided instruction.
        """
elif False:
    AgentToolToolConfigGenerationLlmCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigGenerationLlmCustomizationArgs:
    def __init__(__self__, *,
                 instruction: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instruction: (Updatable) If specified, the default instruction is replaced with provided instruction.
        """
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If specified, the default instruction is replaced with provided instruction.
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instruction", value)


if not MYPY:
    class AgentToolToolConfigIclExamplesArgsDict(TypedDict):
        input_location_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of InputLocation. The allowed values are:
        * `INLINE`: The input location is inline.
        * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The bucket name of an object.
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Inline content as input.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The namespace name of an object.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The prefix of file object(s) or folder prefix.
        """
elif False:
    AgentToolToolConfigIclExamplesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigIclExamplesArgs:
    def __init__(__self__, *,
                 input_location_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_location_type: (Updatable) Type of InputLocation. The allowed values are:
               * `INLINE`: The input location is inline.
               * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The bucket name of an object.
        :param pulumi.Input[_builtins.str] content: (Updatable) Inline content as input.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace name of an object.
        :param pulumi.Input[_builtins.str] prefix: (Updatable) The prefix of file object(s) or folder prefix.
        """
        pulumi.set(__self__, "input_location_type", input_location_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="inputLocationType")
    def input_location_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of InputLocation. The allowed values are:
        * `INLINE`: The input location is inline.
        * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        """
        return pulumi.get(self, "input_location_type")

    @input_location_type.setter
    def input_location_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_location_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The bucket name of an object.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Inline content as input.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The namespace name of an object.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The prefix of file object(s) or folder prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AgentToolToolConfigKnowledgeBaseConfigArgsDict(TypedDict):
        knowledge_base_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the knowledgeBase this RAG Tool uses
        """
elif False:
    AgentToolToolConfigKnowledgeBaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigKnowledgeBaseConfigArgs:
    def __init__(__self__, *,
                 knowledge_base_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] knowledge_base_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the knowledgeBase this RAG Tool uses
        """
        if knowledge_base_id is not None:
            pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the knowledgeBase this RAG Tool uses
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "knowledge_base_id", value)


if not MYPY:
    class AgentToolToolConfigTableAndColumnDescriptionArgsDict(TypedDict):
        input_location_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of InputLocation. The allowed values are:
        * `INLINE`: The input location is inline.
        * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The bucket name of an object.
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Inline content as input.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The namespace name of an object.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The prefix of file object(s) or folder prefix.
        """
elif False:
    AgentToolToolConfigTableAndColumnDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolToolConfigTableAndColumnDescriptionArgs:
    def __init__(__self__, *,
                 input_location_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_location_type: (Updatable) Type of InputLocation. The allowed values are:
               * `INLINE`: The input location is inline.
               * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The bucket name of an object.
        :param pulumi.Input[_builtins.str] content: (Updatable) Inline content as input.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace name of an object.
        :param pulumi.Input[_builtins.str] prefix: (Updatable) The prefix of file object(s) or folder prefix.
        """
        pulumi.set(__self__, "input_location_type", input_location_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="inputLocationType")
    def input_location_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of InputLocation. The allowed values are:
        * `INLINE`: The input location is inline.
        * `OBJECT_STORAGE_PREFIX`: The input location is object storage.
        """
        return pulumi.get(self, "input_location_type")

    @input_location_type.setter
    def input_location_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_location_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The bucket name of an object.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Inline content as input.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The namespace name of an object.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The prefix of file object(s) or folder prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class DedicatedAiClusterCapacityArgsDict(TypedDict):
        capacity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the dedicated AI cluster capacity.
        """
        total_endpoint_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of endpoints that can be hosted on this dedicated AI cluster.
        """
        used_endpoint_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of endpoints hosted on this dedicated AI cluster.
        """
elif False:
    DedicatedAiClusterCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DedicatedAiClusterCapacityArgs:
    def __init__(__self__, *,
                 capacity_type: Optional[pulumi.Input[_builtins.str]] = None,
                 total_endpoint_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 used_endpoint_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_type: The type of the dedicated AI cluster capacity.
        :param pulumi.Input[_builtins.int] total_endpoint_capacity: The total number of endpoints that can be hosted on this dedicated AI cluster.
        :param pulumi.Input[_builtins.int] used_endpoint_capacity: The number of endpoints hosted on this dedicated AI cluster.
        """
        if capacity_type is not None:
            pulumi.set(__self__, "capacity_type", capacity_type)
        if total_endpoint_capacity is not None:
            pulumi.set(__self__, "total_endpoint_capacity", total_endpoint_capacity)
        if used_endpoint_capacity is not None:
            pulumi.set(__self__, "used_endpoint_capacity", used_endpoint_capacity)

    @_builtins.property
    @pulumi.getter(name="capacityType")
    def capacity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the dedicated AI cluster capacity.
        """
        return pulumi.get(self, "capacity_type")

    @capacity_type.setter
    def capacity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "capacity_type", value)

    @_builtins.property
    @pulumi.getter(name="totalEndpointCapacity")
    def total_endpoint_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of endpoints that can be hosted on this dedicated AI cluster.
        """
        return pulumi.get(self, "total_endpoint_capacity")

    @total_endpoint_capacity.setter
    def total_endpoint_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_endpoint_capacity", value)

    @_builtins.property
    @pulumi.getter(name="usedEndpointCapacity")
    def used_endpoint_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of endpoints hosted on this dedicated AI cluster.
        """
        return pulumi.get(self, "used_endpoint_capacity")

    @used_endpoint_capacity.setter
    def used_endpoint_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "used_endpoint_capacity", value)


if not MYPY:
    class EndpointContentModerationConfigArgsDict(TypedDict):
        is_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) Whether to enable the content moderation feature.
        """
elif False:
    EndpointContentModerationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointContentModerationConfigArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Whether to enable the content moderation feature.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Whether to enable the content moderation feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ModelFineTuneDetailsArgsDict(TypedDict):
        dedicated_ai_cluster_id: pulumi.Input[_builtins.str]
        """
        The OCID of the dedicated AI cluster this fine-tuning runs on.
        """
        training_dataset: pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgsDict']
        """
        The dataset used to fine-tune the model. 

        Only one dataset is allowed per custom model, which is split 80-20 for training and validating. You must provide the dataset in a JSON Lines (JSONL) file. Each line in the JSONL file must have the format: `{"prompt": "<first prompt>", "completion": "<expected completion given first prompt>"}`
        """
        training_config: NotRequired[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgsDict']]
        """
        The fine-tuning method and hyperparameters used for fine-tuning a custom model.
        """
elif False:
    ModelFineTuneDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelFineTuneDetailsArgs:
    def __init__(__self__, *,
                 dedicated_ai_cluster_id: pulumi.Input[_builtins.str],
                 training_dataset: pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs'],
                 training_config: Optional[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] dedicated_ai_cluster_id: The OCID of the dedicated AI cluster this fine-tuning runs on.
        :param pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs'] training_dataset: The dataset used to fine-tune the model. 
               
               Only one dataset is allowed per custom model, which is split 80-20 for training and validating. You must provide the dataset in a JSON Lines (JSONL) file. Each line in the JSONL file must have the format: `{"prompt": "<first prompt>", "completion": "<expected completion given first prompt>"}`
        :param pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs'] training_config: The fine-tuning method and hyperparameters used for fine-tuning a custom model.
        """
        pulumi.set(__self__, "dedicated_ai_cluster_id", dedicated_ai_cluster_id)
        pulumi.set(__self__, "training_dataset", training_dataset)
        if training_config is not None:
            pulumi.set(__self__, "training_config", training_config)

    @_builtins.property
    @pulumi.getter(name="dedicatedAiClusterId")
    def dedicated_ai_cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        The OCID of the dedicated AI cluster this fine-tuning runs on.
        """
        return pulumi.get(self, "dedicated_ai_cluster_id")

    @dedicated_ai_cluster_id.setter
    def dedicated_ai_cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dedicated_ai_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="trainingDataset")
    def training_dataset(self) -> pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs']:
        """
        The dataset used to fine-tune the model. 

        Only one dataset is allowed per custom model, which is split 80-20 for training and validating. You must provide the dataset in a JSON Lines (JSONL) file. Each line in the JSONL file must have the format: `{"prompt": "<first prompt>", "completion": "<expected completion given first prompt>"}`
        """
        return pulumi.get(self, "training_dataset")

    @training_dataset.setter
    def training_dataset(self, value: pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs']):
        pulumi.set(self, "training_dataset", value)

    @_builtins.property
    @pulumi.getter(name="trainingConfig")
    def training_config(self) -> Optional[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs']]:
        """
        The fine-tuning method and hyperparameters used for fine-tuning a custom model.
        """
        return pulumi.get(self, "training_config")

    @training_config.setter
    def training_config(self, value: Optional[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs']]):
        pulumi.set(self, "training_config", value)


if not MYPY:
    class ModelFineTuneDetailsTrainingConfigArgsDict(TypedDict):
        training_config_type: pulumi.Input[_builtins.str]
        """
        The fine-tuning method for training a custom model.
        """
        early_stopping_patience: NotRequired[pulumi.Input[_builtins.int]]
        """
        Stop training if the loss metric does not improve beyond 'early_stopping_threshold' for this many times of evaluation.
        """
        early_stopping_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        How much the loss must improve to prevent early stopping.
        """
        learning_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The initial learning rate to be used during training
        """
        log_model_metrics_interval_in_steps: NotRequired[pulumi.Input[_builtins.int]]
        """
        Determines how frequently to log model metrics. 

        Every step is logged for the first 20 steps and then follows this parameter for log frequency. Set to 0 to disable logging the model metrics.
        """
        lora_alpha: NotRequired[pulumi.Input[_builtins.int]]
        """
        This parameter represents the scaling factor for the weight matrices in LoRA.
        """
        lora_dropout: NotRequired[pulumi.Input[_builtins.float]]
        """
        This parameter indicates the dropout probability for LoRA layers.
        """
        lora_r: NotRequired[pulumi.Input[_builtins.int]]
        """
        This parameter represents the LoRA rank of the update matrices.
        """
        num_of_last_layers: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of last layers to be fine-tuned.
        """
        total_training_epochs: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of training epochs to run for.
        """
        training_batch_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The batch size used during training.
        """
elif False:
    ModelFineTuneDetailsTrainingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelFineTuneDetailsTrainingConfigArgs:
    def __init__(__self__, *,
                 training_config_type: pulumi.Input[_builtins.str],
                 early_stopping_patience: Optional[pulumi.Input[_builtins.int]] = None,
                 early_stopping_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 learning_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 log_model_metrics_interval_in_steps: Optional[pulumi.Input[_builtins.int]] = None,
                 lora_alpha: Optional[pulumi.Input[_builtins.int]] = None,
                 lora_dropout: Optional[pulumi.Input[_builtins.float]] = None,
                 lora_r: Optional[pulumi.Input[_builtins.int]] = None,
                 num_of_last_layers: Optional[pulumi.Input[_builtins.int]] = None,
                 total_training_epochs: Optional[pulumi.Input[_builtins.int]] = None,
                 training_batch_size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] training_config_type: The fine-tuning method for training a custom model.
        :param pulumi.Input[_builtins.int] early_stopping_patience: Stop training if the loss metric does not improve beyond 'early_stopping_threshold' for this many times of evaluation.
        :param pulumi.Input[_builtins.float] early_stopping_threshold: How much the loss must improve to prevent early stopping.
        :param pulumi.Input[_builtins.float] learning_rate: The initial learning rate to be used during training
        :param pulumi.Input[_builtins.int] log_model_metrics_interval_in_steps: Determines how frequently to log model metrics. 
               
               Every step is logged for the first 20 steps and then follows this parameter for log frequency. Set to 0 to disable logging the model metrics.
        :param pulumi.Input[_builtins.int] lora_alpha: This parameter represents the scaling factor for the weight matrices in LoRA.
        :param pulumi.Input[_builtins.float] lora_dropout: This parameter indicates the dropout probability for LoRA layers.
        :param pulumi.Input[_builtins.int] lora_r: This parameter represents the LoRA rank of the update matrices.
        :param pulumi.Input[_builtins.int] num_of_last_layers: The number of last layers to be fine-tuned.
        :param pulumi.Input[_builtins.int] total_training_epochs: The maximum number of training epochs to run for.
        :param pulumi.Input[_builtins.int] training_batch_size: The batch size used during training.
        """
        pulumi.set(__self__, "training_config_type", training_config_type)
        if early_stopping_patience is not None:
            pulumi.set(__self__, "early_stopping_patience", early_stopping_patience)
        if early_stopping_threshold is not None:
            pulumi.set(__self__, "early_stopping_threshold", early_stopping_threshold)
        if learning_rate is not None:
            pulumi.set(__self__, "learning_rate", learning_rate)
        if log_model_metrics_interval_in_steps is not None:
            pulumi.set(__self__, "log_model_metrics_interval_in_steps", log_model_metrics_interval_in_steps)
        if lora_alpha is not None:
            pulumi.set(__self__, "lora_alpha", lora_alpha)
        if lora_dropout is not None:
            pulumi.set(__self__, "lora_dropout", lora_dropout)
        if lora_r is not None:
            pulumi.set(__self__, "lora_r", lora_r)
        if num_of_last_layers is not None:
            pulumi.set(__self__, "num_of_last_layers", num_of_last_layers)
        if total_training_epochs is not None:
            pulumi.set(__self__, "total_training_epochs", total_training_epochs)
        if training_batch_size is not None:
            pulumi.set(__self__, "training_batch_size", training_batch_size)

    @_builtins.property
    @pulumi.getter(name="trainingConfigType")
    def training_config_type(self) -> pulumi.Input[_builtins.str]:
        """
        The fine-tuning method for training a custom model.
        """
        return pulumi.get(self, "training_config_type")

    @training_config_type.setter
    def training_config_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "training_config_type", value)

    @_builtins.property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Stop training if the loss metric does not improve beyond 'early_stopping_threshold' for this many times of evaluation.
        """
        return pulumi.get(self, "early_stopping_patience")

    @early_stopping_patience.setter
    def early_stopping_patience(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "early_stopping_patience", value)

    @_builtins.property
    @pulumi.getter(name="earlyStoppingThreshold")
    def early_stopping_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        How much the loss must improve to prevent early stopping.
        """
        return pulumi.get(self, "early_stopping_threshold")

    @early_stopping_threshold.setter
    def early_stopping_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "early_stopping_threshold", value)

    @_builtins.property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The initial learning rate to be used during training
        """
        return pulumi.get(self, "learning_rate")

    @learning_rate.setter
    def learning_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "learning_rate", value)

    @_builtins.property
    @pulumi.getter(name="logModelMetricsIntervalInSteps")
    def log_model_metrics_interval_in_steps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Determines how frequently to log model metrics. 

        Every step is logged for the first 20 steps and then follows this parameter for log frequency. Set to 0 to disable logging the model metrics.
        """
        return pulumi.get(self, "log_model_metrics_interval_in_steps")

    @log_model_metrics_interval_in_steps.setter
    def log_model_metrics_interval_in_steps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "log_model_metrics_interval_in_steps", value)

    @_builtins.property
    @pulumi.getter(name="loraAlpha")
    def lora_alpha(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        This parameter represents the scaling factor for the weight matrices in LoRA.
        """
        return pulumi.get(self, "lora_alpha")

    @lora_alpha.setter
    def lora_alpha(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lora_alpha", value)

    @_builtins.property
    @pulumi.getter(name="loraDropout")
    def lora_dropout(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        This parameter indicates the dropout probability for LoRA layers.
        """
        return pulumi.get(self, "lora_dropout")

    @lora_dropout.setter
    def lora_dropout(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lora_dropout", value)

    @_builtins.property
    @pulumi.getter(name="loraR")
    def lora_r(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        This parameter represents the LoRA rank of the update matrices.
        """
        return pulumi.get(self, "lora_r")

    @lora_r.setter
    def lora_r(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lora_r", value)

    @_builtins.property
    @pulumi.getter(name="numOfLastLayers")
    def num_of_last_layers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of last layers to be fine-tuned.
        """
        return pulumi.get(self, "num_of_last_layers")

    @num_of_last_layers.setter
    def num_of_last_layers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_of_last_layers", value)

    @_builtins.property
    @pulumi.getter(name="totalTrainingEpochs")
    def total_training_epochs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of training epochs to run for.
        """
        return pulumi.get(self, "total_training_epochs")

    @total_training_epochs.setter
    def total_training_epochs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_training_epochs", value)

    @_builtins.property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The batch size used during training.
        """
        return pulumi.get(self, "training_batch_size")

    @training_batch_size.setter
    def training_batch_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "training_batch_size", value)


if not MYPY:
    class ModelFineTuneDetailsTrainingDatasetArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The Object Storage bucket name.
        """
        dataset_type: pulumi.Input[_builtins.str]
        """
        The type of the data asset.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        The Object Storage namespace.
        """
        object: pulumi.Input[_builtins.str]
        """
        The Object Storage object name.
        """
elif False:
    ModelFineTuneDetailsTrainingDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelFineTuneDetailsTrainingDatasetArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 dataset_type: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 object: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: The Object Storage bucket name.
        :param pulumi.Input[_builtins.str] dataset_type: The type of the data asset.
        :param pulumi.Input[_builtins.str] namespace: The Object Storage namespace.
        :param pulumi.Input[_builtins.str] object: The Object Storage object name.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data asset.
        """
        return pulumi.get(self, "dataset_type")

    @dataset_type.setter
    def dataset_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset_type", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        The Object Storage namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input[_builtins.str]:
        """
        The Object Storage object name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object", value)


if not MYPY:
    class ModelModelMetricArgsDict(TypedDict):
        final_accuracy: NotRequired[pulumi.Input[_builtins.float]]
        """
        Fine-tuned model accuracy.
        """
        final_loss: NotRequired[pulumi.Input[_builtins.float]]
        """
        Fine-tuned model loss.
        """
        model_metrics_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the model metrics. Each type of model can expect a different set of model metrics.
        """
elif False:
    ModelModelMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelModelMetricArgs:
    def __init__(__self__, *,
                 final_accuracy: Optional[pulumi.Input[_builtins.float]] = None,
                 final_loss: Optional[pulumi.Input[_builtins.float]] = None,
                 model_metrics_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] final_accuracy: Fine-tuned model accuracy.
        :param pulumi.Input[_builtins.float] final_loss: Fine-tuned model loss.
        :param pulumi.Input[_builtins.str] model_metrics_type: The type of the model metrics. Each type of model can expect a different set of model metrics.
        """
        if final_accuracy is not None:
            pulumi.set(__self__, "final_accuracy", final_accuracy)
        if final_loss is not None:
            pulumi.set(__self__, "final_loss", final_loss)
        if model_metrics_type is not None:
            pulumi.set(__self__, "model_metrics_type", model_metrics_type)

    @_builtins.property
    @pulumi.getter(name="finalAccuracy")
    def final_accuracy(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Fine-tuned model accuracy.
        """
        return pulumi.get(self, "final_accuracy")

    @final_accuracy.setter
    def final_accuracy(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "final_accuracy", value)

    @_builtins.property
    @pulumi.getter(name="finalLoss")
    def final_loss(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Fine-tuned model loss.
        """
        return pulumi.get(self, "final_loss")

    @final_loss.setter
    def final_loss(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "final_loss", value)

    @_builtins.property
    @pulumi.getter(name="modelMetricsType")
    def model_metrics_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the model metrics. Each type of model can expect a different set of model metrics.
        """
        return pulumi.get(self, "model_metrics_type")

    @model_metrics_type.setter
    def model_metrics_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_metrics_type", value)


if not MYPY:
    class GetAgentAgentEndpointsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAgentAgentEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentAgentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAgentAgentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentDataIngestionJobsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAgentDataIngestionJobsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentDataIngestionJobsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentDataSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAgentDataSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentDataSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentKnowledgeBasesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The index name in opensearch.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAgentKnowledgeBasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentKnowledgeBasesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The index name in opensearch.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The index name in opensearch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentToolsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the function to invoke.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAgentToolsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentToolsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the function to invoke.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the function to invoke.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDedicatedAiClustersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDedicatedAiClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDedicatedAiClustersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetEndpointsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


