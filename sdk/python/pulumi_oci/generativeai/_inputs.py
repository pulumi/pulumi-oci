# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAgentEndpointContentModerationConfigArgs',
    'AgentAgentEndpointContentModerationConfigArgsDict',
    'AgentAgentEndpointSessionConfigArgs',
    'AgentAgentEndpointSessionConfigArgsDict',
    'AgentDataIngestionJobDataIngestionJobStatisticArgs',
    'AgentDataIngestionJobDataIngestionJobStatisticArgsDict',
    'AgentDataSourceDataSourceConfigArgs',
    'AgentDataSourceDataSourceConfigArgsDict',
    'AgentDataSourceDataSourceConfigObjectStoragePrefixArgs',
    'AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict',
    'AgentKnowledgeBaseIndexConfigArgs',
    'AgentKnowledgeBaseIndexConfigArgsDict',
    'AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs',
    'AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict',
    'AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs',
    'AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict',
    'AgentKnowledgeBaseIndexConfigIndexArgs',
    'AgentKnowledgeBaseIndexConfigIndexArgsDict',
    'AgentKnowledgeBaseIndexConfigIndexSchemaArgs',
    'AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict',
    'AgentKnowledgeBaseIndexConfigSecretDetailArgs',
    'AgentKnowledgeBaseIndexConfigSecretDetailArgsDict',
    'DedicatedAiClusterCapacityArgs',
    'DedicatedAiClusterCapacityArgsDict',
    'EndpointContentModerationConfigArgs',
    'EndpointContentModerationConfigArgsDict',
    'ModelFineTuneDetailsArgs',
    'ModelFineTuneDetailsArgsDict',
    'ModelFineTuneDetailsTrainingConfigArgs',
    'ModelFineTuneDetailsTrainingConfigArgsDict',
    'ModelFineTuneDetailsTrainingDatasetArgs',
    'ModelFineTuneDetailsTrainingDatasetArgsDict',
    'ModelModelMetricArgs',
    'ModelModelMetricArgsDict',
    'GetAgentAgentEndpointsFilterArgs',
    'GetAgentAgentEndpointsFilterArgsDict',
    'GetAgentAgentsFilterArgs',
    'GetAgentAgentsFilterArgsDict',
    'GetAgentDataIngestionJobsFilterArgs',
    'GetAgentDataIngestionJobsFilterArgsDict',
    'GetAgentDataSourcesFilterArgs',
    'GetAgentDataSourcesFilterArgsDict',
    'GetAgentKnowledgeBasesFilterArgs',
    'GetAgentKnowledgeBasesFilterArgsDict',
    'GetDedicatedAiClustersFilterArgs',
    'GetDedicatedAiClustersFilterArgsDict',
    'GetEndpointsFilterArgs',
    'GetEndpointsFilterArgsDict',
    'GetModelsFilterArgs',
    'GetModelsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAgentEndpointContentModerationConfigArgsDict(TypedDict):
        should_enable_on_input: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) A flag to enable or disable content moderation on input.
        """
        should_enable_on_output: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) A flag to enable or disable content moderation on output.
        """
elif False:
    AgentAgentEndpointContentModerationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointContentModerationConfigArgs:
    def __init__(__self__, *,
                 should_enable_on_input: Optional[pulumi.Input[bool]] = None,
                 should_enable_on_output: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_enable_on_input: (Updatable) A flag to enable or disable content moderation on input.
        :param pulumi.Input[bool] should_enable_on_output: (Updatable) A flag to enable or disable content moderation on output.
        """
        if should_enable_on_input is not None:
            pulumi.set(__self__, "should_enable_on_input", should_enable_on_input)
        if should_enable_on_output is not None:
            pulumi.set(__self__, "should_enable_on_output", should_enable_on_output)

    @property
    @pulumi.getter(name="shouldEnableOnInput")
    def should_enable_on_input(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A flag to enable or disable content moderation on input.
        """
        return pulumi.get(self, "should_enable_on_input")

    @should_enable_on_input.setter
    def should_enable_on_input(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_enable_on_input", value)

    @property
    @pulumi.getter(name="shouldEnableOnOutput")
    def should_enable_on_output(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A flag to enable or disable content moderation on output.
        """
        return pulumi.get(self, "should_enable_on_output")

    @should_enable_on_output.setter
    def should_enable_on_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_enable_on_output", value)


if not MYPY:
    class AgentAgentEndpointSessionConfigArgsDict(TypedDict):
        idle_timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The session will become inactive after this timeout.
        """
elif False:
    AgentAgentEndpointSessionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentEndpointSessionConfigArgs:
    def __init__(__self__, *,
                 idle_timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] idle_timeout_in_seconds: (Updatable) The session will become inactive after this timeout.
        """
        if idle_timeout_in_seconds is not None:
            pulumi.set(__self__, "idle_timeout_in_seconds", idle_timeout_in_seconds)

    @property
    @pulumi.getter(name="idleTimeoutInSeconds")
    def idle_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The session will become inactive after this timeout.
        """
        return pulumi.get(self, "idle_timeout_in_seconds")

    @idle_timeout_in_seconds.setter
    def idle_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_seconds", value)


if not MYPY:
    class AgentDataIngestionJobDataIngestionJobStatisticArgsDict(TypedDict):
        duration_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The duration of this ingestion job.
        """
        number_of_failed_files: NotRequired[pulumi.Input[int]]
        """
        The number of files that have failed during the ingestion.
        """
        number_of_ingested_files: NotRequired[pulumi.Input[int]]
        """
        The number of files that have been successfully ingested during the ingestion.
        """
elif False:
    AgentDataIngestionJobDataIngestionJobStatisticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataIngestionJobDataIngestionJobStatisticArgs:
    def __init__(__self__, *,
                 duration_in_seconds: Optional[pulumi.Input[int]] = None,
                 number_of_failed_files: Optional[pulumi.Input[int]] = None,
                 number_of_ingested_files: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration_in_seconds: The duration of this ingestion job.
        :param pulumi.Input[int] number_of_failed_files: The number of files that have failed during the ingestion.
        :param pulumi.Input[int] number_of_ingested_files: The number of files that have been successfully ingested during the ingestion.
        """
        if duration_in_seconds is not None:
            pulumi.set(__self__, "duration_in_seconds", duration_in_seconds)
        if number_of_failed_files is not None:
            pulumi.set(__self__, "number_of_failed_files", number_of_failed_files)
        if number_of_ingested_files is not None:
            pulumi.set(__self__, "number_of_ingested_files", number_of_ingested_files)

    @property
    @pulumi.getter(name="durationInSeconds")
    def duration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration of this ingestion job.
        """
        return pulumi.get(self, "duration_in_seconds")

    @duration_in_seconds.setter
    def duration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_in_seconds", value)

    @property
    @pulumi.getter(name="numberOfFailedFiles")
    def number_of_failed_files(self) -> Optional[pulumi.Input[int]]:
        """
        The number of files that have failed during the ingestion.
        """
        return pulumi.get(self, "number_of_failed_files")

    @number_of_failed_files.setter
    def number_of_failed_files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_failed_files", value)

    @property
    @pulumi.getter(name="numberOfIngestedFiles")
    def number_of_ingested_files(self) -> Optional[pulumi.Input[int]]:
        """
        The number of files that have been successfully ingested during the ingestion.
        """
        return pulumi.get(self, "number_of_ingested_files")

    @number_of_ingested_files.setter
    def number_of_ingested_files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_ingested_files", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigArgsDict(TypedDict):
        data_source_config_type: pulumi.Input[str]
        """
        (Updatable) The type of the tool. The allowed values are:
        * `OCI_OBJECT_STORAGE`: The data source is Oracle Cloud Infrastructure Object Storage.
        """
        object_storage_prefixes: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict']]]
        """
        (Updatable) The locations of data items in Object Storage, can either be an object (File) or a prefix (folder).
        """
elif False:
    AgentDataSourceDataSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigArgs:
    def __init__(__self__, *,
                 data_source_config_type: pulumi.Input[str],
                 object_storage_prefixes: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]]):
        """
        :param pulumi.Input[str] data_source_config_type: (Updatable) The type of the tool. The allowed values are:
               * `OCI_OBJECT_STORAGE`: The data source is Oracle Cloud Infrastructure Object Storage.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]] object_storage_prefixes: (Updatable) The locations of data items in Object Storage, can either be an object (File) or a prefix (folder).
        """
        pulumi.set(__self__, "data_source_config_type", data_source_config_type)
        pulumi.set(__self__, "object_storage_prefixes", object_storage_prefixes)

    @property
    @pulumi.getter(name="dataSourceConfigType")
    def data_source_config_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of the tool. The allowed values are:
        * `OCI_OBJECT_STORAGE`: The data source is Oracle Cloud Infrastructure Object Storage.
        """
        return pulumi.get(self, "data_source_config_type")

    @data_source_config_type.setter
    def data_source_config_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source_config_type", value)

    @property
    @pulumi.getter(name="objectStoragePrefixes")
    def object_storage_prefixes(self) -> pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]]:
        """
        (Updatable) The locations of data items in Object Storage, can either be an object (File) or a prefix (folder).
        """
        return pulumi.get(self, "object_storage_prefixes")

    @object_storage_prefixes.setter
    def object_storage_prefixes(self, value: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigObjectStoragePrefixArgs']]]):
        pulumi.set(self, "object_storage_prefixes", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        (Updatable) The bucket name of an object.
        """
        namespace: pulumi.Input[str]
        """
        (Updatable) The namespace name of an object.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the object (file) or prefix (folder).
        """
elif False:
    AgentDataSourceDataSourceConfigObjectStoragePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigObjectStoragePrefixArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: (Updatable) The bucket name of an object.
        :param pulumi.Input[str] namespace: (Updatable) The namespace name of an object.
        :param pulumi.Input[str] prefix: (Updatable) The name of the object (file) or prefix (folder).
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        (Updatable) The bucket name of an object.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        (Updatable) The namespace name of an object.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the object (file) or prefix (folder).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigArgsDict(TypedDict):
        index_config_type: pulumi.Input[str]
        """
        (Updatable) The type of index. The allowed values are:
        * `DEFAULT_INDEX_CONFIG`: DefaultIndexConfig allows the service to create and manage vector store on behalf of the customer.
        * `OCI_OPEN_SEARCH_INDEX_CONFIG`: OciOpenSearchIndexConfig allows customer to configure their OpenSearch cluster.
        * `OCI_DATABASE_CONFIG`: OciDatabaseConfig allows customer to configure their Database.
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the OpenSearch Cluster.
        """
        database_connection: NotRequired[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict']]
        """
        (Updatable) **DatabaseConnection**

        The connection type for Databases.
        """
        database_functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict']]]]
        """
        (Updatable) Array of Database functions to be used.
        """
        indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgsDict']]]]
        """
        (Updatable) Index configuration for open search.
        """
        secret_detail: NotRequired[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgsDict']]
        """
        (Updatable) **SecretDetail**

        The details of configured security configuration on OpenSearch.
        """
        should_enable_hybrid_search: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Whether to enable Hybrid search in service managed OpenSearch.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    AgentKnowledgeBaseIndexConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigArgs:
    def __init__(__self__, *,
                 index_config_type: pulumi.Input[str],
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 database_connection: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs']] = None,
                 database_functions: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]]] = None,
                 secret_detail: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs']] = None,
                 should_enable_hybrid_search: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] index_config_type: (Updatable) The type of index. The allowed values are:
               * `DEFAULT_INDEX_CONFIG`: DefaultIndexConfig allows the service to create and manage vector store on behalf of the customer.
               * `OCI_OPEN_SEARCH_INDEX_CONFIG`: OciOpenSearchIndexConfig allows customer to configure their OpenSearch cluster.
               * `OCI_DATABASE_CONFIG`: OciDatabaseConfig allows customer to configure their Database.
        :param pulumi.Input[str] cluster_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the OpenSearch Cluster.
        :param pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs'] database_connection: (Updatable) **DatabaseConnection**
               
               The connection type for Databases.
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]] database_functions: (Updatable) Array of Database functions to be used.
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]] indexes: (Updatable) Index configuration for open search.
        :param pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs'] secret_detail: (Updatable) **SecretDetail**
               
               The details of configured security configuration on OpenSearch.
        :param pulumi.Input[bool] should_enable_hybrid_search: (Updatable) Whether to enable Hybrid search in service managed OpenSearch.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "index_config_type", index_config_type)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if database_connection is not None:
            pulumi.set(__self__, "database_connection", database_connection)
        if database_functions is not None:
            pulumi.set(__self__, "database_functions", database_functions)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if secret_detail is not None:
            pulumi.set(__self__, "secret_detail", secret_detail)
        if should_enable_hybrid_search is not None:
            pulumi.set(__self__, "should_enable_hybrid_search", should_enable_hybrid_search)

    @property
    @pulumi.getter(name="indexConfigType")
    def index_config_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of index. The allowed values are:
        * `DEFAULT_INDEX_CONFIG`: DefaultIndexConfig allows the service to create and manage vector store on behalf of the customer.
        * `OCI_OPEN_SEARCH_INDEX_CONFIG`: OciOpenSearchIndexConfig allows customer to configure their OpenSearch cluster.
        * `OCI_DATABASE_CONFIG`: OciDatabaseConfig allows customer to configure their Database.
        """
        return pulumi.get(self, "index_config_type")

    @index_config_type.setter
    def index_config_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_config_type", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the OpenSearch Cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="databaseConnection")
    def database_connection(self) -> Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs']]:
        """
        (Updatable) **DatabaseConnection**

        The connection type for Databases.
        """
        return pulumi.get(self, "database_connection")

    @database_connection.setter
    def database_connection(self, value: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs']]):
        pulumi.set(self, "database_connection", value)

    @property
    @pulumi.getter(name="databaseFunctions")
    def database_functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]]]:
        """
        (Updatable) Array of Database functions to be used.
        """
        return pulumi.get(self, "database_functions")

    @database_functions.setter
    def database_functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs']]]]):
        pulumi.set(self, "database_functions", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]]]:
        """
        (Updatable) Index configuration for open search.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexArgs']]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="secretDetail")
    def secret_detail(self) -> Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs']]:
        """
        (Updatable) **SecretDetail**

        The details of configured security configuration on OpenSearch.
        """
        return pulumi.get(self, "secret_detail")

    @secret_detail.setter
    def secret_detail(self, value: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigSecretDetailArgs']]):
        pulumi.set(self, "secret_detail", value)

    @property
    @pulumi.getter(name="shouldEnableHybridSearch")
    def should_enable_hybrid_search(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to enable Hybrid search in service managed OpenSearch.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "should_enable_hybrid_search")

    @should_enable_hybrid_search.setter
    def should_enable_hybrid_search(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_enable_hybrid_search", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict(TypedDict):
        connection_id: pulumi.Input[str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        """
        connection_type: pulumi.Input[str]
        """
        (Updatable) The type of Database connection. The allowed values are:
        * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
elif False:
    AgentKnowledgeBaseIndexConfigDatabaseConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigDatabaseConnectionArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[str],
                 connection_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] connection_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        :param pulumi.Input[str] connection_type: (Updatable) The type of Database connection. The allowed values are:
               * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "connection_type", connection_type)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Tools Connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of Database connection. The allowed values are:
        * `DATABASE_TOOL_CONNECTION`: This allows the service to connect to a vector store via a Database Tools Connection.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_type", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the Database function.
        """
elif False:
    AgentKnowledgeBaseIndexConfigDatabaseFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigDatabaseFunctionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the Database function.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the Database function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigIndexArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The index name in opensearch.
        """
        schema: NotRequired[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict']]
        """
        (Updatable) **IndexSchema**

        The index schema details.
        """
elif False:
    AgentKnowledgeBaseIndexConfigIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigIndexArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs']] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The index name in opensearch.
        :param pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs'] schema: (Updatable) **IndexSchema**
               
               The index schema details.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The index name in opensearch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs']]:
        """
        (Updatable) **IndexSchema**

        The index schema details.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['AgentKnowledgeBaseIndexConfigIndexSchemaArgs']]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict(TypedDict):
        body_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Body key name.
        """
        embedding_body_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Field within customer managed Oracle Cloud Infrastructure OpenSearch document containing the vector embedding for queries.
        """
        title_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Title key that stores the Title of a document, if available.
        """
        url_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) URL key that stores the URL of a document, if available.
        """
elif False:
    AgentKnowledgeBaseIndexConfigIndexSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigIndexSchemaArgs:
    def __init__(__self__, *,
                 body_key: Optional[pulumi.Input[str]] = None,
                 embedding_body_key: Optional[pulumi.Input[str]] = None,
                 title_key: Optional[pulumi.Input[str]] = None,
                 url_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body_key: (Updatable) Body key name.
        :param pulumi.Input[str] embedding_body_key: (Updatable) Field within customer managed Oracle Cloud Infrastructure OpenSearch document containing the vector embedding for queries.
        :param pulumi.Input[str] title_key: (Updatable) Title key that stores the Title of a document, if available.
        :param pulumi.Input[str] url_key: (Updatable) URL key that stores the URL of a document, if available.
        """
        if body_key is not None:
            pulumi.set(__self__, "body_key", body_key)
        if embedding_body_key is not None:
            pulumi.set(__self__, "embedding_body_key", embedding_body_key)
        if title_key is not None:
            pulumi.set(__self__, "title_key", title_key)
        if url_key is not None:
            pulumi.set(__self__, "url_key", url_key)

    @property
    @pulumi.getter(name="bodyKey")
    def body_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Body key name.
        """
        return pulumi.get(self, "body_key")

    @body_key.setter
    def body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_key", value)

    @property
    @pulumi.getter(name="embeddingBodyKey")
    def embedding_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Field within customer managed Oracle Cloud Infrastructure OpenSearch document containing the vector embedding for queries.
        """
        return pulumi.get(self, "embedding_body_key")

    @embedding_body_key.setter
    def embedding_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "embedding_body_key", value)

    @property
    @pulumi.getter(name="titleKey")
    def title_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Title key that stores the Title of a document, if available.
        """
        return pulumi.get(self, "title_key")

    @title_key.setter
    def title_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_key", value)

    @property
    @pulumi.getter(name="urlKey")
    def url_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) URL key that stores the URL of a document, if available.
        """
        return pulumi.get(self, "url_key")

    @url_key.setter
    def url_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_key", value)


if not MYPY:
    class AgentKnowledgeBaseIndexConfigSecretDetailArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        (Updatable) The type of OpenID. The allowed values are:
        * `IDCS_SECRET`: The OpenID configuration used is OpenSearch is IDCS.
        * `BASIC_AUTH_SECRET`: Basic authentication use for OpenSearch
        """
        vault_secret_id: pulumi.Input[str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret for basic authentication.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The IDCS Connect clientId.
        """
        idcs_url: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The URL represent authentication url of the IDCS.
        """
        scope_url: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Fully qualified scope url
        """
elif False:
    AgentKnowledgeBaseIndexConfigSecretDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseIndexConfigSecretDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 vault_secret_id: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 idcs_url: Optional[pulumi.Input[str]] = None,
                 scope_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) The type of OpenID. The allowed values are:
               * `IDCS_SECRET`: The OpenID configuration used is OpenSearch is IDCS.
               * `BASIC_AUTH_SECRET`: Basic authentication use for OpenSearch
        :param pulumi.Input[str] vault_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret for basic authentication.
        :param pulumi.Input[str] client_id: (Updatable) The IDCS Connect clientId.
        :param pulumi.Input[str] idcs_url: (Updatable) The URL represent authentication url of the IDCS.
        :param pulumi.Input[str] scope_url: (Updatable) Fully qualified scope url
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_secret_id", vault_secret_id)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if idcs_url is not None:
            pulumi.set(__self__, "idcs_url", idcs_url)
        if scope_url is not None:
            pulumi.set(__self__, "scope_url", scope_url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of OpenID. The allowed values are:
        * `IDCS_SECRET`: The OpenID configuration used is OpenSearch is IDCS.
        * `BASIC_AUTH_SECRET`: Basic authentication use for OpenSearch
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vaultSecretId")
    def vault_secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the secret for basic authentication.
        """
        return pulumi.get(self, "vault_secret_id")

    @vault_secret_id.setter
    def vault_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_secret_id", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The IDCS Connect clientId.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="idcsUrl")
    def idcs_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The URL represent authentication url of the IDCS.
        """
        return pulumi.get(self, "idcs_url")

    @idcs_url.setter
    def idcs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idcs_url", value)

    @property
    @pulumi.getter(name="scopeUrl")
    def scope_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Fully qualified scope url
        """
        return pulumi.get(self, "scope_url")

    @scope_url.setter
    def scope_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope_url", value)


if not MYPY:
    class DedicatedAiClusterCapacityArgsDict(TypedDict):
        capacity_type: NotRequired[pulumi.Input[str]]
        """
        The type of the dedicated AI cluster capacity.
        """
        total_endpoint_capacity: NotRequired[pulumi.Input[int]]
        """
        The total number of endpoints that can be hosted on this dedicated AI cluster.
        """
        used_endpoint_capacity: NotRequired[pulumi.Input[int]]
        """
        The number of endpoints hosted on this dedicated AI cluster.
        """
elif False:
    DedicatedAiClusterCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DedicatedAiClusterCapacityArgs:
    def __init__(__self__, *,
                 capacity_type: Optional[pulumi.Input[str]] = None,
                 total_endpoint_capacity: Optional[pulumi.Input[int]] = None,
                 used_endpoint_capacity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] capacity_type: The type of the dedicated AI cluster capacity.
        :param pulumi.Input[int] total_endpoint_capacity: The total number of endpoints that can be hosted on this dedicated AI cluster.
        :param pulumi.Input[int] used_endpoint_capacity: The number of endpoints hosted on this dedicated AI cluster.
        """
        if capacity_type is not None:
            pulumi.set(__self__, "capacity_type", capacity_type)
        if total_endpoint_capacity is not None:
            pulumi.set(__self__, "total_endpoint_capacity", total_endpoint_capacity)
        if used_endpoint_capacity is not None:
            pulumi.set(__self__, "used_endpoint_capacity", used_endpoint_capacity)

    @property
    @pulumi.getter(name="capacityType")
    def capacity_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the dedicated AI cluster capacity.
        """
        return pulumi.get(self, "capacity_type")

    @capacity_type.setter
    def capacity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_type", value)

    @property
    @pulumi.getter(name="totalEndpointCapacity")
    def total_endpoint_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of endpoints that can be hosted on this dedicated AI cluster.
        """
        return pulumi.get(self, "total_endpoint_capacity")

    @total_endpoint_capacity.setter
    def total_endpoint_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_endpoint_capacity", value)

    @property
    @pulumi.getter(name="usedEndpointCapacity")
    def used_endpoint_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The number of endpoints hosted on this dedicated AI cluster.
        """
        return pulumi.get(self, "used_endpoint_capacity")

    @used_endpoint_capacity.setter
    def used_endpoint_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "used_endpoint_capacity", value)


if not MYPY:
    class EndpointContentModerationConfigArgsDict(TypedDict):
        is_enabled: pulumi.Input[bool]
        """
        (Updatable) Whether to enable the content moderation feature.
        """
elif False:
    EndpointContentModerationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointContentModerationConfigArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether to enable the content moderation feature.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Whether to enable the content moderation feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ModelFineTuneDetailsArgsDict(TypedDict):
        dedicated_ai_cluster_id: pulumi.Input[str]
        """
        The OCID of the dedicated AI cluster this fine-tuning runs on.
        """
        training_dataset: pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgsDict']
        """
        The dataset used to fine-tune the model. 

        Only one dataset is allowed per custom model, which is split 80-20 for training and validating. You must provide the dataset in a JSON Lines (JSONL) file. Each line in the JSONL file must have the format: `{"prompt": "<first prompt>", "completion": "<expected completion given first prompt>"}`
        """
        training_config: NotRequired[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgsDict']]
        """
        The fine-tuning method and hyperparameters used for fine-tuning a custom model.
        """
elif False:
    ModelFineTuneDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelFineTuneDetailsArgs:
    def __init__(__self__, *,
                 dedicated_ai_cluster_id: pulumi.Input[str],
                 training_dataset: pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs'],
                 training_config: Optional[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs']] = None):
        """
        :param pulumi.Input[str] dedicated_ai_cluster_id: The OCID of the dedicated AI cluster this fine-tuning runs on.
        :param pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs'] training_dataset: The dataset used to fine-tune the model. 
               
               Only one dataset is allowed per custom model, which is split 80-20 for training and validating. You must provide the dataset in a JSON Lines (JSONL) file. Each line in the JSONL file must have the format: `{"prompt": "<first prompt>", "completion": "<expected completion given first prompt>"}`
        :param pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs'] training_config: The fine-tuning method and hyperparameters used for fine-tuning a custom model.
        """
        pulumi.set(__self__, "dedicated_ai_cluster_id", dedicated_ai_cluster_id)
        pulumi.set(__self__, "training_dataset", training_dataset)
        if training_config is not None:
            pulumi.set(__self__, "training_config", training_config)

    @property
    @pulumi.getter(name="dedicatedAiClusterId")
    def dedicated_ai_cluster_id(self) -> pulumi.Input[str]:
        """
        The OCID of the dedicated AI cluster this fine-tuning runs on.
        """
        return pulumi.get(self, "dedicated_ai_cluster_id")

    @dedicated_ai_cluster_id.setter
    def dedicated_ai_cluster_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dedicated_ai_cluster_id", value)

    @property
    @pulumi.getter(name="trainingDataset")
    def training_dataset(self) -> pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs']:
        """
        The dataset used to fine-tune the model. 

        Only one dataset is allowed per custom model, which is split 80-20 for training and validating. You must provide the dataset in a JSON Lines (JSONL) file. Each line in the JSONL file must have the format: `{"prompt": "<first prompt>", "completion": "<expected completion given first prompt>"}`
        """
        return pulumi.get(self, "training_dataset")

    @training_dataset.setter
    def training_dataset(self, value: pulumi.Input['ModelFineTuneDetailsTrainingDatasetArgs']):
        pulumi.set(self, "training_dataset", value)

    @property
    @pulumi.getter(name="trainingConfig")
    def training_config(self) -> Optional[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs']]:
        """
        The fine-tuning method and hyperparameters used for fine-tuning a custom model.
        """
        return pulumi.get(self, "training_config")

    @training_config.setter
    def training_config(self, value: Optional[pulumi.Input['ModelFineTuneDetailsTrainingConfigArgs']]):
        pulumi.set(self, "training_config", value)


if not MYPY:
    class ModelFineTuneDetailsTrainingConfigArgsDict(TypedDict):
        training_config_type: pulumi.Input[str]
        """
        The fine-tuning method for training a custom model.
        """
        early_stopping_patience: NotRequired[pulumi.Input[int]]
        """
        Stop training if the loss metric does not improve beyond 'early_stopping_threshold' for this many times of evaluation.
        """
        early_stopping_threshold: NotRequired[pulumi.Input[float]]
        """
        How much the loss must improve to prevent early stopping.
        """
        learning_rate: NotRequired[pulumi.Input[float]]
        """
        The initial learning rate to be used during training
        """
        log_model_metrics_interval_in_steps: NotRequired[pulumi.Input[int]]
        """
        Determines how frequently to log model metrics. 

        Every step is logged for the first 20 steps and then follows this parameter for log frequency. Set to 0 to disable logging the model metrics.
        """
        lora_alpha: NotRequired[pulumi.Input[int]]
        """
        This parameter represents the scaling factor for the weight matrices in LoRA.
        """
        lora_dropout: NotRequired[pulumi.Input[float]]
        """
        This parameter indicates the dropout probability for LoRA layers.
        """
        lora_r: NotRequired[pulumi.Input[int]]
        """
        This parameter represents the LoRA rank of the update matrices.
        """
        num_of_last_layers: NotRequired[pulumi.Input[int]]
        """
        The number of last layers to be fine-tuned.
        """
        total_training_epochs: NotRequired[pulumi.Input[int]]
        """
        The maximum number of training epochs to run for.
        """
        training_batch_size: NotRequired[pulumi.Input[int]]
        """
        The batch size used during training.
        """
elif False:
    ModelFineTuneDetailsTrainingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelFineTuneDetailsTrainingConfigArgs:
    def __init__(__self__, *,
                 training_config_type: pulumi.Input[str],
                 early_stopping_patience: Optional[pulumi.Input[int]] = None,
                 early_stopping_threshold: Optional[pulumi.Input[float]] = None,
                 learning_rate: Optional[pulumi.Input[float]] = None,
                 log_model_metrics_interval_in_steps: Optional[pulumi.Input[int]] = None,
                 lora_alpha: Optional[pulumi.Input[int]] = None,
                 lora_dropout: Optional[pulumi.Input[float]] = None,
                 lora_r: Optional[pulumi.Input[int]] = None,
                 num_of_last_layers: Optional[pulumi.Input[int]] = None,
                 total_training_epochs: Optional[pulumi.Input[int]] = None,
                 training_batch_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] training_config_type: The fine-tuning method for training a custom model.
        :param pulumi.Input[int] early_stopping_patience: Stop training if the loss metric does not improve beyond 'early_stopping_threshold' for this many times of evaluation.
        :param pulumi.Input[float] early_stopping_threshold: How much the loss must improve to prevent early stopping.
        :param pulumi.Input[float] learning_rate: The initial learning rate to be used during training
        :param pulumi.Input[int] log_model_metrics_interval_in_steps: Determines how frequently to log model metrics. 
               
               Every step is logged for the first 20 steps and then follows this parameter for log frequency. Set to 0 to disable logging the model metrics.
        :param pulumi.Input[int] lora_alpha: This parameter represents the scaling factor for the weight matrices in LoRA.
        :param pulumi.Input[float] lora_dropout: This parameter indicates the dropout probability for LoRA layers.
        :param pulumi.Input[int] lora_r: This parameter represents the LoRA rank of the update matrices.
        :param pulumi.Input[int] num_of_last_layers: The number of last layers to be fine-tuned.
        :param pulumi.Input[int] total_training_epochs: The maximum number of training epochs to run for.
        :param pulumi.Input[int] training_batch_size: The batch size used during training.
        """
        pulumi.set(__self__, "training_config_type", training_config_type)
        if early_stopping_patience is not None:
            pulumi.set(__self__, "early_stopping_patience", early_stopping_patience)
        if early_stopping_threshold is not None:
            pulumi.set(__self__, "early_stopping_threshold", early_stopping_threshold)
        if learning_rate is not None:
            pulumi.set(__self__, "learning_rate", learning_rate)
        if log_model_metrics_interval_in_steps is not None:
            pulumi.set(__self__, "log_model_metrics_interval_in_steps", log_model_metrics_interval_in_steps)
        if lora_alpha is not None:
            pulumi.set(__self__, "lora_alpha", lora_alpha)
        if lora_dropout is not None:
            pulumi.set(__self__, "lora_dropout", lora_dropout)
        if lora_r is not None:
            pulumi.set(__self__, "lora_r", lora_r)
        if num_of_last_layers is not None:
            pulumi.set(__self__, "num_of_last_layers", num_of_last_layers)
        if total_training_epochs is not None:
            pulumi.set(__self__, "total_training_epochs", total_training_epochs)
        if training_batch_size is not None:
            pulumi.set(__self__, "training_batch_size", training_batch_size)

    @property
    @pulumi.getter(name="trainingConfigType")
    def training_config_type(self) -> pulumi.Input[str]:
        """
        The fine-tuning method for training a custom model.
        """
        return pulumi.get(self, "training_config_type")

    @training_config_type.setter
    def training_config_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "training_config_type", value)

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[pulumi.Input[int]]:
        """
        Stop training if the loss metric does not improve beyond 'early_stopping_threshold' for this many times of evaluation.
        """
        return pulumi.get(self, "early_stopping_patience")

    @early_stopping_patience.setter
    def early_stopping_patience(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "early_stopping_patience", value)

    @property
    @pulumi.getter(name="earlyStoppingThreshold")
    def early_stopping_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        How much the loss must improve to prevent early stopping.
        """
        return pulumi.get(self, "early_stopping_threshold")

    @early_stopping_threshold.setter
    def early_stopping_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "early_stopping_threshold", value)

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[pulumi.Input[float]]:
        """
        The initial learning rate to be used during training
        """
        return pulumi.get(self, "learning_rate")

    @learning_rate.setter
    def learning_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "learning_rate", value)

    @property
    @pulumi.getter(name="logModelMetricsIntervalInSteps")
    def log_model_metrics_interval_in_steps(self) -> Optional[pulumi.Input[int]]:
        """
        Determines how frequently to log model metrics. 

        Every step is logged for the first 20 steps and then follows this parameter for log frequency. Set to 0 to disable logging the model metrics.
        """
        return pulumi.get(self, "log_model_metrics_interval_in_steps")

    @log_model_metrics_interval_in_steps.setter
    def log_model_metrics_interval_in_steps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_model_metrics_interval_in_steps", value)

    @property
    @pulumi.getter(name="loraAlpha")
    def lora_alpha(self) -> Optional[pulumi.Input[int]]:
        """
        This parameter represents the scaling factor for the weight matrices in LoRA.
        """
        return pulumi.get(self, "lora_alpha")

    @lora_alpha.setter
    def lora_alpha(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lora_alpha", value)

    @property
    @pulumi.getter(name="loraDropout")
    def lora_dropout(self) -> Optional[pulumi.Input[float]]:
        """
        This parameter indicates the dropout probability for LoRA layers.
        """
        return pulumi.get(self, "lora_dropout")

    @lora_dropout.setter
    def lora_dropout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lora_dropout", value)

    @property
    @pulumi.getter(name="loraR")
    def lora_r(self) -> Optional[pulumi.Input[int]]:
        """
        This parameter represents the LoRA rank of the update matrices.
        """
        return pulumi.get(self, "lora_r")

    @lora_r.setter
    def lora_r(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lora_r", value)

    @property
    @pulumi.getter(name="numOfLastLayers")
    def num_of_last_layers(self) -> Optional[pulumi.Input[int]]:
        """
        The number of last layers to be fine-tuned.
        """
        return pulumi.get(self, "num_of_last_layers")

    @num_of_last_layers.setter
    def num_of_last_layers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_last_layers", value)

    @property
    @pulumi.getter(name="totalTrainingEpochs")
    def total_training_epochs(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of training epochs to run for.
        """
        return pulumi.get(self, "total_training_epochs")

    @total_training_epochs.setter
    def total_training_epochs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_training_epochs", value)

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The batch size used during training.
        """
        return pulumi.get(self, "training_batch_size")

    @training_batch_size.setter
    def training_batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "training_batch_size", value)


if not MYPY:
    class ModelFineTuneDetailsTrainingDatasetArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        The Object Storage bucket name.
        """
        dataset_type: pulumi.Input[str]
        """
        The type of the data asset.
        """
        namespace: pulumi.Input[str]
        """
        The Object Storage namespace.
        """
        object: pulumi.Input[str]
        """
        The Object Storage object name.
        """
elif False:
    ModelFineTuneDetailsTrainingDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelFineTuneDetailsTrainingDatasetArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 dataset_type: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 object: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The Object Storage bucket name.
        :param pulumi.Input[str] dataset_type: The type of the data asset.
        :param pulumi.Input[str] namespace: The Object Storage namespace.
        :param pulumi.Input[str] object: The Object Storage object name.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> pulumi.Input[str]:
        """
        The type of the data asset.
        """
        return pulumi.get(self, "dataset_type")

    @dataset_type.setter
    def dataset_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_type", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The Object Storage namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        The Object Storage object name.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)


if not MYPY:
    class ModelModelMetricArgsDict(TypedDict):
        final_accuracy: NotRequired[pulumi.Input[float]]
        """
        Fine-tuned model accuracy.
        """
        final_loss: NotRequired[pulumi.Input[float]]
        """
        Fine-tuned model loss.
        """
        model_metrics_type: NotRequired[pulumi.Input[str]]
        """
        The type of the model metrics. Each type of model can expect a different set of model metrics.
        """
elif False:
    ModelModelMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelModelMetricArgs:
    def __init__(__self__, *,
                 final_accuracy: Optional[pulumi.Input[float]] = None,
                 final_loss: Optional[pulumi.Input[float]] = None,
                 model_metrics_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] final_accuracy: Fine-tuned model accuracy.
        :param pulumi.Input[float] final_loss: Fine-tuned model loss.
        :param pulumi.Input[str] model_metrics_type: The type of the model metrics. Each type of model can expect a different set of model metrics.
        """
        if final_accuracy is not None:
            pulumi.set(__self__, "final_accuracy", final_accuracy)
        if final_loss is not None:
            pulumi.set(__self__, "final_loss", final_loss)
        if model_metrics_type is not None:
            pulumi.set(__self__, "model_metrics_type", model_metrics_type)

    @property
    @pulumi.getter(name="finalAccuracy")
    def final_accuracy(self) -> Optional[pulumi.Input[float]]:
        """
        Fine-tuned model accuracy.
        """
        return pulumi.get(self, "final_accuracy")

    @final_accuracy.setter
    def final_accuracy(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "final_accuracy", value)

    @property
    @pulumi.getter(name="finalLoss")
    def final_loss(self) -> Optional[pulumi.Input[float]]:
        """
        Fine-tuned model loss.
        """
        return pulumi.get(self, "final_loss")

    @final_loss.setter
    def final_loss(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "final_loss", value)

    @property
    @pulumi.getter(name="modelMetricsType")
    def model_metrics_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the model metrics. Each type of model can expect a different set of model metrics.
        """
        return pulumi.get(self, "model_metrics_type")

    @model_metrics_type.setter
    def model_metrics_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_metrics_type", value)


if not MYPY:
    class GetAgentAgentEndpointsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAgentAgentEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentAgentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAgentAgentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentDataIngestionJobsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAgentDataIngestionJobsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentDataIngestionJobsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentDataSourcesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAgentDataSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentDataSourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAgentKnowledgeBasesFilterArgsDict(TypedDict):
        name: str
        """
        The index name in opensearch.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAgentKnowledgeBasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentKnowledgeBasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The index name in opensearch.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The index name in opensearch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDedicatedAiClustersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDedicatedAiClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDedicatedAiClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetEndpointsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetModelsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


