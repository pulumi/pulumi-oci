# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectionAdditionalAttributeArgs',
    'ConnectionAdditionalAttributeArgsDict',
    'ConnectionBootstrapServerArgs',
    'ConnectionBootstrapServerArgsDict',
    'ConnectionCatalogArgs',
    'ConnectionCatalogArgsDict',
    'ConnectionIngressIpArgs',
    'ConnectionIngressIpArgsDict',
    'ConnectionLockArgs',
    'ConnectionLockArgsDict',
    'ConnectionStorageArgs',
    'ConnectionStorageArgsDict',
    'DeploymentBackupLockArgs',
    'DeploymentBackupLockArgsDict',
    'DeploymentBackupScheduleArgs',
    'DeploymentBackupScheduleArgsDict',
    'DeploymentDeploymentDiagnosticDataArgs',
    'DeploymentDeploymentDiagnosticDataArgsDict',
    'DeploymentIngressIpArgs',
    'DeploymentIngressIpArgsDict',
    'DeploymentLockArgs',
    'DeploymentLockArgsDict',
    'DeploymentMaintenanceConfigurationArgs',
    'DeploymentMaintenanceConfigurationArgsDict',
    'DeploymentMaintenanceWindowArgs',
    'DeploymentMaintenanceWindowArgsDict',
    'DeploymentOggDataArgs',
    'DeploymentOggDataArgsDict',
    'DeploymentOggDataGroupToRolesMappingArgs',
    'DeploymentOggDataGroupToRolesMappingArgsDict',
    'DeploymentPlacementArgs',
    'DeploymentPlacementArgsDict',
    'PipelineLockArgs',
    'PipelineLockArgsDict',
    'PipelineMappingRuleArgs',
    'PipelineMappingRuleArgsDict',
    'PipelinePipelineDiagnosticDataArgs',
    'PipelinePipelineDiagnosticDataArgsDict',
    'PipelineProcessOptionsArgs',
    'PipelineProcessOptionsArgsDict',
    'PipelineProcessOptionsInitialDataLoadArgs',
    'PipelineProcessOptionsInitialDataLoadArgsDict',
    'PipelineProcessOptionsReplicateSchemaChangeArgs',
    'PipelineProcessOptionsReplicateSchemaChangeArgsDict',
    'PipelineSourceConnectionDetailsArgs',
    'PipelineSourceConnectionDetailsArgsDict',
    'PipelineTargetConnectionDetailsArgs',
    'PipelineTargetConnectionDetailsArgsDict',
    'GetConnectionAssignmentsFilterArgs',
    'GetConnectionAssignmentsFilterArgsDict',
    'GetConnectionsFilterArgs',
    'GetConnectionsFilterArgsDict',
    'GetDatabaseRegistrationsFilterArgs',
    'GetDatabaseRegistrationsFilterArgsDict',
    'GetDeploymentBackupsFilterArgs',
    'GetDeploymentBackupsFilterArgsDict',
    'GetDeploymentCertificatesFilterArgs',
    'GetDeploymentCertificatesFilterArgsDict',
    'GetDeploymentEnvironmentsFilterArgs',
    'GetDeploymentEnvironmentsFilterArgsDict',
    'GetDeploymentPeersFilterArgs',
    'GetDeploymentPeersFilterArgsDict',
    'GetDeploymentTypesFilterArgs',
    'GetDeploymentTypesFilterArgsDict',
    'GetDeploymentUpgradesFilterArgs',
    'GetDeploymentUpgradesFilterArgsDict',
    'GetDeploymentVersionsFilterArgs',
    'GetDeploymentVersionsFilterArgsDict',
    'GetDeploymentsFilterArgs',
    'GetDeploymentsFilterArgsDict',
    'GetMessagesFilterArgs',
    'GetMessagesFilterArgsDict',
    'GetPipelineRunningProcessesFilterArgs',
    'GetPipelineRunningProcessesFilterArgsDict',
    'GetPipelineSchemaTablesFilterArgs',
    'GetPipelineSchemaTablesFilterArgsDict',
    'GetPipelineSchemasFilterArgs',
    'GetPipelineSchemasFilterArgsDict',
    'GetPipelinesFilterArgs',
    'GetPipelinesFilterArgsDict',
    'GetRecipesFilterArgs',
    'GetRecipesFilterArgsDict',
    'GetTrailFilesFilterArgs',
    'GetTrailFilesFilterArgsDict',
    'GetTrailSequencesFilterArgs',
    'GetTrailSequencesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectionAdditionalAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the property entry.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The value of the property entry.
        """
elif False:
    ConnectionAdditionalAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAdditionalAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the property entry.
        :param pulumi.Input[_builtins.str] value: (Updatable) The value of the property entry.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the property entry.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The value of the property entry.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectionBootstrapServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name or address of a host.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port of an endpoint usually specified for a connection.
        """
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.

        The private IP address of the connection's endpoint in the customer's VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
        """
elif False:
    ConnectionBootstrapServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionBootstrapServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: (Updatable) The name or address of a host.
        :param pulumi.Input[_builtins.int] port: (Updatable) The port of an endpoint usually specified for a connection.
        :param pulumi.Input[_builtins.str] private_ip: (Updatable) Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.
               
               The private IP address of the connection's endpoint in the customer's VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name or address of a host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port of an endpoint usually specified for a connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.

        The private IP address of the connection's endpoint in the customer's VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class ConnectionCatalogArgsDict(TypedDict):
        catalog_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The catalog type.
        """
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The active branch of the Nessie catalog from which Iceberg reads and writes table metadata.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OAuth client ID used for authentication.
        """
        client_secret_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password Oracle GoldenGate uses to connect to Snowflake platform.
        """
        glue_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The AWS Glue Catalog ID where Iceberg tables are registered.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The catalog name within Polaris where Iceberg tables are registered.
        """
        principal_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Snowflake role used to access Polaris.
        """
        properties_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the content of the configuration file containing additional properties for the REST catalog. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The URL endpoint for the Polaris API. e.g.: 'https://<your-snowflake-account>.snowflakecomputing.com/polaris/api/catalog'
        """
elif False:
    ConnectionCatalogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionCatalogArgs:
    def __init__(__self__, *,
                 catalog_type: pulumi.Input[_builtins.str],
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 glue_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 principal_role: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] catalog_type: (Updatable) The catalog type.
        :param pulumi.Input[_builtins.str] branch: (Updatable) The active branch of the Nessie catalog from which Iceberg reads and writes table metadata.
        :param pulumi.Input[_builtins.str] client_id: (Updatable) The OAuth client ID used for authentication.
        :param pulumi.Input[_builtins.str] client_secret_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password Oracle GoldenGate uses to connect to Snowflake platform.
        :param pulumi.Input[_builtins.str] glue_id: (Updatable) The AWS Glue Catalog ID where Iceberg tables are registered.
        :param pulumi.Input[_builtins.str] name: (Updatable) The catalog name within Polaris where Iceberg tables are registered.
        :param pulumi.Input[_builtins.str] principal_role: (Updatable) The Snowflake role used to access Polaris.
        :param pulumi.Input[_builtins.str] properties_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the content of the configuration file containing additional properties for the REST catalog. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm
        :param pulumi.Input[_builtins.str] uri: (Updatable) The URL endpoint for the Polaris API. e.g.: 'https://<your-snowflake-account>.snowflakecomputing.com/polaris/api/catalog'
        """
        pulumi.set(__self__, "catalog_type", catalog_type)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_secret_id is not None:
            pulumi.set(__self__, "client_secret_secret_id", client_secret_secret_id)
        if glue_id is not None:
            pulumi.set(__self__, "glue_id", glue_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if principal_role is not None:
            pulumi.set(__self__, "principal_role", principal_role)
        if properties_secret_id is not None:
            pulumi.set(__self__, "properties_secret_id", properties_secret_id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="catalogType")
    def catalog_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The catalog type.
        """
        return pulumi.get(self, "catalog_type")

    @catalog_type.setter
    def catalog_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "catalog_type", value)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The active branch of the Nessie catalog from which Iceberg reads and writes table metadata.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OAuth client ID used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretSecretId")
    def client_secret_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password Oracle GoldenGate uses to connect to Snowflake platform.
        """
        return pulumi.get(self, "client_secret_secret_id")

    @client_secret_secret_id.setter
    def client_secret_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="glueId")
    def glue_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The AWS Glue Catalog ID where Iceberg tables are registered.
        """
        return pulumi.get(self, "glue_id")

    @glue_id.setter
    def glue_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "glue_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The catalog name within Polaris where Iceberg tables are registered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="principalRole")
    def principal_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Snowflake role used to access Polaris.
        """
        return pulumi.get(self, "principal_role")

    @principal_role.setter
    def principal_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "principal_role", value)

    @_builtins.property
    @pulumi.getter(name="propertiesSecretId")
    def properties_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the content of the configuration file containing additional properties for the REST catalog. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm
        """
        return pulumi.get(self, "properties_secret_id")

    @properties_secret_id.setter
    def properties_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_secret_id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The URL endpoint for the Polaris API. e.g.: 'https://<your-snowflake-account>.snowflakecomputing.com/polaris/api/catalog'
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class ConnectionIngressIpArgsDict(TypedDict):
        ingress_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
elif False:
    ConnectionIngressIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionIngressIpArgs:
    def __init__(__self__, *,
                 ingress_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ingress_ip: A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        if ingress_ip is not None:
            pulumi.set(__self__, "ingress_ip", ingress_ip)

    @_builtins.property
    @pulumi.getter(name="ingressIp")
    def ingress_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        return pulumi.get(self, "ingress_ip")

    @ingress_ip.setter
    def ingress_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ingress_ip", value)


if not MYPY:
    class ConnectionLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    ConnectionLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class ConnectionStorageArgsDict(TypedDict):
        storage_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The storage type used in the Iceberg connection.
        """
        access_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Access key ID to access the Amazon S3 bucket.
        """
        account_key_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the account key is stored.
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Sets the Azure storage account name.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Google Cloud Storage bucket where Iceberg stores metadata and data files.
        """
        container: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Azure Blob Storage container where Iceberg tables are stored.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Azure Blob Storage endpoint where Iceberg data is stored. e.g.: 'https://my-azure-storage-account.blob.core.windows.net'
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Google Cloud Project where the bucket exists.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The AMAZON region where the S3 bucket is hosted. e.g.: 'us-east-2'
        """
        scheme_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The scheme of the storage.
        """
        secret_access_key_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the Secret Access Key is stored.
        """
        service_account_key_file_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the service account key file is stored, which contains the credentials required to use Google Cloud Storage.
        """
elif False:
    ConnectionStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionStorageArgs:
    def __init__(__self__, *,
                 storage_type: pulumi.Input[_builtins.str],
                 access_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 account_key_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 container: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme_type: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account_key_file_secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_type: (Updatable) The storage type used in the Iceberg connection.
        :param pulumi.Input[_builtins.str] access_key_id: (Updatable) Access key ID to access the Amazon S3 bucket.
        :param pulumi.Input[_builtins.str] account_key_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the account key is stored.
        :param pulumi.Input[_builtins.str] account_name: (Updatable) Sets the Azure storage account name.
        :param pulumi.Input[_builtins.str] bucket: (Updatable) Google Cloud Storage bucket where Iceberg stores metadata and data files.
        :param pulumi.Input[_builtins.str] container: (Updatable) The Azure Blob Storage container where Iceberg tables are stored.
        :param pulumi.Input[_builtins.str] endpoint: (Updatable) The Azure Blob Storage endpoint where Iceberg data is stored. e.g.: 'https://my-azure-storage-account.blob.core.windows.net'
        :param pulumi.Input[_builtins.str] project_id: (Updatable) The Google Cloud Project where the bucket exists.
        :param pulumi.Input[_builtins.str] region: (Updatable) The AMAZON region where the S3 bucket is hosted. e.g.: 'us-east-2'
        :param pulumi.Input[_builtins.str] scheme_type: (Updatable) The scheme of the storage.
        :param pulumi.Input[_builtins.str] secret_access_key_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the Secret Access Key is stored.
        :param pulumi.Input[_builtins.str] service_account_key_file_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the service account key file is stored, which contains the credentials required to use Google Cloud Storage.
        """
        pulumi.set(__self__, "storage_type", storage_type)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if account_key_secret_id is not None:
            pulumi.set(__self__, "account_key_secret_id", account_key_secret_id)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if scheme_type is not None:
            pulumi.set(__self__, "scheme_type", scheme_type)
        if secret_access_key_secret_id is not None:
            pulumi.set(__self__, "secret_access_key_secret_id", secret_access_key_secret_id)
        if service_account_key_file_secret_id is not None:
            pulumi.set(__self__, "service_account_key_file_secret_id", service_account_key_file_secret_id)

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The storage type used in the Iceberg connection.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_type", value)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Access key ID to access the Amazon S3 bucket.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="accountKeySecretId")
    def account_key_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the account key is stored.
        """
        return pulumi.get(self, "account_key_secret_id")

    @account_key_secret_id.setter
    def account_key_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_key_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Sets the Azure storage account name.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Google Cloud Storage bucket where Iceberg stores metadata and data files.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Azure Blob Storage container where Iceberg tables are stored.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Azure Blob Storage endpoint where Iceberg data is stored. e.g.: 'https://my-azure-storage-account.blob.core.windows.net'
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Google Cloud Project where the bucket exists.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The AMAZON region where the S3 bucket is hosted. e.g.: 'us-east-2'
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="schemeType")
    def scheme_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The scheme of the storage.
        """
        return pulumi.get(self, "scheme_type")

    @scheme_type.setter
    def scheme_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme_type", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKeySecretId")
    def secret_access_key_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the Secret Access Key is stored.
        """
        return pulumi.get(self, "secret_access_key_secret_id")

    @secret_access_key_secret_id.setter
    def secret_access_key_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountKeyFileSecretId")
    def service_account_key_file_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the service account key file is stored, which contains the credentials required to use Google Cloud Storage.
        """
        return pulumi.get(self, "service_account_key_file_secret_id")

    @service_account_key_file_secret_id.setter
    def service_account_key_file_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account_key_file_secret_id", value)


if not MYPY:
    class DeploymentBackupLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    DeploymentBackupLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentBackupLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentBackupScheduleArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the bucket where the object is to be uploaded in the object storage
        """
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
        """
        frequency_backup_scheduled: pulumi.Input[_builtins.str]
        """
        (Updatable) The frequency of the deployment backup schedule. Frequency can be DAILY, WEEKLY or MONTHLY.
        """
        is_metadata_only: pulumi.Input[_builtins.bool]
        """
        (Updatable) Parameter to allow users to create backup without trails
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of namespace that serves as a container for all of your buckets
        """
        time_backup_scheduled: pulumi.Input[_builtins.str]
        """
        (Updatable) The start timestamp for the deployment backup schedule. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2024-10-25T18:19:29.600Z`.
        """
elif False:
    DeploymentBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentBackupScheduleArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 compartment_id: pulumi.Input[_builtins.str],
                 frequency_backup_scheduled: pulumi.Input[_builtins.str],
                 is_metadata_only: pulumi.Input[_builtins.bool],
                 namespace: pulumi.Input[_builtins.str],
                 time_backup_scheduled: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) Name of the bucket where the object is to be uploaded in the object storage
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
        :param pulumi.Input[_builtins.str] frequency_backup_scheduled: (Updatable) The frequency of the deployment backup schedule. Frequency can be DAILY, WEEKLY or MONTHLY.
        :param pulumi.Input[_builtins.bool] is_metadata_only: (Updatable) Parameter to allow users to create backup without trails
        :param pulumi.Input[_builtins.str] namespace: (Updatable) Name of namespace that serves as a container for all of your buckets
        :param pulumi.Input[_builtins.str] time_backup_scheduled: (Updatable) The start timestamp for the deployment backup schedule. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2024-10-25T18:19:29.600Z`.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "frequency_backup_scheduled", frequency_backup_scheduled)
        pulumi.set(__self__, "is_metadata_only", is_metadata_only)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "time_backup_scheduled", time_backup_scheduled)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the bucket where the object is to be uploaded in the object storage
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="frequencyBackupScheduled")
    def frequency_backup_scheduled(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The frequency of the deployment backup schedule. Frequency can be DAILY, WEEKLY or MONTHLY.
        """
        return pulumi.get(self, "frequency_backup_scheduled")

    @frequency_backup_scheduled.setter
    def frequency_backup_scheduled(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "frequency_backup_scheduled", value)

    @_builtins.property
    @pulumi.getter(name="isMetadataOnly")
    def is_metadata_only(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Parameter to allow users to create backup without trails
        """
        return pulumi.get(self, "is_metadata_only")

    @is_metadata_only.setter
    def is_metadata_only(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_metadata_only", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of namespace that serves as a container for all of your buckets
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="timeBackupScheduled")
    def time_backup_scheduled(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The start timestamp for the deployment backup schedule. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2024-10-25T18:19:29.600Z`.
        """
        return pulumi.get(self, "time_backup_scheduled")

    @time_backup_scheduled.setter
    def time_backup_scheduled(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_backup_scheduled", value)


if not MYPY:
    class DeploymentDeploymentDiagnosticDataArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the bucket where the object is to be uploaded in the object storage
        """
        diagnostic_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the deployment diagnostic collection.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of namespace that serves as a container for all of your buckets
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the diagnostic collected and uploaded to object storage
        """
        time_diagnostic_end: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time until which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        time_diagnostic_start: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time from which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    DeploymentDeploymentDiagnosticDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeploymentDiagnosticDataArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 diagnostic_state: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None,
                 time_diagnostic_end: Optional[pulumi.Input[_builtins.str]] = None,
                 time_diagnostic_start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Name of the bucket where the object is to be uploaded in the object storage
        :param pulumi.Input[_builtins.str] diagnostic_state: The state of the deployment diagnostic collection.
        :param pulumi.Input[_builtins.str] namespace: Name of namespace that serves as a container for all of your buckets
        :param pulumi.Input[_builtins.str] object: Name of the diagnostic collected and uploaded to object storage
        :param pulumi.Input[_builtins.str] time_diagnostic_end: The time until which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        :param pulumi.Input[_builtins.str] time_diagnostic_start: The time from which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if diagnostic_state is not None:
            pulumi.set(__self__, "diagnostic_state", diagnostic_state)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if time_diagnostic_end is not None:
            pulumi.set(__self__, "time_diagnostic_end", time_diagnostic_end)
        if time_diagnostic_start is not None:
            pulumi.set(__self__, "time_diagnostic_start", time_diagnostic_start)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the bucket where the object is to be uploaded in the object storage
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="diagnosticState")
    def diagnostic_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the deployment diagnostic collection.
        """
        return pulumi.get(self, "diagnostic_state")

    @diagnostic_state.setter
    def diagnostic_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "diagnostic_state", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of namespace that serves as a container for all of your buckets
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the diagnostic collected and uploaded to object storage
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="timeDiagnosticEnd")
    def time_diagnostic_end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time until which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_diagnostic_end")

    @time_diagnostic_end.setter
    def time_diagnostic_end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_diagnostic_end", value)

    @_builtins.property
    @pulumi.getter(name="timeDiagnosticStart")
    def time_diagnostic_start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time from which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_diagnostic_start")

    @time_diagnostic_start.setter
    def time_diagnostic_start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_diagnostic_start", value)


if not MYPY:
    class DeploymentIngressIpArgsDict(TypedDict):
        ingress_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
elif False:
    DeploymentIngressIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentIngressIpArgs:
    def __init__(__self__, *,
                 ingress_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ingress_ip: A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        if ingress_ip is not None:
            pulumi.set(__self__, "ingress_ip", ingress_ip)

    @_builtins.property
    @pulumi.getter(name="ingressIp")
    def ingress_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        return pulumi.get(self, "ingress_ip")

    @ingress_ip.setter
    def ingress_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ingress_ip", value)


if not MYPY:
    class DeploymentLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    DeploymentLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentMaintenanceConfigurationArgsDict(TypedDict):
        bundle_release_upgrade_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines auto upgrade period for bundle releases. Manually configured period cannot be longer than service defined period for bundle releases. This period must be shorter or equal to major release upgrade period. Not passing this field during create will equate to using the service default.
        """
        interim_release_upgrade_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines auto upgrade period for interim releases. This period must be shorter or equal to bundle release upgrade period.
        """
        is_interim_release_auto_upgrade_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) By default auto upgrade for interim releases are not enabled. If auto-upgrade is enabled for interim release,  you have to specify interimReleaseUpgradePeriodInDays too.
        """
        major_release_upgrade_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines auto upgrade period for major releases. Manually configured period cannot be longer than service defined period for major releases. Not passing this field during create will equate to using the service default.
        """
        security_patch_upgrade_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines auto upgrade period for releases with security fix. Manually configured period cannot be longer than service defined period for security releases. Not passing this field during create will equate to using the service default.
        """
elif False:
    DeploymentMaintenanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentMaintenanceConfigurationArgs:
    def __init__(__self__, *,
                 bundle_release_upgrade_period_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 interim_release_upgrade_period_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 is_interim_release_auto_upgrade_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 major_release_upgrade_period_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 security_patch_upgrade_period_in_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] bundle_release_upgrade_period_in_days: (Updatable) Defines auto upgrade period for bundle releases. Manually configured period cannot be longer than service defined period for bundle releases. This period must be shorter or equal to major release upgrade period. Not passing this field during create will equate to using the service default.
        :param pulumi.Input[_builtins.int] interim_release_upgrade_period_in_days: (Updatable) Defines auto upgrade period for interim releases. This period must be shorter or equal to bundle release upgrade period.
        :param pulumi.Input[_builtins.bool] is_interim_release_auto_upgrade_enabled: (Updatable) By default auto upgrade for interim releases are not enabled. If auto-upgrade is enabled for interim release,  you have to specify interimReleaseUpgradePeriodInDays too.
        :param pulumi.Input[_builtins.int] major_release_upgrade_period_in_days: (Updatable) Defines auto upgrade period for major releases. Manually configured period cannot be longer than service defined period for major releases. Not passing this field during create will equate to using the service default.
        :param pulumi.Input[_builtins.int] security_patch_upgrade_period_in_days: (Updatable) Defines auto upgrade period for releases with security fix. Manually configured period cannot be longer than service defined period for security releases. Not passing this field during create will equate to using the service default.
        """
        if bundle_release_upgrade_period_in_days is not None:
            pulumi.set(__self__, "bundle_release_upgrade_period_in_days", bundle_release_upgrade_period_in_days)
        if interim_release_upgrade_period_in_days is not None:
            pulumi.set(__self__, "interim_release_upgrade_period_in_days", interim_release_upgrade_period_in_days)
        if is_interim_release_auto_upgrade_enabled is not None:
            pulumi.set(__self__, "is_interim_release_auto_upgrade_enabled", is_interim_release_auto_upgrade_enabled)
        if major_release_upgrade_period_in_days is not None:
            pulumi.set(__self__, "major_release_upgrade_period_in_days", major_release_upgrade_period_in_days)
        if security_patch_upgrade_period_in_days is not None:
            pulumi.set(__self__, "security_patch_upgrade_period_in_days", security_patch_upgrade_period_in_days)

    @_builtins.property
    @pulumi.getter(name="bundleReleaseUpgradePeriodInDays")
    def bundle_release_upgrade_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines auto upgrade period for bundle releases. Manually configured period cannot be longer than service defined period for bundle releases. This period must be shorter or equal to major release upgrade period. Not passing this field during create will equate to using the service default.
        """
        return pulumi.get(self, "bundle_release_upgrade_period_in_days")

    @bundle_release_upgrade_period_in_days.setter
    def bundle_release_upgrade_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bundle_release_upgrade_period_in_days", value)

    @_builtins.property
    @pulumi.getter(name="interimReleaseUpgradePeriodInDays")
    def interim_release_upgrade_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines auto upgrade period for interim releases. This period must be shorter or equal to bundle release upgrade period.
        """
        return pulumi.get(self, "interim_release_upgrade_period_in_days")

    @interim_release_upgrade_period_in_days.setter
    def interim_release_upgrade_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interim_release_upgrade_period_in_days", value)

    @_builtins.property
    @pulumi.getter(name="isInterimReleaseAutoUpgradeEnabled")
    def is_interim_release_auto_upgrade_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) By default auto upgrade for interim releases are not enabled. If auto-upgrade is enabled for interim release,  you have to specify interimReleaseUpgradePeriodInDays too.
        """
        return pulumi.get(self, "is_interim_release_auto_upgrade_enabled")

    @is_interim_release_auto_upgrade_enabled.setter
    def is_interim_release_auto_upgrade_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_interim_release_auto_upgrade_enabled", value)

    @_builtins.property
    @pulumi.getter(name="majorReleaseUpgradePeriodInDays")
    def major_release_upgrade_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines auto upgrade period for major releases. Manually configured period cannot be longer than service defined period for major releases. Not passing this field during create will equate to using the service default.
        """
        return pulumi.get(self, "major_release_upgrade_period_in_days")

    @major_release_upgrade_period_in_days.setter
    def major_release_upgrade_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "major_release_upgrade_period_in_days", value)

    @_builtins.property
    @pulumi.getter(name="securityPatchUpgradePeriodInDays")
    def security_patch_upgrade_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines auto upgrade period for releases with security fix. Manually configured period cannot be longer than service defined period for security releases. Not passing this field during create will equate to using the service default.
        """
        return pulumi.get(self, "security_patch_upgrade_period_in_days")

    @security_patch_upgrade_period_in_days.setter
    def security_patch_upgrade_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "security_patch_upgrade_period_in_days", value)


if not MYPY:
    class DeploymentMaintenanceWindowArgsDict(TypedDict):
        day: pulumi.Input[_builtins.str]
        """
        (Updatable) Days of the week.
        """
        start_hour: pulumi.Input[_builtins.int]
        """
        (Updatable) Start hour for maintenance period. Hour is in UTC.
        """
elif False:
    DeploymentMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[_builtins.str],
                 start_hour: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] day: (Updatable) Days of the week.
        :param pulumi.Input[_builtins.int] start_hour: (Updatable) Start hour for maintenance period. Hour is in UTC.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_hour", start_hour)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Days of the week.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Start hour for maintenance period. Hour is in UTC.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_hour", value)


if not MYPY:
    class DeploymentOggDataArgsDict(TypedDict):
        deployment_name: pulumi.Input[_builtins.str]
        """
        The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        """
        admin_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as $, ^, or ? are not allowed. This field will be deprecated and replaced by "passwordSecretId".
        """
        admin_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The GoldenGate deployment console username.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 encoded content of the PEM file containing the SSL certificate.
        """
        credential_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of credential store for OGG.
        """
        group_to_roles_mapping: NotRequired[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgsDict']]
        """
        (Updatable) Defines the IDP Groups to GoldenGate roles mapping. This field is used only for IAM deployment and does not have any impact on non-IAM deployments. For IAM deployment, when user does not specify this mapping, then it has null value and default mapping is used. User belonging to each group can only perform the actions according to the role the respective group is mapped to.
        """
        identity_domain_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Identity Domain when IAM credential store is used.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 encoded content of the PEM file containing the private key.
        """
        ogg_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of OGG
        """
        password_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the deployment password is stored.
        """
elif False:
    DeploymentOggDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentOggDataArgs:
    def __init__(__self__, *,
                 deployment_name: pulumi.Input[_builtins.str],
                 admin_password: Optional[pulumi.Input[_builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 credential_store: Optional[pulumi.Input[_builtins.str]] = None,
                 group_to_roles_mapping: Optional[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs']] = None,
                 identity_domain_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 ogg_version: Optional[pulumi.Input[_builtins.str]] = None,
                 password_secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] deployment_name: The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        :param pulumi.Input[_builtins.str] admin_password: (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as $, ^, or ? are not allowed. This field will be deprecated and replaced by "passwordSecretId".
        :param pulumi.Input[_builtins.str] admin_username: (Updatable) The GoldenGate deployment console username.
        :param pulumi.Input[_builtins.str] certificate: (Updatable) The base64 encoded content of the PEM file containing the SSL certificate.
        :param pulumi.Input[_builtins.str] credential_store: (Updatable) The type of credential store for OGG.
        :param pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs'] group_to_roles_mapping: (Updatable) Defines the IDP Groups to GoldenGate roles mapping. This field is used only for IAM deployment and does not have any impact on non-IAM deployments. For IAM deployment, when user does not specify this mapping, then it has null value and default mapping is used. User belonging to each group can only perform the actions according to the role the respective group is mapped to.
        :param pulumi.Input[_builtins.str] identity_domain_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Identity Domain when IAM credential store is used.
        :param pulumi.Input[_builtins.str] key: (Updatable) The base64 encoded content of the PEM file containing the private key.
        :param pulumi.Input[_builtins.str] ogg_version: Version of OGG
        :param pulumi.Input[_builtins.str] password_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the deployment password is stored.
        """
        pulumi.set(__self__, "deployment_name", deployment_name)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if credential_store is not None:
            pulumi.set(__self__, "credential_store", credential_store)
        if group_to_roles_mapping is not None:
            pulumi.set(__self__, "group_to_roles_mapping", group_to_roles_mapping)
        if identity_domain_id is not None:
            pulumi.set(__self__, "identity_domain_id", identity_domain_id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if ogg_version is not None:
            pulumi.set(__self__, "ogg_version", ogg_version)
        if password_secret_id is not None:
            pulumi.set(__self__, "password_secret_id", password_secret_id)

    @_builtins.property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        """
        return pulumi.get(self, "deployment_name")

    @deployment_name.setter
    def deployment_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_name", value)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as $, ^, or ? are not allowed. This field will be deprecated and replaced by "passwordSecretId".
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The GoldenGate deployment console username.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 encoded content of the PEM file containing the SSL certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="credentialStore")
    def credential_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of credential store for OGG.
        """
        return pulumi.get(self, "credential_store")

    @credential_store.setter
    def credential_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_store", value)

    @_builtins.property
    @pulumi.getter(name="groupToRolesMapping")
    def group_to_roles_mapping(self) -> Optional[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs']]:
        """
        (Updatable) Defines the IDP Groups to GoldenGate roles mapping. This field is used only for IAM deployment and does not have any impact on non-IAM deployments. For IAM deployment, when user does not specify this mapping, then it has null value and default mapping is used. User belonging to each group can only perform the actions according to the role the respective group is mapped to.
        """
        return pulumi.get(self, "group_to_roles_mapping")

    @group_to_roles_mapping.setter
    def group_to_roles_mapping(self, value: Optional[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs']]):
        pulumi.set(self, "group_to_roles_mapping", value)

    @_builtins.property
    @pulumi.getter(name="identityDomainId")
    def identity_domain_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Identity Domain when IAM credential store is used.
        """
        return pulumi.get(self, "identity_domain_id")

    @identity_domain_id.setter
    def identity_domain_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_domain_id", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 encoded content of the PEM file containing the private key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="oggVersion")
    def ogg_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of OGG
        """
        return pulumi.get(self, "ogg_version")

    @ogg_version.setter
    def ogg_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ogg_version", value)

    @_builtins.property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the deployment password is stored.
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password_secret_id", value)


if not MYPY:
    class DeploymentOggDataGroupToRolesMappingArgsDict(TypedDict):
        security_group_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role securityGroup. It grants administration of security related objects and invoke security related service requests. This role has full privileges.
        """
        administrator_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role administratorGroup. It grants full access to the user, including the ability to alter general, non-security related operational parameters and profiles of the server.
        """
        operator_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role operatorGroup. It allows users to perform only operational actions, like starting and stopping resources. Operators cannot alter the operational parameters or profiles of the MA server.
        """
        user_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role userGroup. It allows information-only service requests, which do not alter or affect the operation of either the MA. Examples of query and read-only information include performance metric information and resource status and monitoring information
        """
elif False:
    DeploymentOggDataGroupToRolesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentOggDataGroupToRolesMappingArgs:
    def __init__(__self__, *,
                 security_group_id: pulumi.Input[_builtins.str],
                 administrator_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 operator_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role securityGroup. It grants administration of security related objects and invoke security related service requests. This role has full privileges.
        :param pulumi.Input[_builtins.str] administrator_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role administratorGroup. It grants full access to the user, including the ability to alter general, non-security related operational parameters and profiles of the server.
        :param pulumi.Input[_builtins.str] operator_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role operatorGroup. It allows users to perform only operational actions, like starting and stopping resources. Operators cannot alter the operational parameters or profiles of the MA server.
        :param pulumi.Input[_builtins.str] user_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role userGroup. It allows information-only service requests, which do not alter or affect the operation of either the MA. Examples of query and read-only information include performance metric information and resource status and monitoring information
        """
        pulumi.set(__self__, "security_group_id", security_group_id)
        if administrator_group_id is not None:
            pulumi.set(__self__, "administrator_group_id", administrator_group_id)
        if operator_group_id is not None:
            pulumi.set(__self__, "operator_group_id", operator_group_id)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role securityGroup. It grants administration of security related objects and invoke security related service requests. This role has full privileges.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="administratorGroupId")
    def administrator_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role administratorGroup. It grants full access to the user, including the ability to alter general, non-security related operational parameters and profiles of the server.
        """
        return pulumi.get(self, "administrator_group_id")

    @administrator_group_id.setter
    def administrator_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "administrator_group_id", value)

    @_builtins.property
    @pulumi.getter(name="operatorGroupId")
    def operator_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role operatorGroup. It allows users to perform only operational actions, like starting and stopping resources. Operators cannot alter the operational parameters or profiles of the MA server.
        """
        return pulumi.get(self, "operator_group_id")

    @operator_group_id.setter
    def operator_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator_group_id", value)

    @_builtins.property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role userGroup. It allows information-only service requests, which do not alter or affect the operation of either the MA. Examples of query and read-only information include performance metric information and resource status and monitoring information
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_group_id", value)


if not MYPY:
    class DeploymentPlacementArgsDict(TypedDict):
        availability_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The availability domain of a placement.
        """
        fault_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The fault domain of a placement.
        """
elif False:
    DeploymentPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPlacementArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 fault_domain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_domain: (Updatable) The availability domain of a placement.
        :param pulumi.Input[_builtins.str] fault_domain: (Updatable) The fault domain of a placement.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The availability domain of a placement.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_domain", value)

    @_builtins.property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The fault domain of a placement.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fault_domain", value)


if not MYPY:
    class PipelineLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
elif False:
    PipelineLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class PipelineMappingRuleArgsDict(TypedDict):
        mapping_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the exclude/include rules of source and target schemas and tables when replicating from source to target. This option applies when creating and updating a pipeline.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source schema/table combination for replication to target.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target schema/table combination for replication from the source.
        """
elif False:
    PipelineMappingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineMappingRuleArgs:
    def __init__(__self__, *,
                 mapping_type: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mapping_type: Defines the exclude/include rules of source and target schemas and tables when replicating from source to target. This option applies when creating and updating a pipeline.
        :param pulumi.Input[_builtins.str] source: The source schema/table combination for replication to target.
        :param pulumi.Input[_builtins.str] target: The target schema/table combination for replication from the source.
        """
        if mapping_type is not None:
            pulumi.set(__self__, "mapping_type", mapping_type)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="mappingType")
    def mapping_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the exclude/include rules of source and target schemas and tables when replicating from source to target. This option applies when creating and updating a pipeline.
        """
        return pulumi.get(self, "mapping_type")

    @mapping_type.setter
    def mapping_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mapping_type", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source schema/table combination for replication to target.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target schema/table combination for replication from the source.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class PipelinePipelineDiagnosticDataArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the bucket where the object is to be uploaded in the object storage
        """
        diagnostic_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the pipeline diagnostics collection.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of namespace that serves as a container for all of your buckets
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the diagnostic collected and uploaded to object storage
        """
        time_last_collected: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the diagnostic data was last collected for the pipeline. The format is defined by  [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2024-07-25T21:10:29.600Z`.
        """
elif False:
    PipelinePipelineDiagnosticDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelinePipelineDiagnosticDataArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 diagnostic_state: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_collected: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Name of the bucket where the object is to be uploaded in the object storage
        :param pulumi.Input[_builtins.str] diagnostic_state: The state of the pipeline diagnostics collection.
        :param pulumi.Input[_builtins.str] namespace: Name of namespace that serves as a container for all of your buckets
        :param pulumi.Input[_builtins.str] object: Name of the diagnostic collected and uploaded to object storage
        :param pulumi.Input[_builtins.str] time_last_collected: The date and time the diagnostic data was last collected for the pipeline. The format is defined by  [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2024-07-25T21:10:29.600Z`.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if diagnostic_state is not None:
            pulumi.set(__self__, "diagnostic_state", diagnostic_state)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if time_last_collected is not None:
            pulumi.set(__self__, "time_last_collected", time_last_collected)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the bucket where the object is to be uploaded in the object storage
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="diagnosticState")
    def diagnostic_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the pipeline diagnostics collection.
        """
        return pulumi.get(self, "diagnostic_state")

    @diagnostic_state.setter
    def diagnostic_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "diagnostic_state", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of namespace that serves as a container for all of your buckets
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the diagnostic collected and uploaded to object storage
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="timeLastCollected")
    def time_last_collected(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the diagnostic data was last collected for the pipeline. The format is defined by  [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2024-07-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_last_collected")

    @time_last_collected.setter
    def time_last_collected(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_collected", value)


if not MYPY:
    class PipelineProcessOptionsArgsDict(TypedDict):
        initial_data_load: pulumi.Input['PipelineProcessOptionsInitialDataLoadArgsDict']
        """
        (Updatable) Options required for the pipeline Initial Data Load. If enabled, copies existing data from source to target before replication.
        """
        replicate_schema_change: pulumi.Input['PipelineProcessOptionsReplicateSchemaChangeArgsDict']
        """
        (Updatable) Options required for pipeline Initial Data Load. If enabled, copies existing data from source to target before replication.
        """
        should_restart_on_failure: pulumi.Input[_builtins.str]
        """
        (Updatable) If ENABLED, then the replication process restarts itself upon failure. This option applies when creating or updating a pipeline.
        """
        start_using_default_mapping: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If ENABLED, then the pipeline is started as part of pipeline creation. It uses default mapping. This option only applies when creating a pipeline and is not applicable while updating a pipeline.
        """
elif False:
    PipelineProcessOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineProcessOptionsArgs:
    def __init__(__self__, *,
                 initial_data_load: pulumi.Input['PipelineProcessOptionsInitialDataLoadArgs'],
                 replicate_schema_change: pulumi.Input['PipelineProcessOptionsReplicateSchemaChangeArgs'],
                 should_restart_on_failure: pulumi.Input[_builtins.str],
                 start_using_default_mapping: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['PipelineProcessOptionsInitialDataLoadArgs'] initial_data_load: (Updatable) Options required for the pipeline Initial Data Load. If enabled, copies existing data from source to target before replication.
        :param pulumi.Input['PipelineProcessOptionsReplicateSchemaChangeArgs'] replicate_schema_change: (Updatable) Options required for pipeline Initial Data Load. If enabled, copies existing data from source to target before replication.
        :param pulumi.Input[_builtins.str] should_restart_on_failure: (Updatable) If ENABLED, then the replication process restarts itself upon failure. This option applies when creating or updating a pipeline.
        :param pulumi.Input[_builtins.str] start_using_default_mapping: (Updatable) If ENABLED, then the pipeline is started as part of pipeline creation. It uses default mapping. This option only applies when creating a pipeline and is not applicable while updating a pipeline.
        """
        pulumi.set(__self__, "initial_data_load", initial_data_load)
        pulumi.set(__self__, "replicate_schema_change", replicate_schema_change)
        pulumi.set(__self__, "should_restart_on_failure", should_restart_on_failure)
        if start_using_default_mapping is not None:
            pulumi.set(__self__, "start_using_default_mapping", start_using_default_mapping)

    @_builtins.property
    @pulumi.getter(name="initialDataLoad")
    def initial_data_load(self) -> pulumi.Input['PipelineProcessOptionsInitialDataLoadArgs']:
        """
        (Updatable) Options required for the pipeline Initial Data Load. If enabled, copies existing data from source to target before replication.
        """
        return pulumi.get(self, "initial_data_load")

    @initial_data_load.setter
    def initial_data_load(self, value: pulumi.Input['PipelineProcessOptionsInitialDataLoadArgs']):
        pulumi.set(self, "initial_data_load", value)

    @_builtins.property
    @pulumi.getter(name="replicateSchemaChange")
    def replicate_schema_change(self) -> pulumi.Input['PipelineProcessOptionsReplicateSchemaChangeArgs']:
        """
        (Updatable) Options required for pipeline Initial Data Load. If enabled, copies existing data from source to target before replication.
        """
        return pulumi.get(self, "replicate_schema_change")

    @replicate_schema_change.setter
    def replicate_schema_change(self, value: pulumi.Input['PipelineProcessOptionsReplicateSchemaChangeArgs']):
        pulumi.set(self, "replicate_schema_change", value)

    @_builtins.property
    @pulumi.getter(name="shouldRestartOnFailure")
    def should_restart_on_failure(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) If ENABLED, then the replication process restarts itself upon failure. This option applies when creating or updating a pipeline.
        """
        return pulumi.get(self, "should_restart_on_failure")

    @should_restart_on_failure.setter
    def should_restart_on_failure(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "should_restart_on_failure", value)

    @_builtins.property
    @pulumi.getter(name="startUsingDefaultMapping")
    def start_using_default_mapping(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If ENABLED, then the pipeline is started as part of pipeline creation. It uses default mapping. This option only applies when creating a pipeline and is not applicable while updating a pipeline.
        """
        return pulumi.get(self, "start_using_default_mapping")

    @start_using_default_mapping.setter
    def start_using_default_mapping(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_using_default_mapping", value)


if not MYPY:
    class PipelineProcessOptionsInitialDataLoadArgsDict(TypedDict):
        is_initial_load: pulumi.Input[_builtins.str]
        """
        (Updatable) If ENABLED, then existing source data is also synchronized to the target when creating or updating the pipeline.
        """
        action_on_existing_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Action upon existing tables in target when initial Data Load is set i.e., isInitialLoad=true.
        """
elif False:
    PipelineProcessOptionsInitialDataLoadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineProcessOptionsInitialDataLoadArgs:
    def __init__(__self__, *,
                 is_initial_load: pulumi.Input[_builtins.str],
                 action_on_existing_table: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] is_initial_load: (Updatable) If ENABLED, then existing source data is also synchronized to the target when creating or updating the pipeline.
        :param pulumi.Input[_builtins.str] action_on_existing_table: (Updatable) Action upon existing tables in target when initial Data Load is set i.e., isInitialLoad=true.
        """
        pulumi.set(__self__, "is_initial_load", is_initial_load)
        if action_on_existing_table is not None:
            pulumi.set(__self__, "action_on_existing_table", action_on_existing_table)

    @_builtins.property
    @pulumi.getter(name="isInitialLoad")
    def is_initial_load(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) If ENABLED, then existing source data is also synchronized to the target when creating or updating the pipeline.
        """
        return pulumi.get(self, "is_initial_load")

    @is_initial_load.setter
    def is_initial_load(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "is_initial_load", value)

    @_builtins.property
    @pulumi.getter(name="actionOnExistingTable")
    def action_on_existing_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Action upon existing tables in target when initial Data Load is set i.e., isInitialLoad=true.
        """
        return pulumi.get(self, "action_on_existing_table")

    @action_on_existing_table.setter
    def action_on_existing_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_on_existing_table", value)


if not MYPY:
    class PipelineProcessOptionsReplicateSchemaChangeArgsDict(TypedDict):
        can_replicate_schema_change: pulumi.Input[_builtins.str]
        """
        (Updatable) If ENABLED, then addition or removal of schema is also replicated, apart from individual tables and records when creating or updating the pipeline.
        """
        action_on_ddl_error: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Action upon DDL Error (active only if 'Replicate schema changes (DDL)' is selected) i.e canReplicateSchemaChange=true
        """
        action_on_dml_error: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Action upon DML Error (active only if 'Replicate schema changes (DDL)' is selected) i.e canReplicateSchemaChange=true
        """
elif False:
    PipelineProcessOptionsReplicateSchemaChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineProcessOptionsReplicateSchemaChangeArgs:
    def __init__(__self__, *,
                 can_replicate_schema_change: pulumi.Input[_builtins.str],
                 action_on_ddl_error: Optional[pulumi.Input[_builtins.str]] = None,
                 action_on_dml_error: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] can_replicate_schema_change: (Updatable) If ENABLED, then addition or removal of schema is also replicated, apart from individual tables and records when creating or updating the pipeline.
        :param pulumi.Input[_builtins.str] action_on_ddl_error: (Updatable) Action upon DDL Error (active only if 'Replicate schema changes (DDL)' is selected) i.e canReplicateSchemaChange=true
        :param pulumi.Input[_builtins.str] action_on_dml_error: (Updatable) Action upon DML Error (active only if 'Replicate schema changes (DDL)' is selected) i.e canReplicateSchemaChange=true
        """
        pulumi.set(__self__, "can_replicate_schema_change", can_replicate_schema_change)
        if action_on_ddl_error is not None:
            pulumi.set(__self__, "action_on_ddl_error", action_on_ddl_error)
        if action_on_dml_error is not None:
            pulumi.set(__self__, "action_on_dml_error", action_on_dml_error)

    @_builtins.property
    @pulumi.getter(name="canReplicateSchemaChange")
    def can_replicate_schema_change(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) If ENABLED, then addition or removal of schema is also replicated, apart from individual tables and records when creating or updating the pipeline.
        """
        return pulumi.get(self, "can_replicate_schema_change")

    @can_replicate_schema_change.setter
    def can_replicate_schema_change(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "can_replicate_schema_change", value)

    @_builtins.property
    @pulumi.getter(name="actionOnDdlError")
    def action_on_ddl_error(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Action upon DDL Error (active only if 'Replicate schema changes (DDL)' is selected) i.e canReplicateSchemaChange=true
        """
        return pulumi.get(self, "action_on_ddl_error")

    @action_on_ddl_error.setter
    def action_on_ddl_error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_on_ddl_error", value)

    @_builtins.property
    @pulumi.getter(name="actionOnDmlError")
    def action_on_dml_error(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Action upon DML Error (active only if 'Replicate schema changes (DDL)' is selected) i.e canReplicateSchemaChange=true
        """
        return pulumi.get(self, "action_on_dml_error")

    @action_on_dml_error.setter
    def action_on_dml_error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_on_dml_error", value)


if not MYPY:
    class PipelineSourceConnectionDetailsArgsDict(TypedDict):
        connection_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
        """
elif False:
    PipelineSourceConnectionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineSourceConnectionDetailsArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
        """
        pulumi.set(__self__, "connection_id", connection_id)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_id", value)


if not MYPY:
    class PipelineTargetConnectionDetailsArgsDict(TypedDict):
        connection_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    PipelineTargetConnectionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTargetConnectionDetailsArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "connection_id", connection_id)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_id", value)


if not MYPY:
    class GetConnectionAssignmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the connection in the assignment (aliasName).
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConnectionAssignmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionAssignmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the connection in the assignment (aliasName).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the connection in the assignment (aliasName).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetConnectionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The catalog name within Polaris where Iceberg tables are registered.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConnectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The catalog name within Polaris where Iceberg tables are registered.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The catalog name within Polaris where Iceberg tables are registered.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabaseRegistrationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDatabaseRegistrationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseRegistrationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentBackupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentBackupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentCertificatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentCertificatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentEnvironmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentEnvironmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentPeersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentPeersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentPeersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentUpgradesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentUpgradesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentUpgradesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentVersionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentVersionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMessagesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMessagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMessagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPipelineRunningProcessesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        An object's Display Name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPipelineRunningProcessesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelineRunningProcessesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: An object's Display Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An object's Display Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPipelineSchemaTablesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPipelineSchemaTablesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelineSchemaTablesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPipelineSchemasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPipelineSchemasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelineSchemasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPipelinesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPipelinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelinesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRecipesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        An object's Display Name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecipesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: An object's Display Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An object's Display Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTrailFilesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTrailFilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrailFilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTrailSequencesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetTrailSequencesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrailSequencesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


