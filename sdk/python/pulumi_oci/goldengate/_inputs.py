# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectionAdditionalAttributeArgs',
    'ConnectionAdditionalAttributeArgsDict',
    'ConnectionBootstrapServerArgs',
    'ConnectionBootstrapServerArgsDict',
    'ConnectionIngressIpArgs',
    'ConnectionIngressIpArgsDict',
    'ConnectionLockArgs',
    'ConnectionLockArgsDict',
    'DeploymentBackupLockArgs',
    'DeploymentBackupLockArgsDict',
    'DeploymentDeploymentDiagnosticDataArgs',
    'DeploymentDeploymentDiagnosticDataArgsDict',
    'DeploymentIngressIpArgs',
    'DeploymentIngressIpArgsDict',
    'DeploymentLockArgs',
    'DeploymentLockArgsDict',
    'DeploymentMaintenanceConfigurationArgs',
    'DeploymentMaintenanceConfigurationArgsDict',
    'DeploymentMaintenanceWindowArgs',
    'DeploymentMaintenanceWindowArgsDict',
    'DeploymentOggDataArgs',
    'DeploymentOggDataArgsDict',
    'DeploymentOggDataGroupToRolesMappingArgs',
    'DeploymentOggDataGroupToRolesMappingArgsDict',
    'GetConnectionAssignmentsFilterArgs',
    'GetConnectionAssignmentsFilterArgsDict',
    'GetConnectionsFilterArgs',
    'GetConnectionsFilterArgsDict',
    'GetDatabaseRegistrationsFilterArgs',
    'GetDatabaseRegistrationsFilterArgsDict',
    'GetDeploymentBackupsFilterArgs',
    'GetDeploymentBackupsFilterArgsDict',
    'GetDeploymentCertificatesFilterArgs',
    'GetDeploymentCertificatesFilterArgsDict',
    'GetDeploymentEnvironmentsFilterArgs',
    'GetDeploymentEnvironmentsFilterArgsDict',
    'GetDeploymentTypesFilterArgs',
    'GetDeploymentTypesFilterArgsDict',
    'GetDeploymentUpgradesFilterArgs',
    'GetDeploymentUpgradesFilterArgsDict',
    'GetDeploymentVersionsFilterArgs',
    'GetDeploymentVersionsFilterArgsDict',
    'GetDeploymentsFilterArgs',
    'GetDeploymentsFilterArgsDict',
    'GetMessagesFilterArgs',
    'GetMessagesFilterArgsDict',
    'GetTrailFilesFilterArgs',
    'GetTrailFilesFilterArgsDict',
    'GetTrailSequencesFilterArgs',
    'GetTrailSequencesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectionAdditionalAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the property entry.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The value of the property entry.
        """
elif False:
    ConnectionAdditionalAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAdditionalAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the property entry.
        :param pulumi.Input[str] value: (Updatable) The value of the property entry.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the property entry.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value of the property entry.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectionBootstrapServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name or address of a host.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The port of an endpoint usually specified for a connection.
        """
        private_ip: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.

        The private IP address of the connection's endpoint in the customer's VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
        """
elif False:
    ConnectionBootstrapServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionBootstrapServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: (Updatable) The name or address of a host.
        :param pulumi.Input[int] port: (Updatable) The port of an endpoint usually specified for a connection.
        :param pulumi.Input[str] private_ip: (Updatable) Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.
               
               The private IP address of the connection's endpoint in the customer's VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name or address of a host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The port of an endpoint usually specified for a connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.

        The private IP address of the connection's endpoint in the customer's VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class ConnectionIngressIpArgsDict(TypedDict):
        ingress_ip: NotRequired[pulumi.Input[str]]
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
elif False:
    ConnectionIngressIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionIngressIpArgs:
    def __init__(__self__, *,
                 ingress_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ingress_ip: A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        if ingress_ip is not None:
            pulumi.set(__self__, "ingress_ip", ingress_ip)

    @property
    @pulumi.getter(name="ingressIp")
    def ingress_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        return pulumi.get(self, "ingress_ip")

    @ingress_ip.setter
    def ingress_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingress_ip", value)


if not MYPY:
    class ConnectionLockArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    ConnectionLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 related_resource_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the lock.
        :param pulumi.Input[str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[str] time_created: The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "related_resource_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentBackupLockArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    DeploymentBackupLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentBackupLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 related_resource_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the lock.
        :param pulumi.Input[str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[str] time_created: The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "related_resource_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentDeploymentDiagnosticDataArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[str]]
        """
        Name of the bucket where the object is to be uploaded in the object storage
        """
        diagnostic_state: NotRequired[pulumi.Input[str]]
        """
        The state of the deployment diagnostic collection.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Name of namespace that serves as a container for all of your buckets
        """
        object: NotRequired[pulumi.Input[str]]
        """
        Name of the diagnostic collected and uploaded to object storage
        """
        time_diagnostic_end: NotRequired[pulumi.Input[str]]
        """
        The time until which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        time_diagnostic_start: NotRequired[pulumi.Input[str]]
        """
        The time from which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    DeploymentDeploymentDiagnosticDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDeploymentDiagnosticDataArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 diagnostic_state: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 object: Optional[pulumi.Input[str]] = None,
                 time_diagnostic_end: Optional[pulumi.Input[str]] = None,
                 time_diagnostic_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of the bucket where the object is to be uploaded in the object storage
        :param pulumi.Input[str] diagnostic_state: The state of the deployment diagnostic collection.
        :param pulumi.Input[str] namespace: Name of namespace that serves as a container for all of your buckets
        :param pulumi.Input[str] object: Name of the diagnostic collected and uploaded to object storage
        :param pulumi.Input[str] time_diagnostic_end: The time until which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        :param pulumi.Input[str] time_diagnostic_start: The time from which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if diagnostic_state is not None:
            pulumi.set(__self__, "diagnostic_state", diagnostic_state)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if time_diagnostic_end is not None:
            pulumi.set(__self__, "time_diagnostic_end", time_diagnostic_end)
        if time_diagnostic_start is not None:
            pulumi.set(__self__, "time_diagnostic_start", time_diagnostic_start)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the bucket where the object is to be uploaded in the object storage
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="diagnosticState")
    def diagnostic_state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the deployment diagnostic collection.
        """
        return pulumi.get(self, "diagnostic_state")

    @diagnostic_state.setter
    def diagnostic_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "diagnostic_state", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Name of namespace that serves as a container for all of your buckets
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the diagnostic collected and uploaded to object storage
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter(name="timeDiagnosticEnd")
    def time_diagnostic_end(self) -> Optional[pulumi.Input[str]]:
        """
        The time until which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_diagnostic_end")

    @time_diagnostic_end.setter
    def time_diagnostic_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_diagnostic_end", value)

    @property
    @pulumi.getter(name="timeDiagnosticStart")
    def time_diagnostic_start(self) -> Optional[pulumi.Input[str]]:
        """
        The time from which the diagnostic collection should collect the logs. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_diagnostic_start")

    @time_diagnostic_start.setter
    def time_diagnostic_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_diagnostic_start", value)


if not MYPY:
    class DeploymentIngressIpArgsDict(TypedDict):
        ingress_ip: NotRequired[pulumi.Input[str]]
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
elif False:
    DeploymentIngressIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentIngressIpArgs:
    def __init__(__self__, *,
                 ingress_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ingress_ip: A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        if ingress_ip is not None:
            pulumi.set(__self__, "ingress_ip", ingress_ip)

    @property
    @pulumi.getter(name="ingressIp")
    def ingress_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A Private Endpoint IPv4 or IPv6 Address created in the customer's subnet.
        """
        return pulumi.get(self, "ingress_ip")

    @ingress_ip.setter
    def ingress_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingress_ip", value)


if not MYPY:
    class DeploymentLockArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
elif False:
    DeploymentLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 related_resource_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the lock.
        :param pulumi.Input[str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[str] time_created: The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "related_resource_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentMaintenanceConfigurationArgsDict(TypedDict):
        bundle_release_upgrade_period_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Defines auto upgrade period for bundle releases. Manually configured period cannot be longer than service defined period for bundle releases. This period must be shorter or equal to major release upgrade period. Not passing this field during create will equate to using the service default.
        """
        interim_release_upgrade_period_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Defines auto upgrade period for interim releases. This period must be shorter or equal to bundle release upgrade period.
        """
        is_interim_release_auto_upgrade_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) By default auto upgrade for interim releases are not enabled. If auto-upgrade is enabled for interim release,  you have to specify interimReleaseUpgradePeriodInDays too.
        """
        major_release_upgrade_period_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Defines auto upgrade period for major releases. Manually configured period cannot be longer than service defined period for major releases. Not passing this field during create will equate to using the service default.
        """
        security_patch_upgrade_period_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Defines auto upgrade period for releases with security fix. Manually configured period cannot be longer than service defined period for security releases. Not passing this field during create will equate to using the service default.
        """
elif False:
    DeploymentMaintenanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentMaintenanceConfigurationArgs:
    def __init__(__self__, *,
                 bundle_release_upgrade_period_in_days: Optional[pulumi.Input[int]] = None,
                 interim_release_upgrade_period_in_days: Optional[pulumi.Input[int]] = None,
                 is_interim_release_auto_upgrade_enabled: Optional[pulumi.Input[bool]] = None,
                 major_release_upgrade_period_in_days: Optional[pulumi.Input[int]] = None,
                 security_patch_upgrade_period_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bundle_release_upgrade_period_in_days: (Updatable) Defines auto upgrade period for bundle releases. Manually configured period cannot be longer than service defined period for bundle releases. This period must be shorter or equal to major release upgrade period. Not passing this field during create will equate to using the service default.
        :param pulumi.Input[int] interim_release_upgrade_period_in_days: (Updatable) Defines auto upgrade period for interim releases. This period must be shorter or equal to bundle release upgrade period.
        :param pulumi.Input[bool] is_interim_release_auto_upgrade_enabled: (Updatable) By default auto upgrade for interim releases are not enabled. If auto-upgrade is enabled for interim release,  you have to specify interimReleaseUpgradePeriodInDays too.
        :param pulumi.Input[int] major_release_upgrade_period_in_days: (Updatable) Defines auto upgrade period for major releases. Manually configured period cannot be longer than service defined period for major releases. Not passing this field during create will equate to using the service default.
        :param pulumi.Input[int] security_patch_upgrade_period_in_days: (Updatable) Defines auto upgrade period for releases with security fix. Manually configured period cannot be longer than service defined period for security releases. Not passing this field during create will equate to using the service default.
        """
        if bundle_release_upgrade_period_in_days is not None:
            pulumi.set(__self__, "bundle_release_upgrade_period_in_days", bundle_release_upgrade_period_in_days)
        if interim_release_upgrade_period_in_days is not None:
            pulumi.set(__self__, "interim_release_upgrade_period_in_days", interim_release_upgrade_period_in_days)
        if is_interim_release_auto_upgrade_enabled is not None:
            pulumi.set(__self__, "is_interim_release_auto_upgrade_enabled", is_interim_release_auto_upgrade_enabled)
        if major_release_upgrade_period_in_days is not None:
            pulumi.set(__self__, "major_release_upgrade_period_in_days", major_release_upgrade_period_in_days)
        if security_patch_upgrade_period_in_days is not None:
            pulumi.set(__self__, "security_patch_upgrade_period_in_days", security_patch_upgrade_period_in_days)

    @property
    @pulumi.getter(name="bundleReleaseUpgradePeriodInDays")
    def bundle_release_upgrade_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines auto upgrade period for bundle releases. Manually configured period cannot be longer than service defined period for bundle releases. This period must be shorter or equal to major release upgrade period. Not passing this field during create will equate to using the service default.
        """
        return pulumi.get(self, "bundle_release_upgrade_period_in_days")

    @bundle_release_upgrade_period_in_days.setter
    def bundle_release_upgrade_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bundle_release_upgrade_period_in_days", value)

    @property
    @pulumi.getter(name="interimReleaseUpgradePeriodInDays")
    def interim_release_upgrade_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines auto upgrade period for interim releases. This period must be shorter or equal to bundle release upgrade period.
        """
        return pulumi.get(self, "interim_release_upgrade_period_in_days")

    @interim_release_upgrade_period_in_days.setter
    def interim_release_upgrade_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interim_release_upgrade_period_in_days", value)

    @property
    @pulumi.getter(name="isInterimReleaseAutoUpgradeEnabled")
    def is_interim_release_auto_upgrade_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) By default auto upgrade for interim releases are not enabled. If auto-upgrade is enabled for interim release,  you have to specify interimReleaseUpgradePeriodInDays too.
        """
        return pulumi.get(self, "is_interim_release_auto_upgrade_enabled")

    @is_interim_release_auto_upgrade_enabled.setter
    def is_interim_release_auto_upgrade_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_interim_release_auto_upgrade_enabled", value)

    @property
    @pulumi.getter(name="majorReleaseUpgradePeriodInDays")
    def major_release_upgrade_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines auto upgrade period for major releases. Manually configured period cannot be longer than service defined period for major releases. Not passing this field during create will equate to using the service default.
        """
        return pulumi.get(self, "major_release_upgrade_period_in_days")

    @major_release_upgrade_period_in_days.setter
    def major_release_upgrade_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "major_release_upgrade_period_in_days", value)

    @property
    @pulumi.getter(name="securityPatchUpgradePeriodInDays")
    def security_patch_upgrade_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines auto upgrade period for releases with security fix. Manually configured period cannot be longer than service defined period for security releases. Not passing this field during create will equate to using the service default.
        """
        return pulumi.get(self, "security_patch_upgrade_period_in_days")

    @security_patch_upgrade_period_in_days.setter
    def security_patch_upgrade_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "security_patch_upgrade_period_in_days", value)


if not MYPY:
    class DeploymentMaintenanceWindowArgsDict(TypedDict):
        day: pulumi.Input[str]
        """
        (Updatable) Days of the week.
        """
        start_hour: pulumi.Input[int]
        """
        (Updatable) Start hour for maintenance period. Hour is in UTC.
        """
elif False:
    DeploymentMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[str],
                 start_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[str] day: (Updatable) Days of the week.
        :param pulumi.Input[int] start_hour: (Updatable) Start hour for maintenance period. Hour is in UTC.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_hour", start_hour)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[str]:
        """
        (Updatable) Days of the week.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        """
        (Updatable) Start hour for maintenance period. Hour is in UTC.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)


if not MYPY:
    class DeploymentOggDataArgsDict(TypedDict):
        deployment_name: pulumi.Input[str]
        """
        The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        """
        admin_password: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as ‘$’, ‘^’, or ‘?’ are not allowed. This field will be deprecated and replaced by "passwordSecretId".
        """
        admin_username: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The GoldenGate deployment console username.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The base64 encoded content of the PEM file containing the SSL certificate.
        """
        credential_store: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The type of credential store for OGG.
        """
        group_to_roles_mapping: NotRequired[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgsDict']]
        """
        (Updatable) Defines the IDP Groups to GoldenGate roles mapping. This field is used only for IAM deployment and does not have any impact on non-IAM deployments. For IAM deployment, when user does not specify this mapping, then it has null value and default mapping is used. User belonging to each group can only perform the actions according to the role the respective group is mapped to.
        """
        identity_domain_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Identity Domain when IAM credential store is used.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The base64 encoded content of the PEM file containing the private key.
        """
        ogg_version: NotRequired[pulumi.Input[str]]
        """
        Version of OGG
        """
        password_secret_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the deployment password is stored.
        """
elif False:
    DeploymentOggDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentOggDataArgs:
    def __init__(__self__, *,
                 deployment_name: pulumi.Input[str],
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 credential_store: Optional[pulumi.Input[str]] = None,
                 group_to_roles_mapping: Optional[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs']] = None,
                 identity_domain_id: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 ogg_version: Optional[pulumi.Input[str]] = None,
                 password_secret_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deployment_name: The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        :param pulumi.Input[str] admin_password: (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as ‘$’, ‘^’, or ‘?’ are not allowed. This field will be deprecated and replaced by "passwordSecretId".
        :param pulumi.Input[str] admin_username: (Updatable) The GoldenGate deployment console username.
        :param pulumi.Input[str] certificate: (Updatable) The base64 encoded content of the PEM file containing the SSL certificate.
        :param pulumi.Input[str] credential_store: (Updatable) The type of credential store for OGG.
        :param pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs'] group_to_roles_mapping: (Updatable) Defines the IDP Groups to GoldenGate roles mapping. This field is used only for IAM deployment and does not have any impact on non-IAM deployments. For IAM deployment, when user does not specify this mapping, then it has null value and default mapping is used. User belonging to each group can only perform the actions according to the role the respective group is mapped to.
        :param pulumi.Input[str] identity_domain_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Identity Domain when IAM credential store is used.
        :param pulumi.Input[str] key: (Updatable) The base64 encoded content of the PEM file containing the private key.
        :param pulumi.Input[str] ogg_version: Version of OGG
        :param pulumi.Input[str] password_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the deployment password is stored.
        """
        pulumi.set(__self__, "deployment_name", deployment_name)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if credential_store is not None:
            pulumi.set(__self__, "credential_store", credential_store)
        if group_to_roles_mapping is not None:
            pulumi.set(__self__, "group_to_roles_mapping", group_to_roles_mapping)
        if identity_domain_id is not None:
            pulumi.set(__self__, "identity_domain_id", identity_domain_id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if ogg_version is not None:
            pulumi.set(__self__, "ogg_version", ogg_version)
        if password_secret_id is not None:
            pulumi.set(__self__, "password_secret_id", password_secret_id)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> pulumi.Input[str]:
        """
        The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        """
        return pulumi.get(self, "deployment_name")

    @deployment_name.setter
    def deployment_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment_name", value)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as ‘$’, ‘^’, or ‘?’ are not allowed. This field will be deprecated and replaced by "passwordSecretId".
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The GoldenGate deployment console username.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The base64 encoded content of the PEM file containing the SSL certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="credentialStore")
    def credential_store(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of credential store for OGG.
        """
        return pulumi.get(self, "credential_store")

    @credential_store.setter
    def credential_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_store", value)

    @property
    @pulumi.getter(name="groupToRolesMapping")
    def group_to_roles_mapping(self) -> Optional[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs']]:
        """
        (Updatable) Defines the IDP Groups to GoldenGate roles mapping. This field is used only for IAM deployment and does not have any impact on non-IAM deployments. For IAM deployment, when user does not specify this mapping, then it has null value and default mapping is used. User belonging to each group can only perform the actions according to the role the respective group is mapped to.
        """
        return pulumi.get(self, "group_to_roles_mapping")

    @group_to_roles_mapping.setter
    def group_to_roles_mapping(self, value: Optional[pulumi.Input['DeploymentOggDataGroupToRolesMappingArgs']]):
        pulumi.set(self, "group_to_roles_mapping", value)

    @property
    @pulumi.getter(name="identityDomainId")
    def identity_domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Identity Domain when IAM credential store is used.
        """
        return pulumi.get(self, "identity_domain_id")

    @identity_domain_id.setter
    def identity_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_domain_id", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The base64 encoded content of the PEM file containing the private key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="oggVersion")
    def ogg_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of OGG
        """
        return pulumi.get(self, "ogg_version")

    @ogg_version.setter
    def ogg_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ogg_version", value)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the deployment password is stored.
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_secret_id", value)


if not MYPY:
    class DeploymentOggDataGroupToRolesMappingArgsDict(TypedDict):
        security_group_id: pulumi.Input[str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role securityGroup. It grants administration of security related objects and invoke security related service requests. This role has full privileges.
        """
        administrator_group_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role administratorGroup. It grants full access to the user, including the ability to alter general, non-security related operational parameters and profiles of the server.
        """
        operator_group_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role operatorGroup. It allows users to perform only operational actions, like starting and stopping resources. Operators cannot alter the operational parameters or profiles of the MA server.
        """
        user_group_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role userGroup. It allows information-only service requests, which do not alter or affect the operation of either the MA. Examples of query and read-only information include performance metric information and resource status and monitoring information
        """
elif False:
    DeploymentOggDataGroupToRolesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentOggDataGroupToRolesMappingArgs:
    def __init__(__self__, *,
                 security_group_id: pulumi.Input[str],
                 administrator_group_id: Optional[pulumi.Input[str]] = None,
                 operator_group_id: Optional[pulumi.Input[str]] = None,
                 user_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] security_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role securityGroup. It grants administration of security related objects and invoke security related service requests. This role has full privileges.
        :param pulumi.Input[str] administrator_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role administratorGroup. It grants full access to the user, including the ability to alter general, non-security related operational parameters and profiles of the server.
        :param pulumi.Input[str] operator_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role operatorGroup. It allows users to perform only operational actions, like starting and stopping resources. Operators cannot alter the operational parameters or profiles of the MA server.
        :param pulumi.Input[str] user_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role userGroup. It allows information-only service requests, which do not alter or affect the operation of either the MA. Examples of query and read-only information include performance metric information and resource status and monitoring information
        """
        pulumi.set(__self__, "security_group_id", security_group_id)
        if administrator_group_id is not None:
            pulumi.set(__self__, "administrator_group_id", administrator_group_id)
        if operator_group_id is not None:
            pulumi.set(__self__, "operator_group_id", operator_group_id)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role securityGroup. It grants administration of security related objects and invoke security related service requests. This role has full privileges.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="administratorGroupId")
    def administrator_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role administratorGroup. It grants full access to the user, including the ability to alter general, non-security related operational parameters and profiles of the server.
        """
        return pulumi.get(self, "administrator_group_id")

    @administrator_group_id.setter
    def administrator_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "administrator_group_id", value)

    @property
    @pulumi.getter(name="operatorGroupId")
    def operator_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role operatorGroup. It allows users to perform only operational actions, like starting and stopping resources. Operators cannot alter the operational parameters or profiles of the MA server.
        """
        return pulumi.get(self, "operator_group_id")

    @operator_group_id.setter
    def operator_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator_group_id", value)

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the IDP group which will be mapped to goldengate role userGroup. It allows information-only service requests, which do not alter or affect the operation of either the MA. Examples of query and read-only information include performance metric information and resource status and monitoring information
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_group_id", value)


if not MYPY:
    class GetConnectionAssignmentsFilterArgsDict(TypedDict):
        name: str
        """
        The name of the connection in the assignment (aliasName).
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetConnectionAssignmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionAssignmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the connection in the assignment (aliasName).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the connection in the assignment (aliasName).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetConnectionsFilterArgsDict(TypedDict):
        name: str
        """
        The name of the property entry.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetConnectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the property entry.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the property entry.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabaseRegistrationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDatabaseRegistrationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseRegistrationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentBackupsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentCertificatesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentCertificatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentEnvironmentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentEnvironmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentTypesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentTypesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentUpgradesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentUpgradesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentUpgradesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDeploymentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMessagesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetMessagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMessagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTrailFilesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetTrailFilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrailFilesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetTrailSequencesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetTrailSequencesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTrailSequencesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


