# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'LogAnalyticsEntityMetadataArgs',
    'LogAnalyticsEntityMetadataArgsDict',
    'LogAnalyticsEntityMetadataItemArgs',
    'LogAnalyticsEntityMetadataItemArgsDict',
    'LogAnalyticsEntityTypePropertyArgs',
    'LogAnalyticsEntityTypePropertyArgsDict',
    'LogAnalyticsImportCustomContentChangeListArgs',
    'LogAnalyticsImportCustomContentChangeListArgsDict',
    'LogAnalyticsObjectCollectionRuleOverrideArgs',
    'LogAnalyticsObjectCollectionRuleOverrideArgsDict',
    'LogAnalyticsPreferencesManagementItemArgs',
    'LogAnalyticsPreferencesManagementItemArgsDict',
    'NamespaceIngestTimeRuleActionArgs',
    'NamespaceIngestTimeRuleActionArgsDict',
    'NamespaceIngestTimeRuleConditionsArgs',
    'NamespaceIngestTimeRuleConditionsArgsDict',
    'NamespaceIngestTimeRuleConditionsAdditionalConditionArgs',
    'NamespaceIngestTimeRuleConditionsAdditionalConditionArgsDict',
    'NamespaceLookupCategoryArgs',
    'NamespaceLookupCategoryArgsDict',
    'NamespaceLookupFieldArgs',
    'NamespaceLookupFieldArgsDict',
    'NamespaceLookupReferringSourceArgs',
    'NamespaceLookupReferringSourceArgsDict',
    'NamespaceLookupStatusSummaryArgs',
    'NamespaceLookupStatusSummaryArgsDict',
    'NamespaceScheduledTaskActionArgs',
    'NamespaceScheduledTaskActionArgsDict',
    'NamespaceScheduledTaskActionMetricExtractionArgs',
    'NamespaceScheduledTaskActionMetricExtractionArgsDict',
    'NamespaceScheduledTaskActionTemplateDetailsArgs',
    'NamespaceScheduledTaskActionTemplateDetailsArgsDict',
    'NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs',
    'NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgsDict',
    'NamespaceScheduledTaskSchedulesArgs',
    'NamespaceScheduledTaskSchedulesArgsDict',
    'NamespaceScheduledTaskSchedulesScheduleArgs',
    'NamespaceScheduledTaskSchedulesScheduleArgsDict',
    'NamespaceStorageArchivalConfigArchivingConfigurationArgs',
    'NamespaceStorageArchivalConfigArchivingConfigurationArgsDict',
    'GetLogAnalyticsEntitiesFilterArgs',
    'GetLogAnalyticsEntitiesFilterArgsDict',
    'GetLogAnalyticsEntityTopologyFilterArgs',
    'GetLogAnalyticsEntityTopologyFilterArgsDict',
    'GetLogAnalyticsEntityTypesFilterArgs',
    'GetLogAnalyticsEntityTypesFilterArgsDict',
    'GetLogAnalyticsLogGroupsFilterArgs',
    'GetLogAnalyticsLogGroupsFilterArgsDict',
    'GetLogAnalyticsObjectCollectionRulesFilterArgs',
    'GetLogAnalyticsObjectCollectionRulesFilterArgsDict',
    'GetNamespaceEffectivePropertiesFilterArgs',
    'GetNamespaceEffectivePropertiesFilterArgsDict',
    'GetNamespaceIngestTimeRulesFilterArgs',
    'GetNamespaceIngestTimeRulesFilterArgsDict',
    'GetNamespaceParserActionsFilterArgs',
    'GetNamespaceParserActionsFilterArgsDict',
    'GetNamespacePropertiesMetadataFilterArgs',
    'GetNamespacePropertiesMetadataFilterArgsDict',
    'GetNamespaceRulesFilterArgs',
    'GetNamespaceRulesFilterArgsDict',
    'GetNamespaceScheduledTasksFilterArgs',
    'GetNamespaceScheduledTasksFilterArgsDict',
    'GetNamespaceStorageOverlappingRecallsFilterArgs',
    'GetNamespaceStorageOverlappingRecallsFilterArgsDict',
    'GetNamespaceTemplatesFilterArgs',
    'GetNamespaceTemplatesFilterArgsDict',
    'GetNamespacesFilterArgs',
    'GetNamespacesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class LogAnalyticsEntityMetadataArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgsDict']]]]
        """
        (Updatable) An array of entity metadata details.
        """
elif False:
    LogAnalyticsEntityMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsEntityMetadataArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]] items: (Updatable) An array of entity metadata details.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]]]:
        """
        (Updatable) An array of entity metadata details.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class LogAnalyticsEntityMetadataItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The metadata name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The metadata type.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The metadata value.
        """
elif False:
    LogAnalyticsEntityMetadataItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsEntityMetadataItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The metadata name.
        :param pulumi.Input[_builtins.str] type: (Updatable) The metadata type.
        :param pulumi.Input[_builtins.str] value: (Updatable) The metadata value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The metadata name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The metadata type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The metadata value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LogAnalyticsEntityTypePropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Log analytics entity type property name. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description for the log analytics entity type property.
        """
elif False:
    LogAnalyticsEntityTypePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsEntityTypePropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Log analytics entity type property name. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] description: Description for the log analytics entity type property.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Log analytics entity type property name. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description for the log analytics entity type property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class LogAnalyticsImportCustomContentChangeListArgsDict(TypedDict):
        conflict_field_display_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of field display names with conflicts.
        """
        conflict_parser_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of parser names with conflicts.
        """
        conflict_source_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of source names with conflicts.
        """
        created_field_display_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of created field display names.
        """
        created_parser_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of created parser names.
        """
        created_source_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of created source names.
        """
        updated_field_display_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of updated field display names.
        """
        updated_parser_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of updated parser names.
        """
        updated_source_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of updated source names.
        """
elif False:
    LogAnalyticsImportCustomContentChangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsImportCustomContentChangeListArgs:
    def __init__(__self__, *,
                 conflict_field_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 conflict_parser_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 conflict_source_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 created_field_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 created_parser_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 created_source_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 updated_field_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 updated_parser_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 updated_source_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] conflict_field_display_names: A list of field display names with conflicts.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] conflict_parser_names: A list of parser names with conflicts.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] conflict_source_names: A list of source names with conflicts.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] created_field_display_names: An array of created field display names.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] created_parser_names: An array of created parser names.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] created_source_names: An array of created source names.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] updated_field_display_names: An array of updated field display names.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] updated_parser_names: An array of updated parser names.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] updated_source_names: An array of updated source names.
        """
        if conflict_field_display_names is not None:
            pulumi.set(__self__, "conflict_field_display_names", conflict_field_display_names)
        if conflict_parser_names is not None:
            pulumi.set(__self__, "conflict_parser_names", conflict_parser_names)
        if conflict_source_names is not None:
            pulumi.set(__self__, "conflict_source_names", conflict_source_names)
        if created_field_display_names is not None:
            pulumi.set(__self__, "created_field_display_names", created_field_display_names)
        if created_parser_names is not None:
            pulumi.set(__self__, "created_parser_names", created_parser_names)
        if created_source_names is not None:
            pulumi.set(__self__, "created_source_names", created_source_names)
        if updated_field_display_names is not None:
            pulumi.set(__self__, "updated_field_display_names", updated_field_display_names)
        if updated_parser_names is not None:
            pulumi.set(__self__, "updated_parser_names", updated_parser_names)
        if updated_source_names is not None:
            pulumi.set(__self__, "updated_source_names", updated_source_names)

    @_builtins.property
    @pulumi.getter(name="conflictFieldDisplayNames")
    def conflict_field_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of field display names with conflicts.
        """
        return pulumi.get(self, "conflict_field_display_names")

    @conflict_field_display_names.setter
    def conflict_field_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "conflict_field_display_names", value)

    @_builtins.property
    @pulumi.getter(name="conflictParserNames")
    def conflict_parser_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of parser names with conflicts.
        """
        return pulumi.get(self, "conflict_parser_names")

    @conflict_parser_names.setter
    def conflict_parser_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "conflict_parser_names", value)

    @_builtins.property
    @pulumi.getter(name="conflictSourceNames")
    def conflict_source_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of source names with conflicts.
        """
        return pulumi.get(self, "conflict_source_names")

    @conflict_source_names.setter
    def conflict_source_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "conflict_source_names", value)

    @_builtins.property
    @pulumi.getter(name="createdFieldDisplayNames")
    def created_field_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of created field display names.
        """
        return pulumi.get(self, "created_field_display_names")

    @created_field_display_names.setter
    def created_field_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "created_field_display_names", value)

    @_builtins.property
    @pulumi.getter(name="createdParserNames")
    def created_parser_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of created parser names.
        """
        return pulumi.get(self, "created_parser_names")

    @created_parser_names.setter
    def created_parser_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "created_parser_names", value)

    @_builtins.property
    @pulumi.getter(name="createdSourceNames")
    def created_source_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of created source names.
        """
        return pulumi.get(self, "created_source_names")

    @created_source_names.setter
    def created_source_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "created_source_names", value)

    @_builtins.property
    @pulumi.getter(name="updatedFieldDisplayNames")
    def updated_field_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of updated field display names.
        """
        return pulumi.get(self, "updated_field_display_names")

    @updated_field_display_names.setter
    def updated_field_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "updated_field_display_names", value)

    @_builtins.property
    @pulumi.getter(name="updatedParserNames")
    def updated_parser_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of updated parser names.
        """
        return pulumi.get(self, "updated_parser_names")

    @updated_parser_names.setter
    def updated_parser_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "updated_parser_names", value)

    @_builtins.property
    @pulumi.getter(name="updatedSourceNames")
    def updated_source_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of updated source names.
        """
        return pulumi.get(self, "updated_source_names")

    @updated_source_names.setter
    def updated_source_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "updated_source_names", value)


if not MYPY:
    class LogAnalyticsObjectCollectionRuleOverrideArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[_builtins.str]]
        match_value: NotRequired[pulumi.Input[_builtins.str]]
        property_name: NotRequired[pulumi.Input[_builtins.str]]
        property_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogAnalyticsObjectCollectionRuleOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsObjectCollectionRuleOverrideArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None,
                 match_value: Optional[pulumi.Input[_builtins.str]] = None,
                 property_name: Optional[pulumi.Input[_builtins.str]] = None,
                 property_value: Optional[pulumi.Input[_builtins.str]] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_value is not None:
            pulumi.set(__self__, "property_value", property_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property_name", value)

    @_builtins.property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property_value", value)


if not MYPY:
    class LogAnalyticsPreferencesManagementItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The preference name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The preference value.
        """
elif False:
    LogAnalyticsPreferencesManagementItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsPreferencesManagementItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The preference name.
        :param pulumi.Input[_builtins.str] value: The preference value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The preference name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The preference value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NamespaceIngestTimeRuleActionArgsDict(TypedDict):
        compartment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Discriminator.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
elif False:
    NamespaceIngestTimeRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceIngestTimeRuleActionArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[_builtins.str],
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param pulumi.Input[_builtins.str] metric_name: (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param pulumi.Input[_builtins.str] type: (Updatable) Discriminator.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dimensions: (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        :param pulumi.Input[_builtins.str] resource_group: (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "type", type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)


if not MYPY:
    class NamespaceIngestTimeRuleConditionsArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The field name to be evaluated.
        """
        field_operator: pulumi.Input[_builtins.str]
        """
        (Updatable) The operator to be used for evaluating the field.
        """
        field_value: pulumi.Input[_builtins.str]
        """
        (Updatable) The field value to be evaluated.
        """
        kind: pulumi.Input[_builtins.str]
        """
        (Updatable) Discriminator.
        """
        additional_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgsDict']]]]
        """
        (Updatable) Optional additional condition(s) to be evaluated.
        """
elif False:
    NamespaceIngestTimeRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceIngestTimeRuleConditionsArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 field_operator: pulumi.Input[_builtins.str],
                 field_value: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str],
                 additional_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: (Updatable) The field name to be evaluated.
        :param pulumi.Input[_builtins.str] field_operator: (Updatable) The operator to be used for evaluating the field.
        :param pulumi.Input[_builtins.str] field_value: (Updatable) The field value to be evaluated.
        :param pulumi.Input[_builtins.str] kind: (Updatable) Discriminator.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]] additional_conditions: (Updatable) Optional additional condition(s) to be evaluated.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_operator", field_operator)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "kind", kind)
        if additional_conditions is not None:
            pulumi.set(__self__, "additional_conditions", additional_conditions)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The field name to be evaluated.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldOperator")
    def field_operator(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The operator to be used for evaluating the field.
        """
        return pulumi.get(self, "field_operator")

    @field_operator.setter
    def field_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_operator", value)

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The field value to be evaluated.
        """
        return pulumi.get(self, "field_value")

    @field_value.setter
    def field_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_value", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="additionalConditions")
    def additional_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]]]:
        """
        (Updatable) Optional additional condition(s) to be evaluated.
        """
        return pulumi.get(self, "additional_conditions")

    @additional_conditions.setter
    def additional_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]]]):
        pulumi.set(self, "additional_conditions", value)


if not MYPY:
    class NamespaceIngestTimeRuleConditionsAdditionalConditionArgsDict(TypedDict):
        condition_field: pulumi.Input[_builtins.str]
        """
        (Updatable) The additional field name to be evaluated.
        """
        condition_operator: pulumi.Input[_builtins.str]
        """
        (Updatable) The operator to be used for evaluating the additional field.
        """
        condition_value: pulumi.Input[_builtins.str]
        """
        (Updatable) The additional field value to be evaluated.
        """
elif False:
    NamespaceIngestTimeRuleConditionsAdditionalConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceIngestTimeRuleConditionsAdditionalConditionArgs:
    def __init__(__self__, *,
                 condition_field: pulumi.Input[_builtins.str],
                 condition_operator: pulumi.Input[_builtins.str],
                 condition_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] condition_field: (Updatable) The additional field name to be evaluated.
        :param pulumi.Input[_builtins.str] condition_operator: (Updatable) The operator to be used for evaluating the additional field.
        :param pulumi.Input[_builtins.str] condition_value: (Updatable) The additional field value to be evaluated.
        """
        pulumi.set(__self__, "condition_field", condition_field)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_value", condition_value)

    @_builtins.property
    @pulumi.getter(name="conditionField")
    def condition_field(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The additional field name to be evaluated.
        """
        return pulumi.get(self, "condition_field")

    @condition_field.setter
    def condition_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_field", value)

    @_builtins.property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The operator to be used for evaluating the additional field.
        """
        return pulumi.get(self, "condition_operator")

    @condition_operator.setter
    def condition_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_operator", value)

    @_builtins.property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The additional field value to be evaluated.
        """
        return pulumi.get(self, "condition_value")

    @condition_value.setter
    def condition_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_value", value)


if not MYPY:
    class NamespaceLookupCategoryArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The category description.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The category display name.
        """
        is_system: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The unique name that identifies the category.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
elif False:
    NamespaceLookupCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceLookupCategoryArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_system: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) The category description.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The category display name.
        :param pulumi.Input[_builtins.bool] is_system: (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param pulumi.Input[_builtins.str] name: (Updatable) The unique name that identifies the category.
        :param pulumi.Input[_builtins.str] type: (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The category description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The category display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_system", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The unique name that identifies the category.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NamespaceLookupFieldArgsDict(TypedDict):
        common_field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The common field name.
        """
        default_match_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The default match value.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The display name.
        """
        is_common_field: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) A flag indicating whether or not the field is a common field.
        """
        match_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The match operator.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The field name.
        """
        position: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The position.
        """
elif False:
    NamespaceLookupFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceLookupFieldArgs:
    def __init__(__self__, *,
                 common_field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 default_match_value: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_common_field: Optional[pulumi.Input[_builtins.bool]] = None,
                 match_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 position: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] common_field_name: (Updatable) The common field name.
        :param pulumi.Input[_builtins.str] default_match_value: (Updatable) The default match value.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The display name.
        :param pulumi.Input[_builtins.bool] is_common_field: (Updatable) A flag indicating whether or not the field is a common field.
        :param pulumi.Input[_builtins.str] match_operator: (Updatable) The match operator.
        :param pulumi.Input[_builtins.str] name: (Updatable) The field name.
        :param pulumi.Input[_builtins.str] position: (Updatable) The position.
        """
        if common_field_name is not None:
            pulumi.set(__self__, "common_field_name", common_field_name)
        if default_match_value is not None:
            pulumi.set(__self__, "default_match_value", default_match_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_common_field is not None:
            pulumi.set(__self__, "is_common_field", is_common_field)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="commonFieldName")
    def common_field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The common field name.
        """
        return pulumi.get(self, "common_field_name")

    @common_field_name.setter
    def common_field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "common_field_name", value)

    @_builtins.property
    @pulumi.getter(name="defaultMatchValue")
    def default_match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The default match value.
        """
        return pulumi.get(self, "default_match_value")

    @default_match_value.setter
    def default_match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_match_value", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="isCommonField")
    def is_common_field(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) A flag indicating whether or not the field is a common field.
        """
        return pulumi.get(self, "is_common_field")

    @is_common_field.setter
    def is_common_field(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_common_field", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The match operator.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The field name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The position.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class NamespaceLookupReferringSourceArgsDict(TypedDict):
        canonical_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        The canonical link.
        """
        total_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        The total count.
        """
elif False:
    NamespaceLookupReferringSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceLookupReferringSourceArgs:
    def __init__(__self__, *,
                 canonical_link: Optional[pulumi.Input[_builtins.str]] = None,
                 total_count: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] canonical_link: The canonical link.
        :param pulumi.Input[_builtins.str] total_count: The total count.
        """
        if canonical_link is not None:
            pulumi.set(__self__, "canonical_link", canonical_link)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter(name="canonicalLink")
    def canonical_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The canonical link.
        """
        return pulumi.get(self, "canonical_link")

    @canonical_link.setter
    def canonical_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canonical_link", value)

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The total count.
        """
        return pulumi.get(self, "total_count")

    @total_count.setter
    def total_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "total_count", value)


if not MYPY:
    class NamespaceLookupStatusSummaryArgsDict(TypedDict):
        chunks_processed: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of chunks processed.
        """
        failure_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        The failure details, if any.
        """
        filename: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filename.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status.
        """
        total_chunks: NotRequired[pulumi.Input[_builtins.str]]
        """
        The total number of chunks.
        """
elif False:
    NamespaceLookupStatusSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceLookupStatusSummaryArgs:
    def __init__(__self__, *,
                 chunks_processed: Optional[pulumi.Input[_builtins.str]] = None,
                 failure_details: Optional[pulumi.Input[_builtins.str]] = None,
                 filename: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 total_chunks: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] chunks_processed: The number of chunks processed.
        :param pulumi.Input[_builtins.str] failure_details: The failure details, if any.
        :param pulumi.Input[_builtins.str] filename: The filename.
        :param pulumi.Input[_builtins.str] status: The status.
        :param pulumi.Input[_builtins.str] total_chunks: The total number of chunks.
        """
        if chunks_processed is not None:
            pulumi.set(__self__, "chunks_processed", chunks_processed)
        if failure_details is not None:
            pulumi.set(__self__, "failure_details", failure_details)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if total_chunks is not None:
            pulumi.set(__self__, "total_chunks", total_chunks)

    @_builtins.property
    @pulumi.getter(name="chunksProcessed")
    def chunks_processed(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of chunks processed.
        """
        return pulumi.get(self, "chunks_processed")

    @chunks_processed.setter
    def chunks_processed(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "chunks_processed", value)

    @_builtins.property
    @pulumi.getter(name="failureDetails")
    def failure_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The failure details, if any.
        """
        return pulumi.get(self, "failure_details")

    @failure_details.setter
    def failure_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "failure_details", value)

    @_builtins.property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filename.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filename", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="totalChunks")
    def total_chunks(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The total number of chunks.
        """
        return pulumi.get(self, "total_chunks")

    @total_chunks.setter
    def total_chunks(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "total_chunks", value)


if not MYPY:
    class NamespaceScheduledTaskActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Action type discriminator.
        """
        compartment_id_in_subtree: NotRequired[pulumi.Input[_builtins.bool]]
        """
        if true, purge child compartments data
        """
        data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        the type of the log data to be purged
        """
        metric_extraction: NotRequired[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgsDict']]
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        purge_compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        the compartment OCID under which the data will be purged
        """
        purge_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        query_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Purge query string.
        """
        saved_search_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        """
        template_details: NotRequired[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsArgsDict']]
        """
        details for scheduled task using template
        """
elif False:
    NamespaceScheduledTaskActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceScheduledTaskActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 compartment_id_in_subtree: Optional[pulumi.Input[_builtins.bool]] = None,
                 data_type: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_extraction: Optional[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs']] = None,
                 purge_compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 purge_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 query_string: Optional[pulumi.Input[_builtins.str]] = None,
                 saved_search_id: Optional[pulumi.Input[_builtins.str]] = None,
                 template_details: Optional[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Action type discriminator.
        :param pulumi.Input[_builtins.bool] compartment_id_in_subtree: if true, purge child compartments data
        :param pulumi.Input[_builtins.str] data_type: the type of the log data to be purged
        :param pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs'] metric_extraction: Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        :param pulumi.Input[_builtins.str] purge_compartment_id: the compartment OCID under which the data will be purged
        :param pulumi.Input[_builtins.str] purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param pulumi.Input[_builtins.str] query_string: Purge query string.
        :param pulumi.Input[_builtins.str] saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        :param pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsArgs'] template_details: details for scheduled task using template
        """
        pulumi.set(__self__, "type", type)
        if compartment_id_in_subtree is not None:
            pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if metric_extraction is not None:
            pulumi.set(__self__, "metric_extraction", metric_extraction)
        if purge_compartment_id is not None:
            pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        if purge_duration is not None:
            pulumi.set(__self__, "purge_duration", purge_duration)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if saved_search_id is not None:
            pulumi.set(__self__, "saved_search_id", saved_search_id)
        if template_details is not None:
            pulumi.set(__self__, "template_details", template_details)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Action type discriminator.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @compartment_id_in_subtree.setter
    def compartment_id_in_subtree(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compartment_id_in_subtree", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_type", value)

    @_builtins.property
    @pulumi.getter(name="metricExtraction")
    def metric_extraction(self) -> Optional[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs']]:
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        return pulumi.get(self, "metric_extraction")

    @metric_extraction.setter
    def metric_extraction(self, value: Optional[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs']]):
        pulumi.set(self, "metric_extraction", value)

    @_builtins.property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @purge_compartment_id.setter
    def purge_compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purge_compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @purge_duration.setter
    def purge_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purge_duration", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        """
        return pulumi.get(self, "saved_search_id")

    @saved_search_id.setter
    def saved_search_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "saved_search_id", value)

    @_builtins.property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Optional[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsArgs']]:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")

    @template_details.setter
    def template_details(self, value: Optional[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsArgs']]):
        pulumi.set(self, "template_details", value)


if not MYPY:
    class NamespaceScheduledTaskActionMetricExtractionArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
elif False:
    NamespaceScheduledTaskActionMetricExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceScheduledTaskActionMetricExtractionArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param pulumi.Input[_builtins.str] metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param pulumi.Input[_builtins.str] namespace: The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param pulumi.Input[_builtins.str] resource_group: The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)


if not MYPY:
    class NamespaceScheduledTaskActionTemplateDetailsArgsDict(TypedDict):
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The template Id of a particular template.  Should not be provided when a saved search ID is present.
        """
        template_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgsDict']]]]
        """
        To store macro params.
        """
elif False:
    NamespaceScheduledTaskActionTemplateDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceScheduledTaskActionTemplateDetailsArgs:
    def __init__(__self__, *,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 template_params: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] template_id: The template Id of a particular template.  Should not be provided when a saved search ID is present.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs']]] template_params: To store macro params.
        """
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if template_params is not None:
            pulumi.set(__self__, "template_params", template_params)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The template Id of a particular template.  Should not be provided when a saved search ID is present.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs']]]]:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")

    @template_params.setter
    def template_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs']]]]):
        pulumi.set(self, "template_params", value)


if not MYPY:
    class NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgsDict(TypedDict):
        key_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains a template parameter's name.
        """
        value_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains the desired value for a given parameter.
        """
elif False:
    NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs:
    def __init__(__self__, *,
                 key_field: Optional[pulumi.Input[_builtins.str]] = None,
                 value_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key_field: Contains a template parameter's name.
        :param pulumi.Input[_builtins.str] value_field: Contains the desired value for a given parameter.
        """
        if key_field is not None:
            pulumi.set(__self__, "key_field", key_field)
        if value_field is not None:
            pulumi.set(__self__, "value_field", value_field)

    @_builtins.property
    @pulumi.getter(name="keyField")
    def key_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains a template parameter's name.
        """
        return pulumi.get(self, "key_field")

    @key_field.setter
    def key_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_field", value)

    @_builtins.property
    @pulumi.getter(name="valueField")
    def value_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains the desired value for a given parameter.
        """
        return pulumi.get(self, "value_field")

    @value_field.setter
    def value_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_field", value)


if not MYPY:
    class NamespaceScheduledTaskSchedulesArgsDict(TypedDict):
        schedules: pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgsDict']]]
elif False:
    NamespaceScheduledTaskSchedulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceScheduledTaskSchedulesArgs:
    def __init__(__self__, *,
                 schedules: pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgs']]]):
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgs']]]:
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgs']]]):
        pulumi.set(self, "schedules", value)


if not MYPY:
    class NamespaceScheduledTaskSchedulesScheduleArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Schedule type discriminator.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value in cron format.
        """
        misfire_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schedule misfire retry policy.
        """
        recurring_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        repeat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone, by default UTC.
        """
elif False:
    NamespaceScheduledTaskSchedulesScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceScheduledTaskSchedulesScheduleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 misfire_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 recurring_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 repeat_count: Optional[pulumi.Input[_builtins.int]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Schedule type discriminator.
        :param pulumi.Input[_builtins.str] expression: Value in cron format.
        :param pulumi.Input[_builtins.str] misfire_policy: Schedule misfire retry policy.
        :param pulumi.Input[_builtins.str] recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param pulumi.Input[_builtins.int] repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param pulumi.Input[_builtins.str] time_zone: Time zone, by default UTC.
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if misfire_policy is not None:
            pulumi.set(__self__, "misfire_policy", misfire_policy)
        if recurring_interval is not None:
            pulumi.set(__self__, "recurring_interval", recurring_interval)
        if repeat_count is not None:
            pulumi.set(__self__, "repeat_count", repeat_count)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @misfire_policy.setter
    def misfire_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "misfire_policy", value)

    @_builtins.property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @recurring_interval.setter
    def recurring_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurring_interval", value)

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @repeat_count.setter
    def repeat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "repeat_count", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class NamespaceStorageArchivalConfigArchivingConfigurationArgsDict(TypedDict):
        active_storage_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        archival_storage_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
elif False:
    NamespaceStorageArchivalConfigArchivingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceStorageArchivalConfigArchivingConfigurationArgs:
    def __init__(__self__, *,
                 active_storage_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 archival_storage_duration: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] active_storage_duration: (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        :param pulumi.Input[_builtins.str] archival_storage_duration: (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        if active_storage_duration is not None:
            pulumi.set(__self__, "active_storage_duration", active_storage_duration)
        if archival_storage_duration is not None:
            pulumi.set(__self__, "archival_storage_duration", archival_storage_duration)

    @_builtins.property
    @pulumi.getter(name="activeStorageDuration")
    def active_storage_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "active_storage_duration")

    @active_storage_duration.setter
    def active_storage_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active_storage_duration", value)

    @_builtins.property
    @pulumi.getter(name="archivalStorageDuration")
    def archival_storage_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "archival_storage_duration")

    @archival_storage_duration.setter
    def archival_storage_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "archival_storage_duration", value)


if not MYPY:
    class GetLogAnalyticsEntitiesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLogAnalyticsEntitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogAnalyticsEntitiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLogAnalyticsEntityTopologyFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Log analytics entity name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLogAnalyticsEntityTopologyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogAnalyticsEntityTopologyFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Log analytics entity name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLogAnalyticsEntityTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLogAnalyticsEntityTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogAnalyticsEntityTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLogAnalyticsLogGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLogAnalyticsLogGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogAnalyticsLogGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLogAnalyticsObjectCollectionRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return rules only matching with this name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetLogAnalyticsObjectCollectionRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogAnalyticsObjectCollectionRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return rules only matching with this name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceEffectivePropertiesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The property name used for filtering.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceEffectivePropertiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceEffectivePropertiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceIngestTimeRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceIngestTimeRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceIngestTimeRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceParserActionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The parser action name used for filtering.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceParserActionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceParserActionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The parser action name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The parser action name used for filtering.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespacePropertiesMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The property name used for filtering.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespacePropertiesMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespacePropertiesMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceScheduledTasksFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceScheduledTasksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceScheduledTasksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceStorageOverlappingRecallsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceStorageOverlappingRecallsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceStorageOverlappingRecallsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespaceTemplatesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The template name used for filtering.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespaceTemplatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceTemplatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The template name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamespacesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamespacesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespacesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


