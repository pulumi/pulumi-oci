# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'LogAnalyticsEntityMetadataArgs',
    'LogAnalyticsEntityMetadataItemArgs',
    'LogAnalyticsImportCustomContentChangeListArgs',
    'LogAnalyticsObjectCollectionRuleOverrideArgs',
    'LogAnalyticsPreferencesManagementItemArgs',
    'NamespaceIngestTimeRuleActionArgs',
    'NamespaceIngestTimeRuleConditionsArgs',
    'NamespaceIngestTimeRuleConditionsAdditionalConditionArgs',
    'NamespaceScheduledTaskActionArgs',
    'NamespaceScheduledTaskActionMetricExtractionArgs',
    'NamespaceScheduledTaskSchedulesArgs',
    'NamespaceScheduledTaskSchedulesScheduleArgs',
    'GetLogAnalyticsEntitiesFilterArgs',
    'GetLogAnalyticsLogGroupsFilterArgs',
    'GetLogAnalyticsObjectCollectionRulesFilterArgs',
    'GetNamespaceEffectivePropertiesFilterArgs',
    'GetNamespaceIngestTimeRulesFilterArgs',
    'GetNamespacePropertiesMetadataFilterArgs',
    'GetNamespaceRulesFilterArgs',
    'GetNamespaceScheduledTasksFilterArgs',
    'GetNamespaceStorageOverlappingRecallsFilterArgs',
    'GetNamespacesFilterArgs',
]

@pulumi.input_type
class LogAnalyticsEntityMetadataArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]] items: (Updatable) An array of entity metadata details.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]]]:
        """
        (Updatable) An array of entity metadata details.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsEntityMetadataItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class LogAnalyticsEntityMetadataItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The metadata name.
        :param pulumi.Input[str] type: (Updatable) The metadata type.
        :param pulumi.Input[str] value: (Updatable) The metadata value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The metadata name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The metadata type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The metadata value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class LogAnalyticsImportCustomContentChangeListArgs:
    def __init__(__self__, *,
                 conflict_field_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 conflict_parser_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 conflict_source_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 created_field_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 created_parser_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 created_source_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 updated_field_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 updated_parser_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 updated_source_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] conflict_field_display_names: A list of field display names with conflicts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] conflict_parser_names: A list of parser names with conflicts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] conflict_source_names: A list of source names with conflicts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] created_field_display_names: An array of created field display names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] created_parser_names: An array of created parser names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] created_source_names: An array of created source names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] updated_field_display_names: An array of updated field display names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] updated_parser_names: An array of updated parser names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] updated_source_names: An array of updated source names.
        """
        if conflict_field_display_names is not None:
            pulumi.set(__self__, "conflict_field_display_names", conflict_field_display_names)
        if conflict_parser_names is not None:
            pulumi.set(__self__, "conflict_parser_names", conflict_parser_names)
        if conflict_source_names is not None:
            pulumi.set(__self__, "conflict_source_names", conflict_source_names)
        if created_field_display_names is not None:
            pulumi.set(__self__, "created_field_display_names", created_field_display_names)
        if created_parser_names is not None:
            pulumi.set(__self__, "created_parser_names", created_parser_names)
        if created_source_names is not None:
            pulumi.set(__self__, "created_source_names", created_source_names)
        if updated_field_display_names is not None:
            pulumi.set(__self__, "updated_field_display_names", updated_field_display_names)
        if updated_parser_names is not None:
            pulumi.set(__self__, "updated_parser_names", updated_parser_names)
        if updated_source_names is not None:
            pulumi.set(__self__, "updated_source_names", updated_source_names)

    @property
    @pulumi.getter(name="conflictFieldDisplayNames")
    def conflict_field_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of field display names with conflicts.
        """
        return pulumi.get(self, "conflict_field_display_names")

    @conflict_field_display_names.setter
    def conflict_field_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conflict_field_display_names", value)

    @property
    @pulumi.getter(name="conflictParserNames")
    def conflict_parser_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of parser names with conflicts.
        """
        return pulumi.get(self, "conflict_parser_names")

    @conflict_parser_names.setter
    def conflict_parser_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conflict_parser_names", value)

    @property
    @pulumi.getter(name="conflictSourceNames")
    def conflict_source_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of source names with conflicts.
        """
        return pulumi.get(self, "conflict_source_names")

    @conflict_source_names.setter
    def conflict_source_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conflict_source_names", value)

    @property
    @pulumi.getter(name="createdFieldDisplayNames")
    def created_field_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of created field display names.
        """
        return pulumi.get(self, "created_field_display_names")

    @created_field_display_names.setter
    def created_field_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "created_field_display_names", value)

    @property
    @pulumi.getter(name="createdParserNames")
    def created_parser_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of created parser names.
        """
        return pulumi.get(self, "created_parser_names")

    @created_parser_names.setter
    def created_parser_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "created_parser_names", value)

    @property
    @pulumi.getter(name="createdSourceNames")
    def created_source_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of created source names.
        """
        return pulumi.get(self, "created_source_names")

    @created_source_names.setter
    def created_source_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "created_source_names", value)

    @property
    @pulumi.getter(name="updatedFieldDisplayNames")
    def updated_field_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of updated field display names.
        """
        return pulumi.get(self, "updated_field_display_names")

    @updated_field_display_names.setter
    def updated_field_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "updated_field_display_names", value)

    @property
    @pulumi.getter(name="updatedParserNames")
    def updated_parser_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of updated parser names.
        """
        return pulumi.get(self, "updated_parser_names")

    @updated_parser_names.setter
    def updated_parser_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "updated_parser_names", value)

    @property
    @pulumi.getter(name="updatedSourceNames")
    def updated_source_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of updated source names.
        """
        return pulumi.get(self, "updated_source_names")

    @updated_source_names.setter
    def updated_source_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "updated_source_names", value)


@pulumi.input_type
class LogAnalyticsObjectCollectionRuleOverrideArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 match_value: Optional[pulumi.Input[str]] = None,
                 property_name: Optional[pulumi.Input[str]] = None,
                 property_value: Optional[pulumi.Input[str]] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_value is not None:
            pulumi.set(__self__, "property_value", property_value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_value", value)


@pulumi.input_type
class LogAnalyticsPreferencesManagementItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The preference name.
        :param pulumi.Input[str] value: The preference value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The preference name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The preference value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NamespaceIngestTimeRuleActionArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 type: pulumi.Input[str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param pulumi.Input[str] metric_name: (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param pulumi.Input[str] namespace: (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param pulumi.Input[str] type: (Updatable) Discriminator.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        :param pulumi.Input[str] resource_group: (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "type", type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)


@pulumi.input_type
class NamespaceIngestTimeRuleConditionsArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 field_operator: pulumi.Input[str],
                 field_value: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 additional_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] field_name: (Updatable) The field name to be evaluated.
        :param pulumi.Input[str] field_operator: (Updatable) The operator to be used for evaluating the field.
        :param pulumi.Input[str] field_value: (Updatable) The field value to be evaluated.
        :param pulumi.Input[str] kind: (Updatable) Discriminator.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]] additional_conditions: (Updatable) Optional additional condition(s) to be evaluated.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_operator", field_operator)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "kind", kind)
        if additional_conditions is not None:
            pulumi.set(__self__, "additional_conditions", additional_conditions)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The field name to be evaluated.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter(name="fieldOperator")
    def field_operator(self) -> pulumi.Input[str]:
        """
        (Updatable) The operator to be used for evaluating the field.
        """
        return pulumi.get(self, "field_operator")

    @field_operator.setter
    def field_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_operator", value)

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> pulumi.Input[str]:
        """
        (Updatable) The field value to be evaluated.
        """
        return pulumi.get(self, "field_value")

    @field_value.setter
    def field_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_value", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="additionalConditions")
    def additional_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]]]:
        """
        (Updatable) Optional additional condition(s) to be evaluated.
        """
        return pulumi.get(self, "additional_conditions")

    @additional_conditions.setter
    def additional_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs']]]]):
        pulumi.set(self, "additional_conditions", value)


@pulumi.input_type
class NamespaceIngestTimeRuleConditionsAdditionalConditionArgs:
    def __init__(__self__, *,
                 condition_field: pulumi.Input[str],
                 condition_operator: pulumi.Input[str],
                 condition_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] condition_field: (Updatable) The additional field name to be evaluated.
        :param pulumi.Input[str] condition_operator: (Updatable) The operator to be used for evaluating the additional field.
        :param pulumi.Input[str] condition_value: (Updatable) The additional field value to be evaluated.
        """
        pulumi.set(__self__, "condition_field", condition_field)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_value", condition_value)

    @property
    @pulumi.getter(name="conditionField")
    def condition_field(self) -> pulumi.Input[str]:
        """
        (Updatable) The additional field name to be evaluated.
        """
        return pulumi.get(self, "condition_field")

    @condition_field.setter
    def condition_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_field", value)

    @property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> pulumi.Input[str]:
        """
        (Updatable) The operator to be used for evaluating the additional field.
        """
        return pulumi.get(self, "condition_operator")

    @condition_operator.setter
    def condition_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_operator", value)

    @property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> pulumi.Input[str]:
        """
        (Updatable) The additional field value to be evaluated.
        """
        return pulumi.get(self, "condition_value")

    @condition_value.setter
    def condition_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_value", value)


@pulumi.input_type
class NamespaceScheduledTaskActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 compartment_id_in_subtree: Optional[pulumi.Input[bool]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 metric_extraction: Optional[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs']] = None,
                 purge_compartment_id: Optional[pulumi.Input[str]] = None,
                 purge_duration: Optional[pulumi.Input[str]] = None,
                 query_string: Optional[pulumi.Input[str]] = None,
                 saved_search_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Action type discriminator.
        :param pulumi.Input[bool] compartment_id_in_subtree: if true, purge child compartments data
        :param pulumi.Input[str] data_type: the type of the log data to be purged
        :param pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs'] metric_extraction: Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        :param pulumi.Input[str] purge_compartment_id: the compartment OCID under which the data will be purged
        :param pulumi.Input[str] purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param pulumi.Input[str] query_string: Purge query string.
        :param pulumi.Input[str] saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        """
        pulumi.set(__self__, "type", type)
        if compartment_id_in_subtree is not None:
            pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if metric_extraction is not None:
            pulumi.set(__self__, "metric_extraction", metric_extraction)
        if purge_compartment_id is not None:
            pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        if purge_duration is not None:
            pulumi.set(__self__, "purge_duration", purge_duration)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if saved_search_id is not None:
            pulumi.set(__self__, "saved_search_id", saved_search_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Action type discriminator.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> Optional[pulumi.Input[bool]]:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @compartment_id_in_subtree.setter
    def compartment_id_in_subtree(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compartment_id_in_subtree", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter(name="metricExtraction")
    def metric_extraction(self) -> Optional[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs']]:
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        return pulumi.get(self, "metric_extraction")

    @metric_extraction.setter
    def metric_extraction(self, value: Optional[pulumi.Input['NamespaceScheduledTaskActionMetricExtractionArgs']]):
        pulumi.set(self, "metric_extraction", value)

    @property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @purge_compartment_id.setter
    def purge_compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "purge_compartment_id", value)

    @property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @purge_duration.setter
    def purge_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "purge_duration", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @saved_search_id.setter
    def saved_search_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved_search_id", value)


@pulumi.input_type
class NamespaceScheduledTaskActionMetricExtractionArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 metric_name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param pulumi.Input[str] metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param pulumi.Input[str] namespace: The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param pulumi.Input[str] resource_group: The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[str]]:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)


@pulumi.input_type
class NamespaceScheduledTaskSchedulesArgs:
    def __init__(__self__, *,
                 schedules: pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgs']]]):
        pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter
    def schedules(self) -> pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgs']]]:
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: pulumi.Input[Sequence[pulumi.Input['NamespaceScheduledTaskSchedulesScheduleArgs']]]):
        pulumi.set(self, "schedules", value)


@pulumi.input_type
class NamespaceScheduledTaskSchedulesScheduleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 expression: Optional[pulumi.Input[str]] = None,
                 misfire_policy: Optional[pulumi.Input[str]] = None,
                 recurring_interval: Optional[pulumi.Input[str]] = None,
                 repeat_count: Optional[pulumi.Input[int]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Schedule type discriminator.
        :param pulumi.Input[str] expression: Value in cron format.
        :param pulumi.Input[str] misfire_policy: Schedule misfire retry policy.
        :param pulumi.Input[str] recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param pulumi.Input[int] repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param pulumi.Input[str] time_zone: Time zone, by default UTC.
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if misfire_policy is not None:
            pulumi.set(__self__, "misfire_policy", misfire_policy)
        if recurring_interval is not None:
            pulumi.set(__self__, "recurring_interval", recurring_interval)
        if repeat_count is not None:
            pulumi.set(__self__, "repeat_count", repeat_count)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @misfire_policy.setter
    def misfire_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "misfire_policy", value)

    @property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @recurring_interval.setter
    def recurring_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recurring_interval", value)

    @property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @repeat_count.setter
    def repeat_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "repeat_count", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class GetLogAnalyticsEntitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogAnalyticsLogGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogAnalyticsObjectCollectionRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return rules only matching with this name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespaceEffectivePropertiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespaceIngestTimeRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespacePropertiesMetadataFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespaceRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespaceScheduledTasksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespaceStorageOverlappingRecallsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNamespacesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


