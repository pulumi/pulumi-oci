# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'LogAnalyticsEntityMetadata',
    'LogAnalyticsEntityMetadataItem',
    'LogAnalyticsEntityTypeProperty',
    'LogAnalyticsImportCustomContentChangeList',
    'LogAnalyticsObjectCollectionRuleOverride',
    'LogAnalyticsPreferencesManagementItem',
    'NamespaceIngestTimeRuleAction',
    'NamespaceIngestTimeRuleConditions',
    'NamespaceIngestTimeRuleConditionsAdditionalCondition',
    'NamespaceLookupCategory',
    'NamespaceLookupField',
    'NamespaceLookupReferringSource',
    'NamespaceLookupStatusSummary',
    'NamespaceScheduledTaskAction',
    'NamespaceScheduledTaskActionMetricExtraction',
    'NamespaceScheduledTaskActionTemplateDetails',
    'NamespaceScheduledTaskActionTemplateDetailsTemplateParam',
    'NamespaceScheduledTaskSchedules',
    'NamespaceScheduledTaskSchedulesSchedule',
    'NamespaceStorageArchivalConfigArchivingConfiguration',
    'GetLogAnalyticsCategoriesListItemResult',
    'GetLogAnalyticsEntitiesFilterResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult',
    'GetLogAnalyticsEntityMetadataResult',
    'GetLogAnalyticsEntityMetadataItemResult',
    'GetLogAnalyticsEntityTopologyFilterResult',
    'GetLogAnalyticsEntityTopologyItemResult',
    'GetLogAnalyticsEntityTopologyItemLinkResult',
    'GetLogAnalyticsEntityTopologyItemLinkItemResult',
    'GetLogAnalyticsEntityTopologyItemNodeResult',
    'GetLogAnalyticsEntityTopologyItemNodeItemResult',
    'GetLogAnalyticsEntityTypePropertyResult',
    'GetLogAnalyticsEntityTypesFilterResult',
    'GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionResult',
    'GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemResult',
    'GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemPropertyResult',
    'GetLogAnalyticsLogGroupsFilterResult',
    'GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionResult',
    'GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult',
    'GetLogAnalyticsObjectCollectionRuleOverrideResult',
    'GetLogAnalyticsObjectCollectionRulesFilterResult',
    'GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionResult',
    'GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult',
    'GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult',
    'GetLogAnalyticsPreferenceItemResult',
    'GetLogAnalyticsResourceCategoriesListCategoryResult',
    'GetLogAnalyticsResourceCategoriesListItemResult',
    'GetNamespaceEffectivePropertiesEffectivePropertyCollectionResult',
    'GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult',
    'GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult',
    'GetNamespaceEffectivePropertiesFilterResult',
    'GetNamespaceFieldUsageDependentParserResult',
    'GetNamespaceFieldUsageDependentParserDependencyResult',
    'GetNamespaceFieldUsageDependentSourceResult',
    'GetNamespaceFieldUsageDependentSourceDependencyResult',
    'GetNamespaceFieldUsageDependentSourceEntityTypeResult',
    'GetNamespaceIngestTimeRuleActionResult',
    'GetNamespaceIngestTimeRuleConditionResult',
    'GetNamespaceIngestTimeRuleConditionAdditionalConditionResult',
    'GetNamespaceIngestTimeRulesFilterResult',
    'GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionResult',
    'GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult',
    'GetNamespaceLookupCategoryResult',
    'GetNamespaceLookupFieldResult',
    'GetNamespaceLookupReferringSourceResult',
    'GetNamespaceLookupStatusSummaryResult',
    'GetNamespaceParserActionsFilterResult',
    'GetNamespaceParserActionsParserActionSummaryCollectionResult',
    'GetNamespaceParserActionsParserActionSummaryCollectionItemResult',
    'GetNamespacePropertiesMetadataFilterResult',
    'GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionResult',
    'GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult',
    'GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult',
    'GetNamespaceRulesFilterResult',
    'GetNamespaceRulesRuleSummaryCollectionResult',
    'GetNamespaceRulesRuleSummaryCollectionItemResult',
    'GetNamespaceScheduledTaskActionResult',
    'GetNamespaceScheduledTaskActionMetricExtractionResult',
    'GetNamespaceScheduledTaskActionTemplateDetailResult',
    'GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult',
    'GetNamespaceScheduledTaskScheduleResult',
    'GetNamespaceScheduledTaskScheduleScheduleResult',
    'GetNamespaceScheduledTasksFilterResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult',
    'GetNamespaceStorageArchivalConfigArchivingConfigurationResult',
    'GetNamespaceStorageEncryptionKeyInfoItemResult',
    'GetNamespaceStorageOverlappingRecallsFilterResult',
    'GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionResult',
    'GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult',
    'GetNamespaceTemplateFacetResult',
    'GetNamespaceTemplatesFilterResult',
    'GetNamespaceTemplatesLogAnalyticsTemplateCollectionResult',
    'GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult',
    'GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult',
    'GetNamespacesFilterResult',
    'GetNamespacesNamespaceCollectionResult',
    'GetNamespacesNamespaceCollectionItemResult',
]

@pulumi.output_type
class LogAnalyticsEntityMetadata(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.LogAnalyticsEntityMetadataItem']] = None):
        """
        :param Sequence['LogAnalyticsEntityMetadataItemArgs'] items: (Updatable) An array of entity metadata details.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.LogAnalyticsEntityMetadataItem']]:
        """
        (Updatable) An array of entity metadata details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class LogAnalyticsEntityMetadataItem(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (Updatable) The metadata name.
        :param _builtins.str type: (Updatable) The metadata type.
        :param _builtins.str value: (Updatable) The metadata value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The metadata name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Updatable) The metadata type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (Updatable) The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LogAnalyticsEntityTypeProperty(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Log analytics entity type property name. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param _builtins.str description: Description for the log analytics entity type property.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Log analytics entity type property name. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the log analytics entity type property.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class LogAnalyticsImportCustomContentChangeList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conflictFieldDisplayNames":
            suggest = "conflict_field_display_names"
        elif key == "conflictParserNames":
            suggest = "conflict_parser_names"
        elif key == "conflictSourceNames":
            suggest = "conflict_source_names"
        elif key == "createdFieldDisplayNames":
            suggest = "created_field_display_names"
        elif key == "createdParserNames":
            suggest = "created_parser_names"
        elif key == "createdSourceNames":
            suggest = "created_source_names"
        elif key == "updatedFieldDisplayNames":
            suggest = "updated_field_display_names"
        elif key == "updatedParserNames":
            suggest = "updated_parser_names"
        elif key == "updatedSourceNames":
            suggest = "updated_source_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsImportCustomContentChangeList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsImportCustomContentChangeList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsImportCustomContentChangeList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conflict_field_display_names: Optional[Sequence[_builtins.str]] = None,
                 conflict_parser_names: Optional[Sequence[_builtins.str]] = None,
                 conflict_source_names: Optional[Sequence[_builtins.str]] = None,
                 created_field_display_names: Optional[Sequence[_builtins.str]] = None,
                 created_parser_names: Optional[Sequence[_builtins.str]] = None,
                 created_source_names: Optional[Sequence[_builtins.str]] = None,
                 updated_field_display_names: Optional[Sequence[_builtins.str]] = None,
                 updated_parser_names: Optional[Sequence[_builtins.str]] = None,
                 updated_source_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] conflict_field_display_names: A list of field display names with conflicts.
        :param Sequence[_builtins.str] conflict_parser_names: A list of parser names with conflicts.
        :param Sequence[_builtins.str] conflict_source_names: A list of source names with conflicts.
        :param Sequence[_builtins.str] created_field_display_names: An array of created field display names.
        :param Sequence[_builtins.str] created_parser_names: An array of created parser names.
        :param Sequence[_builtins.str] created_source_names: An array of created source names.
        :param Sequence[_builtins.str] updated_field_display_names: An array of updated field display names.
        :param Sequence[_builtins.str] updated_parser_names: An array of updated parser names.
        :param Sequence[_builtins.str] updated_source_names: An array of updated source names.
        """
        if conflict_field_display_names is not None:
            pulumi.set(__self__, "conflict_field_display_names", conflict_field_display_names)
        if conflict_parser_names is not None:
            pulumi.set(__self__, "conflict_parser_names", conflict_parser_names)
        if conflict_source_names is not None:
            pulumi.set(__self__, "conflict_source_names", conflict_source_names)
        if created_field_display_names is not None:
            pulumi.set(__self__, "created_field_display_names", created_field_display_names)
        if created_parser_names is not None:
            pulumi.set(__self__, "created_parser_names", created_parser_names)
        if created_source_names is not None:
            pulumi.set(__self__, "created_source_names", created_source_names)
        if updated_field_display_names is not None:
            pulumi.set(__self__, "updated_field_display_names", updated_field_display_names)
        if updated_parser_names is not None:
            pulumi.set(__self__, "updated_parser_names", updated_parser_names)
        if updated_source_names is not None:
            pulumi.set(__self__, "updated_source_names", updated_source_names)

    @_builtins.property
    @pulumi.getter(name="conflictFieldDisplayNames")
    def conflict_field_display_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of field display names with conflicts.
        """
        return pulumi.get(self, "conflict_field_display_names")

    @_builtins.property
    @pulumi.getter(name="conflictParserNames")
    def conflict_parser_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of parser names with conflicts.
        """
        return pulumi.get(self, "conflict_parser_names")

    @_builtins.property
    @pulumi.getter(name="conflictSourceNames")
    def conflict_source_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of source names with conflicts.
        """
        return pulumi.get(self, "conflict_source_names")

    @_builtins.property
    @pulumi.getter(name="createdFieldDisplayNames")
    def created_field_display_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of created field display names.
        """
        return pulumi.get(self, "created_field_display_names")

    @_builtins.property
    @pulumi.getter(name="createdParserNames")
    def created_parser_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of created parser names.
        """
        return pulumi.get(self, "created_parser_names")

    @_builtins.property
    @pulumi.getter(name="createdSourceNames")
    def created_source_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of created source names.
        """
        return pulumi.get(self, "created_source_names")

    @_builtins.property
    @pulumi.getter(name="updatedFieldDisplayNames")
    def updated_field_display_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of updated field display names.
        """
        return pulumi.get(self, "updated_field_display_names")

    @_builtins.property
    @pulumi.getter(name="updatedParserNames")
    def updated_parser_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of updated parser names.
        """
        return pulumi.get(self, "updated_parser_names")

    @_builtins.property
    @pulumi.getter(name="updatedSourceNames")
    def updated_source_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of updated source names.
        """
        return pulumi.get(self, "updated_source_names")


@pulumi.output_type
class LogAnalyticsObjectCollectionRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"
        elif key == "propertyName":
            suggest = "property_name"
        elif key == "propertyValue":
            suggest = "property_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsObjectCollectionRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsObjectCollectionRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsObjectCollectionRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 property_name: Optional[_builtins.str] = None,
                 property_value: Optional[_builtins.str] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_value is not None:
            pulumi.set(__self__, "property_value", property_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property_value")


@pulumi.output_type
class LogAnalyticsPreferencesManagementItem(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The preference name.
        :param _builtins.str value: The preference value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The preference name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The preference value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NamespaceIngestTimeRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "resourceGroup":
            suggest = "resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceIngestTimeRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceIngestTimeRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceIngestTimeRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 type: _builtins.str,
                 dimensions: Optional[Sequence[_builtins.str]] = None,
                 resource_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param _builtins.str metric_name: (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param _builtins.str namespace: (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param _builtins.str type: (Updatable) Discriminator.
        :param Sequence[_builtins.str] dimensions: (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        :param _builtins.str resource_group: (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "type", type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class NamespaceIngestTimeRuleConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldOperator":
            suggest = "field_operator"
        elif key == "fieldValue":
            suggest = "field_value"
        elif key == "additionalConditions":
            suggest = "additional_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceIngestTimeRuleConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceIngestTimeRuleConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceIngestTimeRuleConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_operator: _builtins.str,
                 field_value: _builtins.str,
                 kind: _builtins.str,
                 additional_conditions: Optional[Sequence['outputs.NamespaceIngestTimeRuleConditionsAdditionalCondition']] = None):
        """
        :param _builtins.str field_name: (Updatable) The field name to be evaluated.
        :param _builtins.str field_operator: (Updatable) The operator to be used for evaluating the field.
        :param _builtins.str field_value: (Updatable) The field value to be evaluated.
        :param _builtins.str kind: (Updatable) Discriminator.
        :param Sequence['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs'] additional_conditions: (Updatable) Optional additional condition(s) to be evaluated.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_operator", field_operator)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "kind", kind)
        if additional_conditions is not None:
            pulumi.set(__self__, "additional_conditions", additional_conditions)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        (Updatable) The field name to be evaluated.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldOperator")
    def field_operator(self) -> _builtins.str:
        """
        (Updatable) The operator to be used for evaluating the field.
        """
        return pulumi.get(self, "field_operator")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> _builtins.str:
        """
        (Updatable) The field value to be evaluated.
        """
        return pulumi.get(self, "field_value")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="additionalConditions")
    def additional_conditions(self) -> Optional[Sequence['outputs.NamespaceIngestTimeRuleConditionsAdditionalCondition']]:
        """
        (Updatable) Optional additional condition(s) to be evaluated.
        """
        return pulumi.get(self, "additional_conditions")


@pulumi.output_type
class NamespaceIngestTimeRuleConditionsAdditionalCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionField":
            suggest = "condition_field"
        elif key == "conditionOperator":
            suggest = "condition_operator"
        elif key == "conditionValue":
            suggest = "condition_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceIngestTimeRuleConditionsAdditionalCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceIngestTimeRuleConditionsAdditionalCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceIngestTimeRuleConditionsAdditionalCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_field: _builtins.str,
                 condition_operator: _builtins.str,
                 condition_value: _builtins.str):
        """
        :param _builtins.str condition_field: (Updatable) The additional field name to be evaluated.
        :param _builtins.str condition_operator: (Updatable) The operator to be used for evaluating the additional field.
        :param _builtins.str condition_value: (Updatable) The additional field value to be evaluated.
        """
        pulumi.set(__self__, "condition_field", condition_field)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_value", condition_value)

    @_builtins.property
    @pulumi.getter(name="conditionField")
    def condition_field(self) -> _builtins.str:
        """
        (Updatable) The additional field name to be evaluated.
        """
        return pulumi.get(self, "condition_field")

    @_builtins.property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> _builtins.str:
        """
        (Updatable) The operator to be used for evaluating the additional field.
        """
        return pulumi.get(self, "condition_operator")

    @_builtins.property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> _builtins.str:
        """
        (Updatable) The additional field value to be evaluated.
        """
        return pulumi.get(self, "condition_value")


@pulumi.output_type
class NamespaceLookupCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isSystem":
            suggest = "is_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 is_system: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: (Updatable) The category description.
        :param _builtins.str display_name: (Updatable) The category display name.
        :param _builtins.bool is_system: (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param _builtins.str name: (Updatable) The unique name that identifies the category.
        :param _builtins.str type: (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (Updatable) The category description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The category display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[_builtins.bool]:
        """
        (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The unique name that identifies the category.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NamespaceLookupField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonFieldName":
            suggest = "common_field_name"
        elif key == "defaultMatchValue":
            suggest = "default_match_value"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "isCommonField":
            suggest = "is_common_field"
        elif key == "matchOperator":
            suggest = "match_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_field_name: Optional[_builtins.str] = None,
                 default_match_value: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 is_common_field: Optional[_builtins.bool] = None,
                 match_operator: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 position: Optional[_builtins.str] = None):
        """
        :param _builtins.str common_field_name: (Updatable) The common field name.
        :param _builtins.str default_match_value: (Updatable) The default match value.
        :param _builtins.str display_name: (Updatable) The display name.
        :param _builtins.bool is_common_field: (Updatable) A flag indicating whether or not the field is a common field.
        :param _builtins.str match_operator: (Updatable) The match operator.
        :param _builtins.str name: (Updatable) The field name.
        :param _builtins.str position: (Updatable) The position.
        """
        if common_field_name is not None:
            pulumi.set(__self__, "common_field_name", common_field_name)
        if default_match_value is not None:
            pulumi.set(__self__, "default_match_value", default_match_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_common_field is not None:
            pulumi.set(__self__, "is_common_field", is_common_field)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="commonFieldName")
    def common_field_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The common field name.
        """
        return pulumi.get(self, "common_field_name")

    @_builtins.property
    @pulumi.getter(name="defaultMatchValue")
    def default_match_value(self) -> Optional[_builtins.str]:
        """
        (Updatable) The default match value.
        """
        return pulumi.get(self, "default_match_value")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isCommonField")
    def is_common_field(self) -> Optional[_builtins.bool]:
        """
        (Updatable) A flag indicating whether or not the field is a common field.
        """
        return pulumi.get(self, "is_common_field")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        (Updatable) The match operator.
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Updatable) The field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[_builtins.str]:
        """
        (Updatable) The position.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class NamespaceLookupReferringSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canonicalLink":
            suggest = "canonical_link"
        elif key == "totalCount":
            suggest = "total_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupReferringSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupReferringSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupReferringSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canonical_link: Optional[_builtins.str] = None,
                 total_count: Optional[_builtins.str] = None):
        """
        :param _builtins.str canonical_link: The canonical link.
        :param _builtins.str total_count: The total count.
        """
        if canonical_link is not None:
            pulumi.set(__self__, "canonical_link", canonical_link)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter(name="canonicalLink")
    def canonical_link(self) -> Optional[_builtins.str]:
        """
        The canonical link.
        """
        return pulumi.get(self, "canonical_link")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[_builtins.str]:
        """
        The total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class NamespaceLookupStatusSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunksProcessed":
            suggest = "chunks_processed"
        elif key == "failureDetails":
            suggest = "failure_details"
        elif key == "totalChunks":
            suggest = "total_chunks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupStatusSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupStatusSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupStatusSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunks_processed: Optional[_builtins.str] = None,
                 failure_details: Optional[_builtins.str] = None,
                 filename: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 total_chunks: Optional[_builtins.str] = None):
        """
        :param _builtins.str chunks_processed: The number of chunks processed.
        :param _builtins.str failure_details: The failure details, if any.
        :param _builtins.str filename: The filename.
        :param _builtins.str status: The status.
        :param _builtins.str total_chunks: The total number of chunks.
        """
        if chunks_processed is not None:
            pulumi.set(__self__, "chunks_processed", chunks_processed)
        if failure_details is not None:
            pulumi.set(__self__, "failure_details", failure_details)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if total_chunks is not None:
            pulumi.set(__self__, "total_chunks", total_chunks)

    @_builtins.property
    @pulumi.getter(name="chunksProcessed")
    def chunks_processed(self) -> Optional[_builtins.str]:
        """
        The number of chunks processed.
        """
        return pulumi.get(self, "chunks_processed")

    @_builtins.property
    @pulumi.getter(name="failureDetails")
    def failure_details(self) -> Optional[_builtins.str]:
        """
        The failure details, if any.
        """
        return pulumi.get(self, "failure_details")

    @_builtins.property
    @pulumi.getter
    def filename(self) -> Optional[_builtins.str]:
        """
        The filename.
        """
        return pulumi.get(self, "filename")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalChunks")
    def total_chunks(self) -> Optional[_builtins.str]:
        """
        The total number of chunks.
        """
        return pulumi.get(self, "total_chunks")


@pulumi.output_type
class NamespaceScheduledTaskAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentIdInSubtree":
            suggest = "compartment_id_in_subtree"
        elif key == "dataType":
            suggest = "data_type"
        elif key == "metricExtraction":
            suggest = "metric_extraction"
        elif key == "purgeCompartmentId":
            suggest = "purge_compartment_id"
        elif key == "purgeDuration":
            suggest = "purge_duration"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "savedSearchId":
            suggest = "saved_search_id"
        elif key == "templateDetails":
            suggest = "template_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 compartment_id_in_subtree: Optional[_builtins.bool] = None,
                 data_type: Optional[_builtins.str] = None,
                 metric_extraction: Optional['outputs.NamespaceScheduledTaskActionMetricExtraction'] = None,
                 purge_compartment_id: Optional[_builtins.str] = None,
                 purge_duration: Optional[_builtins.str] = None,
                 query_string: Optional[_builtins.str] = None,
                 saved_search_id: Optional[_builtins.str] = None,
                 template_details: Optional['outputs.NamespaceScheduledTaskActionTemplateDetails'] = None):
        """
        :param _builtins.str type: Action type discriminator.
        :param _builtins.bool compartment_id_in_subtree: if true, purge child compartments data
        :param _builtins.str data_type: the type of the log data to be purged
        :param 'NamespaceScheduledTaskActionMetricExtractionArgs' metric_extraction: Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        :param _builtins.str purge_compartment_id: the compartment OCID under which the data will be purged
        :param _builtins.str purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param _builtins.str query_string: Purge query string.
        :param _builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        :param 'NamespaceScheduledTaskActionTemplateDetailsArgs' template_details: details for scheduled task using template
        """
        pulumi.set(__self__, "type", type)
        if compartment_id_in_subtree is not None:
            pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if metric_extraction is not None:
            pulumi.set(__self__, "metric_extraction", metric_extraction)
        if purge_compartment_id is not None:
            pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        if purge_duration is not None:
            pulumi.set(__self__, "purge_duration", purge_duration)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if saved_search_id is not None:
            pulumi.set(__self__, "saved_search_id", saved_search_id)
        if template_details is not None:
            pulumi.set(__self__, "template_details", template_details)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Action type discriminator.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> Optional[_builtins.bool]:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="metricExtraction")
    def metric_extraction(self) -> Optional['outputs.NamespaceScheduledTaskActionMetricExtraction']:
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        return pulumi.get(self, "metric_extraction")

    @_builtins.property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> Optional[_builtins.str]:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @_builtins.property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> Optional[_builtins.str]:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[_builtins.str]:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> Optional[_builtins.str]:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        """
        return pulumi.get(self, "saved_search_id")

    @_builtins.property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Optional['outputs.NamespaceScheduledTaskActionTemplateDetails']:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")


@pulumi.output_type
class NamespaceScheduledTaskActionMetricExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "resourceGroup":
            suggest = "resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskActionMetricExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskActionMetricExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskActionMetricExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[_builtins.str] = None,
                 metric_name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param _builtins.str metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param _builtins.str namespace: The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param _builtins.str resource_group: The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class NamespaceScheduledTaskActionTemplateDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateId":
            suggest = "template_id"
        elif key == "templateParams":
            suggest = "template_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskActionTemplateDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskActionTemplateDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskActionTemplateDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_id: Optional[_builtins.str] = None,
                 template_params: Optional[Sequence['outputs.NamespaceScheduledTaskActionTemplateDetailsTemplateParam']] = None):
        """
        :param _builtins.str template_id: The template Id of a particular template.  Should not be provided when a saved search ID is present.
        :param Sequence['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs'] template_params: To store macro params.
        """
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if template_params is not None:
            pulumi.set(__self__, "template_params", template_params)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[_builtins.str]:
        """
        The template Id of a particular template.  Should not be provided when a saved search ID is present.
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Optional[Sequence['outputs.NamespaceScheduledTaskActionTemplateDetailsTemplateParam']]:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")


@pulumi.output_type
class NamespaceScheduledTaskActionTemplateDetailsTemplateParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyField":
            suggest = "key_field"
        elif key == "valueField":
            suggest = "value_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskActionTemplateDetailsTemplateParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskActionTemplateDetailsTemplateParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskActionTemplateDetailsTemplateParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_field: Optional[_builtins.str] = None,
                 value_field: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_field: Contains a template parameter's name.
        :param _builtins.str value_field: Contains the desired value for a given parameter.
        """
        if key_field is not None:
            pulumi.set(__self__, "key_field", key_field)
        if value_field is not None:
            pulumi.set(__self__, "value_field", value_field)

    @_builtins.property
    @pulumi.getter(name="keyField")
    def key_field(self) -> Optional[_builtins.str]:
        """
        Contains a template parameter's name.
        """
        return pulumi.get(self, "key_field")

    @_builtins.property
    @pulumi.getter(name="valueField")
    def value_field(self) -> Optional[_builtins.str]:
        """
        Contains the desired value for a given parameter.
        """
        return pulumi.get(self, "value_field")


@pulumi.output_type
class NamespaceScheduledTaskSchedules(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.NamespaceScheduledTaskSchedulesSchedule']):
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.NamespaceScheduledTaskSchedulesSchedule']:
        return pulumi.get(self, "schedules")


@pulumi.output_type
class NamespaceScheduledTaskSchedulesSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "misfirePolicy":
            suggest = "misfire_policy"
        elif key == "recurringInterval":
            suggest = "recurring_interval"
        elif key == "repeatCount":
            suggest = "repeat_count"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskSchedulesSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskSchedulesSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskSchedulesSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 expression: Optional[_builtins.str] = None,
                 misfire_policy: Optional[_builtins.str] = None,
                 recurring_interval: Optional[_builtins.str] = None,
                 repeat_count: Optional[_builtins.int] = None,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Schedule type discriminator.
        :param _builtins.str expression: Value in cron format.
        :param _builtins.str misfire_policy: Schedule misfire retry policy.
        :param _builtins.str recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param _builtins.int repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param _builtins.str time_zone: Time zone, by default UTC.
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if misfire_policy is not None:
            pulumi.set(__self__, "misfire_policy", misfire_policy)
        if recurring_interval is not None:
            pulumi.set(__self__, "recurring_interval", recurring_interval)
        if repeat_count is not None:
            pulumi.set(__self__, "repeat_count", repeat_count)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> Optional[_builtins.str]:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @_builtins.property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> Optional[_builtins.str]:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> Optional[_builtins.int]:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class NamespaceStorageArchivalConfigArchivingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeStorageDuration":
            suggest = "active_storage_duration"
        elif key == "archivalStorageDuration":
            suggest = "archival_storage_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceStorageArchivalConfigArchivingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceStorageArchivalConfigArchivingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceStorageArchivalConfigArchivingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_storage_duration: Optional[_builtins.str] = None,
                 archival_storage_duration: Optional[_builtins.str] = None):
        """
        :param _builtins.str active_storage_duration: (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        :param _builtins.str archival_storage_duration: (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        if active_storage_duration is not None:
            pulumi.set(__self__, "active_storage_duration", active_storage_duration)
        if archival_storage_duration is not None:
            pulumi.set(__self__, "archival_storage_duration", archival_storage_duration)

    @_builtins.property
    @pulumi.getter(name="activeStorageDuration")
    def active_storage_duration(self) -> Optional[_builtins.str]:
        """
        (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "active_storage_duration")

    @_builtins.property
    @pulumi.getter(name="archivalStorageDuration")
    def archival_storage_duration(self) -> Optional[_builtins.str]:
        """
        (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "archival_storage_duration")


@pulumi.output_type
class GetLogAnalyticsCategoriesListItemResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 is_system: _builtins.bool,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The category description.
        :param _builtins.str display_name: The category display name.
        :param _builtins.bool is_system: The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param _builtins.str name: A filter to return only log analytics category whose name matches the entire name given. The match is case-insensitive.
        :param _builtins.str type: The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The category description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The category display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics category whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogAnalyticsEntitiesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult(dict):
    def __init__(__self__, *,
                 are_logs_collected: _builtins.bool,
                 associated_sources_count: _builtins.int,
                 cloud_resource_id: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 entity_type_internal_name: _builtins.str,
                 entity_type_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 hostname: _builtins.str,
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 management_agent_compartment_id: _builtins.str,
                 management_agent_display_name: _builtins.str,
                 management_agent_id: _builtins.str,
                 metadatas: Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult'],
                 name: _builtins.str,
                 namespace: _builtins.str,
                 properties: Mapping[str, _builtins.str],
                 source_id: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_last_discovered: _builtins.str,
                 time_updated: _builtins.str,
                 timezone_region: _builtins.str):
        """
        :param _builtins.bool are_logs_collected: The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        :param _builtins.int associated_sources_count: The count of associated log sources for a given log analytics entity.
        :param _builtins.str cloud_resource_id: A filter to return only log analytics entities whose cloudResourceId matches the cloudResourceId given.
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str entity_type_internal_name: Internal name for the log analytics entity type.
        :param _builtins.str entity_type_name: A filter to return only log analytics entities whose entityTypeName matches the entire log analytics entity type name of one of the entityTypeNames given in the list. The match is case-insensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str hostname: A filter to return only log analytics entities whose hostname matches the entire hostname given.
        :param _builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.str lifecycle_details: lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        :param _builtins.str management_agent_compartment_id: Management agent (management-agents resource kind) compartment OCID
        :param _builtins.str management_agent_display_name: Management agent (management-agents resource kind) display name
        :param _builtins.str management_agent_id: The OCID of the Management Agent.
        :param Sequence['GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataArgs'] metadatas: Details of entity metadata information.
        :param _builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param Mapping[str, _builtins.str] properties: The name/value pairs for parameter values to be used in file patterns specified in log sources.
        :param _builtins.str source_id: A filter to return only log analytics entities whose sourceId matches the sourceId given.
        :param _builtins.str state: A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        :param _builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param _builtins.str time_last_discovered: The date and time the resource was last discovered, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        :param _builtins.str timezone_region: The timezone region of the log analytics entity.
        """
        pulumi.set(__self__, "are_logs_collected", are_logs_collected)
        pulumi.set(__self__, "associated_sources_count", associated_sources_count)
        pulumi.set(__self__, "cloud_resource_id", cloud_resource_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "entity_type_internal_name", entity_type_internal_name)
        pulumi.set(__self__, "entity_type_name", entity_type_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "management_agent_compartment_id", management_agent_compartment_id)
        pulumi.set(__self__, "management_agent_display_name", management_agent_display_name)
        pulumi.set(__self__, "management_agent_id", management_agent_id)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_last_discovered", time_last_discovered)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone_region", timezone_region)

    @_builtins.property
    @pulumi.getter(name="areLogsCollected")
    def are_logs_collected(self) -> _builtins.bool:
        """
        The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        """
        return pulumi.get(self, "are_logs_collected")

    @_builtins.property
    @pulumi.getter(name="associatedSourcesCount")
    def associated_sources_count(self) -> _builtins.int:
        """
        The count of associated log sources for a given log analytics entity.
        """
        return pulumi.get(self, "associated_sources_count")

    @_builtins.property
    @pulumi.getter(name="cloudResourceId")
    def cloud_resource_id(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose cloudResourceId matches the cloudResourceId given.
        """
        return pulumi.get(self, "cloud_resource_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="entityTypeInternalName")
    def entity_type_internal_name(self) -> _builtins.str:
        """
        Internal name for the log analytics entity type.
        """
        return pulumi.get(self, "entity_type_internal_name")

    @_builtins.property
    @pulumi.getter(name="entityTypeName")
    def entity_type_name(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose entityTypeName matches the entire log analytics entity type name of one of the entityTypeNames given in the list. The match is case-insensitive.
        """
        return pulumi.get(self, "entity_type_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose hostname matches the entire hostname given.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="managementAgentCompartmentId")
    def management_agent_compartment_id(self) -> _builtins.str:
        """
        Management agent (management-agents resource kind) compartment OCID
        """
        return pulumi.get(self, "management_agent_compartment_id")

    @_builtins.property
    @pulumi.getter(name="managementAgentDisplayName")
    def management_agent_display_name(self) -> _builtins.str:
        """
        Management agent (management-agents resource kind) display name
        """
        return pulumi.get(self, "management_agent_display_name")

    @_builtins.property
    @pulumi.getter(name="managementAgentId")
    def management_agent_id(self) -> _builtins.str:
        """
        The OCID of the Management Agent.
        """
        return pulumi.get(self, "management_agent_id")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult']:
        """
        Details of entity metadata information.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        The name/value pairs for parameter values to be used in file patterns specified in log sources.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose sourceId matches the sourceId given.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLastDiscovered")
    def time_last_discovered(self) -> _builtins.str:
        """
        The date and time the resource was last discovered, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_discovered")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="timezoneRegion")
    def timezone_region(self) -> _builtins.str:
        """
        The timezone region of the log analytics entity.
        """
        return pulumi.get(self, "timezone_region")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        :param _builtins.str type: The metadata type.
        :param _builtins.str value: The metadata value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The metadata type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLogAnalyticsEntityMetadataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityMetadataItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityMetadataItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityMetadataItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityMetadataItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Log analytics entity name.
        :param _builtins.str type: The metadata type.
        :param _builtins.str value: The metadata value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The metadata type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Log analytics entity name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemResult(dict):
    def __init__(__self__, *,
                 links: Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkResult'],
                 nodes: Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTopologyItemLinkArgs'] links: Collection of log analytics entity relationship links.
        :param Sequence['GetLogAnalyticsEntityTopologyItemNodeArgs'] nodes: Collection of log analytics entities.
        """
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkResult']:
        """
        Collection of log analytics entity relationship links.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeResult']:
        """
        Collection of log analytics entities.
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemLinkResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTopologyItemLinkItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemLinkItemResult(dict):
    def __init__(__self__, *,
                 destination_entity_id: _builtins.str,
                 source_entity_id: _builtins.str):
        """
        :param _builtins.str destination_entity_id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.str source_entity_id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        pulumi.set(__self__, "destination_entity_id", destination_entity_id)
        pulumi.set(__self__, "source_entity_id", source_entity_id)

    @_builtins.property
    @pulumi.getter(name="destinationEntityId")
    def destination_entity_id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "destination_entity_id")

    @_builtins.property
    @pulumi.getter(name="sourceEntityId")
    def source_entity_id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "source_entity_id")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemNodeResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTopologyItemNodeItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemNodeItemResult(dict):
    def __init__(__self__, *,
                 are_logs_collected: _builtins.bool,
                 cloud_resource_id: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 entity_type_internal_name: _builtins.str,
                 entity_type_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 management_agent_id: _builtins.str,
                 name: _builtins.str,
                 source_id: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 timezone_region: _builtins.str):
        """
        :param _builtins.bool are_logs_collected: The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        :param _builtins.str cloud_resource_id: The OCID of the Cloud resource which this entity is a representation of. This may be blank when the entity represents a non-cloud resource that the customer may have on their premises.
        :param _builtins.str compartment_id: Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str entity_type_internal_name: Internal name for the log analytics entity type.
        :param _builtins.str entity_type_name: Log analytics entity type name.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.str lifecycle_details: lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        :param _builtins.str management_agent_id: The OCID of the Management Agent.
        :param _builtins.str name: Log analytics entity name.
        :param _builtins.str source_id: This indicates the type of source. It is primarily for Enterprise Manager Repository ID.
        :param _builtins.str state: A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        :param _builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        :param _builtins.str timezone_region: The timezone region of the log analytics entity.
        """
        pulumi.set(__self__, "are_logs_collected", are_logs_collected)
        pulumi.set(__self__, "cloud_resource_id", cloud_resource_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "entity_type_internal_name", entity_type_internal_name)
        pulumi.set(__self__, "entity_type_name", entity_type_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "management_agent_id", management_agent_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone_region", timezone_region)

    @_builtins.property
    @pulumi.getter(name="areLogsCollected")
    def are_logs_collected(self) -> _builtins.bool:
        """
        The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        """
        return pulumi.get(self, "are_logs_collected")

    @_builtins.property
    @pulumi.getter(name="cloudResourceId")
    def cloud_resource_id(self) -> _builtins.str:
        """
        The OCID of the Cloud resource which this entity is a representation of. This may be blank when the entity represents a non-cloud resource that the customer may have on their premises.
        """
        return pulumi.get(self, "cloud_resource_id")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="entityTypeInternalName")
    def entity_type_internal_name(self) -> _builtins.str:
        """
        Internal name for the log analytics entity type.
        """
        return pulumi.get(self, "entity_type_internal_name")

    @_builtins.property
    @pulumi.getter(name="entityTypeName")
    def entity_type_name(self) -> _builtins.str:
        """
        Log analytics entity type name.
        """
        return pulumi.get(self, "entity_type_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="managementAgentId")
    def management_agent_id(self) -> _builtins.str:
        """
        The OCID of the Management Agent.
        """
        return pulumi.get(self, "management_agent_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        This indicates the type of source. It is primarily for Enterprise Manager Repository ID.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="timezoneRegion")
    def timezone_region(self) -> _builtins.str:
        """
        The timezone region of the log analytics entity.
        """
        return pulumi.get(self, "timezone_region")


@pulumi.output_type
class GetLogAnalyticsEntityTypePropertyResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str description: Description for the log analytics entity type property.
        :param _builtins.str name: Log analytics entity type property name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for the log analytics entity type property.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Log analytics entity type property name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLogAnalyticsEntityTypesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemArgs'] items: Array of log analytics entity type summary.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemResult']:
        """
        Array of log analytics entity type summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 cloud_type: _builtins.str,
                 internal_name: _builtins.str,
                 management_agent_eligibility_status: _builtins.str,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 properties: Sequence['outputs.GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemPropertyResult'],
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str category: Log analytics entity type category. Category will be used for grouping and filtering.
        :param _builtins.str cloud_type: A filter to return CLOUD or NON_CLOUD entity types.
        :param _builtins.str internal_name: Internal name for the log analytics entity type.
        :param _builtins.str name: A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param _builtins.str state: A filter to return only those log analytics entity types with the specified lifecycle state. The state value is case-insensitive.
        :param _builtins.str time_created: Time the log analytics entity type was created. An RFC3339 formatted datetime string.
        :param _builtins.str time_updated: Time the log analytics entity type was updated. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "cloud_type", cloud_type)
        pulumi.set(__self__, "internal_name", internal_name)
        pulumi.set(__self__, "management_agent_eligibility_status", management_agent_eligibility_status)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Log analytics entity type category. Category will be used for grouping and filtering.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="cloudType")
    def cloud_type(self) -> _builtins.str:
        """
        A filter to return CLOUD or NON_CLOUD entity types.
        """
        return pulumi.get(self, "cloud_type")

    @_builtins.property
    @pulumi.getter(name="internalName")
    def internal_name(self) -> _builtins.str:
        """
        Internal name for the log analytics entity type.
        """
        return pulumi.get(self, "internal_name")

    @_builtins.property
    @pulumi.getter(name="managementAgentEligibilityStatus")
    def management_agent_eligibility_status(self) -> _builtins.str:
        return pulumi.get(self, "management_agent_eligibility_status")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemPropertyResult']:
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only those log analytics entity types with the specified lifecycle state. The state value is case-insensitive.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        Time the log analytics entity type was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        Time the log analytics entity type was updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetLogAnalyticsEntityTypesLogAnalyticsEntityTypeCollectionItemPropertyResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str name: A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only log analytics entity types whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLogAnalyticsLogGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 namespace: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: Description for this resource.
        :param _builtins.str display_name: A filter to return only log analytics log groups whose displayName matches the entire display name given. The match is case-insensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param _builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only log analytics log groups whose displayName matches the entire display name given. The match is case-insensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRuleOverrideResult(dict):
    def __init__(__self__, *,
                 match_type: _builtins.str,
                 match_value: _builtins.str,
                 property_name: _builtins.str,
                 property_value: _builtins.str):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "match_value", match_value)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "property_value", property_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> _builtins.str:
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> _builtins.str:
        return pulumi.get(self, "property_value")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return rules only matching with this name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult(dict):
    def __init__(__self__, *,
                 char_encoding: _builtins.str,
                 collection_type: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 entity_id: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enabled: _builtins.bool,
                 is_force_historic_collection: _builtins.bool,
                 last_collected_object: _builtins.str,
                 lifecycle_details: _builtins.str,
                 log_group_id: _builtins.str,
                 log_set: _builtins.str,
                 log_set_ext_regex: _builtins.str,
                 log_set_key: _builtins.str,
                 log_source_name: _builtins.str,
                 log_type: _builtins.str,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 object_name_filters: Sequence[_builtins.str],
                 os_bucket_name: _builtins.str,
                 os_namespace: _builtins.str,
                 overrides: Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult'],
                 poll_since: _builtins.str,
                 poll_till: _builtins.str,
                 state: _builtins.str,
                 stream_cursor_time: _builtins.str,
                 stream_cursor_type: _builtins.str,
                 stream_id: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 timezone: _builtins.str):
        """
        :param _builtins.str char_encoding: An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
        :param _builtins.str collection_type: The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
        :param _builtins.str entity_id: Logging Analytics entity OCID to associate the processed logs with.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of this rule.
        :param _builtins.bool is_enabled: Whether or not this rule is currently enabled.
        :param _builtins.bool is_force_historic_collection: Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
        :param _builtins.str last_collected_object: Last Collected Object for the rule
        :param _builtins.str lifecycle_details: A detailed status of the life cycle state.
        :param _builtins.str log_group_id: Logging Analytics Log group OCID to associate the processed logs with.
        :param _builtins.str log_set: The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
        :param _builtins.str log_set_ext_regex: The regex to be applied against given logSetKey. Regex has to be in string escaped format.
        :param _builtins.str log_set_key: An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/<namespace>/b/<bucketname>/o/<objectname>).
        :param _builtins.str log_source_name: Name of the Logging Analytics Source to use for the processing.
        :param _builtins.str log_type: Type of files/objects in this object collection rule.
        :param _builtins.str name: A filter to return rules only matching with this name.
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param Sequence[_builtins.str] object_name_filters: When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard "*". For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
        :param _builtins.str os_bucket_name: Name of the Object Storage bucket.
        :param _builtins.str os_namespace: Object Storage namespace.
        :param Sequence['GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideArgs'] overrides: Use this to override some property values which are defined at bucket level to the scope of object. Supported propeties for override are, logSourceName, charEncoding. Supported matchType for override are "contains".
        :param _builtins.str poll_since: The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
        :param _builtins.str poll_till: The oldest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollTill will result in error.
        :param _builtins.str state: Lifecycle state filter.
        :param _builtins.str stream_cursor_time: The time from which to consume the objects, if streamCursorType is AT_TIME.
        :param _builtins.str stream_cursor_type: Cursor type used to fetch messages from stream. When the streamCursorType is set to DEFAULT, the existing cursor position will be used if already set by any previous objection collection rule(s) using the same stream.  Otherwise, the behaviour is to consume from the oldest available message in the stream.  When the streamCursorType is set to TRIM_HORIZON, the behaviour is to start consuming from the oldest available message in the stream.  When the streamCursorType is set to LATEST, the behavior is to start consuming messages that were published after the creation of this rule.  When the streamCursorType is set to AT_TIME, the behavior is to start consuming from a given time.  For more information on cursor types, see [Stream Consumer Groups](https://docs.oracle.com/en-us/iaas/Content/Streaming/Tasks/using_consumer_groups.htm).
        :param _builtins.str stream_id: A Stream OCID is required for Object Collection rules of type LIVE or HISTORIC_LIVE, which will be used by Logging Analytics while creating Event Rule and consume the event notifications created by the Object Storage.
        :param _builtins.str time_created: The time when this rule was created. An RFC3339 formatted datetime string.
        :param _builtins.str time_updated: The time when this rule was last updated. An RFC3339 formatted datetime string.
        :param _builtins.str timezone: Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
        """
        pulumi.set(__self__, "char_encoding", char_encoding)
        pulumi.set(__self__, "collection_type", collection_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "is_force_historic_collection", is_force_historic_collection)
        pulumi.set(__self__, "last_collected_object", last_collected_object)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_set", log_set)
        pulumi.set(__self__, "log_set_ext_regex", log_set_ext_regex)
        pulumi.set(__self__, "log_set_key", log_set_key)
        pulumi.set(__self__, "log_source_name", log_source_name)
        pulumi.set(__self__, "log_type", log_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_name_filters", object_name_filters)
        pulumi.set(__self__, "os_bucket_name", os_bucket_name)
        pulumi.set(__self__, "os_namespace", os_namespace)
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "poll_since", poll_since)
        pulumi.set(__self__, "poll_till", poll_till)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stream_cursor_time", stream_cursor_time)
        pulumi.set(__self__, "stream_cursor_type", stream_cursor_type)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="charEncoding")
    def char_encoding(self) -> _builtins.str:
        """
        An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
        """
        return pulumi.get(self, "char_encoding")

    @_builtins.property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> _builtins.str:
        """
        The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
        """
        return pulumi.get(self, "collection_type")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> _builtins.str:
        """
        Logging Analytics entity OCID to associate the processed logs with.
        """
        return pulumi.get(self, "entity_id")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of this rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Whether or not this rule is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="isForceHistoricCollection")
    def is_force_historic_collection(self) -> _builtins.bool:
        """
        Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
        """
        return pulumi.get(self, "is_force_historic_collection")

    @_builtins.property
    @pulumi.getter(name="lastCollectedObject")
    def last_collected_object(self) -> _builtins.str:
        """
        Last Collected Object for the rule
        """
        return pulumi.get(self, "last_collected_object")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A detailed status of the life cycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Logging Analytics Log group OCID to associate the processed logs with.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logSet")
    def log_set(self) -> _builtins.str:
        """
        The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
        """
        return pulumi.get(self, "log_set")

    @_builtins.property
    @pulumi.getter(name="logSetExtRegex")
    def log_set_ext_regex(self) -> _builtins.str:
        """
        The regex to be applied against given logSetKey. Regex has to be in string escaped format.
        """
        return pulumi.get(self, "log_set_ext_regex")

    @_builtins.property
    @pulumi.getter(name="logSetKey")
    def log_set_key(self) -> _builtins.str:
        """
        An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/<namespace>/b/<bucketname>/o/<objectname>).
        """
        return pulumi.get(self, "log_set_key")

    @_builtins.property
    @pulumi.getter(name="logSourceName")
    def log_source_name(self) -> _builtins.str:
        """
        Name of the Logging Analytics Source to use for the processing.
        """
        return pulumi.get(self, "log_source_name")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        """
        Type of files/objects in this object collection rule.
        """
        return pulumi.get(self, "log_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNameFilters")
    def object_name_filters(self) -> Sequence[_builtins.str]:
        """
        When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard "*". For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
        """
        return pulumi.get(self, "object_name_filters")

    @_builtins.property
    @pulumi.getter(name="osBucketName")
    def os_bucket_name(self) -> _builtins.str:
        """
        Name of the Object Storage bucket.
        """
        return pulumi.get(self, "os_bucket_name")

    @_builtins.property
    @pulumi.getter(name="osNamespace")
    def os_namespace(self) -> _builtins.str:
        """
        Object Storage namespace.
        """
        return pulumi.get(self, "os_namespace")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult']:
        """
        Use this to override some property values which are defined at bucket level to the scope of object. Supported propeties for override are, logSourceName, charEncoding. Supported matchType for override are "contains".
        """
        return pulumi.get(self, "overrides")

    @_builtins.property
    @pulumi.getter(name="pollSince")
    def poll_since(self) -> _builtins.str:
        """
        The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
        """
        return pulumi.get(self, "poll_since")

    @_builtins.property
    @pulumi.getter(name="pollTill")
    def poll_till(self) -> _builtins.str:
        """
        The oldest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollTill will result in error.
        """
        return pulumi.get(self, "poll_till")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Lifecycle state filter.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="streamCursorTime")
    def stream_cursor_time(self) -> _builtins.str:
        """
        The time from which to consume the objects, if streamCursorType is AT_TIME.
        """
        return pulumi.get(self, "stream_cursor_time")

    @_builtins.property
    @pulumi.getter(name="streamCursorType")
    def stream_cursor_type(self) -> _builtins.str:
        """
        Cursor type used to fetch messages from stream. When the streamCursorType is set to DEFAULT, the existing cursor position will be used if already set by any previous objection collection rule(s) using the same stream.  Otherwise, the behaviour is to consume from the oldest available message in the stream.  When the streamCursorType is set to TRIM_HORIZON, the behaviour is to start consuming from the oldest available message in the stream.  When the streamCursorType is set to LATEST, the behavior is to start consuming messages that were published after the creation of this rule.  When the streamCursorType is set to AT_TIME, the behavior is to start consuming from a given time.  For more information on cursor types, see [Stream Consumer Groups](https://docs.oracle.com/en-us/iaas/Content/Streaming/Tasks/using_consumer_groups.htm).
        """
        return pulumi.get(self, "stream_cursor_type")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> _builtins.str:
        """
        A Stream OCID is required for Object Collection rules of type LIVE or HISTORIC_LIVE, which will be used by Logging Analytics while creating Event Rule and consume the event notifications created by the Object Storage.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time when this rule was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time when this rule was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult(dict):
    def __init__(__self__, *,
                 match_type: _builtins.str,
                 match_value: _builtins.str,
                 property_name: _builtins.str,
                 property_value: _builtins.str):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "match_value", match_value)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "property_value", property_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> _builtins.str:
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> _builtins.str:
        return pulumi.get(self, "property_value")


@pulumi.output_type
class GetLogAnalyticsPreferenceItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The preference name.
        :param _builtins.str value: The preference value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The preference name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The preference value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLogAnalyticsResourceCategoriesListCategoryResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 is_system: _builtins.bool,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The category description.
        :param _builtins.str display_name: The category display name.
        :param _builtins.bool is_system: The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        :param _builtins.str name: The unique name that identifies the category.
        :param _builtins.str type: The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The category description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The category display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The unique name that identifies the category.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogAnalyticsResourceCategoriesListItemResult(dict):
    def __init__(__self__, *,
                 category_name: _builtins.str,
                 compartment_id: _builtins.str,
                 is_system: _builtins.bool,
                 resource_display_name: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str category_name: The category name to which this resource belongs.
        :param _builtins.str compartment_id: The compartment id in which to list resources.
        :param _builtins.bool is_system: The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        :param _builtins.str resource_display_name: The resource display name.
        :param _builtins.str resource_id: The unique identifier of the resource, usually a name or ocid.
        :param _builtins.str resource_type: The resource type.
        """
        pulumi.set(__self__, "category_name", category_name)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "resource_display_name", resource_display_name)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="categoryName")
    def category_name(self) -> _builtins.str:
        """
        The category name to which this resource belongs.
        """
        return pulumi.get(self, "category_name")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The compartment id in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter(name="resourceDisplayName")
    def resource_display_name(self) -> _builtins.str:
        """
        The resource display name.
        """
        return pulumi.get(self, "resource_display_name")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The unique identifier of the resource, usually a name or ocid.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetNamespaceEffectivePropertiesEffectivePropertyCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult']):
        """
        :param Sequence['GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemArgs'] items: A list of properties and their effective values.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult']:
        """
        A list of properties and their effective values.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult(dict):
    def __init__(__self__, *,
                 effective_level: _builtins.str,
                 name: _builtins.str,
                 patterns: Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult'],
                 value: _builtins.str):
        """
        :param _builtins.str effective_level: The effective level of the property value.
        :param _builtins.str name: The property name used for filtering.
        :param Sequence['GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternArgs'] patterns: A list of pattern level override values for the property.
        :param _builtins.str value: The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        pulumi.set(__self__, "effective_level", effective_level)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "patterns", patterns)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="effectiveLevel")
    def effective_level(self) -> _builtins.str:
        """
        The effective level of the property value.
        """
        return pulumi.get(self, "effective_level")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult']:
        """
        A list of pattern level override values for the property.
        """
        return pulumi.get(self, "patterns")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult(dict):
    def __init__(__self__, *,
                 effective_level: _builtins.str,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effective_level: The effective level of the property value.
        :param _builtins.str id: The pattern id.
        :param _builtins.str value: The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        pulumi.set(__self__, "effective_level", effective_level)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="effectiveLevel")
    def effective_level(self) -> _builtins.str:
        """
        The effective level of the property value.
        """
        return pulumi.get(self, "effective_level")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The pattern id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespaceEffectivePropertiesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceFieldUsageDependentParserResult(dict):
    def __init__(__self__, *,
                 dependencies: Sequence['outputs.GetNamespaceFieldUsageDependentParserDependencyResult'],
                 is_system: _builtins.bool,
                 parser_display_name: _builtins.str,
                 parser_id: _builtins.str,
                 parser_name: _builtins.str,
                 parser_type: _builtins.str):
        """
        :param Sequence['GetNamespaceFieldUsageDependentParserDependencyArgs'] dependencies: The list of dependencies defined by the source.
        :param _builtins.bool is_system: The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        :param _builtins.str parser_display_name: The parser display name.
        :param _builtins.str parser_id: The parser unique identifier.
        :param _builtins.str parser_name: The parser name.
        :param _builtins.str parser_type: The parser type
        """
        pulumi.set(__self__, "dependencies", dependencies)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "parser_display_name", parser_display_name)
        pulumi.set(__self__, "parser_id", parser_id)
        pulumi.set(__self__, "parser_name", parser_name)
        pulumi.set(__self__, "parser_type", parser_type)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Sequence['outputs.GetNamespaceFieldUsageDependentParserDependencyResult']:
        """
        The list of dependencies defined by the source.
        """
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter(name="parserDisplayName")
    def parser_display_name(self) -> _builtins.str:
        """
        The parser display name.
        """
        return pulumi.get(self, "parser_display_name")

    @_builtins.property
    @pulumi.getter(name="parserId")
    def parser_id(self) -> _builtins.str:
        """
        The parser unique identifier.
        """
        return pulumi.get(self, "parser_id")

    @_builtins.property
    @pulumi.getter(name="parserName")
    def parser_name(self) -> _builtins.str:
        """
        The parser name.
        """
        return pulumi.get(self, "parser_name")

    @_builtins.property
    @pulumi.getter(name="parserType")
    def parser_type(self) -> _builtins.str:
        """
        The parser type
        """
        return pulumi.get(self, "parser_type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentParserDependencyResult(dict):
    def __init__(__self__, *,
                 reference_display_name: _builtins.str,
                 reference_id: _builtins.str,
                 reference_name: _builtins.str,
                 reference_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str reference_display_name: The display name of the dependency object
        :param _builtins.str reference_id: The unique identifier of the reference, if available.
        :param _builtins.str reference_name: The name of the dependency object
        :param _builtins.str reference_type: The type of reference that defines the dependency.
        :param _builtins.str type: The dependency type.
        """
        pulumi.set(__self__, "reference_display_name", reference_display_name)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "reference_type", reference_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="referenceDisplayName")
    def reference_display_name(self) -> _builtins.str:
        """
        The display name of the dependency object
        """
        return pulumi.get(self, "reference_display_name")

    @_builtins.property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> _builtins.str:
        """
        The unique identifier of the reference, if available.
        """
        return pulumi.get(self, "reference_id")

    @_builtins.property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> _builtins.str:
        """
        The name of the dependency object
        """
        return pulumi.get(self, "reference_name")

    @_builtins.property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> _builtins.str:
        """
        The type of reference that defines the dependency.
        """
        return pulumi.get(self, "reference_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The dependency type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentSourceResult(dict):
    def __init__(__self__, *,
                 dependencies: Sequence['outputs.GetNamespaceFieldUsageDependentSourceDependencyResult'],
                 entity_types: Sequence['outputs.GetNamespaceFieldUsageDependentSourceEntityTypeResult'],
                 is_auto_association_enabled: _builtins.bool,
                 is_system: _builtins.bool,
                 source_display_name: _builtins.str,
                 source_id: _builtins.str,
                 source_name: _builtins.str,
                 source_type: _builtins.str):
        """
        :param Sequence['GetNamespaceFieldUsageDependentSourceDependencyArgs'] dependencies: The list of dependencies defined by the source.
        :param Sequence['GetNamespaceFieldUsageDependentSourceEntityTypeArgs'] entity_types: The entity types.
        :param _builtins.bool is_auto_association_enabled: A flag indicating whether or not the source is marked for auto association.
        :param _builtins.bool is_system: The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        :param _builtins.str source_display_name: The source display name.
        :param _builtins.str source_id: The source unique identifier.
        :param _builtins.str source_name: The source name.
        :param _builtins.str source_type: The source type.
        """
        pulumi.set(__self__, "dependencies", dependencies)
        pulumi.set(__self__, "entity_types", entity_types)
        pulumi.set(__self__, "is_auto_association_enabled", is_auto_association_enabled)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "source_display_name", source_display_name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "source_type", source_type)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Sequence['outputs.GetNamespaceFieldUsageDependentSourceDependencyResult']:
        """
        The list of dependencies defined by the source.
        """
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="entityTypes")
    def entity_types(self) -> Sequence['outputs.GetNamespaceFieldUsageDependentSourceEntityTypeResult']:
        """
        The entity types.
        """
        return pulumi.get(self, "entity_types")

    @_builtins.property
    @pulumi.getter(name="isAutoAssociationEnabled")
    def is_auto_association_enabled(self) -> _builtins.bool:
        """
        A flag indicating whether or not the source is marked for auto association.
        """
        return pulumi.get(self, "is_auto_association_enabled")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter(name="sourceDisplayName")
    def source_display_name(self) -> _builtins.str:
        """
        The source display name.
        """
        return pulumi.get(self, "source_display_name")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        The source unique identifier.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> _builtins.str:
        """
        The source name.
        """
        return pulumi.get(self, "source_name")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        The source type.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentSourceDependencyResult(dict):
    def __init__(__self__, *,
                 reference_display_name: _builtins.str,
                 reference_id: _builtins.str,
                 reference_name: _builtins.str,
                 reference_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str reference_display_name: The display name of the dependency object
        :param _builtins.str reference_id: The unique identifier of the reference, if available.
        :param _builtins.str reference_name: The name of the dependency object
        :param _builtins.str reference_type: The type of reference that defines the dependency.
        :param _builtins.str type: The dependency type.
        """
        pulumi.set(__self__, "reference_display_name", reference_display_name)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "reference_type", reference_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="referenceDisplayName")
    def reference_display_name(self) -> _builtins.str:
        """
        The display name of the dependency object
        """
        return pulumi.get(self, "reference_display_name")

    @_builtins.property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> _builtins.str:
        """
        The unique identifier of the reference, if available.
        """
        return pulumi.get(self, "reference_id")

    @_builtins.property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> _builtins.str:
        """
        The name of the dependency object
        """
        return pulumi.get(self, "reference_name")

    @_builtins.property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> _builtins.str:
        """
        The type of reference that defines the dependency.
        """
        return pulumi.get(self, "reference_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The dependency type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentSourceEntityTypeResult(dict):
    def __init__(__self__, *,
                 entity_type: _builtins.str,
                 entity_type_category: _builtins.str,
                 entity_type_display_name: _builtins.str,
                 source_id: _builtins.str):
        """
        :param _builtins.str entity_type: The entity type.
        :param _builtins.str entity_type_category: The type category.
        :param _builtins.str entity_type_display_name: The entity type display name.
        :param _builtins.str source_id: The source unique identifier.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "entity_type_category", entity_type_category)
        pulumi.set(__self__, "entity_type_display_name", entity_type_display_name)
        pulumi.set(__self__, "source_id", source_id)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> _builtins.str:
        """
        The entity type.
        """
        return pulumi.get(self, "entity_type")

    @_builtins.property
    @pulumi.getter(name="entityTypeCategory")
    def entity_type_category(self) -> _builtins.str:
        """
        The type category.
        """
        return pulumi.get(self, "entity_type_category")

    @_builtins.property
    @pulumi.getter(name="entityTypeDisplayName")
    def entity_type_display_name(self) -> _builtins.str:
        """
        The entity type display name.
        """
        return pulumi.get(self, "entity_type_display_name")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.str:
        """
        The source unique identifier.
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class GetNamespaceIngestTimeRuleActionResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 dimensions: Sequence[_builtins.str],
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 resource_group: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str compartment_id: Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence[_builtins.str] dimensions: Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        :param _builtins.str metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param _builtins.str resource_group: The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param _builtins.str type: Discriminator.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Sequence[_builtins.str]:
        """
        Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        """
        The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceIngestTimeRuleConditionResult(dict):
    def __init__(__self__, *,
                 additional_conditions: Sequence['outputs.GetNamespaceIngestTimeRuleConditionAdditionalConditionResult'],
                 field_name: _builtins.str,
                 field_operator: _builtins.str,
                 field_value: _builtins.str,
                 kind: _builtins.str):
        """
        :param Sequence['GetNamespaceIngestTimeRuleConditionAdditionalConditionArgs'] additional_conditions: Optional additional condition(s) to be evaluated.
        :param _builtins.str field_name: The field name to be evaluated.
        :param _builtins.str field_operator: The operator to be used for evaluating the field.
        :param _builtins.str field_value: The field value to be evaluated.
        :param _builtins.str kind: Discriminator.
        """
        pulumi.set(__self__, "additional_conditions", additional_conditions)
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_operator", field_operator)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="additionalConditions")
    def additional_conditions(self) -> Sequence['outputs.GetNamespaceIngestTimeRuleConditionAdditionalConditionResult']:
        """
        Optional additional condition(s) to be evaluated.
        """
        return pulumi.get(self, "additional_conditions")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        The field name to be evaluated.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldOperator")
    def field_operator(self) -> _builtins.str:
        """
        The operator to be used for evaluating the field.
        """
        return pulumi.get(self, "field_operator")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> _builtins.str:
        """
        The field value to be evaluated.
        """
        return pulumi.get(self, "field_value")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Discriminator.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GetNamespaceIngestTimeRuleConditionAdditionalConditionResult(dict):
    def __init__(__self__, *,
                 condition_field: _builtins.str,
                 condition_operator: _builtins.str,
                 condition_value: _builtins.str):
        """
        :param _builtins.str condition_field: The additional field name to be evaluated.
        :param _builtins.str condition_operator: The operator to be used for evaluating the additional field.
        :param _builtins.str condition_value: The additional field value to be evaluated.
        """
        pulumi.set(__self__, "condition_field", condition_field)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_value", condition_value)

    @_builtins.property
    @pulumi.getter(name="conditionField")
    def condition_field(self) -> _builtins.str:
        """
        The additional field name to be evaluated.
        """
        return pulumi.get(self, "condition_field")

    @_builtins.property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> _builtins.str:
        """
        The operator to be used for evaluating the additional field.
        """
        return pulumi.get(self, "condition_operator")

    @_builtins.property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> _builtins.str:
        """
        The additional field value to be evaluated.
        """
        return pulumi.get(self, "condition_value")


@pulumi.output_type
class GetNamespaceIngestTimeRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 condition_kind: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 field_name: _builtins.str,
                 field_value: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enabled: _builtins.bool,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param _builtins.str condition_kind: The ingest time rule condition kind used for filtering. Only rules with conditions of the specified kind will be returned.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: Description for this resource.
        :param _builtins.str display_name: A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        :param _builtins.str field_name: The field name used for filtering. Only rules using the specified field name will be returned.
        :param _builtins.str field_value: The field value used for filtering. Only rules using the specified field value will be returned.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.bool is_enabled: A flag indicating whether or not the ingest time rule is enabled.
        :param _builtins.str state: The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        :param _builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "condition_kind", condition_kind)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="conditionKind")
    def condition_kind(self) -> _builtins.str:
        """
        The ingest time rule condition kind used for filtering. Only rules with conditions of the specified kind will be returned.
        """
        return pulumi.get(self, "condition_kind")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        The field name used for filtering. Only rules using the specified field name will be returned.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> _builtins.str:
        """
        The field value used for filtering. Only rules using the specified field value will be returned.
        """
        return pulumi.get(self, "field_value")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        A flag indicating whether or not the ingest time rule is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetNamespaceLookupCategoryResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 is_system: _builtins.bool,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The lookup description.
        :param _builtins.str display_name: The field display name.
        :param _builtins.bool is_system: The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param _builtins.str name: The field name.
        :param _builtins.str type: The lookup type. Valid values are Lookup, Dictionary or Module.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The lookup description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The field display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The lookup type. Valid values are Lookup, Dictionary or Module.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceLookupFieldResult(dict):
    def __init__(__self__, *,
                 common_field_name: _builtins.str,
                 default_match_value: _builtins.str,
                 display_name: _builtins.str,
                 is_common_field: _builtins.bool,
                 match_operator: _builtins.str,
                 name: _builtins.str,
                 position: _builtins.str):
        """
        :param _builtins.str common_field_name: The common field name.
        :param _builtins.str default_match_value: The default match value.
        :param _builtins.str display_name: The field display name.
        :param _builtins.bool is_common_field: A flag indicating whether or not the lookup field is a common field.
        :param _builtins.str match_operator: The match operator.
        :param _builtins.str name: The field name.
        :param _builtins.str position: THe field position.
        """
        pulumi.set(__self__, "common_field_name", common_field_name)
        pulumi.set(__self__, "default_match_value", default_match_value)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_common_field", is_common_field)
        pulumi.set(__self__, "match_operator", match_operator)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="commonFieldName")
    def common_field_name(self) -> _builtins.str:
        """
        The common field name.
        """
        return pulumi.get(self, "common_field_name")

    @_builtins.property
    @pulumi.getter(name="defaultMatchValue")
    def default_match_value(self) -> _builtins.str:
        """
        The default match value.
        """
        return pulumi.get(self, "default_match_value")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The field display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isCommonField")
    def is_common_field(self) -> _builtins.bool:
        """
        A flag indicating whether or not the lookup field is a common field.
        """
        return pulumi.get(self, "is_common_field")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> _builtins.str:
        """
        The match operator.
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        """
        THe field position.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class GetNamespaceLookupReferringSourceResult(dict):
    def __init__(__self__, *,
                 canonical_link: _builtins.str,
                 total_count: _builtins.str):
        """
        :param _builtins.str canonical_link: The canonical link.
        :param _builtins.str total_count: The total count.
        """
        pulumi.set(__self__, "canonical_link", canonical_link)
        pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter(name="canonicalLink")
    def canonical_link(self) -> _builtins.str:
        """
        The canonical link.
        """
        return pulumi.get(self, "canonical_link")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.str:
        """
        The total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetNamespaceLookupStatusSummaryResult(dict):
    def __init__(__self__, *,
                 chunks_processed: _builtins.str,
                 failure_details: _builtins.str,
                 filename: _builtins.str,
                 status: _builtins.str,
                 total_chunks: _builtins.str):
        """
        :param _builtins.str chunks_processed: The number of chunks processed.
        :param _builtins.str failure_details: The failure details, if any.
        :param _builtins.str filename: The filename.
        :param _builtins.str status: The status.
        :param _builtins.str total_chunks: The total number of chunks.
        """
        pulumi.set(__self__, "chunks_processed", chunks_processed)
        pulumi.set(__self__, "failure_details", failure_details)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_chunks", total_chunks)

    @_builtins.property
    @pulumi.getter(name="chunksProcessed")
    def chunks_processed(self) -> _builtins.str:
        """
        The number of chunks processed.
        """
        return pulumi.get(self, "chunks_processed")

    @_builtins.property
    @pulumi.getter(name="failureDetails")
    def failure_details(self) -> _builtins.str:
        """
        The failure details, if any.
        """
        return pulumi.get(self, "failure_details")

    @_builtins.property
    @pulumi.getter
    def filename(self) -> _builtins.str:
        """
        The filename.
        """
        return pulumi.get(self, "filename")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalChunks")
    def total_chunks(self) -> _builtins.str:
        """
        The total number of chunks.
        """
        return pulumi.get(self, "total_chunks")


@pulumi.output_type
class GetNamespaceParserActionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The parser action name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The parser action name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceParserActionsParserActionSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceParserActionsParserActionSummaryCollectionItemResult']):
        """
        :param Sequence['GetNamespaceParserActionsParserActionSummaryCollectionItemArgs'] items: An array of parser action summary objects.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceParserActionsParserActionSummaryCollectionItemResult']:
        """
        An array of parser action summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceParserActionsParserActionSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str description: The parser action description.
        :param _builtins.str display_name: The parser action display name.
        :param _builtins.str name: The parser action name used for filtering.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The parser action description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The parser action display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The parser action name used for filtering.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNamespacePropertiesMetadataFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult']):
        """
        :param Sequence['GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemArgs'] items: An array of properties along with their metadata summary.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult']:
        """
        An array of properties along with their metadata summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 levels: Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult'],
                 name: _builtins.str):
        """
        :param _builtins.str default_value: The default property value.
        :param _builtins.str description: The property description.
        :param _builtins.str display_name: The property display name.
        :param Sequence['GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelArgs'] levels: A list of levels at which the property could be defined.
        :param _builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        The default property value.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The property description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The property display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def levels(self) -> Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult']:
        """
        A list of levels at which the property could be defined.
        """
        return pulumi.get(self, "levels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult(dict):
    def __init__(__self__, *,
                 constraints: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str constraints: The constraints that apply to the properties at a certain level.
        :param _builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "constraints", constraints)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def constraints(self) -> _builtins.str:
        """
        The constraints that apply to the properties at a certain level.
        """
        return pulumi.get(self, "constraints")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNamespaceRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceRulesRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceRulesRuleSummaryCollectionItemResult']):
        """
        :param Sequence['GetNamespaceRulesRuleSummaryCollectionItemArgs'] items: An array of rule summary objects.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceRulesRuleSummaryCollectionItemResult']:
        """
        An array of rule summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceRulesRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_enabled: _builtins.bool,
                 kind: _builtins.str,
                 last_execution_status: _builtins.str,
                 state: _builtins.str,
                 target_service: _builtins.str,
                 time_created: _builtins.str,
                 time_last_executed: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: Description for this resource.
        :param _builtins.str display_name: A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.bool is_enabled: A flag indicating whether or not the ingest time rule or scheduled task is enabled.
        :param _builtins.str kind: The rule kind used for filtering. Only rules of the specified kind will be returned.
        :param _builtins.str last_execution_status: The most recent task execution status.
        :param _builtins.str state: The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        :param _builtins.str target_service: The target service to use for filtering.
        :param _builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param _builtins.str time_last_executed: The date and time the scheduled task last executed, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "last_execution_status", last_execution_status)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target_service", target_service)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_last_executed", time_last_executed)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        A flag indicating whether or not the ingest time rule or scheduled task is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The rule kind used for filtering. Only rules of the specified kind will be returned.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="lastExecutionStatus")
    def last_execution_status(self) -> _builtins.str:
        """
        The most recent task execution status.
        """
        return pulumi.get(self, "last_execution_status")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="targetService")
    def target_service(self) -> _builtins.str:
        """
        The target service to use for filtering.
        """
        return pulumi.get(self, "target_service")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeLastExecuted")
    def time_last_executed(self) -> _builtins.str:
        """
        The date and time the scheduled task last executed, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_executed")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetNamespaceScheduledTaskActionResult(dict):
    def __init__(__self__, *,
                 compartment_id_in_subtree: _builtins.bool,
                 data_type: _builtins.str,
                 metric_extractions: Sequence['outputs.GetNamespaceScheduledTaskActionMetricExtractionResult'],
                 purge_compartment_id: _builtins.str,
                 purge_duration: _builtins.str,
                 query_string: _builtins.str,
                 saved_search_id: _builtins.str,
                 template_details: Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailResult'],
                 type: _builtins.str):
        """
        :param _builtins.bool compartment_id_in_subtree: if true, purge child compartments data
        :param _builtins.str data_type: the type of the log data to be purged
        :param Sequence['GetNamespaceScheduledTaskActionMetricExtractionArgs'] metric_extractions: Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        :param _builtins.str purge_compartment_id: the compartment OCID under which the data will be purged
        :param _builtins.str purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param _builtins.str query_string: Purge query string.
        :param _builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        :param Sequence['GetNamespaceScheduledTaskActionTemplateDetailArgs'] template_details: details for scheduled task using template
        :param _builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "metric_extractions", metric_extractions)
        pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        pulumi.set(__self__, "purge_duration", purge_duration)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "saved_search_id", saved_search_id)
        pulumi.set(__self__, "template_details", template_details)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> _builtins.bool:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="metricExtractions")
    def metric_extractions(self) -> Sequence['outputs.GetNamespaceScheduledTaskActionMetricExtractionResult']:
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        return pulumi.get(self, "metric_extractions")

    @_builtins.property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> _builtins.str:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @_builtins.property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> _builtins.str:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> _builtins.str:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> _builtins.str:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @_builtins.property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailResult']:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceScheduledTaskActionMetricExtractionResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 resource_group: _builtins.str):
        """
        :param _builtins.str compartment_id: Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param _builtins.str metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param _builtins.str resource_group: The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_group", resource_group)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class GetNamespaceScheduledTaskActionTemplateDetailResult(dict):
    def __init__(__self__, *,
                 template_id: _builtins.str,
                 template_params: Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult']):
        """
        :param _builtins.str template_id: The Config template Id of a particular template.
        :param Sequence['GetNamespaceScheduledTaskActionTemplateDetailTemplateParamArgs'] template_params: To store macro params.
        """
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "template_params", template_params)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        The Config template Id of a particular template.
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult']:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")


@pulumi.output_type
class GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult(dict):
    def __init__(__self__, *,
                 key_field: _builtins.str,
                 value_field: _builtins.str):
        """
        :param _builtins.str key_field: Contains macro parameter's names.
        :param _builtins.str value_field: Contains macro parameter's value.
        """
        pulumi.set(__self__, "key_field", key_field)
        pulumi.set(__self__, "value_field", value_field)

    @_builtins.property
    @pulumi.getter(name="keyField")
    def key_field(self) -> _builtins.str:
        """
        Contains macro parameter's names.
        """
        return pulumi.get(self, "key_field")

    @_builtins.property
    @pulumi.getter(name="valueField")
    def value_field(self) -> _builtins.str:
        """
        Contains macro parameter's value.
        """
        return pulumi.get(self, "value_field")


@pulumi.output_type
class GetNamespaceScheduledTaskScheduleResult(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.GetNamespaceScheduledTaskScheduleScheduleResult']):
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetNamespaceScheduledTaskScheduleScheduleResult']:
        return pulumi.get(self, "schedules")


@pulumi.output_type
class GetNamespaceScheduledTaskScheduleScheduleResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 misfire_policy: _builtins.str,
                 recurring_interval: _builtins.str,
                 repeat_count: _builtins.int,
                 time_zone: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str expression: Value in cron format.
        :param _builtins.str misfire_policy: Schedule misfire retry policy.
        :param _builtins.str recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param _builtins.int repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param _builtins.str time_zone: Time zone, by default UTC.
        :param _builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "misfire_policy", misfire_policy)
        pulumi.set(__self__, "recurring_interval", recurring_interval)
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> _builtins.str:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @_builtins.property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> _builtins.str:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> _builtins.int:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceScheduledTasksFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult'],
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 kind: _builtins.str,
                 namespace: _builtins.str,
                 num_occurrences: _builtins.str,
                 saved_search_id: _builtins.str,
                 scheduled_task_id: _builtins.str,
                 schedules: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult'],
                 state: _builtins.str,
                 task_status: _builtins.str,
                 task_type: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 work_request_id: _builtins.str):
        """
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemActionArgs'] actions: Action for scheduled task.
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str display_name: A filter to return only resources that match the given display name exactly.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the data plane resource.
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        :param _builtins.str num_occurrences: Number of execution occurrences.
        :param _builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleArgs'] schedules: Schedules.
        :param _builtins.str state: The current state of the scheduled task.
        :param _builtins.str task_status: Status of the scheduled task. - PURGE_RESOURCE_NOT_FOUND
        :param _builtins.str task_type: Required parameter to specify schedule task type.
        :param _builtins.str time_created: The date and time the scheduled task was created, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the scheduled task was last updated, in the format defined by RFC3339.
        :param _builtins.str work_request_id: most recent Work Request Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the asynchronous request.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "num_occurrences", num_occurrences)
        pulumi.set(__self__, "saved_search_id", saved_search_id)
        pulumi.set(__self__, "scheduled_task_id", scheduled_task_id)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "task_status", task_status)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "work_request_id", work_request_id)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult']:
        """
        Action for scheduled task.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the data plane resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="numOccurrences")
    def num_occurrences(self) -> _builtins.str:
        """
        Number of execution occurrences.
        """
        return pulumi.get(self, "num_occurrences")

    @_builtins.property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> _builtins.str:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @_builtins.property
    @pulumi.getter(name="scheduledTaskId")
    def scheduled_task_id(self) -> _builtins.str:
        return pulumi.get(self, "scheduled_task_id")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult']:
        """
        Schedules.
        """
        return pulumi.get(self, "schedules")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current state of the scheduled task.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="taskStatus")
    def task_status(self) -> _builtins.str:
        """
        Status of the scheduled task. - PURGE_RESOURCE_NOT_FOUND
        """
        return pulumi.get(self, "task_status")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Required parameter to specify schedule task type.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the scheduled task was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the scheduled task was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> _builtins.str:
        """
        most recent Work Request Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the asynchronous request.
        """
        return pulumi.get(self, "work_request_id")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult(dict):
    def __init__(__self__, *,
                 compartment_id_in_subtree: _builtins.bool,
                 data_type: _builtins.str,
                 metric_extractions: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult'],
                 purge_compartment_id: _builtins.str,
                 purge_duration: _builtins.str,
                 query_string: _builtins.str,
                 saved_search_id: _builtins.str,
                 template_details: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult'],
                 type: _builtins.str):
        """
        :param _builtins.bool compartment_id_in_subtree: if true, purge child compartments data
        :param _builtins.str data_type: the type of the log data to be purged
        :param _builtins.str purge_compartment_id: the compartment OCID under which the data will be purged
        :param _builtins.str purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param _builtins.str query_string: Purge query string.
        :param _builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailArgs'] template_details: details for scheduled task using template
        :param _builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "metric_extractions", metric_extractions)
        pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        pulumi.set(__self__, "purge_duration", purge_duration)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "saved_search_id", saved_search_id)
        pulumi.set(__self__, "template_details", template_details)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> _builtins.bool:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="metricExtractions")
    def metric_extractions(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult']:
        return pulumi.get(self, "metric_extractions")

    @_builtins.property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> _builtins.str:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @_builtins.property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> _builtins.str:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> _builtins.str:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> _builtins.str:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @_builtins.property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult']:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 resource_group: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param _builtins.str namespace: The Logging Analytics namespace used for the request.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_group", resource_group)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult(dict):
    def __init__(__self__, *,
                 template_id: _builtins.str,
                 template_params: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult']):
        """
        :param _builtins.str template_id: A filter to return only scheduled tasks whose stream action templateId matches the given id  exactly.
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamArgs'] template_params: To store macro params.
        """
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "template_params", template_params)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        A filter to return only scheduled tasks whose stream action templateId matches the given id  exactly.
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult']:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult(dict):
    def __init__(__self__, *,
                 key_field: _builtins.str,
                 value_field: _builtins.str):
        """
        :param _builtins.str key_field: Contains macro parameter's names.
        :param _builtins.str value_field: Contains macro parameter's value.
        """
        pulumi.set(__self__, "key_field", key_field)
        pulumi.set(__self__, "value_field", value_field)

    @_builtins.property
    @pulumi.getter(name="keyField")
    def key_field(self) -> _builtins.str:
        """
        Contains macro parameter's names.
        """
        return pulumi.get(self, "key_field")

    @_builtins.property
    @pulumi.getter(name="valueField")
    def value_field(self) -> _builtins.str:
        """
        Contains macro parameter's value.
        """
        return pulumi.get(self, "value_field")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult']):
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult']:
        return pulumi.get(self, "schedules")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 misfire_policy: _builtins.str,
                 recurring_interval: _builtins.str,
                 repeat_count: _builtins.int,
                 time_zone: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str expression: Value in cron format.
        :param _builtins.str misfire_policy: Schedule misfire retry policy.
        :param _builtins.str recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param _builtins.int repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param _builtins.str time_zone: Time zone, by default UTC.
        :param _builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "misfire_policy", misfire_policy)
        pulumi.set(__self__, "recurring_interval", recurring_interval)
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> _builtins.str:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @_builtins.property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> _builtins.str:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> _builtins.int:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceStorageArchivalConfigArchivingConfigurationResult(dict):
    def __init__(__self__, *,
                 active_storage_duration: _builtins.str,
                 archival_storage_duration: _builtins.str):
        """
        :param _builtins.str active_storage_duration: This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        :param _builtins.str archival_storage_duration: This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        pulumi.set(__self__, "active_storage_duration", active_storage_duration)
        pulumi.set(__self__, "archival_storage_duration", archival_storage_duration)

    @_builtins.property
    @pulumi.getter(name="activeStorageDuration")
    def active_storage_duration(self) -> _builtins.str:
        """
        This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "active_storage_duration")

    @_builtins.property
    @pulumi.getter(name="archivalStorageDuration")
    def archival_storage_duration(self) -> _builtins.str:
        """
        This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "archival_storage_duration")


@pulumi.output_type
class GetNamespaceStorageEncryptionKeyInfoItemResult(dict):
    def __init__(__self__, *,
                 key_id: _builtins.str,
                 key_source: _builtins.str,
                 key_type: _builtins.str):
        """
        :param _builtins.str key_id: This is the key OCID of the encryption key (null if Oracle-managed).
        :param _builtins.str key_source: This is the source of the encryption key.
        :param _builtins.str key_type: This is the type of data to be encrypted. It can be either active or archival.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "key_source", key_source)
        pulumi.set(__self__, "key_type", key_type)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        This is the key OCID of the encryption key (null if Oracle-managed).
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="keySource")
    def key_source(self) -> _builtins.str:
        """
        This is the source of the encryption key.
        """
        return pulumi.get(self, "key_source")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> _builtins.str:
        """
        This is the type of data to be encrypted. It can be either active or archival.
        """
        return pulumi.get(self, "key_type")


@pulumi.output_type
class GetNamespaceStorageOverlappingRecallsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult']):
        """
        :param Sequence['GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemArgs'] items: This is the array of overlapping recall requests
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult']:
        """
        This is the array of overlapping recall requests
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult(dict):
    def __init__(__self__, *,
                 collection_id: _builtins.str,
                 created_by: _builtins.str,
                 log_sets: _builtins.str,
                 purpose: _builtins.str,
                 query_string: _builtins.str,
                 recall_id: _builtins.str,
                 status: _builtins.str,
                 time_data_ended: _builtins.str,
                 time_data_started: _builtins.str,
                 time_started: _builtins.str):
        """
        :param _builtins.str collection_id: This is the id of the associated recalled data collection
        :param _builtins.str created_by: This is the user who initiated the recall request
        :param _builtins.str log_sets: This is the list of logsets associated with this recall
        :param _builtins.str purpose: This is the purpose of the recall
        :param _builtins.str query_string: This is the query associated with the recall
        :param _builtins.str recall_id: This is the id for the recall request
        :param _builtins.str status: This is the status of the recall
        :param _builtins.str time_data_ended: This is the end of the time range for recalled data
        :param _builtins.str time_data_started: This is the start of the time range for recalled data
        :param _builtins.str time_started: This is the time when the recall operation was started for this recall request
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "log_sets", log_sets)
        pulumi.set(__self__, "purpose", purpose)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "recall_id", recall_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "time_data_ended", time_data_ended)
        pulumi.set(__self__, "time_data_started", time_data_started)
        pulumi.set(__self__, "time_started", time_started)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> _builtins.str:
        """
        This is the id of the associated recalled data collection
        """
        return pulumi.get(self, "collection_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        This is the user who initiated the recall request
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="logSets")
    def log_sets(self) -> _builtins.str:
        """
        This is the list of logsets associated with this recall
        """
        return pulumi.get(self, "log_sets")

    @_builtins.property
    @pulumi.getter
    def purpose(self) -> _builtins.str:
        """
        This is the purpose of the recall
        """
        return pulumi.get(self, "purpose")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> _builtins.str:
        """
        This is the query associated with the recall
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="recallId")
    def recall_id(self) -> _builtins.str:
        """
        This is the id for the recall request
        """
        return pulumi.get(self, "recall_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        This is the status of the recall
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="timeDataEnded")
    def time_data_ended(self) -> _builtins.str:
        """
        This is the end of the time range for recalled data
        """
        return pulumi.get(self, "time_data_ended")

    @_builtins.property
    @pulumi.getter(name="timeDataStarted")
    def time_data_started(self) -> _builtins.str:
        """
        This is the start of the time range for recalled data
        """
        return pulumi.get(self, "time_data_started")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        This is the time when the recall operation was started for this recall request
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetNamespaceTemplateFacetResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The template name.
        :param _builtins.str value: The facet value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The template name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The facet value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespaceTemplatesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The template name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceTemplatesLogAnalyticsTemplateCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 content: _builtins.str,
                 content_format: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 facets: Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 is_system: _builtins.bool,
                 name: _builtins.str,
                 parameters: _builtins.str,
                 parameters_format: _builtins.str,
                 parameters_metadata: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param _builtins.str content: Base64 encoded template content.
        :param _builtins.str content_format: Content format. For example - XML.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: Description for this resource.
        :param Sequence['GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetArgs'] facets: Facets of the template
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param _builtins.bool is_system: The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        :param _builtins.str name: The template name used for filtering.
        :param _builtins.str parameters: Base64 encoded template parameters.
        :param _builtins.str parameters_format: Parameters format.  For example - NAME_VALUE_PAIR.
        :param _builtins.str parameters_metadata: Base64 encoded parameters metadata definition.
        :param _builtins.str state: The template lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        :param _builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param _builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        :param _builtins.str type: The template type used for filtering. Only templates of the specified type will be returned.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_format", content_format)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "facets", facets)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "parameters_format", parameters_format)
        pulumi.set(__self__, "parameters_metadata", parameters_metadata)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Base64 encoded template content.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="contentFormat")
    def content_format(self) -> _builtins.str:
        """
        Content format. For example - XML.
        """
        return pulumi.get(self, "content_format")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def facets(self) -> Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult']:
        """
        Facets of the template
        """
        return pulumi.get(self, "facets")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> _builtins.bool:
        """
        The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        """
        return pulumi.get(self, "is_system")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> _builtins.str:
        """
        Base64 encoded template parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="parametersFormat")
    def parameters_format(self) -> _builtins.str:
        """
        Parameters format.  For example - NAME_VALUE_PAIR.
        """
        return pulumi.get(self, "parameters_format")

    @_builtins.property
    @pulumi.getter(name="parametersMetadata")
    def parameters_metadata(self) -> _builtins.str:
        """
        Base64 encoded parameters metadata definition.
        """
        return pulumi.get(self, "parameters_metadata")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The template lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The template type used for filtering. Only templates of the specified type will be returned.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The template name used for filtering.
        :param _builtins.str value: The facet value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The facet value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespacesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespacesNamespaceCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespacesNamespaceCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespacesNamespaceCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespacesNamespaceCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 is_archiving_enabled: _builtins.bool,
                 is_data_ever_ingested: _builtins.bool,
                 is_logset_enabled: _builtins.bool,
                 is_onboarded: _builtins.bool,
                 namespace: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param _builtins.bool is_archiving_enabled: This indicates if old data can be archived for a tenancy
        :param _builtins.bool is_data_ever_ingested: This indicates if the tenancy is data ever ingested
        :param _builtins.bool is_onboarded: This indicates if the tenancy is onboarded to Logging Analytics
        :param _builtins.str namespace: This is the namespace name of a tenancy
               * `is_logSet_enabled` - This indicates if the tenancy is logSet enable
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "is_archiving_enabled", is_archiving_enabled)
        pulumi.set(__self__, "is_data_ever_ingested", is_data_ever_ingested)
        pulumi.set(__self__, "is_logset_enabled", is_logset_enabled)
        pulumi.set(__self__, "is_onboarded", is_onboarded)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="isArchivingEnabled")
    def is_archiving_enabled(self) -> _builtins.bool:
        """
        This indicates if old data can be archived for a tenancy
        """
        return pulumi.get(self, "is_archiving_enabled")

    @_builtins.property
    @pulumi.getter(name="isDataEverIngested")
    def is_data_ever_ingested(self) -> _builtins.bool:
        """
        This indicates if the tenancy is data ever ingested
        """
        return pulumi.get(self, "is_data_ever_ingested")

    @_builtins.property
    @pulumi.getter(name="isLogsetEnabled")
    def is_logset_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_logset_enabled")

    @_builtins.property
    @pulumi.getter(name="isOnboarded")
    def is_onboarded(self) -> _builtins.bool:
        """
        This indicates if the tenancy is onboarded to Logging Analytics
        """
        return pulumi.get(self, "is_onboarded")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        This is the namespace name of a tenancy
        * `is_logSet_enabled` - This indicates if the tenancy is logSet enable
        """
        return pulumi.get(self, "namespace")


