# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'LogAnalyticsEntityMetadata',
    'LogAnalyticsEntityMetadataItem',
    'LogAnalyticsImportCustomContentChangeList',
    'LogAnalyticsObjectCollectionRuleOverride',
    'LogAnalyticsPreferencesManagementItem',
    'NamespaceIngestTimeRuleAction',
    'NamespaceIngestTimeRuleConditions',
    'NamespaceIngestTimeRuleConditionsAdditionalCondition',
    'NamespaceLookupCategory',
    'NamespaceLookupField',
    'NamespaceLookupReferringSource',
    'NamespaceLookupStatusSummary',
    'NamespaceScheduledTaskAction',
    'NamespaceScheduledTaskActionMetricExtraction',
    'NamespaceScheduledTaskActionTemplateDetails',
    'NamespaceScheduledTaskActionTemplateDetailsTemplateParam',
    'NamespaceScheduledTaskSchedules',
    'NamespaceScheduledTaskSchedulesSchedule',
    'NamespaceStorageArchivalConfigArchivingConfiguration',
    'GetLogAnalyticsCategoriesListItemResult',
    'GetLogAnalyticsEntitiesFilterResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult',
    'GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult',
    'GetLogAnalyticsEntityMetadataResult',
    'GetLogAnalyticsEntityMetadataItemResult',
    'GetLogAnalyticsEntityTopologyFilterResult',
    'GetLogAnalyticsEntityTopologyItemResult',
    'GetLogAnalyticsEntityTopologyItemLinkResult',
    'GetLogAnalyticsEntityTopologyItemLinkItemResult',
    'GetLogAnalyticsEntityTopologyItemNodeResult',
    'GetLogAnalyticsEntityTopologyItemNodeItemResult',
    'GetLogAnalyticsLogGroupsFilterResult',
    'GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionResult',
    'GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult',
    'GetLogAnalyticsObjectCollectionRuleOverrideResult',
    'GetLogAnalyticsObjectCollectionRulesFilterResult',
    'GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionResult',
    'GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult',
    'GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult',
    'GetLogAnalyticsPreferenceItemResult',
    'GetLogAnalyticsResourceCategoriesListCategoryResult',
    'GetLogAnalyticsResourceCategoriesListItemResult',
    'GetNamespaceEffectivePropertiesEffectivePropertyCollectionResult',
    'GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult',
    'GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult',
    'GetNamespaceEffectivePropertiesFilterResult',
    'GetNamespaceFieldUsageDependentParserResult',
    'GetNamespaceFieldUsageDependentParserDependencyResult',
    'GetNamespaceFieldUsageDependentSourceResult',
    'GetNamespaceFieldUsageDependentSourceDependencyResult',
    'GetNamespaceFieldUsageDependentSourceEntityTypeResult',
    'GetNamespaceIngestTimeRuleActionResult',
    'GetNamespaceIngestTimeRuleConditionResult',
    'GetNamespaceIngestTimeRuleConditionAdditionalConditionResult',
    'GetNamespaceIngestTimeRulesFilterResult',
    'GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionResult',
    'GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult',
    'GetNamespaceLookupCategoryResult',
    'GetNamespaceLookupFieldResult',
    'GetNamespaceLookupReferringSourceResult',
    'GetNamespaceLookupStatusSummaryResult',
    'GetNamespaceParserActionsFilterResult',
    'GetNamespaceParserActionsParserActionSummaryCollectionResult',
    'GetNamespaceParserActionsParserActionSummaryCollectionItemResult',
    'GetNamespacePropertiesMetadataFilterResult',
    'GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionResult',
    'GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult',
    'GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult',
    'GetNamespaceRulesFilterResult',
    'GetNamespaceRulesRuleSummaryCollectionResult',
    'GetNamespaceRulesRuleSummaryCollectionItemResult',
    'GetNamespaceScheduledTaskActionResult',
    'GetNamespaceScheduledTaskActionMetricExtractionResult',
    'GetNamespaceScheduledTaskActionTemplateDetailResult',
    'GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult',
    'GetNamespaceScheduledTaskScheduleResult',
    'GetNamespaceScheduledTaskScheduleScheduleResult',
    'GetNamespaceScheduledTasksFilterResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult',
    'GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult',
    'GetNamespaceStorageArchivalConfigArchivingConfigurationResult',
    'GetNamespaceStorageEncryptionKeyInfoItemResult',
    'GetNamespaceStorageOverlappingRecallsFilterResult',
    'GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionResult',
    'GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult',
    'GetNamespaceTemplateFacetResult',
    'GetNamespaceTemplatesFilterResult',
    'GetNamespaceTemplatesLogAnalyticsTemplateCollectionResult',
    'GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult',
    'GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult',
    'GetNamespacesFilterResult',
    'GetNamespacesNamespaceCollectionResult',
    'GetNamespacesNamespaceCollectionItemResult',
]

@pulumi.output_type
class LogAnalyticsEntityMetadata(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.LogAnalyticsEntityMetadataItem']] = None):
        """
        :param Sequence['LogAnalyticsEntityMetadataItemArgs'] items: (Updatable) An array of entity metadata details.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.LogAnalyticsEntityMetadataItem']]:
        """
        (Updatable) An array of entity metadata details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class LogAnalyticsEntityMetadataItem(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str name: (Updatable) The metadata name.
        :param builtins.str type: (Updatable) The metadata type.
        :param builtins.str value: (Updatable) The metadata value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        (Updatable) The metadata name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Updatable) The metadata type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        (Updatable) The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LogAnalyticsImportCustomContentChangeList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conflictFieldDisplayNames":
            suggest = "conflict_field_display_names"
        elif key == "conflictParserNames":
            suggest = "conflict_parser_names"
        elif key == "conflictSourceNames":
            suggest = "conflict_source_names"
        elif key == "createdFieldDisplayNames":
            suggest = "created_field_display_names"
        elif key == "createdParserNames":
            suggest = "created_parser_names"
        elif key == "createdSourceNames":
            suggest = "created_source_names"
        elif key == "updatedFieldDisplayNames":
            suggest = "updated_field_display_names"
        elif key == "updatedParserNames":
            suggest = "updated_parser_names"
        elif key == "updatedSourceNames":
            suggest = "updated_source_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsImportCustomContentChangeList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsImportCustomContentChangeList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsImportCustomContentChangeList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conflict_field_display_names: Optional[Sequence[builtins.str]] = None,
                 conflict_parser_names: Optional[Sequence[builtins.str]] = None,
                 conflict_source_names: Optional[Sequence[builtins.str]] = None,
                 created_field_display_names: Optional[Sequence[builtins.str]] = None,
                 created_parser_names: Optional[Sequence[builtins.str]] = None,
                 created_source_names: Optional[Sequence[builtins.str]] = None,
                 updated_field_display_names: Optional[Sequence[builtins.str]] = None,
                 updated_parser_names: Optional[Sequence[builtins.str]] = None,
                 updated_source_names: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] conflict_field_display_names: A list of field display names with conflicts.
        :param Sequence[builtins.str] conflict_parser_names: A list of parser names with conflicts.
        :param Sequence[builtins.str] conflict_source_names: A list of source names with conflicts.
        :param Sequence[builtins.str] created_field_display_names: An array of created field display names.
        :param Sequence[builtins.str] created_parser_names: An array of created parser names.
        :param Sequence[builtins.str] created_source_names: An array of created source names.
        :param Sequence[builtins.str] updated_field_display_names: An array of updated field display names.
        :param Sequence[builtins.str] updated_parser_names: An array of updated parser names.
        :param Sequence[builtins.str] updated_source_names: An array of updated source names.
        """
        if conflict_field_display_names is not None:
            pulumi.set(__self__, "conflict_field_display_names", conflict_field_display_names)
        if conflict_parser_names is not None:
            pulumi.set(__self__, "conflict_parser_names", conflict_parser_names)
        if conflict_source_names is not None:
            pulumi.set(__self__, "conflict_source_names", conflict_source_names)
        if created_field_display_names is not None:
            pulumi.set(__self__, "created_field_display_names", created_field_display_names)
        if created_parser_names is not None:
            pulumi.set(__self__, "created_parser_names", created_parser_names)
        if created_source_names is not None:
            pulumi.set(__self__, "created_source_names", created_source_names)
        if updated_field_display_names is not None:
            pulumi.set(__self__, "updated_field_display_names", updated_field_display_names)
        if updated_parser_names is not None:
            pulumi.set(__self__, "updated_parser_names", updated_parser_names)
        if updated_source_names is not None:
            pulumi.set(__self__, "updated_source_names", updated_source_names)

    @property
    @pulumi.getter(name="conflictFieldDisplayNames")
    def conflict_field_display_names(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of field display names with conflicts.
        """
        return pulumi.get(self, "conflict_field_display_names")

    @property
    @pulumi.getter(name="conflictParserNames")
    def conflict_parser_names(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of parser names with conflicts.
        """
        return pulumi.get(self, "conflict_parser_names")

    @property
    @pulumi.getter(name="conflictSourceNames")
    def conflict_source_names(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of source names with conflicts.
        """
        return pulumi.get(self, "conflict_source_names")

    @property
    @pulumi.getter(name="createdFieldDisplayNames")
    def created_field_display_names(self) -> Optional[Sequence[builtins.str]]:
        """
        An array of created field display names.
        """
        return pulumi.get(self, "created_field_display_names")

    @property
    @pulumi.getter(name="createdParserNames")
    def created_parser_names(self) -> Optional[Sequence[builtins.str]]:
        """
        An array of created parser names.
        """
        return pulumi.get(self, "created_parser_names")

    @property
    @pulumi.getter(name="createdSourceNames")
    def created_source_names(self) -> Optional[Sequence[builtins.str]]:
        """
        An array of created source names.
        """
        return pulumi.get(self, "created_source_names")

    @property
    @pulumi.getter(name="updatedFieldDisplayNames")
    def updated_field_display_names(self) -> Optional[Sequence[builtins.str]]:
        """
        An array of updated field display names.
        """
        return pulumi.get(self, "updated_field_display_names")

    @property
    @pulumi.getter(name="updatedParserNames")
    def updated_parser_names(self) -> Optional[Sequence[builtins.str]]:
        """
        An array of updated parser names.
        """
        return pulumi.get(self, "updated_parser_names")

    @property
    @pulumi.getter(name="updatedSourceNames")
    def updated_source_names(self) -> Optional[Sequence[builtins.str]]:
        """
        An array of updated source names.
        """
        return pulumi.get(self, "updated_source_names")


@pulumi.output_type
class LogAnalyticsObjectCollectionRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"
        elif key == "propertyName":
            suggest = "property_name"
        elif key == "propertyValue":
            suggest = "property_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsObjectCollectionRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsObjectCollectionRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsObjectCollectionRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[builtins.str] = None,
                 match_value: Optional[builtins.str] = None,
                 property_name: Optional[builtins.str] = None,
                 property_value: Optional[builtins.str] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_value is not None:
            pulumi.set(__self__, "property_value", property_value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "match_value")

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "property_name")

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "property_value")


@pulumi.output_type
class LogAnalyticsPreferencesManagementItem(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str name: The preference name.
        :param builtins.str value: The preference value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The preference name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        The preference value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NamespaceIngestTimeRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "resourceGroup":
            suggest = "resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceIngestTimeRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceIngestTimeRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceIngestTimeRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 metric_name: builtins.str,
                 namespace: builtins.str,
                 type: builtins.str,
                 dimensions: Optional[Sequence[builtins.str]] = None,
                 resource_group: Optional[builtins.str] = None):
        """
        :param builtins.str compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param builtins.str metric_name: (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param builtins.str namespace: (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param builtins.str type: (Updatable) Discriminator.
        :param Sequence[builtins.str] dimensions: (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        :param builtins.str resource_group: (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "type", type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> builtins.str:
        """
        (Updatable) The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        (Updatable) The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[builtins.str]]:
        """
        (Updatable) Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        (Updatable) The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class NamespaceIngestTimeRuleConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldOperator":
            suggest = "field_operator"
        elif key == "fieldValue":
            suggest = "field_value"
        elif key == "additionalConditions":
            suggest = "additional_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceIngestTimeRuleConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceIngestTimeRuleConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceIngestTimeRuleConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: builtins.str,
                 field_operator: builtins.str,
                 field_value: builtins.str,
                 kind: builtins.str,
                 additional_conditions: Optional[Sequence['outputs.NamespaceIngestTimeRuleConditionsAdditionalCondition']] = None):
        """
        :param builtins.str field_name: (Updatable) The field name to be evaluated.
        :param builtins.str field_operator: (Updatable) The operator to be used for evaluating the field.
        :param builtins.str field_value: (Updatable) The field value to be evaluated.
        :param builtins.str kind: (Updatable) Discriminator.
        :param Sequence['NamespaceIngestTimeRuleConditionsAdditionalConditionArgs'] additional_conditions: (Updatable) Optional additional condition(s) to be evaluated.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_operator", field_operator)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "kind", kind)
        if additional_conditions is not None:
            pulumi.set(__self__, "additional_conditions", additional_conditions)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> builtins.str:
        """
        (Updatable) The field name to be evaluated.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldOperator")
    def field_operator(self) -> builtins.str:
        """
        (Updatable) The operator to be used for evaluating the field.
        """
        return pulumi.get(self, "field_operator")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> builtins.str:
        """
        (Updatable) The field value to be evaluated.
        """
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        (Updatable) Discriminator.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="additionalConditions")
    def additional_conditions(self) -> Optional[Sequence['outputs.NamespaceIngestTimeRuleConditionsAdditionalCondition']]:
        """
        (Updatable) Optional additional condition(s) to be evaluated.
        """
        return pulumi.get(self, "additional_conditions")


@pulumi.output_type
class NamespaceIngestTimeRuleConditionsAdditionalCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionField":
            suggest = "condition_field"
        elif key == "conditionOperator":
            suggest = "condition_operator"
        elif key == "conditionValue":
            suggest = "condition_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceIngestTimeRuleConditionsAdditionalCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceIngestTimeRuleConditionsAdditionalCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceIngestTimeRuleConditionsAdditionalCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_field: builtins.str,
                 condition_operator: builtins.str,
                 condition_value: builtins.str):
        """
        :param builtins.str condition_field: (Updatable) The additional field name to be evaluated.
        :param builtins.str condition_operator: (Updatable) The operator to be used for evaluating the additional field.
        :param builtins.str condition_value: (Updatable) The additional field value to be evaluated.
        """
        pulumi.set(__self__, "condition_field", condition_field)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_value", condition_value)

    @property
    @pulumi.getter(name="conditionField")
    def condition_field(self) -> builtins.str:
        """
        (Updatable) The additional field name to be evaluated.
        """
        return pulumi.get(self, "condition_field")

    @property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> builtins.str:
        """
        (Updatable) The operator to be used for evaluating the additional field.
        """
        return pulumi.get(self, "condition_operator")

    @property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> builtins.str:
        """
        (Updatable) The additional field value to be evaluated.
        """
        return pulumi.get(self, "condition_value")


@pulumi.output_type
class NamespaceLookupCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isSystem":
            suggest = "is_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 is_system: Optional[builtins.bool] = None,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str description: (Updatable) The category description.
        :param builtins.str display_name: (Updatable) The category display name.
        :param builtins.bool is_system: (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param builtins.str name: (Updatable) The unique name that identifies the category.
        :param builtins.str type: (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        (Updatable) The category description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        (Updatable) The category display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[builtins.bool]:
        """
        (Updatable) The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        (Updatable) The unique name that identifies the category.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Updatable) The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NamespaceLookupField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonFieldName":
            suggest = "common_field_name"
        elif key == "defaultMatchValue":
            suggest = "default_match_value"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "isCommonField":
            suggest = "is_common_field"
        elif key == "matchOperator":
            suggest = "match_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_field_name: Optional[builtins.str] = None,
                 default_match_value: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 is_common_field: Optional[builtins.bool] = None,
                 match_operator: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 position: Optional[builtins.str] = None):
        """
        :param builtins.str common_field_name: (Updatable) The common field name.
        :param builtins.str default_match_value: (Updatable) The default match value.
        :param builtins.str display_name: (Updatable) The display name.
        :param builtins.bool is_common_field: (Updatable) A flag indicating whether or not the field is a common field.
        :param builtins.str match_operator: (Updatable) The match operator.
        :param builtins.str name: (Updatable) The field name.
        :param builtins.str position: (Updatable) The position.
        """
        if common_field_name is not None:
            pulumi.set(__self__, "common_field_name", common_field_name)
        if default_match_value is not None:
            pulumi.set(__self__, "default_match_value", default_match_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_common_field is not None:
            pulumi.set(__self__, "is_common_field", is_common_field)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="commonFieldName")
    def common_field_name(self) -> Optional[builtins.str]:
        """
        (Updatable) The common field name.
        """
        return pulumi.get(self, "common_field_name")

    @property
    @pulumi.getter(name="defaultMatchValue")
    def default_match_value(self) -> Optional[builtins.str]:
        """
        (Updatable) The default match value.
        """
        return pulumi.get(self, "default_match_value")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        (Updatable) The display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isCommonField")
    def is_common_field(self) -> Optional[builtins.bool]:
        """
        (Updatable) A flag indicating whether or not the field is a common field.
        """
        return pulumi.get(self, "is_common_field")

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[builtins.str]:
        """
        (Updatable) The match operator.
        """
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        (Updatable) The field name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def position(self) -> Optional[builtins.str]:
        """
        (Updatable) The position.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class NamespaceLookupReferringSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canonicalLink":
            suggest = "canonical_link"
        elif key == "totalCount":
            suggest = "total_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupReferringSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupReferringSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupReferringSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canonical_link: Optional[builtins.str] = None,
                 total_count: Optional[builtins.str] = None):
        """
        :param builtins.str canonical_link: The canonical link.
        :param builtins.str total_count: The total count.
        """
        if canonical_link is not None:
            pulumi.set(__self__, "canonical_link", canonical_link)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="canonicalLink")
    def canonical_link(self) -> Optional[builtins.str]:
        """
        The canonical link.
        """
        return pulumi.get(self, "canonical_link")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[builtins.str]:
        """
        The total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class NamespaceLookupStatusSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunksProcessed":
            suggest = "chunks_processed"
        elif key == "failureDetails":
            suggest = "failure_details"
        elif key == "totalChunks":
            suggest = "total_chunks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceLookupStatusSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceLookupStatusSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceLookupStatusSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunks_processed: Optional[builtins.str] = None,
                 failure_details: Optional[builtins.str] = None,
                 filename: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None,
                 total_chunks: Optional[builtins.str] = None):
        """
        :param builtins.str chunks_processed: The number of chunks processed.
        :param builtins.str failure_details: The failure details, if any.
        :param builtins.str filename: The filename.
        :param builtins.str status: The status.
        :param builtins.str total_chunks: The total number of chunks.
        """
        if chunks_processed is not None:
            pulumi.set(__self__, "chunks_processed", chunks_processed)
        if failure_details is not None:
            pulumi.set(__self__, "failure_details", failure_details)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if total_chunks is not None:
            pulumi.set(__self__, "total_chunks", total_chunks)

    @property
    @pulumi.getter(name="chunksProcessed")
    def chunks_processed(self) -> Optional[builtins.str]:
        """
        The number of chunks processed.
        """
        return pulumi.get(self, "chunks_processed")

    @property
    @pulumi.getter(name="failureDetails")
    def failure_details(self) -> Optional[builtins.str]:
        """
        The failure details, if any.
        """
        return pulumi.get(self, "failure_details")

    @property
    @pulumi.getter
    def filename(self) -> Optional[builtins.str]:
        """
        The filename.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="totalChunks")
    def total_chunks(self) -> Optional[builtins.str]:
        """
        The total number of chunks.
        """
        return pulumi.get(self, "total_chunks")


@pulumi.output_type
class NamespaceScheduledTaskAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentIdInSubtree":
            suggest = "compartment_id_in_subtree"
        elif key == "dataType":
            suggest = "data_type"
        elif key == "metricExtraction":
            suggest = "metric_extraction"
        elif key == "purgeCompartmentId":
            suggest = "purge_compartment_id"
        elif key == "purgeDuration":
            suggest = "purge_duration"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "savedSearchId":
            suggest = "saved_search_id"
        elif key == "templateDetails":
            suggest = "template_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 compartment_id_in_subtree: Optional[builtins.bool] = None,
                 data_type: Optional[builtins.str] = None,
                 metric_extraction: Optional['outputs.NamespaceScheduledTaskActionMetricExtraction'] = None,
                 purge_compartment_id: Optional[builtins.str] = None,
                 purge_duration: Optional[builtins.str] = None,
                 query_string: Optional[builtins.str] = None,
                 saved_search_id: Optional[builtins.str] = None,
                 template_details: Optional['outputs.NamespaceScheduledTaskActionTemplateDetails'] = None):
        """
        :param builtins.str type: Action type discriminator.
        :param builtins.bool compartment_id_in_subtree: if true, purge child compartments data
        :param builtins.str data_type: the type of the log data to be purged
        :param 'NamespaceScheduledTaskActionMetricExtractionArgs' metric_extraction: Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        :param builtins.str purge_compartment_id: the compartment OCID under which the data will be purged
        :param builtins.str purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param builtins.str query_string: Purge query string.
        :param builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        :param 'NamespaceScheduledTaskActionTemplateDetailsArgs' template_details: details for scheduled task using template
        """
        pulumi.set(__self__, "type", type)
        if compartment_id_in_subtree is not None:
            pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if metric_extraction is not None:
            pulumi.set(__self__, "metric_extraction", metric_extraction)
        if purge_compartment_id is not None:
            pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        if purge_duration is not None:
            pulumi.set(__self__, "purge_duration", purge_duration)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if saved_search_id is not None:
            pulumi.set(__self__, "saved_search_id", saved_search_id)
        if template_details is not None:
            pulumi.set(__self__, "template_details", template_details)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Action type discriminator.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> Optional[builtins.bool]:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[builtins.str]:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="metricExtraction")
    def metric_extraction(self) -> Optional['outputs.NamespaceScheduledTaskActionMetricExtraction']:
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        return pulumi.get(self, "metric_extraction")

    @property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> Optional[builtins.str]:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> Optional[builtins.str]:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[builtins.str]:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> Optional[builtins.str]:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.  Should not be provided when a template ID is present.
        """
        return pulumi.get(self, "saved_search_id")

    @property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Optional['outputs.NamespaceScheduledTaskActionTemplateDetails']:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")


@pulumi.output_type
class NamespaceScheduledTaskActionMetricExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "resourceGroup":
            suggest = "resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskActionMetricExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskActionMetricExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskActionMetricExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[builtins.str] = None,
                 metric_name: Optional[builtins.str] = None,
                 namespace: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None):
        """
        :param builtins.str compartment_id: (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        :param builtins.str metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param builtins.str namespace: The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        :param builtins.str resource_group: The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[builtins.str]:
        """
        (Updatable) The compartment OCID (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the extracted metric.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[builtins.str]:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        The namespace of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters and underscores (_).
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class NamespaceScheduledTaskActionTemplateDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateId":
            suggest = "template_id"
        elif key == "templateParams":
            suggest = "template_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskActionTemplateDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskActionTemplateDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskActionTemplateDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_id: Optional[builtins.str] = None,
                 template_params: Optional[Sequence['outputs.NamespaceScheduledTaskActionTemplateDetailsTemplateParam']] = None):
        """
        :param builtins.str template_id: The template Id of a particular template.  Should not be provided when a saved search ID is present.
        :param Sequence['NamespaceScheduledTaskActionTemplateDetailsTemplateParamArgs'] template_params: To store macro params.
        """
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if template_params is not None:
            pulumi.set(__self__, "template_params", template_params)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[builtins.str]:
        """
        The template Id of a particular template.  Should not be provided when a saved search ID is present.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Optional[Sequence['outputs.NamespaceScheduledTaskActionTemplateDetailsTemplateParam']]:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")


@pulumi.output_type
class NamespaceScheduledTaskActionTemplateDetailsTemplateParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyField":
            suggest = "key_field"
        elif key == "valueField":
            suggest = "value_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskActionTemplateDetailsTemplateParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskActionTemplateDetailsTemplateParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskActionTemplateDetailsTemplateParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_field: Optional[builtins.str] = None,
                 value_field: Optional[builtins.str] = None):
        """
        :param builtins.str key_field: Contains a template parameter's name.
        :param builtins.str value_field: Contains the desired value for a given parameter.
        """
        if key_field is not None:
            pulumi.set(__self__, "key_field", key_field)
        if value_field is not None:
            pulumi.set(__self__, "value_field", value_field)

    @property
    @pulumi.getter(name="keyField")
    def key_field(self) -> Optional[builtins.str]:
        """
        Contains a template parameter's name.
        """
        return pulumi.get(self, "key_field")

    @property
    @pulumi.getter(name="valueField")
    def value_field(self) -> Optional[builtins.str]:
        """
        Contains the desired value for a given parameter.
        """
        return pulumi.get(self, "value_field")


@pulumi.output_type
class NamespaceScheduledTaskSchedules(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.NamespaceScheduledTaskSchedulesSchedule']):
        pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.NamespaceScheduledTaskSchedulesSchedule']:
        return pulumi.get(self, "schedules")


@pulumi.output_type
class NamespaceScheduledTaskSchedulesSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "misfirePolicy":
            suggest = "misfire_policy"
        elif key == "recurringInterval":
            suggest = "recurring_interval"
        elif key == "repeatCount":
            suggest = "repeat_count"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceScheduledTaskSchedulesSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceScheduledTaskSchedulesSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceScheduledTaskSchedulesSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 expression: Optional[builtins.str] = None,
                 misfire_policy: Optional[builtins.str] = None,
                 recurring_interval: Optional[builtins.str] = None,
                 repeat_count: Optional[builtins.int] = None,
                 time_zone: Optional[builtins.str] = None):
        """
        :param builtins.str type: Schedule type discriminator.
        :param builtins.str expression: Value in cron format.
        :param builtins.str misfire_policy: Schedule misfire retry policy.
        :param builtins.str recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param builtins.int repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param builtins.str time_zone: Time zone, by default UTC.
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if misfire_policy is not None:
            pulumi.set(__self__, "misfire_policy", misfire_policy)
        if recurring_interval is not None:
            pulumi.set(__self__, "recurring_interval", recurring_interval)
        if repeat_count is not None:
            pulumi.set(__self__, "repeat_count", repeat_count)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> Optional[builtins.str]:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> Optional[builtins.str]:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> Optional[builtins.int]:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class NamespaceStorageArchivalConfigArchivingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeStorageDuration":
            suggest = "active_storage_duration"
        elif key == "archivalStorageDuration":
            suggest = "archival_storage_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceStorageArchivalConfigArchivingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceStorageArchivalConfigArchivingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceStorageArchivalConfigArchivingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_storage_duration: Optional[builtins.str] = None,
                 archival_storage_duration: Optional[builtins.str] = None):
        """
        :param builtins.str active_storage_duration: (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        :param builtins.str archival_storage_duration: (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        if active_storage_duration is not None:
            pulumi.set(__self__, "active_storage_duration", active_storage_duration)
        if archival_storage_duration is not None:
            pulumi.set(__self__, "archival_storage_duration", archival_storage_duration)

    @property
    @pulumi.getter(name="activeStorageDuration")
    def active_storage_duration(self) -> Optional[builtins.str]:
        """
        (Updatable) This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "active_storage_duration")

    @property
    @pulumi.getter(name="archivalStorageDuration")
    def archival_storage_duration(self) -> Optional[builtins.str]:
        """
        (Updatable) This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "archival_storage_duration")


@pulumi.output_type
class GetLogAnalyticsCategoriesListItemResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 display_name: builtins.str,
                 is_system: builtins.bool,
                 name: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str description: The category description.
        :param builtins.str display_name: The category display name.
        :param builtins.bool is_system: The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param builtins.str name: A filter to return only log analytics category whose name matches the entire name given. The match is case-insensitive.
        :param builtins.str type: The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The category description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The category display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A filter to return only log analytics category whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogAnalyticsEntitiesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemResult(dict):
    def __init__(__self__, *,
                 are_logs_collected: builtins.bool,
                 associated_sources_count: builtins.int,
                 cloud_resource_id: builtins.str,
                 compartment_id: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 entity_type_internal_name: builtins.str,
                 entity_type_name: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 hostname: builtins.str,
                 id: builtins.str,
                 lifecycle_details: builtins.str,
                 management_agent_compartment_id: builtins.str,
                 management_agent_display_name: builtins.str,
                 management_agent_id: builtins.str,
                 metadatas: Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult'],
                 name: builtins.str,
                 namespace: builtins.str,
                 properties: Mapping[str, builtins.str],
                 source_id: builtins.str,
                 state: builtins.str,
                 time_created: builtins.str,
                 time_last_discovered: builtins.str,
                 time_updated: builtins.str,
                 timezone_region: builtins.str):
        """
        :param builtins.bool are_logs_collected: The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        :param builtins.int associated_sources_count: The count of associated log sources for a given log analytics entity.
        :param builtins.str cloud_resource_id: A filter to return only log analytics entities whose cloudResourceId matches the cloudResourceId given.
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str entity_type_internal_name: Internal name for the log analytics entity type.
        :param builtins.str entity_type_name: A filter to return only log analytics entities whose entityTypeName matches the entire log analytics entity type name of one of the entityTypeNames given in the list. The match is case-insensitive.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str hostname: A filter to return only log analytics entities whose hostname matches the entire hostname given.
        :param builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.str lifecycle_details: lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        :param builtins.str management_agent_compartment_id: Management agent (management-agents resource kind) compartment OCID
        :param builtins.str management_agent_display_name: Management agent (management-agents resource kind) display name
        :param builtins.str management_agent_id: The OCID of the Management Agent.
        :param Sequence['GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataArgs'] metadatas: Details of entity metadata information.
        :param builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        :param Mapping[str, builtins.str] properties: The name/value pairs for parameter values to be used in file patterns specified in log sources.
        :param builtins.str source_id: A filter to return only log analytics entities whose sourceId matches the sourceId given.
        :param builtins.str state: A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        :param builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param builtins.str time_last_discovered: The date and time the resource was last discovered, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        :param builtins.str timezone_region: The timezone region of the log analytics entity.
        """
        pulumi.set(__self__, "are_logs_collected", are_logs_collected)
        pulumi.set(__self__, "associated_sources_count", associated_sources_count)
        pulumi.set(__self__, "cloud_resource_id", cloud_resource_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "entity_type_internal_name", entity_type_internal_name)
        pulumi.set(__self__, "entity_type_name", entity_type_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "management_agent_compartment_id", management_agent_compartment_id)
        pulumi.set(__self__, "management_agent_display_name", management_agent_display_name)
        pulumi.set(__self__, "management_agent_id", management_agent_id)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_last_discovered", time_last_discovered)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone_region", timezone_region)

    @property
    @pulumi.getter(name="areLogsCollected")
    def are_logs_collected(self) -> builtins.bool:
        """
        The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        """
        return pulumi.get(self, "are_logs_collected")

    @property
    @pulumi.getter(name="associatedSourcesCount")
    def associated_sources_count(self) -> builtins.int:
        """
        The count of associated log sources for a given log analytics entity.
        """
        return pulumi.get(self, "associated_sources_count")

    @property
    @pulumi.getter(name="cloudResourceId")
    def cloud_resource_id(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose cloudResourceId matches the cloudResourceId given.
        """
        return pulumi.get(self, "cloud_resource_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="entityTypeInternalName")
    def entity_type_internal_name(self) -> builtins.str:
        """
        Internal name for the log analytics entity type.
        """
        return pulumi.get(self, "entity_type_internal_name")

    @property
    @pulumi.getter(name="entityTypeName")
    def entity_type_name(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose entityTypeName matches the entire log analytics entity type name of one of the entityTypeNames given in the list. The match is case-insensitive.
        """
        return pulumi.get(self, "entity_type_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose hostname matches the entire hostname given.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> builtins.str:
        """
        lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managementAgentCompartmentId")
    def management_agent_compartment_id(self) -> builtins.str:
        """
        Management agent (management-agents resource kind) compartment OCID
        """
        return pulumi.get(self, "management_agent_compartment_id")

    @property
    @pulumi.getter(name="managementAgentDisplayName")
    def management_agent_display_name(self) -> builtins.str:
        """
        Management agent (management-agents resource kind) display name
        """
        return pulumi.get(self, "management_agent_display_name")

    @property
    @pulumi.getter(name="managementAgentId")
    def management_agent_id(self) -> builtins.str:
        """
        The OCID of the Management Agent.
        """
        return pulumi.get(self, "management_agent_id")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult']:
        """
        Details of entity metadata information.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, builtins.str]:
        """
        The name/value pairs for parameter values to be used in file patterns specified in log sources.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose sourceId matches the sourceId given.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastDiscovered")
    def time_last_discovered(self) -> builtins.str:
        """
        The date and time the resource was last discovered, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_discovered")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="timezoneRegion")
    def timezone_region(self) -> builtins.str:
        """
        The timezone region of the log analytics entity.
        """
        return pulumi.get(self, "timezone_region")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntitiesLogAnalyticsEntityCollectionItemMetadataItemResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        :param builtins.str type: The metadata type.
        :param builtins.str value: The metadata value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The metadata type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLogAnalyticsEntityMetadataResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityMetadataItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityMetadataItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityMetadataItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityMetadataItemResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: Log analytics entity name.
        :param builtins.str type: The metadata type.
        :param builtins.str value: The metadata value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The metadata type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: Log analytics entity name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemResult(dict):
    def __init__(__self__, *,
                 links: Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkResult'],
                 nodes: Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTopologyItemLinkArgs'] links: Collection of log analytics entity relationship links.
        :param Sequence['GetLogAnalyticsEntityTopologyItemNodeArgs'] nodes: Collection of log analytics entities.
        """
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkResult']:
        """
        Collection of log analytics entity relationship links.
        """
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeResult']:
        """
        Collection of log analytics entities.
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemLinkResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTopologyItemLinkItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemLinkItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemLinkItemResult(dict):
    def __init__(__self__, *,
                 destination_entity_id: builtins.str,
                 source_entity_id: builtins.str):
        """
        :param builtins.str destination_entity_id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.str source_entity_id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        pulumi.set(__self__, "destination_entity_id", destination_entity_id)
        pulumi.set(__self__, "source_entity_id", source_entity_id)

    @property
    @pulumi.getter(name="destinationEntityId")
    def destination_entity_id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "destination_entity_id")

    @property
    @pulumi.getter(name="sourceEntityId")
    def source_entity_id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "source_entity_id")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemNodeResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeItemResult']):
        """
        :param Sequence['GetLogAnalyticsEntityTopologyItemNodeItemArgs'] items: An array of entity metadata.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsEntityTopologyItemNodeItemResult']:
        """
        An array of entity metadata.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsEntityTopologyItemNodeItemResult(dict):
    def __init__(__self__, *,
                 are_logs_collected: builtins.bool,
                 cloud_resource_id: builtins.str,
                 compartment_id: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 entity_type_internal_name: builtins.str,
                 entity_type_name: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 lifecycle_details: builtins.str,
                 management_agent_id: builtins.str,
                 name: builtins.str,
                 source_id: builtins.str,
                 state: builtins.str,
                 time_created: builtins.str,
                 time_updated: builtins.str,
                 timezone_region: builtins.str):
        """
        :param builtins.bool are_logs_collected: The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        :param builtins.str cloud_resource_id: The OCID of the Cloud resource which this entity is a representation of. This may be blank when the entity represents a non-cloud resource that the customer may have on their premises.
        :param builtins.str compartment_id: Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str entity_type_internal_name: Internal name for the log analytics entity type.
        :param builtins.str entity_type_name: Log analytics entity type name.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.str lifecycle_details: lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        :param builtins.str management_agent_id: The OCID of the Management Agent.
        :param builtins.str name: Log analytics entity name.
        :param builtins.str source_id: This indicates the type of source. It is primarily for Enterprise Manager Repository ID.
        :param builtins.str state: A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        :param builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        :param builtins.str timezone_region: The timezone region of the log analytics entity.
        """
        pulumi.set(__self__, "are_logs_collected", are_logs_collected)
        pulumi.set(__self__, "cloud_resource_id", cloud_resource_id)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "entity_type_internal_name", entity_type_internal_name)
        pulumi.set(__self__, "entity_type_name", entity_type_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "management_agent_id", management_agent_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone_region", timezone_region)

    @property
    @pulumi.getter(name="areLogsCollected")
    def are_logs_collected(self) -> builtins.bool:
        """
        The Boolean flag to indicate if logs are collected for an entity for log analytics usage.
        """
        return pulumi.get(self, "are_logs_collected")

    @property
    @pulumi.getter(name="cloudResourceId")
    def cloud_resource_id(self) -> builtins.str:
        """
        The OCID of the Cloud resource which this entity is a representation of. This may be blank when the entity represents a non-cloud resource that the customer may have on their premises.
        """
        return pulumi.get(self, "cloud_resource_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="entityTypeInternalName")
    def entity_type_internal_name(self) -> builtins.str:
        """
        Internal name for the log analytics entity type.
        """
        return pulumi.get(self, "entity_type_internal_name")

    @property
    @pulumi.getter(name="entityTypeName")
    def entity_type_name(self) -> builtins.str:
        """
        Log analytics entity type name.
        """
        return pulumi.get(self, "entity_type_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> builtins.str:
        """
        lifecycleDetails has additional information regarding substeps such as management agent plugin deployment.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managementAgentId")
    def management_agent_id(self) -> builtins.str:
        """
        The OCID of the Management Agent.
        """
        return pulumi.get(self, "management_agent_id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Log analytics entity name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> builtins.str:
        """
        This indicates the type of source. It is primarily for Enterprise Manager Repository ID.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        A filter to return only those log analytics entities with the specified lifecycle state. The state value is case-insensitive.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="timezoneRegion")
    def timezone_region(self) -> builtins.str:
        """
        The timezone region of the log analytics entity.
        """
        return pulumi.get(self, "timezone_region")


@pulumi.output_type
class GetLogAnalyticsLogGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsLogGroupsLogAnalyticsLogGroupSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 description: builtins.str,
                 display_name: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 namespace: builtins.str,
                 time_created: builtins.str,
                 time_updated: builtins.str):
        """
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str description: Description for this resource.
        :param builtins.str display_name: A filter to return only log analytics log groups whose displayName matches the entire display name given. The match is case-insensitive.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        :param builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        A filter to return only log analytics log groups whose displayName matches the entire display name given. The match is case-insensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRuleOverrideResult(dict):
    def __init__(__self__, *,
                 match_type: builtins.str,
                 match_value: builtins.str,
                 property_name: builtins.str,
                 property_value: builtins.str):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "match_value", match_value)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "property_value", property_value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> builtins.str:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> builtins.str:
        return pulumi.get(self, "match_value")

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> builtins.str:
        return pulumi.get(self, "property_name")

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> builtins.str:
        return pulumi.get(self, "property_value")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: A filter to return rules only matching with this name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemResult(dict):
    def __init__(__self__, *,
                 char_encoding: builtins.str,
                 collection_type: builtins.str,
                 compartment_id: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 description: builtins.str,
                 entity_id: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 is_enabled: builtins.bool,
                 is_force_historic_collection: builtins.bool,
                 last_collected_object: builtins.str,
                 lifecycle_details: builtins.str,
                 log_group_id: builtins.str,
                 log_set: builtins.str,
                 log_set_ext_regex: builtins.str,
                 log_set_key: builtins.str,
                 log_source_name: builtins.str,
                 log_type: builtins.str,
                 name: builtins.str,
                 namespace: builtins.str,
                 object_name_filters: Sequence[builtins.str],
                 os_bucket_name: builtins.str,
                 os_namespace: builtins.str,
                 overrides: Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult'],
                 poll_since: builtins.str,
                 poll_till: builtins.str,
                 state: builtins.str,
                 stream_cursor_time: builtins.str,
                 stream_cursor_type: builtins.str,
                 stream_id: builtins.str,
                 time_created: builtins.str,
                 time_updated: builtins.str,
                 timezone: builtins.str):
        """
        :param builtins.str char_encoding: An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
        :param builtins.str collection_type: The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str description: A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
        :param builtins.str entity_id: Logging Analytics entity OCID to associate the processed logs with.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of this rule.
        :param builtins.bool is_enabled: Whether or not this rule is currently enabled.
        :param builtins.bool is_force_historic_collection: Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
        :param builtins.str last_collected_object: Last Collected Object for the rule
        :param builtins.str lifecycle_details: A detailed status of the life cycle state.
        :param builtins.str log_group_id: Logging Analytics Log group OCID to associate the processed logs with.
        :param builtins.str log_set: The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
        :param builtins.str log_set_ext_regex: The regex to be applied against given logSetKey. Regex has to be in string escaped format.
        :param builtins.str log_set_key: An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/<namespace>/b/<bucketname>/o/<objectname>).
        :param builtins.str log_source_name: Name of the Logging Analytics Source to use for the processing.
        :param builtins.str log_type: Type of files/objects in this object collection rule.
        :param builtins.str name: A filter to return rules only matching with this name.
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        :param Sequence[builtins.str] object_name_filters: When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard "*". For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
        :param builtins.str os_bucket_name: Name of the Object Storage bucket.
        :param builtins.str os_namespace: Object Storage namespace.
        :param Sequence['GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideArgs'] overrides: Use this to override some property values which are defined at bucket level to the scope of object. Supported propeties for override are, logSourceName, charEncoding. Supported matchType for override are "contains".
        :param builtins.str poll_since: The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
        :param builtins.str poll_till: The oldest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollTill will result in error.
        :param builtins.str state: Lifecycle state filter.
        :param builtins.str stream_cursor_time: The time from which to consume the objects, if streamCursorType is AT_TIME.
        :param builtins.str stream_cursor_type: Cursor type used to fetch messages from stream. When the streamCursorType is set to DEFAULT, the existing cursor position will be used if already set by any previous objection collection rule(s) using the same stream.  Otherwise, the behaviour is to consume from the oldest available message in the stream.  When the streamCursorType is set to TRIM_HORIZON, the behaviour is to start consuming from the oldest available message in the stream.  When the streamCursorType is set to LATEST, the behavior is to start consuming messages that were published after the creation of this rule.  When the streamCursorType is set to AT_TIME, the behavior is to start consuming from a given time.  For more information on cursor types, see [Stream Consumer Groups](https://docs.oracle.com/en-us/iaas/Content/Streaming/Tasks/using_consumer_groups.htm).
        :param builtins.str stream_id: A Stream OCID is required for Object Collection rules of type LIVE or HISTORIC_LIVE, which will be used by Logging Analytics while creating Event Rule and consume the event notifications created by the Object Storage.
        :param builtins.str time_created: The time when this rule was created. An RFC3339 formatted datetime string.
        :param builtins.str time_updated: The time when this rule was last updated. An RFC3339 formatted datetime string.
        :param builtins.str timezone: Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
        """
        pulumi.set(__self__, "char_encoding", char_encoding)
        pulumi.set(__self__, "collection_type", collection_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "is_force_historic_collection", is_force_historic_collection)
        pulumi.set(__self__, "last_collected_object", last_collected_object)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_set", log_set)
        pulumi.set(__self__, "log_set_ext_regex", log_set_ext_regex)
        pulumi.set(__self__, "log_set_key", log_set_key)
        pulumi.set(__self__, "log_source_name", log_source_name)
        pulumi.set(__self__, "log_type", log_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_name_filters", object_name_filters)
        pulumi.set(__self__, "os_bucket_name", os_bucket_name)
        pulumi.set(__self__, "os_namespace", os_namespace)
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "poll_since", poll_since)
        pulumi.set(__self__, "poll_till", poll_till)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stream_cursor_time", stream_cursor_time)
        pulumi.set(__self__, "stream_cursor_type", stream_cursor_type)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="charEncoding")
    def char_encoding(self) -> builtins.str:
        """
        An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
        """
        return pulumi.get(self, "char_encoding")

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> builtins.str:
        """
        The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
        """
        return pulumi.get(self, "collection_type")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> builtins.str:
        """
        Logging Analytics entity OCID to associate the processed logs with.
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of this rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> builtins.bool:
        """
        Whether or not this rule is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isForceHistoricCollection")
    def is_force_historic_collection(self) -> builtins.bool:
        """
        Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
        """
        return pulumi.get(self, "is_force_historic_collection")

    @property
    @pulumi.getter(name="lastCollectedObject")
    def last_collected_object(self) -> builtins.str:
        """
        Last Collected Object for the rule
        """
        return pulumi.get(self, "last_collected_object")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> builtins.str:
        """
        A detailed status of the life cycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> builtins.str:
        """
        Logging Analytics Log group OCID to associate the processed logs with.
        """
        return pulumi.get(self, "log_group_id")

    @property
    @pulumi.getter(name="logSet")
    def log_set(self) -> builtins.str:
        """
        The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
        """
        return pulumi.get(self, "log_set")

    @property
    @pulumi.getter(name="logSetExtRegex")
    def log_set_ext_regex(self) -> builtins.str:
        """
        The regex to be applied against given logSetKey. Regex has to be in string escaped format.
        """
        return pulumi.get(self, "log_set_ext_regex")

    @property
    @pulumi.getter(name="logSetKey")
    def log_set_key(self) -> builtins.str:
        """
        An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/<namespace>/b/<bucketname>/o/<objectname>).
        """
        return pulumi.get(self, "log_set_key")

    @property
    @pulumi.getter(name="logSourceName")
    def log_source_name(self) -> builtins.str:
        """
        Name of the Logging Analytics Source to use for the processing.
        """
        return pulumi.get(self, "log_source_name")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> builtins.str:
        """
        Type of files/objects in this object collection rule.
        """
        return pulumi.get(self, "log_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="objectNameFilters")
    def object_name_filters(self) -> Sequence[builtins.str]:
        """
        When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard "*". For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
        """
        return pulumi.get(self, "object_name_filters")

    @property
    @pulumi.getter(name="osBucketName")
    def os_bucket_name(self) -> builtins.str:
        """
        Name of the Object Storage bucket.
        """
        return pulumi.get(self, "os_bucket_name")

    @property
    @pulumi.getter(name="osNamespace")
    def os_namespace(self) -> builtins.str:
        """
        Object Storage namespace.
        """
        return pulumi.get(self, "os_namespace")

    @property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult']:
        """
        Use this to override some property values which are defined at bucket level to the scope of object. Supported propeties for override are, logSourceName, charEncoding. Supported matchType for override are "contains".
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter(name="pollSince")
    def poll_since(self) -> builtins.str:
        """
        The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
        """
        return pulumi.get(self, "poll_since")

    @property
    @pulumi.getter(name="pollTill")
    def poll_till(self) -> builtins.str:
        """
        The oldest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. When collectionType is LIVE, specifying pollTill will result in error.
        """
        return pulumi.get(self, "poll_till")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Lifecycle state filter.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="streamCursorTime")
    def stream_cursor_time(self) -> builtins.str:
        """
        The time from which to consume the objects, if streamCursorType is AT_TIME.
        """
        return pulumi.get(self, "stream_cursor_time")

    @property
    @pulumi.getter(name="streamCursorType")
    def stream_cursor_type(self) -> builtins.str:
        """
        Cursor type used to fetch messages from stream. When the streamCursorType is set to DEFAULT, the existing cursor position will be used if already set by any previous objection collection rule(s) using the same stream.  Otherwise, the behaviour is to consume from the oldest available message in the stream.  When the streamCursorType is set to TRIM_HORIZON, the behaviour is to start consuming from the oldest available message in the stream.  When the streamCursorType is set to LATEST, the behavior is to start consuming messages that were published after the creation of this rule.  When the streamCursorType is set to AT_TIME, the behavior is to start consuming from a given time.  For more information on cursor types, see [Stream Consumer Groups](https://docs.oracle.com/en-us/iaas/Content/Streaming/Tasks/using_consumer_groups.htm).
        """
        return pulumi.get(self, "stream_cursor_type")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> builtins.str:
        """
        A Stream OCID is required for Object Collection rules of type LIVE or HISTORIC_LIVE, which will be used by Logging Analytics while creating Event Rule and consume the event notifications created by the Object Storage.
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The time when this rule was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The time when this rule was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def timezone(self) -> builtins.str:
        """
        Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetLogAnalyticsObjectCollectionRulesLogAnalyticsObjectCollectionRuleCollectionItemOverrideResult(dict):
    def __init__(__self__, *,
                 match_type: builtins.str,
                 match_value: builtins.str,
                 property_name: builtins.str,
                 property_value: builtins.str):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "match_value", match_value)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "property_value", property_value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> builtins.str:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> builtins.str:
        return pulumi.get(self, "match_value")

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> builtins.str:
        return pulumi.get(self, "property_name")

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> builtins.str:
        return pulumi.get(self, "property_value")


@pulumi.output_type
class GetLogAnalyticsPreferenceItemResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: The preference name.
        :param builtins.str value: The preference value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The preference name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The preference value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLogAnalyticsResourceCategoriesListCategoryResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 display_name: builtins.str,
                 is_system: builtins.bool,
                 name: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str description: The category description.
        :param builtins.str display_name: The category display name.
        :param builtins.bool is_system: The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        :param builtins.str name: The unique name that identifies the category.
        :param builtins.str type: The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The category description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The category display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The unique name that identifies the category.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The category type. Values include "PRODUCT", "TIER", "VENDOR" and "GENERIC".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogAnalyticsResourceCategoriesListItemResult(dict):
    def __init__(__self__, *,
                 category_name: builtins.str,
                 compartment_id: builtins.str,
                 is_system: builtins.bool,
                 resource_display_name: builtins.str,
                 resource_id: builtins.str,
                 resource_type: builtins.str):
        """
        :param builtins.str category_name: The category name to which this resource belongs.
        :param builtins.str compartment_id: The compartment id in which to list resources.
        :param builtins.bool is_system: The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        :param builtins.str resource_display_name: The resource display name.
        :param builtins.str resource_id: The unique identifier of the resource, usually a name or ocid.
        :param builtins.str resource_type: The resource type.
        """
        pulumi.set(__self__, "category_name", category_name)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "resource_display_name", resource_display_name)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="categoryName")
    def category_name(self) -> builtins.str:
        """
        The category name to which this resource belongs.
        """
        return pulumi.get(self, "category_name")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The compartment id in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag. A value of false denotes a user-created category assignment. A value of true denotes an Oracle-defined category assignment.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter(name="resourceDisplayName")
    def resource_display_name(self) -> builtins.str:
        """
        The resource display name.
        """
        return pulumi.get(self, "resource_display_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        The unique identifier of the resource, usually a name or ocid.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> builtins.str:
        """
        The resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetNamespaceEffectivePropertiesEffectivePropertyCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult']):
        """
        :param Sequence['GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemArgs'] items: A list of properties and their effective values.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult']:
        """
        A list of properties and their effective values.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemResult(dict):
    def __init__(__self__, *,
                 effective_level: builtins.str,
                 name: builtins.str,
                 patterns: Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult'],
                 value: builtins.str):
        """
        :param builtins.str effective_level: The effective level of the property value.
        :param builtins.str name: The property name used for filtering.
        :param Sequence['GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternArgs'] patterns: A list of pattern level override values for the property.
        :param builtins.str value: The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        pulumi.set(__self__, "effective_level", effective_level)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "patterns", patterns)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="effectiveLevel")
    def effective_level(self) -> builtins.str:
        """
        The effective level of the property value.
        """
        return pulumi.get(self, "effective_level")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def patterns(self) -> Sequence['outputs.GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult']:
        """
        A list of pattern level override values for the property.
        """
        return pulumi.get(self, "patterns")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespaceEffectivePropertiesEffectivePropertyCollectionItemPatternResult(dict):
    def __init__(__self__, *,
                 effective_level: builtins.str,
                 id: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str effective_level: The effective level of the property value.
        :param builtins.str id: The pattern id.
        :param builtins.str value: The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        pulumi.set(__self__, "effective_level", effective_level)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="effectiveLevel")
    def effective_level(self) -> builtins.str:
        """
        The effective level of the property value.
        """
        return pulumi.get(self, "effective_level")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The pattern id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The effective value of the property. This is determined by considering the value set at the most effective level.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespaceEffectivePropertiesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceFieldUsageDependentParserResult(dict):
    def __init__(__self__, *,
                 dependencies: Sequence['outputs.GetNamespaceFieldUsageDependentParserDependencyResult'],
                 is_system: builtins.bool,
                 parser_display_name: builtins.str,
                 parser_id: builtins.str,
                 parser_name: builtins.str,
                 parser_type: builtins.str):
        """
        :param Sequence['GetNamespaceFieldUsageDependentParserDependencyArgs'] dependencies: The list of dependencies defined by the source.
        :param builtins.bool is_system: The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        :param builtins.str parser_display_name: The parser display name.
        :param builtins.str parser_id: The parser unique identifier.
        :param builtins.str parser_name: The parser name.
        :param builtins.str parser_type: The parser type
        """
        pulumi.set(__self__, "dependencies", dependencies)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "parser_display_name", parser_display_name)
        pulumi.set(__self__, "parser_id", parser_id)
        pulumi.set(__self__, "parser_name", parser_name)
        pulumi.set(__self__, "parser_type", parser_type)

    @property
    @pulumi.getter
    def dependencies(self) -> Sequence['outputs.GetNamespaceFieldUsageDependentParserDependencyResult']:
        """
        The list of dependencies defined by the source.
        """
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter(name="parserDisplayName")
    def parser_display_name(self) -> builtins.str:
        """
        The parser display name.
        """
        return pulumi.get(self, "parser_display_name")

    @property
    @pulumi.getter(name="parserId")
    def parser_id(self) -> builtins.str:
        """
        The parser unique identifier.
        """
        return pulumi.get(self, "parser_id")

    @property
    @pulumi.getter(name="parserName")
    def parser_name(self) -> builtins.str:
        """
        The parser name.
        """
        return pulumi.get(self, "parser_name")

    @property
    @pulumi.getter(name="parserType")
    def parser_type(self) -> builtins.str:
        """
        The parser type
        """
        return pulumi.get(self, "parser_type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentParserDependencyResult(dict):
    def __init__(__self__, *,
                 reference_display_name: builtins.str,
                 reference_id: builtins.str,
                 reference_name: builtins.str,
                 reference_type: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str reference_display_name: The display name of the dependency object
        :param builtins.str reference_id: The unique identifier of the reference, if available.
        :param builtins.str reference_name: The name of the dependency object
        :param builtins.str reference_type: The type of reference that defines the dependency.
        :param builtins.str type: The dependency type.
        """
        pulumi.set(__self__, "reference_display_name", reference_display_name)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "reference_type", reference_type)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceDisplayName")
    def reference_display_name(self) -> builtins.str:
        """
        The display name of the dependency object
        """
        return pulumi.get(self, "reference_display_name")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> builtins.str:
        """
        The unique identifier of the reference, if available.
        """
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> builtins.str:
        """
        The name of the dependency object
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> builtins.str:
        """
        The type of reference that defines the dependency.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The dependency type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentSourceResult(dict):
    def __init__(__self__, *,
                 dependencies: Sequence['outputs.GetNamespaceFieldUsageDependentSourceDependencyResult'],
                 entity_types: Sequence['outputs.GetNamespaceFieldUsageDependentSourceEntityTypeResult'],
                 is_auto_association_enabled: builtins.bool,
                 is_system: builtins.bool,
                 source_display_name: builtins.str,
                 source_id: builtins.str,
                 source_name: builtins.str,
                 source_type: builtins.str):
        """
        :param Sequence['GetNamespaceFieldUsageDependentSourceDependencyArgs'] dependencies: The list of dependencies defined by the source.
        :param Sequence['GetNamespaceFieldUsageDependentSourceEntityTypeArgs'] entity_types: The entity types.
        :param builtins.bool is_auto_association_enabled: A flag indicating whether or not the source is marked for auto association.
        :param builtins.bool is_system: The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        :param builtins.str source_display_name: The source display name.
        :param builtins.str source_id: The source unique identifier.
        :param builtins.str source_name: The source name.
        :param builtins.str source_type: The source type.
        """
        pulumi.set(__self__, "dependencies", dependencies)
        pulumi.set(__self__, "entity_types", entity_types)
        pulumi.set(__self__, "is_auto_association_enabled", is_auto_association_enabled)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "source_display_name", source_display_name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def dependencies(self) -> Sequence['outputs.GetNamespaceFieldUsageDependentSourceDependencyResult']:
        """
        The list of dependencies defined by the source.
        """
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter(name="entityTypes")
    def entity_types(self) -> Sequence['outputs.GetNamespaceFieldUsageDependentSourceEntityTypeResult']:
        """
        The entity types.
        """
        return pulumi.get(self, "entity_types")

    @property
    @pulumi.getter(name="isAutoAssociationEnabled")
    def is_auto_association_enabled(self) -> builtins.bool:
        """
        A flag indicating whether or not the source is marked for auto association.
        """
        return pulumi.get(self, "is_auto_association_enabled")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter(name="sourceDisplayName")
    def source_display_name(self) -> builtins.str:
        """
        The source display name.
        """
        return pulumi.get(self, "source_display_name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> builtins.str:
        """
        The source unique identifier.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> builtins.str:
        """
        The source name.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> builtins.str:
        """
        The source type.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentSourceDependencyResult(dict):
    def __init__(__self__, *,
                 reference_display_name: builtins.str,
                 reference_id: builtins.str,
                 reference_name: builtins.str,
                 reference_type: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str reference_display_name: The display name of the dependency object
        :param builtins.str reference_id: The unique identifier of the reference, if available.
        :param builtins.str reference_name: The name of the dependency object
        :param builtins.str reference_type: The type of reference that defines the dependency.
        :param builtins.str type: The dependency type.
        """
        pulumi.set(__self__, "reference_display_name", reference_display_name)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "reference_type", reference_type)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceDisplayName")
    def reference_display_name(self) -> builtins.str:
        """
        The display name of the dependency object
        """
        return pulumi.get(self, "reference_display_name")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> builtins.str:
        """
        The unique identifier of the reference, if available.
        """
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> builtins.str:
        """
        The name of the dependency object
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> builtins.str:
        """
        The type of reference that defines the dependency.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The dependency type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceFieldUsageDependentSourceEntityTypeResult(dict):
    def __init__(__self__, *,
                 entity_type: builtins.str,
                 entity_type_category: builtins.str,
                 entity_type_display_name: builtins.str,
                 source_id: builtins.str):
        """
        :param builtins.str entity_type: The entity type.
        :param builtins.str entity_type_category: The type category.
        :param builtins.str entity_type_display_name: The entity type display name.
        :param builtins.str source_id: The source unique identifier.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "entity_type_category", entity_type_category)
        pulumi.set(__self__, "entity_type_display_name", entity_type_display_name)
        pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        The entity type.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="entityTypeCategory")
    def entity_type_category(self) -> builtins.str:
        """
        The type category.
        """
        return pulumi.get(self, "entity_type_category")

    @property
    @pulumi.getter(name="entityTypeDisplayName")
    def entity_type_display_name(self) -> builtins.str:
        """
        The entity type display name.
        """
        return pulumi.get(self, "entity_type_display_name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> builtins.str:
        """
        The source unique identifier.
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class GetNamespaceIngestTimeRuleActionResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 dimensions: Sequence[builtins.str],
                 metric_name: builtins.str,
                 namespace: builtins.str,
                 resource_group: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str compartment_id: Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence[builtins.str] dimensions: Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        :param builtins.str metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        :param builtins.str resource_group: The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param builtins.str type: Discriminator.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence[builtins.str]:
        """
        Additional dimensions to publish for the extracted metric. A valid list contains the source field names whose values are to be published as dimensions. The source name itself is specified using a special macro SOURCE_NAME
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> builtins.str:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> builtins.str:
        """
        The resourceGroup of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceIngestTimeRuleConditionResult(dict):
    def __init__(__self__, *,
                 additional_conditions: Sequence['outputs.GetNamespaceIngestTimeRuleConditionAdditionalConditionResult'],
                 field_name: builtins.str,
                 field_operator: builtins.str,
                 field_value: builtins.str,
                 kind: builtins.str):
        """
        :param Sequence['GetNamespaceIngestTimeRuleConditionAdditionalConditionArgs'] additional_conditions: Optional additional condition(s) to be evaluated.
        :param builtins.str field_name: The field name to be evaluated.
        :param builtins.str field_operator: The operator to be used for evaluating the field.
        :param builtins.str field_value: The field value to be evaluated.
        :param builtins.str kind: Discriminator.
        """
        pulumi.set(__self__, "additional_conditions", additional_conditions)
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_operator", field_operator)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="additionalConditions")
    def additional_conditions(self) -> Sequence['outputs.GetNamespaceIngestTimeRuleConditionAdditionalConditionResult']:
        """
        Optional additional condition(s) to be evaluated.
        """
        return pulumi.get(self, "additional_conditions")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> builtins.str:
        """
        The field name to be evaluated.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldOperator")
    def field_operator(self) -> builtins.str:
        """
        The operator to be used for evaluating the field.
        """
        return pulumi.get(self, "field_operator")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> builtins.str:
        """
        The field value to be evaluated.
        """
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        Discriminator.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GetNamespaceIngestTimeRuleConditionAdditionalConditionResult(dict):
    def __init__(__self__, *,
                 condition_field: builtins.str,
                 condition_operator: builtins.str,
                 condition_value: builtins.str):
        """
        :param builtins.str condition_field: The additional field name to be evaluated.
        :param builtins.str condition_operator: The operator to be used for evaluating the additional field.
        :param builtins.str condition_value: The additional field value to be evaluated.
        """
        pulumi.set(__self__, "condition_field", condition_field)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_value", condition_value)

    @property
    @pulumi.getter(name="conditionField")
    def condition_field(self) -> builtins.str:
        """
        The additional field name to be evaluated.
        """
        return pulumi.get(self, "condition_field")

    @property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> builtins.str:
        """
        The operator to be used for evaluating the additional field.
        """
        return pulumi.get(self, "condition_operator")

    @property
    @pulumi.getter(name="conditionValue")
    def condition_value(self) -> builtins.str:
        """
        The additional field value to be evaluated.
        """
        return pulumi.get(self, "condition_value")


@pulumi.output_type
class GetNamespaceIngestTimeRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceIngestTimeRulesIngestTimeRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 condition_kind: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 description: builtins.str,
                 display_name: builtins.str,
                 field_name: builtins.str,
                 field_value: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 is_enabled: builtins.bool,
                 state: builtins.str,
                 time_created: builtins.str,
                 time_updated: builtins.str):
        """
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param builtins.str condition_kind: The ingest time rule condition kind used for filtering. Only rules with conditions of the specified kind will be returned.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str description: Description for this resource.
        :param builtins.str display_name: A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        :param builtins.str field_name: The field name used for filtering. Only rules using the specified field name will be returned.
        :param builtins.str field_value: The field value used for filtering. Only rules using the specified field value will be returned.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.bool is_enabled: A flag indicating whether or not the ingest time rule is enabled.
        :param builtins.str state: The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        :param builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "condition_kind", condition_kind)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_value", field_value)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="conditionKind")
    def condition_kind(self) -> builtins.str:
        """
        The ingest time rule condition kind used for filtering. Only rules with conditions of the specified kind will be returned.
        """
        return pulumi.get(self, "condition_kind")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> builtins.str:
        """
        The field name used for filtering. Only rules using the specified field name will be returned.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> builtins.str:
        """
        The field value used for filtering. Only rules using the specified field value will be returned.
        """
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> builtins.bool:
        """
        A flag indicating whether or not the ingest time rule is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetNamespaceLookupCategoryResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 display_name: builtins.str,
                 is_system: builtins.bool,
                 name: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str description: The lookup description.
        :param builtins.str display_name: The field display name.
        :param builtins.bool is_system: The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        :param builtins.str name: The field name.
        :param builtins.str type: The lookup type. Valid values are Lookup, Dictionary or Module.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The lookup description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The field display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag. A value of false denotes a user-created category. A value of true denotes an Oracle-defined category.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The field name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The lookup type. Valid values are Lookup, Dictionary or Module.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceLookupFieldResult(dict):
    def __init__(__self__, *,
                 common_field_name: builtins.str,
                 default_match_value: builtins.str,
                 display_name: builtins.str,
                 is_common_field: builtins.bool,
                 match_operator: builtins.str,
                 name: builtins.str,
                 position: builtins.str):
        """
        :param builtins.str common_field_name: The common field name.
        :param builtins.str default_match_value: The default match value.
        :param builtins.str display_name: The field display name.
        :param builtins.bool is_common_field: A flag indicating whether or not the lookup field is a common field.
        :param builtins.str match_operator: The match operator.
        :param builtins.str name: The field name.
        :param builtins.str position: THe field position.
        """
        pulumi.set(__self__, "common_field_name", common_field_name)
        pulumi.set(__self__, "default_match_value", default_match_value)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_common_field", is_common_field)
        pulumi.set(__self__, "match_operator", match_operator)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="commonFieldName")
    def common_field_name(self) -> builtins.str:
        """
        The common field name.
        """
        return pulumi.get(self, "common_field_name")

    @property
    @pulumi.getter(name="defaultMatchValue")
    def default_match_value(self) -> builtins.str:
        """
        The default match value.
        """
        return pulumi.get(self, "default_match_value")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The field display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isCommonField")
    def is_common_field(self) -> builtins.bool:
        """
        A flag indicating whether or not the lookup field is a common field.
        """
        return pulumi.get(self, "is_common_field")

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> builtins.str:
        """
        The match operator.
        """
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The field name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def position(self) -> builtins.str:
        """
        THe field position.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class GetNamespaceLookupReferringSourceResult(dict):
    def __init__(__self__, *,
                 canonical_link: builtins.str,
                 total_count: builtins.str):
        """
        :param builtins.str canonical_link: The canonical link.
        :param builtins.str total_count: The total count.
        """
        pulumi.set(__self__, "canonical_link", canonical_link)
        pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter(name="canonicalLink")
    def canonical_link(self) -> builtins.str:
        """
        The canonical link.
        """
        return pulumi.get(self, "canonical_link")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> builtins.str:
        """
        The total count.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class GetNamespaceLookupStatusSummaryResult(dict):
    def __init__(__self__, *,
                 chunks_processed: builtins.str,
                 failure_details: builtins.str,
                 filename: builtins.str,
                 status: builtins.str,
                 total_chunks: builtins.str):
        """
        :param builtins.str chunks_processed: The number of chunks processed.
        :param builtins.str failure_details: The failure details, if any.
        :param builtins.str filename: The filename.
        :param builtins.str status: The status.
        :param builtins.str total_chunks: The total number of chunks.
        """
        pulumi.set(__self__, "chunks_processed", chunks_processed)
        pulumi.set(__self__, "failure_details", failure_details)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_chunks", total_chunks)

    @property
    @pulumi.getter(name="chunksProcessed")
    def chunks_processed(self) -> builtins.str:
        """
        The number of chunks processed.
        """
        return pulumi.get(self, "chunks_processed")

    @property
    @pulumi.getter(name="failureDetails")
    def failure_details(self) -> builtins.str:
        """
        The failure details, if any.
        """
        return pulumi.get(self, "failure_details")

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="totalChunks")
    def total_chunks(self) -> builtins.str:
        """
        The total number of chunks.
        """
        return pulumi.get(self, "total_chunks")


@pulumi.output_type
class GetNamespaceParserActionsFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The parser action name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The parser action name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceParserActionsParserActionSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceParserActionsParserActionSummaryCollectionItemResult']):
        """
        :param Sequence['GetNamespaceParserActionsParserActionSummaryCollectionItemArgs'] items: An array of parser action summary objects.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceParserActionsParserActionSummaryCollectionItemResult']:
        """
        An array of parser action summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceParserActionsParserActionSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 display_name: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str description: The parser action description.
        :param builtins.str display_name: The parser action display name.
        :param builtins.str name: The parser action name used for filtering.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The parser action description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The parser action display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The parser action name used for filtering.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNamespacePropertiesMetadataFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult']):
        """
        :param Sequence['GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemArgs'] items: An array of properties along with their metadata summary.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult']:
        """
        An array of properties along with their metadata summary.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 default_value: builtins.str,
                 description: builtins.str,
                 display_name: builtins.str,
                 levels: Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult'],
                 name: builtins.str):
        """
        :param builtins.str default_value: The default property value.
        :param builtins.str description: The property description.
        :param builtins.str display_name: The property display name.
        :param Sequence['GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelArgs'] levels: A list of levels at which the property could be defined.
        :param builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> builtins.str:
        """
        The default property value.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The property description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The property display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def levels(self) -> Sequence['outputs.GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult']:
        """
        A list of levels at which the property could be defined.
        """
        return pulumi.get(self, "levels")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNamespacePropertiesMetadataPropertyMetadataSummaryCollectionItemLevelResult(dict):
    def __init__(__self__, *,
                 constraints: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str constraints: The constraints that apply to the properties at a certain level.
        :param builtins.str name: The property name used for filtering.
        """
        pulumi.set(__self__, "constraints", constraints)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def constraints(self) -> builtins.str:
        """
        The constraints that apply to the properties at a certain level.
        """
        return pulumi.get(self, "constraints")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The property name used for filtering.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNamespaceRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceRulesRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceRulesRuleSummaryCollectionItemResult']):
        """
        :param Sequence['GetNamespaceRulesRuleSummaryCollectionItemArgs'] items: An array of rule summary objects.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceRulesRuleSummaryCollectionItemResult']:
        """
        An array of rule summary objects.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceRulesRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 description: builtins.str,
                 display_name: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 is_enabled: builtins.bool,
                 kind: builtins.str,
                 last_execution_status: builtins.str,
                 state: builtins.str,
                 target_service: builtins.str,
                 time_created: builtins.str,
                 time_last_executed: builtins.str,
                 time_updated: builtins.str):
        """
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str description: Description for this resource.
        :param builtins.str display_name: A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.bool is_enabled: A flag indicating whether or not the ingest time rule or scheduled task is enabled.
        :param builtins.str kind: The rule kind used for filtering. Only rules of the specified kind will be returned.
        :param builtins.str last_execution_status: The most recent task execution status.
        :param builtins.str state: The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        :param builtins.str target_service: The target service to use for filtering.
        :param builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param builtins.str time_last_executed: The date and time the scheduled task last executed, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "last_execution_status", last_execution_status)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target_service", target_service)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_last_executed", time_last_executed)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        A filter to return rules whose displayName matches in whole or in part the specified value. The match is case-insensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> builtins.bool:
        """
        A flag indicating whether or not the ingest time rule or scheduled task is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        The rule kind used for filtering. Only rules of the specified kind will be returned.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="lastExecutionStatus")
    def last_execution_status(self) -> builtins.str:
        """
        The most recent task execution status.
        """
        return pulumi.get(self, "last_execution_status")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The rule lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetService")
    def target_service(self) -> builtins.str:
        """
        The target service to use for filtering.
        """
        return pulumi.get(self, "target_service")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastExecuted")
    def time_last_executed(self) -> builtins.str:
        """
        The date and time the scheduled task last executed, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_last_executed")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetNamespaceScheduledTaskActionResult(dict):
    def __init__(__self__, *,
                 compartment_id_in_subtree: builtins.bool,
                 data_type: builtins.str,
                 metric_extractions: Sequence['outputs.GetNamespaceScheduledTaskActionMetricExtractionResult'],
                 purge_compartment_id: builtins.str,
                 purge_duration: builtins.str,
                 query_string: builtins.str,
                 saved_search_id: builtins.str,
                 template_details: Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailResult'],
                 type: builtins.str):
        """
        :param builtins.bool compartment_id_in_subtree: if true, purge child compartments data
        :param builtins.str data_type: the type of the log data to be purged
        :param Sequence['GetNamespaceScheduledTaskActionMetricExtractionArgs'] metric_extractions: Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        :param builtins.str purge_compartment_id: the compartment OCID under which the data will be purged
        :param builtins.str purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param builtins.str query_string: Purge query string.
        :param builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        :param Sequence['GetNamespaceScheduledTaskActionTemplateDetailArgs'] template_details: details for scheduled task using template
        :param builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "metric_extractions", metric_extractions)
        pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        pulumi.set(__self__, "purge_duration", purge_duration)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "saved_search_id", saved_search_id)
        pulumi.set(__self__, "template_details", template_details)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> builtins.bool:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="metricExtractions")
    def metric_extractions(self) -> Sequence['outputs.GetNamespaceScheduledTaskActionMetricExtractionResult']:
        """
        Specify metric extraction for SAVED_SEARCH scheduled task execution to post to Oracle Cloud Infrastructure Monitoring.
        """
        return pulumi.get(self, "metric_extractions")

    @property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> builtins.str:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> builtins.str:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> builtins.str:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> builtins.str:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailResult']:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceScheduledTaskActionMetricExtractionResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 metric_name: builtins.str,
                 namespace: builtins.str,
                 resource_group: builtins.str):
        """
        :param builtins.str compartment_id: Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param builtins.str metric_name: The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        :param builtins.str resource_group: The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_group", resource_group)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        Compartment Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> builtins.str:
        """
        The metric name of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> builtins.str:
        """
        The resource group of the extracted metric. A valid value starts with an alphabetical character and includes only alphanumeric characters, periods (.), underscores (_), hyphens (-), and dollar signs ($).
        """
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class GetNamespaceScheduledTaskActionTemplateDetailResult(dict):
    def __init__(__self__, *,
                 template_id: builtins.str,
                 template_params: Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult']):
        """
        :param builtins.str template_id: The Config template Id of a particular template.
        :param Sequence['GetNamespaceScheduledTaskActionTemplateDetailTemplateParamArgs'] template_params: To store macro params.
        """
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "template_params", template_params)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> builtins.str:
        """
        The Config template Id of a particular template.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Sequence['outputs.GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult']:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")


@pulumi.output_type
class GetNamespaceScheduledTaskActionTemplateDetailTemplateParamResult(dict):
    def __init__(__self__, *,
                 key_field: builtins.str,
                 value_field: builtins.str):
        """
        :param builtins.str key_field: Contains macro parameter's names.
        :param builtins.str value_field: Contains macro parameter's value.
        """
        pulumi.set(__self__, "key_field", key_field)
        pulumi.set(__self__, "value_field", value_field)

    @property
    @pulumi.getter(name="keyField")
    def key_field(self) -> builtins.str:
        """
        Contains macro parameter's names.
        """
        return pulumi.get(self, "key_field")

    @property
    @pulumi.getter(name="valueField")
    def value_field(self) -> builtins.str:
        """
        Contains macro parameter's value.
        """
        return pulumi.get(self, "value_field")


@pulumi.output_type
class GetNamespaceScheduledTaskScheduleResult(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.GetNamespaceScheduledTaskScheduleScheduleResult']):
        pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetNamespaceScheduledTaskScheduleScheduleResult']:
        return pulumi.get(self, "schedules")


@pulumi.output_type
class GetNamespaceScheduledTaskScheduleScheduleResult(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 misfire_policy: builtins.str,
                 recurring_interval: builtins.str,
                 repeat_count: builtins.int,
                 time_zone: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str expression: Value in cron format.
        :param builtins.str misfire_policy: Schedule misfire retry policy.
        :param builtins.str recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param builtins.int repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param builtins.str time_zone: Time zone, by default UTC.
        :param builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "misfire_policy", misfire_policy)
        pulumi.set(__self__, "recurring_interval", recurring_interval)
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> builtins.str:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> builtins.str:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> builtins.int:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> builtins.str:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceScheduledTasksFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult'],
                 compartment_id: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 display_name: builtins.str,
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 kind: builtins.str,
                 namespace: builtins.str,
                 num_occurrences: builtins.str,
                 saved_search_id: builtins.str,
                 scheduled_task_id: builtins.str,
                 schedules: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult'],
                 state: builtins.str,
                 task_status: builtins.str,
                 task_type: builtins.str,
                 time_created: builtins.str,
                 time_updated: builtins.str,
                 work_request_id: builtins.str):
        """
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemActionArgs'] actions: Action for scheduled task.
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str display_name: A filter to return only resources that match the given display name exactly.
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the data plane resource.
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        :param builtins.str num_occurrences: Number of execution occurrences.
        :param builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleArgs'] schedules: Schedules.
        :param builtins.str state: The current state of the scheduled task.
        :param builtins.str task_status: Status of the scheduled task. - PURGE_RESOURCE_NOT_FOUND
        :param builtins.str task_type: Required parameter to specify schedule task type.
        :param builtins.str time_created: The date and time the scheduled task was created, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the scheduled task was last updated, in the format defined by RFC3339.
        :param builtins.str work_request_id: most recent Work Request Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the asynchronous request.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "num_occurrences", num_occurrences)
        pulumi.set(__self__, "saved_search_id", saved_search_id)
        pulumi.set(__self__, "scheduled_task_id", scheduled_task_id)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "task_status", task_status)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "work_request_id", work_request_id)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult']:
        """
        Action for scheduled task.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        A filter to return only resources that match the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the data plane resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="numOccurrences")
    def num_occurrences(self) -> builtins.str:
        """
        Number of execution occurrences.
        """
        return pulumi.get(self, "num_occurrences")

    @property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> builtins.str:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @property
    @pulumi.getter(name="scheduledTaskId")
    def scheduled_task_id(self) -> builtins.str:
        return pulumi.get(self, "scheduled_task_id")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult']:
        """
        Schedules.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The current state of the scheduled task.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskStatus")
    def task_status(self) -> builtins.str:
        """
        Status of the scheduled task. - PURGE_RESOURCE_NOT_FOUND
        """
        return pulumi.get(self, "task_status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        Required parameter to specify schedule task type.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the scheduled task was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the scheduled task was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="workRequestId")
    def work_request_id(self) -> builtins.str:
        """
        most recent Work Request Identifier [OCID] (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the asynchronous request.
        """
        return pulumi.get(self, "work_request_id")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionResult(dict):
    def __init__(__self__, *,
                 compartment_id_in_subtree: builtins.bool,
                 data_type: builtins.str,
                 metric_extractions: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult'],
                 purge_compartment_id: builtins.str,
                 purge_duration: builtins.str,
                 query_string: builtins.str,
                 saved_search_id: builtins.str,
                 template_details: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult'],
                 type: builtins.str):
        """
        :param builtins.bool compartment_id_in_subtree: if true, purge child compartments data
        :param builtins.str data_type: the type of the log data to be purged
        :param builtins.str purge_compartment_id: the compartment OCID under which the data will be purged
        :param builtins.str purge_duration: The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        :param builtins.str query_string: Purge query string.
        :param builtins.str saved_search_id: The ManagementSavedSearch id [OCID] utilized in the action.
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailArgs'] template_details: details for scheduled task using template
        :param builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "compartment_id_in_subtree", compartment_id_in_subtree)
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "metric_extractions", metric_extractions)
        pulumi.set(__self__, "purge_compartment_id", purge_compartment_id)
        pulumi.set(__self__, "purge_duration", purge_duration)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "saved_search_id", saved_search_id)
        pulumi.set(__self__, "template_details", template_details)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentIdInSubtree")
    def compartment_id_in_subtree(self) -> builtins.bool:
        """
        if true, purge child compartments data
        """
        return pulumi.get(self, "compartment_id_in_subtree")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        the type of the log data to be purged
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="metricExtractions")
    def metric_extractions(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult']:
        return pulumi.get(self, "metric_extractions")

    @property
    @pulumi.getter(name="purgeCompartmentId")
    def purge_compartment_id(self) -> builtins.str:
        """
        the compartment OCID under which the data will be purged
        """
        return pulumi.get(self, "purge_compartment_id")

    @property
    @pulumi.getter(name="purgeDuration")
    def purge_duration(self) -> builtins.str:
        """
        The duration of data to be retained, which is used to calculate the timeDataEnded when the task fires. The value should be negative. Purge duration in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. -P365D (not -P1Y) or -P14D (not -P2W).
        """
        return pulumi.get(self, "purge_duration")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> builtins.str:
        """
        Purge query string.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="savedSearchId")
    def saved_search_id(self) -> builtins.str:
        """
        The ManagementSavedSearch id [OCID] utilized in the action.
        """
        return pulumi.get(self, "saved_search_id")

    @property
    @pulumi.getter(name="templateDetails")
    def template_details(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult']:
        """
        details for scheduled task using template
        """
        return pulumi.get(self, "template_details")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionMetricExtractionResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 metric_name: builtins.str,
                 namespace: builtins.str,
                 resource_group: builtins.str):
        """
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param builtins.str namespace: The Logging Analytics namespace used for the request.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_group", resource_group)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> builtins.str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        The Logging Analytics namespace used for the request.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> builtins.str:
        return pulumi.get(self, "resource_group")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailResult(dict):
    def __init__(__self__, *,
                 template_id: builtins.str,
                 template_params: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult']):
        """
        :param builtins.str template_id: A filter to return only scheduled tasks whose stream action templateId matches the given id  exactly.
        :param Sequence['GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamArgs'] template_params: To store macro params.
        """
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "template_params", template_params)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> builtins.str:
        """
        A filter to return only scheduled tasks whose stream action templateId matches the given id  exactly.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="templateParams")
    def template_params(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult']:
        """
        To store macro params.
        """
        return pulumi.get(self, "template_params")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemActionTemplateDetailTemplateParamResult(dict):
    def __init__(__self__, *,
                 key_field: builtins.str,
                 value_field: builtins.str):
        """
        :param builtins.str key_field: Contains macro parameter's names.
        :param builtins.str value_field: Contains macro parameter's value.
        """
        pulumi.set(__self__, "key_field", key_field)
        pulumi.set(__self__, "value_field", value_field)

    @property
    @pulumi.getter(name="keyField")
    def key_field(self) -> builtins.str:
        """
        Contains macro parameter's names.
        """
        return pulumi.get(self, "key_field")

    @property
    @pulumi.getter(name="valueField")
    def value_field(self) -> builtins.str:
        """
        Contains macro parameter's value.
        """
        return pulumi.get(self, "value_field")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleResult(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult']):
        pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult']:
        return pulumi.get(self, "schedules")


@pulumi.output_type
class GetNamespaceScheduledTasksScheduledTaskCollectionItemScheduleScheduleResult(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 misfire_policy: builtins.str,
                 recurring_interval: builtins.str,
                 repeat_count: builtins.int,
                 time_zone: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str expression: Value in cron format.
        :param builtins.str misfire_policy: Schedule misfire retry policy.
        :param builtins.str recurring_interval: Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        :param builtins.int repeat_count: Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        :param builtins.str time_zone: Time zone, by default UTC.
        :param builtins.str type: Schedule type discriminator.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "misfire_policy", misfire_policy)
        pulumi.set(__self__, "recurring_interval", recurring_interval)
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Value in cron format.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="misfirePolicy")
    def misfire_policy(self) -> builtins.str:
        """
        Schedule misfire retry policy.
        """
        return pulumi.get(self, "misfire_policy")

    @property
    @pulumi.getter(name="recurringInterval")
    def recurring_interval(self) -> builtins.str:
        """
        Recurring interval in ISO 8601 extended format as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P14D (not P2W). The value must be at least 5 minutes (PT5M) and at most 3 weeks (P21D or PT30240M).
        """
        return pulumi.get(self, "recurring_interval")

    @property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> builtins.int:
        """
        Number of times (0-based) to execute until auto-stop. Default value -1 will execute indefinitely. Value 0 will execute once.
        """
        return pulumi.get(self, "repeat_count")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> builtins.str:
        """
        Time zone, by default UTC.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Schedule type discriminator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceStorageArchivalConfigArchivingConfigurationResult(dict):
    def __init__(__self__, *,
                 active_storage_duration: builtins.str,
                 archival_storage_duration: builtins.str):
        """
        :param builtins.str active_storage_duration: This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        :param builtins.str archival_storage_duration: This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        pulumi.set(__self__, "active_storage_duration", active_storage_duration)
        pulumi.set(__self__, "archival_storage_duration", archival_storage_duration)

    @property
    @pulumi.getter(name="activeStorageDuration")
    def active_storage_duration(self) -> builtins.str:
        """
        This is the duration data in active storage before data is archived, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations. The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "active_storage_duration")

    @property
    @pulumi.getter(name="archivalStorageDuration")
    def archival_storage_duration(self) -> builtins.str:
        """
        This is the duration before archived data is deleted from object storage, as described in https://en.wikipedia.org/wiki/ISO_8601#Durations The largest supported unit is D, e.g. P365D (not P1Y) or P14D (not P2W).
        """
        return pulumi.get(self, "archival_storage_duration")


@pulumi.output_type
class GetNamespaceStorageEncryptionKeyInfoItemResult(dict):
    def __init__(__self__, *,
                 key_id: builtins.str,
                 key_source: builtins.str,
                 key_type: builtins.str):
        """
        :param builtins.str key_id: This is the key OCID of the encryption key (null if Oracle-managed).
        :param builtins.str key_source: This is the source of the encryption key.
        :param builtins.str key_type: This is the type of data to be encrypted. It can be either active or archival.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "key_source", key_source)
        pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> builtins.str:
        """
        This is the key OCID of the encryption key (null if Oracle-managed).
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> builtins.str:
        """
        This is the source of the encryption key.
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> builtins.str:
        """
        This is the type of data to be encrypted. It can be either active or archival.
        """
        return pulumi.get(self, "key_type")


@pulumi.output_type
class GetNamespaceStorageOverlappingRecallsFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult']):
        """
        :param Sequence['GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemArgs'] items: This is the array of overlapping recall requests
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult']:
        """
        This is the array of overlapping recall requests
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceStorageOverlappingRecallsOverlappingRecallCollectionItemResult(dict):
    def __init__(__self__, *,
                 collection_id: builtins.str,
                 created_by: builtins.str,
                 log_sets: builtins.str,
                 purpose: builtins.str,
                 query_string: builtins.str,
                 recall_id: builtins.str,
                 status: builtins.str,
                 time_data_ended: builtins.str,
                 time_data_started: builtins.str,
                 time_started: builtins.str):
        """
        :param builtins.str collection_id: This is the id of the associated recalled data collection
        :param builtins.str created_by: This is the user who initiated the recall request
        :param builtins.str log_sets: This is the list of logsets associated with this recall
        :param builtins.str purpose: This is the purpose of the recall
        :param builtins.str query_string: This is the query associated with the recall
        :param builtins.str recall_id: This is the id for the recall request
        :param builtins.str status: This is the status of the recall
        :param builtins.str time_data_ended: This is the end of the time range for recalled data
        :param builtins.str time_data_started: This is the start of the time range for recalled data
        :param builtins.str time_started: This is the time when the recall operation was started for this recall request
        """
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "log_sets", log_sets)
        pulumi.set(__self__, "purpose", purpose)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "recall_id", recall_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "time_data_ended", time_data_ended)
        pulumi.set(__self__, "time_data_started", time_data_started)
        pulumi.set(__self__, "time_started", time_started)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> builtins.str:
        """
        This is the id of the associated recalled data collection
        """
        return pulumi.get(self, "collection_id")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> builtins.str:
        """
        This is the user who initiated the recall request
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="logSets")
    def log_sets(self) -> builtins.str:
        """
        This is the list of logsets associated with this recall
        """
        return pulumi.get(self, "log_sets")

    @property
    @pulumi.getter
    def purpose(self) -> builtins.str:
        """
        This is the purpose of the recall
        """
        return pulumi.get(self, "purpose")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> builtins.str:
        """
        This is the query associated with the recall
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="recallId")
    def recall_id(self) -> builtins.str:
        """
        This is the id for the recall request
        """
        return pulumi.get(self, "recall_id")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        This is the status of the recall
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="timeDataEnded")
    def time_data_ended(self) -> builtins.str:
        """
        This is the end of the time range for recalled data
        """
        return pulumi.get(self, "time_data_ended")

    @property
    @pulumi.getter(name="timeDataStarted")
    def time_data_started(self) -> builtins.str:
        """
        This is the start of the time range for recalled data
        """
        return pulumi.get(self, "time_data_started")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> builtins.str:
        """
        This is the time when the recall operation was started for this recall request
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetNamespaceTemplateFacetResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: The template name.
        :param builtins.str value: The facet value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The template name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The facet value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespaceTemplatesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The template name used for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespaceTemplatesLogAnalyticsTemplateCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 content: builtins.str,
                 content_format: builtins.str,
                 defined_tags: Mapping[str, builtins.str],
                 description: builtins.str,
                 facets: Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult'],
                 freeform_tags: Mapping[str, builtins.str],
                 id: builtins.str,
                 is_system: builtins.bool,
                 name: builtins.str,
                 parameters: builtins.str,
                 parameters_format: builtins.str,
                 parameters_metadata: builtins.str,
                 state: builtins.str,
                 time_created: builtins.str,
                 time_updated: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param builtins.str content: Base64 encoded template content.
        :param builtins.str content_format: Content format. For example - XML.
        :param Mapping[str, builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param builtins.str description: Description for this resource.
        :param Sequence['GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetArgs'] facets: Facets of the template
        :param Mapping[str, builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param builtins.str id: The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        :param builtins.bool is_system: The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        :param builtins.str name: The template name used for filtering.
        :param builtins.str parameters: Base64 encoded template parameters.
        :param builtins.str parameters_format: Parameters format.  For example - NAME_VALUE_PAIR.
        :param builtins.str parameters_metadata: Base64 encoded parameters metadata definition.
        :param builtins.str state: The template lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        :param builtins.str time_created: The date and time the resource was created, in the format defined by RFC3339.
        :param builtins.str time_updated: The date and time the resource was last updated, in the format defined by RFC3339.
        :param builtins.str type: The template type used for filtering. Only templates of the specified type will be returned.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_format", content_format)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "facets", facets)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "parameters_format", parameters_format)
        pulumi.set(__self__, "parameters_metadata", parameters_metadata)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def content(self) -> builtins.str:
        """
        Base64 encoded template content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentFormat")
    def content_format(self) -> builtins.str:
        """
        Content format. For example - XML.
        """
        return pulumi.get(self, "content_format")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description for this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def facets(self) -> Sequence['outputs.GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult']:
        """
        Facets of the template
        """
        return pulumi.get(self, "facets")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The log analytics entity OCID. This ID is a reference used by log analytics features and it represents a resource that is provisioned and managed by the customer on their premises or on the cloud.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> builtins.bool:
        """
        The system flag.  A value of false denotes a custom, or user defined object.  A value of true denotes a built in object.
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> builtins.str:
        """
        Base64 encoded template parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="parametersFormat")
    def parameters_format(self) -> builtins.str:
        """
        Parameters format.  For example - NAME_VALUE_PAIR.
        """
        return pulumi.get(self, "parameters_format")

    @property
    @pulumi.getter(name="parametersMetadata")
    def parameters_metadata(self) -> builtins.str:
        """
        Base64 encoded parameters metadata definition.
        """
        return pulumi.get(self, "parameters_metadata")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The template lifecycle state used for filtering. Currently supported values are ACTIVE and DELETED.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> builtins.str:
        """
        The date and time the resource was created, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> builtins.str:
        """
        The date and time the resource was last updated, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The template type used for filtering. Only templates of the specified type will be returned.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespaceTemplatesLogAnalyticsTemplateCollectionItemFacetResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: The template name used for filtering.
        :param builtins.str value: The facet value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The template name used for filtering.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The facet value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNamespacesFilterResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNamespacesNamespaceCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNamespacesNamespaceCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNamespacesNamespaceCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNamespacesNamespaceCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: builtins.str,
                 is_archiving_enabled: builtins.bool,
                 is_data_ever_ingested: builtins.bool,
                 is_logset_enabled: builtins.bool,
                 is_onboarded: builtins.bool,
                 namespace: builtins.str):
        """
        :param builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param builtins.bool is_archiving_enabled: This indicates if old data can be archived for a tenancy
        :param builtins.bool is_data_ever_ingested: This indicates if the tenancy is data ever ingested
        :param builtins.bool is_onboarded: This indicates if the tenancy is onboarded to Logging Analytics
        :param builtins.str namespace: This is the namespace name of a tenancy
               * `is_logSet_enabled` - This indicates if the tenancy is logSet enable
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "is_archiving_enabled", is_archiving_enabled)
        pulumi.set(__self__, "is_data_ever_ingested", is_data_ever_ingested)
        pulumi.set(__self__, "is_logset_enabled", is_logset_enabled)
        pulumi.set(__self__, "is_onboarded", is_onboarded)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="isArchivingEnabled")
    def is_archiving_enabled(self) -> builtins.bool:
        """
        This indicates if old data can be archived for a tenancy
        """
        return pulumi.get(self, "is_archiving_enabled")

    @property
    @pulumi.getter(name="isDataEverIngested")
    def is_data_ever_ingested(self) -> builtins.bool:
        """
        This indicates if the tenancy is data ever ingested
        """
        return pulumi.get(self, "is_data_ever_ingested")

    @property
    @pulumi.getter(name="isLogsetEnabled")
    def is_logset_enabled(self) -> builtins.bool:
        return pulumi.get(self, "is_logset_enabled")

    @property
    @pulumi.getter(name="isOnboarded")
    def is_onboarded(self) -> builtins.bool:
        """
        This indicates if the tenancy is onboarded to Logging Analytics
        """
        return pulumi.get(self, "is_onboarded")

    @property
    @pulumi.getter
    def namespace(self) -> builtins.str:
        """
        This is the namespace name of a tenancy
        * `is_logSet_enabled` - This indicates if the tenancy is logSet enable
        """
        return pulumi.get(self, "namespace")


