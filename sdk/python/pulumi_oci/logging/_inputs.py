# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'LogConfigurationArgs',
    'LogConfigurationSourceArgs',
    'UnifiedAgentConfigurationGroupAssociationArgs',
    'UnifiedAgentConfigurationServiceConfigurationArgs',
    'UnifiedAgentConfigurationServiceConfigurationDestinationArgs',
    'UnifiedAgentConfigurationServiceConfigurationSourceArgs',
    'UnifiedAgentConfigurationServiceConfigurationSourceParserArgs',
    'UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs',
    'UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs',
    'GetLogGroupsFilterArgs',
    'GetLogSavedSearchesFilterArgs',
    'GetLogsFilterArgs',
    'GetUnifiedAgentConfigurationsFilterArgs',
]

@pulumi.input_type
class LogConfigurationArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['LogConfigurationSourceArgs'],
                 compartment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LogConfigurationSourceArgs'] source: The source the log object comes from.
        :param pulumi.Input[str] compartment_id: The OCID of the compartment that the resource belongs to.
        """
        LogConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            compartment_id=compartment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: pulumi.Input['LogConfigurationSourceArgs'],
             compartment_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source", source)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['LogConfigurationSourceArgs']:
        """
        The source the log object comes from.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['LogConfigurationSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compartment that the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)


@pulumi.input_type
class LogConfigurationSourceArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 resource: pulumi.Input[str],
                 service: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] category: Log object category.
        :param pulumi.Input[str] resource: The unique identifier of the resource emitting the log.
        :param pulumi.Input[str] service: Service generating log.
        :param pulumi.Input[str] source_type: The log source.
               * **OCISERVICE:** Oracle Service.
        """
        LogConfigurationSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            resource=resource,
            service=service,
            source_type=source_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: pulumi.Input[str],
             resource: pulumi.Input[str],
             service: pulumi.Input[str],
             source_type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("category", category)
        _setter("resource", resource)
        _setter("service", service)
        _setter("source_type", source_type)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        Log object category.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        The unique identifier of the resource emitting the log.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Service generating log.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The log source.
        * **OCISERVICE:** Oracle Service.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


@pulumi.input_type
class UnifiedAgentConfigurationGroupAssociationArgs:
    def __init__(__self__, *,
                 group_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_lists: (Updatable) list of group/dynamic group ids associated with this configuration.
        """
        UnifiedAgentConfigurationGroupAssociationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_lists=group_lists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_lists is not None:
            _setter("group_lists", group_lists)

    @property
    @pulumi.getter(name="groupLists")
    def group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) list of group/dynamic group ids associated with this configuration.
        """
        return pulumi.get(self, "group_lists")

    @group_lists.setter
    def group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_lists", value)


@pulumi.input_type
class UnifiedAgentConfigurationServiceConfigurationArgs:
    def __init__(__self__, *,
                 configuration_type: pulumi.Input[str],
                 destination: pulumi.Input['UnifiedAgentConfigurationServiceConfigurationDestinationArgs'],
                 sources: pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceArgs']]]):
        """
        :param pulumi.Input[str] configuration_type: (Updatable) Type of Unified Agent service configuration.
        :param pulumi.Input['UnifiedAgentConfigurationServiceConfigurationDestinationArgs'] destination: (Updatable) Logging destination object.
        :param pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceArgs']]] sources: (Updatable) Logging source object.
        """
        UnifiedAgentConfigurationServiceConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_type=configuration_type,
            destination=destination,
            sources=sources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_type: pulumi.Input[str],
             destination: pulumi.Input['UnifiedAgentConfigurationServiceConfigurationDestinationArgs'],
             sources: pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration_type", configuration_type)
        _setter("destination", destination)
        _setter("sources", sources)

    @property
    @pulumi.getter(name="configurationType")
    def configuration_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of Unified Agent service configuration.
        """
        return pulumi.get(self, "configuration_type")

    @configuration_type.setter
    def configuration_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "configuration_type", value)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['UnifiedAgentConfigurationServiceConfigurationDestinationArgs']:
        """
        (Updatable) Logging destination object.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['UnifiedAgentConfigurationServiceConfigurationDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceArgs']]]:
        """
        (Updatable) Logging source object.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceArgs']]]):
        pulumi.set(self, "sources", value)


@pulumi.input_type
class UnifiedAgentConfigurationServiceConfigurationDestinationArgs:
    def __init__(__self__, *,
                 log_object_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_object_id: (Updatable) The OCID of the resource.
        """
        UnifiedAgentConfigurationServiceConfigurationDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_object_id=log_object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_object_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_object_id", log_object_id)

    @property
    @pulumi.getter(name="logObjectId")
    def log_object_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "log_object_id")

    @log_object_id.setter
    def log_object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_object_id", value)


@pulumi.input_type
class UnifiedAgentConfigurationServiceConfigurationSourceArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parser: Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserArgs']] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] source_type: (Updatable) Unified schema logging source type.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[Sequence[pulumi.Input[str]]] channels: (Updatable) Windows event log channels.
        :param pulumi.Input[str] name: (Updatable) The name key to tag this grok pattern.
        :param pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserArgs'] parser: (Updatable) source parser object.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: (Updatable) Absolute paths for log source files. Wildcard can be used.
        """
        UnifiedAgentConfigurationServiceConfigurationSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            channels=channels,
            name=name,
            parser=parser,
            paths=paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: pulumi.Input[str],
             channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             parser: Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserArgs']] = None,
             paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        if channels is not None:
            _setter("channels", channels)
        if name is not None:
            _setter("name", name)
        if parser is not None:
            _setter("parser", parser)
        if paths is not None:
            _setter("paths", paths)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Unified schema logging source type.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Windows event log channels.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name key to tag this grok pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parser(self) -> Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserArgs']]:
        """
        (Updatable) source parser object.
        """
        return pulumi.get(self, "parser")

    @parser.setter
    def parser(self, value: Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserArgs']]):
        pulumi.set(self, "parser", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Absolute paths for log source files. Wildcard can be used.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)


@pulumi.input_type
class UnifiedAgentConfigurationServiceConfigurationSourceParserArgs:
    def __init__(__self__, *,
                 parser_type: pulumi.Input[str],
                 delimiter: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 field_time_key: Optional[pulumi.Input[str]] = None,
                 format_firstline: Optional[pulumi.Input[str]] = None,
                 formats: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 grok_failure_key: Optional[pulumi.Input[str]] = None,
                 grok_name_key: Optional[pulumi.Input[str]] = None,
                 is_estimate_current_event: Optional[pulumi.Input[bool]] = None,
                 is_keep_time_key: Optional[pulumi.Input[bool]] = None,
                 is_merge_cri_fields: Optional[pulumi.Input[bool]] = None,
                 is_null_empty_string: Optional[pulumi.Input[bool]] = None,
                 is_support_colonless_ident: Optional[pulumi.Input[bool]] = None,
                 is_with_priority: Optional[pulumi.Input[bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 message_format: Optional[pulumi.Input[str]] = None,
                 message_key: Optional[pulumi.Input[str]] = None,
                 multi_line_start_regexp: Optional[pulumi.Input[str]] = None,
                 nested_parser: Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs']] = None,
                 null_value_pattern: Optional[pulumi.Input[str]] = None,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]] = None,
                 rfc5424time_format: Optional[pulumi.Input[str]] = None,
                 syslog_parser_type: Optional[pulumi.Input[str]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 time_type: Optional[pulumi.Input[str]] = None,
                 timeout_in_milliseconds: Optional[pulumi.Input[int]] = None,
                 types: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] parser_type: (Updatable) Type of fluent parser.
        :param pulumi.Input[str] delimiter: (Updatable) csv delimiter.
        :param pulumi.Input[str] expression: (Updatable) Regex pattern.
        :param pulumi.Input[str] field_time_key: (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        :param pulumi.Input[str] format_firstline: (Updatable) First line pattern format.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] formats: (Updatable) Mutiline pattern format.
        :param pulumi.Input[str] grok_failure_key: (Updatable) grok failure key.
        :param pulumi.Input[str] grok_name_key: (Updatable) grok name key.
        :param pulumi.Input[bool] is_estimate_current_event: (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
        :param pulumi.Input[bool] is_keep_time_key: (Updatable) If true, keep time field in the record.
        :param pulumi.Input[bool] is_merge_cri_fields: (Updatable) If you don't need stream/logtag fields, set this to false.
        :param pulumi.Input[bool] is_null_empty_string: (Updatable) If true, an empty string field is replaced with nil.
        :param pulumi.Input[bool] is_support_colonless_ident: (Updatable) Support colonless ident or not.
        :param pulumi.Input[bool] is_with_priority: (Updatable) With priority or not.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: (Updatable) csv keys.
        :param pulumi.Input[str] message_format: (Updatable) Message format of syslog.
        :param pulumi.Input[str] message_key: (Updatable) Specifies the field name to contain logs.
        :param pulumi.Input[str] multi_line_start_regexp: (Updatable) Multiline start regexp pattern.
        :param pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs'] nested_parser: (Updatable) Optional nested JSON Parser for CRI Parser. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
        :param pulumi.Input[str] null_value_pattern: (Updatable) Specify the null value pattern.
        :param pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]] patterns: (Updatable) grok pattern object.
        :param pulumi.Input[str] rfc5424time_format: (Updatable) rfc5424 time format.
        :param pulumi.Input[str] syslog_parser_type: (Updatable) Syslog parser type.
        :param pulumi.Input[str] time_format: (Updatable) Process time value using the specified format.
        :param pulumi.Input[str] time_type: (Updatable) Time type of JSON parser.
        :param pulumi.Input[int] timeout_in_milliseconds: (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
        :param pulumi.Input[Mapping[str, Any]] types: (Updatable) Specify types for converting a field into another type. For example, With this configuration: <parse> @type csv keys time,host,req_id,user time_key time </parse>
               
               This incoming event: "2013/02/28 12:00:00,192.168.0.1,111,-"
               
               is parsed as: 1362020400 (2013/02/28/ 12:00:00)
               
               record: { "host"   : "192.168.0.1", "req_id" : "111", "user"   : "-" }
        """
        UnifiedAgentConfigurationServiceConfigurationSourceParserArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parser_type=parser_type,
            delimiter=delimiter,
            expression=expression,
            field_time_key=field_time_key,
            format_firstline=format_firstline,
            formats=formats,
            grok_failure_key=grok_failure_key,
            grok_name_key=grok_name_key,
            is_estimate_current_event=is_estimate_current_event,
            is_keep_time_key=is_keep_time_key,
            is_merge_cri_fields=is_merge_cri_fields,
            is_null_empty_string=is_null_empty_string,
            is_support_colonless_ident=is_support_colonless_ident,
            is_with_priority=is_with_priority,
            keys=keys,
            message_format=message_format,
            message_key=message_key,
            multi_line_start_regexp=multi_line_start_regexp,
            nested_parser=nested_parser,
            null_value_pattern=null_value_pattern,
            patterns=patterns,
            rfc5424time_format=rfc5424time_format,
            syslog_parser_type=syslog_parser_type,
            time_format=time_format,
            time_type=time_type,
            timeout_in_milliseconds=timeout_in_milliseconds,
            types=types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parser_type: pulumi.Input[str],
             delimiter: Optional[pulumi.Input[str]] = None,
             expression: Optional[pulumi.Input[str]] = None,
             field_time_key: Optional[pulumi.Input[str]] = None,
             format_firstline: Optional[pulumi.Input[str]] = None,
             formats: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             grok_failure_key: Optional[pulumi.Input[str]] = None,
             grok_name_key: Optional[pulumi.Input[str]] = None,
             is_estimate_current_event: Optional[pulumi.Input[bool]] = None,
             is_keep_time_key: Optional[pulumi.Input[bool]] = None,
             is_merge_cri_fields: Optional[pulumi.Input[bool]] = None,
             is_null_empty_string: Optional[pulumi.Input[bool]] = None,
             is_support_colonless_ident: Optional[pulumi.Input[bool]] = None,
             is_with_priority: Optional[pulumi.Input[bool]] = None,
             keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             message_format: Optional[pulumi.Input[str]] = None,
             message_key: Optional[pulumi.Input[str]] = None,
             multi_line_start_regexp: Optional[pulumi.Input[str]] = None,
             nested_parser: Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs']] = None,
             null_value_pattern: Optional[pulumi.Input[str]] = None,
             patterns: Optional[pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]] = None,
             rfc5424time_format: Optional[pulumi.Input[str]] = None,
             syslog_parser_type: Optional[pulumi.Input[str]] = None,
             time_format: Optional[pulumi.Input[str]] = None,
             time_type: Optional[pulumi.Input[str]] = None,
             timeout_in_milliseconds: Optional[pulumi.Input[int]] = None,
             types: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parser_type", parser_type)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if expression is not None:
            _setter("expression", expression)
        if field_time_key is not None:
            _setter("field_time_key", field_time_key)
        if format_firstline is not None:
            _setter("format_firstline", format_firstline)
        if formats is not None:
            _setter("formats", formats)
        if grok_failure_key is not None:
            _setter("grok_failure_key", grok_failure_key)
        if grok_name_key is not None:
            _setter("grok_name_key", grok_name_key)
        if is_estimate_current_event is not None:
            _setter("is_estimate_current_event", is_estimate_current_event)
        if is_keep_time_key is not None:
            _setter("is_keep_time_key", is_keep_time_key)
        if is_merge_cri_fields is not None:
            _setter("is_merge_cri_fields", is_merge_cri_fields)
        if is_null_empty_string is not None:
            _setter("is_null_empty_string", is_null_empty_string)
        if is_support_colonless_ident is not None:
            _setter("is_support_colonless_ident", is_support_colonless_ident)
        if is_with_priority is not None:
            _setter("is_with_priority", is_with_priority)
        if keys is not None:
            _setter("keys", keys)
        if message_format is not None:
            _setter("message_format", message_format)
        if message_key is not None:
            _setter("message_key", message_key)
        if multi_line_start_regexp is not None:
            _setter("multi_line_start_regexp", multi_line_start_regexp)
        if nested_parser is not None:
            _setter("nested_parser", nested_parser)
        if null_value_pattern is not None:
            _setter("null_value_pattern", null_value_pattern)
        if patterns is not None:
            _setter("patterns", patterns)
        if rfc5424time_format is not None:
            _setter("rfc5424time_format", rfc5424time_format)
        if syslog_parser_type is not None:
            _setter("syslog_parser_type", syslog_parser_type)
        if time_format is not None:
            _setter("time_format", time_format)
        if time_type is not None:
            _setter("time_type", time_type)
        if timeout_in_milliseconds is not None:
            _setter("timeout_in_milliseconds", timeout_in_milliseconds)
        if types is not None:
            _setter("types", types)

    @property
    @pulumi.getter(name="parserType")
    def parser_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of fluent parser.
        """
        return pulumi.get(self, "parser_type")

    @parser_type.setter
    def parser_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "parser_type", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) csv delimiter.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Regex pattern.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="fieldTimeKey")
    def field_time_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        """
        return pulumi.get(self, "field_time_key")

    @field_time_key.setter
    def field_time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_key", value)

    @property
    @pulumi.getter(name="formatFirstline")
    def format_firstline(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) First line pattern format.
        """
        return pulumi.get(self, "format_firstline")

    @format_firstline.setter
    def format_firstline(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_firstline", value)

    @property
    @pulumi.getter
    def formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Mutiline pattern format.
        """
        return pulumi.get(self, "formats")

    @formats.setter
    def formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "formats", value)

    @property
    @pulumi.getter(name="grokFailureKey")
    def grok_failure_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) grok failure key.
        """
        return pulumi.get(self, "grok_failure_key")

    @grok_failure_key.setter
    def grok_failure_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grok_failure_key", value)

    @property
    @pulumi.getter(name="grokNameKey")
    def grok_name_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) grok name key.
        """
        return pulumi.get(self, "grok_name_key")

    @grok_name_key.setter
    def grok_name_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grok_name_key", value)

    @property
    @pulumi.getter(name="isEstimateCurrentEvent")
    def is_estimate_current_event(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
        """
        return pulumi.get(self, "is_estimate_current_event")

    @is_estimate_current_event.setter
    def is_estimate_current_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_estimate_current_event", value)

    @property
    @pulumi.getter(name="isKeepTimeKey")
    def is_keep_time_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, keep time field in the record.
        """
        return pulumi.get(self, "is_keep_time_key")

    @is_keep_time_key.setter
    def is_keep_time_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_keep_time_key", value)

    @property
    @pulumi.getter(name="isMergeCriFields")
    def is_merge_cri_fields(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If you don't need stream/logtag fields, set this to false.
        """
        return pulumi.get(self, "is_merge_cri_fields")

    @is_merge_cri_fields.setter
    def is_merge_cri_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_merge_cri_fields", value)

    @property
    @pulumi.getter(name="isNullEmptyString")
    def is_null_empty_string(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, an empty string field is replaced with nil.
        """
        return pulumi.get(self, "is_null_empty_string")

    @is_null_empty_string.setter
    def is_null_empty_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_null_empty_string", value)

    @property
    @pulumi.getter(name="isSupportColonlessIdent")
    def is_support_colonless_ident(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Support colonless ident or not.
        """
        return pulumi.get(self, "is_support_colonless_ident")

    @is_support_colonless_ident.setter
    def is_support_colonless_ident(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_support_colonless_ident", value)

    @property
    @pulumi.getter(name="isWithPriority")
    def is_with_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) With priority or not.
        """
        return pulumi.get(self, "is_with_priority")

    @is_with_priority.setter
    def is_with_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_with_priority", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) csv keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Message format of syslog.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)

    @property
    @pulumi.getter(name="messageKey")
    def message_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies the field name to contain logs.
        """
        return pulumi.get(self, "message_key")

    @message_key.setter
    def message_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_key", value)

    @property
    @pulumi.getter(name="multiLineStartRegexp")
    def multi_line_start_regexp(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Multiline start regexp pattern.
        """
        return pulumi.get(self, "multi_line_start_regexp")

    @multi_line_start_regexp.setter
    def multi_line_start_regexp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multi_line_start_regexp", value)

    @property
    @pulumi.getter(name="nestedParser")
    def nested_parser(self) -> Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs']]:
        """
        (Updatable) Optional nested JSON Parser for CRI Parser. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
        """
        return pulumi.get(self, "nested_parser")

    @nested_parser.setter
    def nested_parser(self, value: Optional[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs']]):
        pulumi.set(self, "nested_parser", value)

    @property
    @pulumi.getter(name="nullValuePattern")
    def null_value_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the null value pattern.
        """
        return pulumi.get(self, "null_value_pattern")

    @null_value_pattern.setter
    def null_value_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "null_value_pattern", value)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]]:
        """
        (Updatable) grok pattern object.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]]):
        pulumi.set(self, "patterns", value)

    @property
    @pulumi.getter(name="rfc5424timeFormat")
    def rfc5424time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) rfc5424 time format.
        """
        return pulumi.get(self, "rfc5424time_format")

    @rfc5424time_format.setter
    def rfc5424time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rfc5424time_format", value)

    @property
    @pulumi.getter(name="syslogParserType")
    def syslog_parser_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Syslog parser type.
        """
        return pulumi.get(self, "syslog_parser_type")

    @syslog_parser_type.setter
    def syslog_parser_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "syslog_parser_type", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Process time value using the specified format.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter(name="timeType")
    def time_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time type of JSON parser.
        """
        return pulumi.get(self, "time_type")

    @time_type.setter
    def time_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_type", value)

    @property
    @pulumi.getter(name="timeoutInMilliseconds")
    def timeout_in_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
        """
        return pulumi.get(self, "timeout_in_milliseconds")

    @timeout_in_milliseconds.setter
    def timeout_in_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_milliseconds", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Specify types for converting a field into another type. For example, With this configuration: <parse> @type csv keys time,host,req_id,user time_key time </parse>

        This incoming event: "2013/02/28 12:00:00,192.168.0.1,111,-"

        is parsed as: 1362020400 (2013/02/28/ 12:00:00)

        record: { "host"   : "192.168.0.1", "req_id" : "111", "user"   : "-" }
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "types", value)


@pulumi.input_type
class UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs:
    def __init__(__self__, *,
                 field_time_key: Optional[pulumi.Input[str]] = None,
                 is_keep_time_key: Optional[pulumi.Input[bool]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 time_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] field_time_key: (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        :param pulumi.Input[bool] is_keep_time_key: (Updatable) If true, keep time field in the record.
        :param pulumi.Input[str] time_format: (Updatable) Process time value using the specified format.
        :param pulumi.Input[str] time_type: (Updatable) Time type of JSON parser.
        """
        UnifiedAgentConfigurationServiceConfigurationSourceParserNestedParserArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_time_key=field_time_key,
            is_keep_time_key=is_keep_time_key,
            time_format=time_format,
            time_type=time_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_time_key: Optional[pulumi.Input[str]] = None,
             is_keep_time_key: Optional[pulumi.Input[bool]] = None,
             time_format: Optional[pulumi.Input[str]] = None,
             time_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_time_key is not None:
            _setter("field_time_key", field_time_key)
        if is_keep_time_key is not None:
            _setter("is_keep_time_key", is_keep_time_key)
        if time_format is not None:
            _setter("time_format", time_format)
        if time_type is not None:
            _setter("time_type", time_type)

    @property
    @pulumi.getter(name="fieldTimeKey")
    def field_time_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        """
        return pulumi.get(self, "field_time_key")

    @field_time_key.setter
    def field_time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_key", value)

    @property
    @pulumi.getter(name="isKeepTimeKey")
    def is_keep_time_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, keep time field in the record.
        """
        return pulumi.get(self, "is_keep_time_key")

    @is_keep_time_key.setter
    def is_keep_time_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_keep_time_key", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Process time value using the specified format.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter(name="timeType")
    def time_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time type of JSON parser.
        """
        return pulumi.get(self, "time_type")

    @time_type.setter
    def time_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_type", value)


@pulumi.input_type
class UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs:
    def __init__(__self__, *,
                 field_time_format: Optional[pulumi.Input[str]] = None,
                 field_time_key: Optional[pulumi.Input[str]] = None,
                 field_time_zone: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] field_time_format: (Updatable) Process value using the specified format. This is available only when time_type is a string.
        :param pulumi.Input[str] field_time_key: (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        :param pulumi.Input[str] field_time_zone: (Updatable) Use the specified time zone. The time value can be parsed or formatted in the specified time zone.
        :param pulumi.Input[str] name: (Updatable) The name key to tag this grok pattern.
        :param pulumi.Input[str] pattern: (Updatable) The grok pattern.
        """
        UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_time_format=field_time_format,
            field_time_key=field_time_key,
            field_time_zone=field_time_zone,
            name=name,
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_time_format: Optional[pulumi.Input[str]] = None,
             field_time_key: Optional[pulumi.Input[str]] = None,
             field_time_zone: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             pattern: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_time_format is not None:
            _setter("field_time_format", field_time_format)
        if field_time_key is not None:
            _setter("field_time_key", field_time_key)
        if field_time_zone is not None:
            _setter("field_time_zone", field_time_zone)
        if name is not None:
            _setter("name", name)
        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter(name="fieldTimeFormat")
    def field_time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Process value using the specified format. This is available only when time_type is a string.
        """
        return pulumi.get(self, "field_time_format")

    @field_time_format.setter
    def field_time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_format", value)

    @property
    @pulumi.getter(name="fieldTimeKey")
    def field_time_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        """
        return pulumi.get(self, "field_time_key")

    @field_time_key.setter
    def field_time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_key", value)

    @property
    @pulumi.getter(name="fieldTimeZone")
    def field_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Use the specified time zone. The time value can be parsed or formatted in the specified time zone.
        """
        return pulumi.get(self, "field_time_zone")

    @field_time_zone.setter
    def field_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_zone", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name key to tag this grok pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The grok pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class GetLogGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetLogGroupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogSavedSearchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Resource name.
        """
        GetLogSavedSearchesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetLogsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetUnifiedAgentConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name key to tag this grok pattern.
        """
        GetUnifiedAgentConfigurationsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name key to tag this grok pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


