# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ManagementAgentDataSourceListArgs',
    'ManagementAgentDataSourceListArgsDict',
    'ManagementAgentDataSourceListMetricDimensionArgs',
    'ManagementAgentDataSourceListMetricDimensionArgsDict',
    'ManagementAgentDataSourceMetricDimensionArgs',
    'ManagementAgentDataSourceMetricDimensionArgsDict',
    'ManagementAgentDataSourceSummaryListArgs',
    'ManagementAgentDataSourceSummaryListArgsDict',
    'ManagementAgentManagementAgentPropertyArgs',
    'ManagementAgentManagementAgentPropertyArgsDict',
    'ManagementAgentPluginListArgs',
    'ManagementAgentPluginListArgsDict',
    'NamedCredentialPropertyArgs',
    'NamedCredentialPropertyArgsDict',
    'GetManagementAgentAvailableHistoriesFilterArgs',
    'GetManagementAgentAvailableHistoriesFilterArgsDict',
    'GetManagementAgentDataSourcesFilterArgs',
    'GetManagementAgentDataSourcesFilterArgsDict',
    'GetManagementAgentImagesFilterArgs',
    'GetManagementAgentImagesFilterArgsDict',
    'GetManagementAgentInstallKeysFilterArgs',
    'GetManagementAgentInstallKeysFilterArgsDict',
    'GetManagementAgentPluginsFilterArgs',
    'GetManagementAgentPluginsFilterArgsDict',
    'GetManagementAgentsFilterArgs',
    'GetManagementAgentsFilterArgsDict',
    'GetNamedCredentialsFilterArgs',
    'GetNamedCredentialsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ManagementAgentDataSourceListArgsDict(TypedDict):
        allow_metrics: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma separated metric name list. The complete set of desired scraped metrics. Use this property to limit the set of metrics uploaded if required.
        """
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compartment owning this DataSource.
        """
        connection_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number in milliseconds. The timeout for connecting to the Prometheus Exporter's endpoint.
        """
        is_daemon_set: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the Kubernetes cluster type is Daemon set then this will be set to true.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier for DataSource. This represents the type and name for the data source associated with the Management Agent.
        """
        metric_dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ManagementAgentDataSourceListMetricDimensionArgsDict']]]]
        """
        The names of other user-supplied properties expressed as fixed values to be used as dimensions for every uploaded datapoint.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Oracle Cloud Infrastructure monitoring namespace to which scraped metrics should be uploaded.
        """
        proxy_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url of the network proxy that provides access to the Prometheus Exporter's endpoint (url required property).
        """
        read_data_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number in kilobytes. The limit on the data being sent, not to exceed the agent's fixed limit of 400 (KB).
        """
        read_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number in milliseconds. The timeout for reading the response from the Prometheus Exporter's endpoint.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Oracle Cloud Infrastructure monitoring resource group to assign the metric to.
        """
        schedule_mins: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number in minutes. The scraping occurs at the specified interval.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current state of managementAgent
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the Management Agent was created. An RFC3339 formatted datetime string
        """
        time_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time the Management Agent was last updated. An RFC3339 formatted datetime string
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the DataSource.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url through which the Prometheus Exporter publishes its metrics. (http only)
        """
elif False:
    ManagementAgentDataSourceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementAgentDataSourceListArgs:
    def __init__(__self__, *,
                 allow_metrics: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 is_daemon_set: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagementAgentDataSourceListMetricDimensionArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_url: Optional[pulumi.Input[_builtins.str]] = None,
                 read_data_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 read_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule_mins: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 time_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] allow_metrics: Comma separated metric name list. The complete set of desired scraped metrics. Use this property to limit the set of metrics uploaded if required.
        :param pulumi.Input[_builtins.str] compartment_id: Compartment owning this DataSource.
        :param pulumi.Input[_builtins.int] connection_timeout: Number in milliseconds. The timeout for connecting to the Prometheus Exporter's endpoint.
        :param pulumi.Input[_builtins.bool] is_daemon_set: If the Kubernetes cluster type is Daemon set then this will be set to true.
        :param pulumi.Input[_builtins.str] key: Identifier for DataSource. This represents the type and name for the data source associated with the Management Agent.
        :param pulumi.Input[Sequence[pulumi.Input['ManagementAgentDataSourceListMetricDimensionArgs']]] metric_dimensions: The names of other user-supplied properties expressed as fixed values to be used as dimensions for every uploaded datapoint.
        :param pulumi.Input[_builtins.str] name: Name of the property
        :param pulumi.Input[_builtins.str] namespace: The Oracle Cloud Infrastructure monitoring namespace to which scraped metrics should be uploaded.
        :param pulumi.Input[_builtins.str] proxy_url: The url of the network proxy that provides access to the Prometheus Exporter's endpoint (url required property).
        :param pulumi.Input[_builtins.int] read_data_limit: Number in kilobytes. The limit on the data being sent, not to exceed the agent's fixed limit of 400 (KB).
        :param pulumi.Input[_builtins.int] read_timeout: Number in milliseconds. The timeout for reading the response from the Prometheus Exporter's endpoint.
        :param pulumi.Input[_builtins.str] resource_group: Oracle Cloud Infrastructure monitoring resource group to assign the metric to.
        :param pulumi.Input[_builtins.int] schedule_mins: Number in minutes. The scraping occurs at the specified interval.
        :param pulumi.Input[_builtins.str] state: The current state of managementAgent
        :param pulumi.Input[_builtins.str] time_created: The time the Management Agent was created. An RFC3339 formatted datetime string
        :param pulumi.Input[_builtins.str] time_updated: The time the Management Agent was last updated. An RFC3339 formatted datetime string
        :param pulumi.Input[_builtins.str] type: The type of the DataSource.
        :param pulumi.Input[_builtins.str] url: The url through which the Prometheus Exporter publishes its metrics. (http only)
        """
        if allow_metrics is not None:
            pulumi.set(__self__, "allow_metrics", allow_metrics)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if is_daemon_set is not None:
            pulumi.set(__self__, "is_daemon_set", is_daemon_set)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if metric_dimensions is not None:
            pulumi.set(__self__, "metric_dimensions", metric_dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if read_data_limit is not None:
            pulumi.set(__self__, "read_data_limit", read_data_limit)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if schedule_mins is not None:
            pulumi.set(__self__, "schedule_mins", schedule_mins)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="allowMetrics")
    def allow_metrics(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma separated metric name list. The complete set of desired scraped metrics. Use this property to limit the set of metrics uploaded if required.
        """
        return pulumi.get(self, "allow_metrics")

    @allow_metrics.setter
    def allow_metrics(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allow_metrics", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compartment owning this DataSource.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number in milliseconds. The timeout for connecting to the Prometheus Exporter's endpoint.
        """
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_timeout", value)

    @_builtins.property
    @pulumi.getter(name="isDaemonSet")
    def is_daemon_set(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the Kubernetes cluster type is Daemon set then this will be set to true.
        """
        return pulumi.get(self, "is_daemon_set")

    @is_daemon_set.setter
    def is_daemon_set(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_daemon_set", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier for DataSource. This represents the type and name for the data source associated with the Management Agent.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="metricDimensions")
    def metric_dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagementAgentDataSourceListMetricDimensionArgs']]]]:
        """
        The names of other user-supplied properties expressed as fixed values to be used as dimensions for every uploaded datapoint.
        """
        return pulumi.get(self, "metric_dimensions")

    @metric_dimensions.setter
    def metric_dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagementAgentDataSourceListMetricDimensionArgs']]]]):
        pulumi.set(self, "metric_dimensions", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Oracle Cloud Infrastructure monitoring namespace to which scraped metrics should be uploaded.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url of the network proxy that provides access to the Prometheus Exporter's endpoint (url required property).
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_url", value)

    @_builtins.property
    @pulumi.getter(name="readDataLimit")
    def read_data_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number in kilobytes. The limit on the data being sent, not to exceed the agent's fixed limit of 400 (KB).
        """
        return pulumi.get(self, "read_data_limit")

    @read_data_limit.setter
    def read_data_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_data_limit", value)

    @_builtins.property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number in milliseconds. The timeout for reading the response from the Prometheus Exporter's endpoint.
        """
        return pulumi.get(self, "read_timeout")

    @read_timeout.setter
    def read_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_timeout", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Oracle Cloud Infrastructure monitoring resource group to assign the metric to.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter(name="scheduleMins")
    def schedule_mins(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number in minutes. The scraping occurs at the specified interval.
        """
        return pulumi.get(self, "schedule_mins")

    @schedule_mins.setter
    def schedule_mins(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "schedule_mins", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current state of managementAgent
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the Management Agent was created. An RFC3339 formatted datetime string
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time the Management Agent was last updated. An RFC3339 formatted datetime string
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_updated", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the DataSource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url through which the Prometheus Exporter publishes its metrics. (http only)
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ManagementAgentDataSourceListMetricDimensionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the metric dimension
        """
elif False:
    ManagementAgentDataSourceListMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementAgentDataSourceListMetricDimensionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property
        :param pulumi.Input[_builtins.str] value: Value of the metric dimension
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the metric dimension
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ManagementAgentDataSourceMetricDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the metric dimension
        """
        value: pulumi.Input[_builtins.str]
        """
        (Updatable) Value of the metric dimension
        """
elif False:
    ManagementAgentDataSourceMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementAgentDataSourceMetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the metric dimension
        :param pulumi.Input[_builtins.str] value: (Updatable) Value of the metric dimension
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the metric dimension
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Value of the metric dimension
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ManagementAgentDataSourceSummaryListArgsDict(TypedDict):
        is_daemon_set: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the Kubernetes cluster type is Daemon set then this will be set to true.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier for DataSource. This represents the type and name for the data source associated with the Management Agent.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the DataSource.
        """
elif False:
    ManagementAgentDataSourceSummaryListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementAgentDataSourceSummaryListArgs:
    def __init__(__self__, *,
                 is_daemon_set: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_daemon_set: If the Kubernetes cluster type is Daemon set then this will be set to true.
        :param pulumi.Input[_builtins.str] key: Identifier for DataSource. This represents the type and name for the data source associated with the Management Agent.
        :param pulumi.Input[_builtins.str] name: Name of the property
        :param pulumi.Input[_builtins.str] type: The type of the DataSource.
        """
        if is_daemon_set is not None:
            pulumi.set(__self__, "is_daemon_set", is_daemon_set)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="isDaemonSet")
    def is_daemon_set(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the Kubernetes cluster type is Daemon set then this will be set to true.
        """
        return pulumi.get(self, "is_daemon_set")

    @is_daemon_set.setter
    def is_daemon_set(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_daemon_set", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier for DataSource. This represents the type and name for the data source associated with the Management Agent.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the DataSource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagementAgentManagementAgentPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property
        """
        units: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit for the property
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Values of the property
        """
elif False:
    ManagementAgentManagementAgentPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementAgentManagementAgentPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 units: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property
        :param pulumi.Input[_builtins.str] units: Unit for the property
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Values of the property
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit for the property
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "units", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Values of the property
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ManagementAgentPluginListArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        flag indicating whether the plugin is in enabled mode or disabled mode.
        """
        plugin_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Agent Plugin Identifier, can be renamed
        """
        plugin_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plugin Id
        """
        plugin_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Agent Plugin Name
        """
        plugin_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plugin Status
        """
        plugin_status_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status message of the Plugin
        """
        plugin_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plugin Version
        """
elif False:
    ManagementAgentPluginListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementAgentPluginListArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 plugin_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 plugin_id: Optional[pulumi.Input[_builtins.str]] = None,
                 plugin_name: Optional[pulumi.Input[_builtins.str]] = None,
                 plugin_status: Optional[pulumi.Input[_builtins.str]] = None,
                 plugin_status_message: Optional[pulumi.Input[_builtins.str]] = None,
                 plugin_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: flag indicating whether the plugin is in enabled mode or disabled mode.
        :param pulumi.Input[_builtins.str] plugin_display_name: Management Agent Plugin Identifier, can be renamed
        :param pulumi.Input[_builtins.str] plugin_id: Plugin Id
        :param pulumi.Input[_builtins.str] plugin_name: Management Agent Plugin Name
        :param pulumi.Input[_builtins.str] plugin_status: Plugin Status
        :param pulumi.Input[_builtins.str] plugin_status_message: Status message of the Plugin
        :param pulumi.Input[_builtins.str] plugin_version: Plugin Version
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if plugin_display_name is not None:
            pulumi.set(__self__, "plugin_display_name", plugin_display_name)
        if plugin_id is not None:
            pulumi.set(__self__, "plugin_id", plugin_id)
        if plugin_name is not None:
            pulumi.set(__self__, "plugin_name", plugin_name)
        if plugin_status is not None:
            pulumi.set(__self__, "plugin_status", plugin_status)
        if plugin_status_message is not None:
            pulumi.set(__self__, "plugin_status_message", plugin_status_message)
        if plugin_version is not None:
            pulumi.set(__self__, "plugin_version", plugin_version)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        flag indicating whether the plugin is in enabled mode or disabled mode.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="pluginDisplayName")
    def plugin_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Agent Plugin Identifier, can be renamed
        """
        return pulumi.get(self, "plugin_display_name")

    @plugin_display_name.setter
    def plugin_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plugin_display_name", value)

    @_builtins.property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plugin Id
        """
        return pulumi.get(self, "plugin_id")

    @plugin_id.setter
    def plugin_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plugin_id", value)

    @_builtins.property
    @pulumi.getter(name="pluginName")
    def plugin_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Agent Plugin Name
        """
        return pulumi.get(self, "plugin_name")

    @plugin_name.setter
    def plugin_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plugin_name", value)

    @_builtins.property
    @pulumi.getter(name="pluginStatus")
    def plugin_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plugin Status
        """
        return pulumi.get(self, "plugin_status")

    @plugin_status.setter
    def plugin_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plugin_status", value)

    @_builtins.property
    @pulumi.getter(name="pluginStatusMessage")
    def plugin_status_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status message of the Plugin
        """
        return pulumi.get(self, "plugin_status_message")

    @plugin_status_message.setter
    def plugin_status_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plugin_status_message", value)

    @_builtins.property
    @pulumi.getter(name="pluginVersion")
    def plugin_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plugin Version
        """
        return pulumi.get(self, "plugin_version")

    @plugin_version.setter
    def plugin_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plugin_version", value)


if not MYPY:
    class NamedCredentialPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the property
        """
        value: pulumi.Input[_builtins.str]
        """
        (Updatable) Value of the property
        """
        value_category: pulumi.Input[_builtins.str]
        """
        (Updatable) The category of the Named credential property value. CLEAR_TEXT indicates the value field contains a clear text value. SECRET_IDENTIFIER indicates the value field contains a vault secret ocid identifier. ADB_IDENTIFIER indicates the value field contains an Autonomous database ocid identifier. ALLOWED_VALUE indicates the value should be selected from the options in the allowedValues field.
        """
elif False:
    NamedCredentialPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamedCredentialPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 value_category: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the property
        :param pulumi.Input[_builtins.str] value: (Updatable) Value of the property
        :param pulumi.Input[_builtins.str] value_category: (Updatable) The category of the Named credential property value. CLEAR_TEXT indicates the value field contains a clear text value. SECRET_IDENTIFIER indicates the value field contains a vault secret ocid identifier. ADB_IDENTIFIER indicates the value field contains an Autonomous database ocid identifier. ALLOWED_VALUE indicates the value should be selected from the options in the allowedValues field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_category", value_category)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the property
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Value of the property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueCategory")
    def value_category(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The category of the Named credential property value. CLEAR_TEXT indicates the value field contains a clear text value. SECRET_IDENTIFIER indicates the value field contains a vault secret ocid identifier. ADB_IDENTIFIER indicates the value field contains an Autonomous database ocid identifier. ALLOWED_VALUE indicates the value should be selected from the options in the allowedValues field.
        """
        return pulumi.get(self, "value_category")

    @value_category.setter
    def value_category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_category", value)


if not MYPY:
    class GetManagementAgentAvailableHistoriesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementAgentAvailableHistoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementAgentAvailableHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementAgentDataSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique name of the dataSource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementAgentDataSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementAgentDataSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name of the dataSource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name of the dataSource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementAgentImagesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the entire platform name given.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementAgentImagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementAgentImagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the entire platform name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire platform name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementAgentInstallKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementAgentInstallKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementAgentInstallKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementAgentPluginsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Management Agent Plugin Name
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementAgentPluginsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementAgentPluginsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Management Agent Plugin Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Management Agent Plugin Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagementAgentsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the property
        """
        values: Sequence[_builtins.str]
        """
        Values of the property
        """
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagementAgentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagementAgentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the property
        :param Sequence[_builtins.str] values: Values of the property
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the property
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values of the property
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetNamedCredentialsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Filter list for these name items.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetNamedCredentialsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamedCredentialsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Filter list for these name items.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Filter list for these name items.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


