# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CustomTableSavedCustomTableArgs',
    'CustomTableSavedCustomTableArgsDict',
    'CustomTableSavedCustomTableGroupByTagArgs',
    'CustomTableSavedCustomTableGroupByTagArgsDict',
    'QueryQueryDefinitionArgs',
    'QueryQueryDefinitionArgsDict',
    'QueryQueryDefinitionCostAnalysisUiArgs',
    'QueryQueryDefinitionCostAnalysisUiArgsDict',
    'QueryQueryDefinitionReportQueryArgs',
    'QueryQueryDefinitionReportQueryArgsDict',
    'QueryQueryDefinitionReportQueryForecastArgs',
    'QueryQueryDefinitionReportQueryForecastArgsDict',
    'QueryQueryDefinitionReportQueryGroupByTagArgs',
    'QueryQueryDefinitionReportQueryGroupByTagArgsDict',
    'ScheduleQueryPropertiesArgs',
    'ScheduleQueryPropertiesArgsDict',
    'ScheduleQueryPropertiesDateRangeArgs',
    'ScheduleQueryPropertiesDateRangeArgsDict',
    'ScheduleQueryPropertiesGroupByTagArgs',
    'ScheduleQueryPropertiesGroupByTagArgsDict',
    'ScheduleResultLocationArgs',
    'ScheduleResultLocationArgsDict',
    'UsageCarbonEmissionGroupByTagArgs',
    'UsageCarbonEmissionGroupByTagArgsDict',
    'UsageCarbonEmissionItemArgs',
    'UsageCarbonEmissionItemArgsDict',
    'UsageCarbonEmissionItemTagArgs',
    'UsageCarbonEmissionItemTagArgsDict',
    'UsageCarbonEmissionsQueryQueryDefinitionArgs',
    'UsageCarbonEmissionsQueryQueryDefinitionArgsDict',
    'UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs',
    'UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgsDict',
    'UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs',
    'UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgsDict',
    'UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs',
    'UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgsDict',
    'UsageForecastArgs',
    'UsageForecastArgsDict',
    'UsageGroupByTagArgs',
    'UsageGroupByTagArgsDict',
    'UsageItemArgs',
    'UsageItemArgsDict',
    'UsageItemTagArgs',
    'UsageItemTagArgsDict',
    'UsageStatementEmailRecipientsGroupRecipientsListArgs',
    'UsageStatementEmailRecipientsGroupRecipientsListArgsDict',
    'GetCustomTablesFilterArgs',
    'GetCustomTablesFilterArgsDict',
    'GetQueriesFilterArgs',
    'GetQueriesFilterArgsDict',
    'GetScheduledRunsFilterArgs',
    'GetScheduledRunsFilterArgsDict',
    'GetSchedulesFilterArgs',
    'GetSchedulesFilterArgsDict',
    'GetUsageCarbonEmissionsQueriesFilterArgs',
    'GetUsageCarbonEmissionsQueriesFilterArgsDict',
    'GetUsageStatementEmailRecipientsGroupsFilterArgs',
    'GetUsageStatementEmailRecipientsGroupsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CustomTableSavedCustomTableArgsDict(TypedDict):
        display_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the custom table.
        """
        column_group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The column groupBy key list. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        compartment_depth: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The compartment depth level.
        """
        group_by_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomTableSavedCustomTableGroupByTagArgsDict']]]]
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        row_group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The row groupBy key list. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        version: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The version of the custom table.
        """
elif False:
    CustomTableSavedCustomTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTableSavedCustomTableArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[_builtins.str],
                 column_group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 compartment_depth: Optional[pulumi.Input[_builtins.float]] = None,
                 group_by_tags: Optional[pulumi.Input[Sequence[pulumi.Input['CustomTableSavedCustomTableGroupByTagArgs']]]] = None,
                 row_group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 version: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The name of the custom table.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] column_group_bies: (Updatable) The column groupBy key list. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[_builtins.float] compartment_depth: (Updatable) The compartment depth level.
        :param pulumi.Input[Sequence[pulumi.Input['CustomTableSavedCustomTableGroupByTagArgs']]] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] row_group_bies: (Updatable) The row groupBy key list. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[_builtins.float] version: (Updatable) The version of the custom table.
        """
        pulumi.set(__self__, "display_name", display_name)
        if column_group_bies is not None:
            pulumi.set(__self__, "column_group_bies", column_group_bies)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if row_group_bies is not None:
            pulumi.set(__self__, "row_group_bies", row_group_bies)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the custom table.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="columnGroupBies")
    def column_group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The column groupBy key list. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "column_group_bies")

    @column_group_bies.setter
    def column_group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "column_group_bies", value)

    @_builtins.property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @compartment_depth.setter
    def compartment_depth(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "compartment_depth", value)

    @_builtins.property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomTableSavedCustomTableGroupByTagArgs']]]]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @group_by_tags.setter
    def group_by_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomTableSavedCustomTableGroupByTagArgs']]]]):
        pulumi.set(self, "group_by_tags", value)

    @_builtins.property
    @pulumi.getter(name="rowGroupBies")
    def row_group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The row groupBy key list. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "row_group_bies")

    @row_group_bies.setter
    def row_group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "row_group_bies", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The version of the custom table.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class CustomTableSavedCustomTableGroupByTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag value.
        """
elif False:
    CustomTableSavedCustomTableGroupByTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTableSavedCustomTableGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) The tag key.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The tag namespace.
        :param pulumi.Input[_builtins.str] value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class QueryQueryDefinitionArgsDict(TypedDict):
        cost_analysis_ui: pulumi.Input['QueryQueryDefinitionCostAnalysisUiArgsDict']
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        report_query: pulumi.Input['QueryQueryDefinitionReportQueryArgsDict']
        """
        (Updatable) The request of the generated Cost Analysis report.
        """
        version: pulumi.Input[_builtins.float]
        """
        (Updatable) The saved query version.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    QueryQueryDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryQueryDefinitionArgs:
    def __init__(__self__, *,
                 cost_analysis_ui: pulumi.Input['QueryQueryDefinitionCostAnalysisUiArgs'],
                 display_name: pulumi.Input[_builtins.str],
                 report_query: pulumi.Input['QueryQueryDefinitionReportQueryArgs'],
                 version: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input['QueryQueryDefinitionCostAnalysisUiArgs'] cost_analysis_ui: (Updatable) The common fields for Cost Analysis UI rendering.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The query display name. Avoid entering confidential information.
        :param pulumi.Input['QueryQueryDefinitionReportQueryArgs'] report_query: (Updatable) The request of the generated Cost Analysis report.
        :param pulumi.Input[_builtins.float] version: (Updatable) The saved query version.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "cost_analysis_ui", cost_analysis_ui)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_query", report_query)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="costAnalysisUi")
    def cost_analysis_ui(self) -> pulumi.Input['QueryQueryDefinitionCostAnalysisUiArgs']:
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_ui")

    @cost_analysis_ui.setter
    def cost_analysis_ui(self, value: pulumi.Input['QueryQueryDefinitionCostAnalysisUiArgs']):
        pulumi.set(self, "cost_analysis_ui", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="reportQuery")
    def report_query(self) -> pulumi.Input['QueryQueryDefinitionReportQueryArgs']:
        """
        (Updatable) The request of the generated Cost Analysis report.
        """
        return pulumi.get(self, "report_query")

    @report_query.setter
    def report_query(self, value: pulumi.Input['QueryQueryDefinitionReportQueryArgs']):
        pulumi.set(self, "report_query", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.float]:
        """
        (Updatable) The saved query version.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "version", value)


if not MYPY:
    class QueryQueryDefinitionCostAnalysisUiArgsDict(TypedDict):
        graph: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The graph type.
        """
        is_cumulative_graph: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) A cumulative graph.
        """
elif False:
    QueryQueryDefinitionCostAnalysisUiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryQueryDefinitionCostAnalysisUiArgs:
    def __init__(__self__, *,
                 graph: Optional[pulumi.Input[_builtins.str]] = None,
                 is_cumulative_graph: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] graph: (Updatable) The graph type.
        :param pulumi.Input[_builtins.bool] is_cumulative_graph: (Updatable) A cumulative graph.
        """
        if graph is not None:
            pulumi.set(__self__, "graph", graph)
        if is_cumulative_graph is not None:
            pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @_builtins.property
    @pulumi.getter
    def graph(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The graph type.
        """
        return pulumi.get(self, "graph")

    @graph.setter
    def graph(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "graph", value)

    @_builtins.property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")

    @is_cumulative_graph.setter
    def is_cumulative_graph(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_cumulative_graph", value)


if not MYPY:
    class QueryQueryDefinitionReportQueryArgsDict(TypedDict):
        granularity: pulumi.Input[_builtins.str]
        """
        (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        """
        tenant_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Tenant ID.
        """
        compartment_depth: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The compartment depth level.
        """
        date_range_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The filter object for query usage.
        """
        forecast: NotRequired[pulumi.Input['QueryQueryDefinitionReportQueryForecastArgsDict']]
        """
        (Updatable) Forecast configuration of usage/cost.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        group_by_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['QueryQueryDefinitionReportQueryGroupByTagArgsDict']]]]
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        is_aggregate_by_time: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        query_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The query usage type. COST by default if it is missing.
        * Usage: Query the usage data.
        * Cost: Query the cost/billing data.
        * Credit: Query the credit adjustments data.
        * ExpiredCredit: Query the expired credits data.
        * AllCredit: Query the credit adjustments and expired credit.
        """
        time_usage_ended: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The usage end time.
        """
        time_usage_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The usage start time.
        """
elif False:
    QueryQueryDefinitionReportQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryQueryDefinitionReportQueryArgs:
    def __init__(__self__, *,
                 granularity: pulumi.Input[_builtins.str],
                 tenant_id: pulumi.Input[_builtins.str],
                 compartment_depth: Optional[pulumi.Input[_builtins.float]] = None,
                 date_range_name: Optional[pulumi.Input[_builtins.str]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 forecast: Optional[pulumi.Input['QueryQueryDefinitionReportQueryForecastArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_by_tags: Optional[pulumi.Input[Sequence[pulumi.Input['QueryQueryDefinitionReportQueryGroupByTagArgs']]]] = None,
                 is_aggregate_by_time: Optional[pulumi.Input[_builtins.bool]] = None,
                 query_type: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_ended: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] granularity: (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        :param pulumi.Input[_builtins.str] tenant_id: (Updatable) Tenant ID.
        :param pulumi.Input[_builtins.float] compartment_depth: (Updatable) The compartment depth level.
        :param pulumi.Input[_builtins.str] date_range_name: (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        :param pulumi.Input[_builtins.str] filter: (Updatable) The filter object for query usage.
        :param pulumi.Input['QueryQueryDefinitionReportQueryForecastArgs'] forecast: (Updatable) Forecast configuration of usage/cost.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[Sequence[pulumi.Input['QueryQueryDefinitionReportQueryGroupByTagArgs']]] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param pulumi.Input[_builtins.bool] is_aggregate_by_time: (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param pulumi.Input[_builtins.str] query_type: (Updatable) The query usage type. COST by default if it is missing.
               * Usage: Query the usage data.
               * Cost: Query the cost/billing data.
               * Credit: Query the credit adjustments data.
               * ExpiredCredit: Query the expired credits data.
               * AllCredit: Query the credit adjustments and expired credit.
        :param pulumi.Input[_builtins.str] time_usage_ended: (Updatable) The usage end time.
        :param pulumi.Input[_builtins.str] time_usage_started: (Updatable) The usage start time.
        """
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if date_range_name is not None:
            pulumi.set(__self__, "date_range_name", date_range_name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if forecast is not None:
            pulumi.set(__self__, "forecast", forecast)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @_builtins.property
    @pulumi.getter
    def granularity(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "granularity", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @compartment_depth.setter
    def compartment_depth(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "compartment_depth", value)

    @_builtins.property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        """
        return pulumi.get(self, "date_range_name")

    @date_range_name.setter
    def date_range_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date_range_name", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def forecast(self) -> Optional[pulumi.Input['QueryQueryDefinitionReportQueryForecastArgs']]:
        """
        (Updatable) Forecast configuration of usage/cost.
        """
        return pulumi.get(self, "forecast")

    @forecast.setter
    def forecast(self, value: Optional[pulumi.Input['QueryQueryDefinitionReportQueryForecastArgs']]):
        pulumi.set(self, "forecast", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['QueryQueryDefinitionReportQueryGroupByTagArgs']]]]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @group_by_tags.setter
    def group_by_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['QueryQueryDefinitionReportQueryGroupByTagArgs']]]]):
        pulumi.set(self, "group_by_tags", value)

    @_builtins.property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @is_aggregate_by_time.setter
    def is_aggregate_by_time(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_aggregate_by_time", value)

    @_builtins.property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The query usage type. COST by default if it is missing.
        * Usage: Query the usage data.
        * Cost: Query the cost/billing data.
        * Credit: Query the credit adjustments data.
        * ExpiredCredit: Query the expired credits data.
        * AllCredit: Query the credit adjustments and expired credit.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_type", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_ended", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_started", value)


if not MYPY:
    class QueryQueryDefinitionReportQueryForecastArgsDict(TypedDict):
        time_forecast_ended: pulumi.Input[_builtins.str]
        """
        (Updatable) The forecast end time.
        """
        forecast_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        time_forecast_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
elif False:
    QueryQueryDefinitionReportQueryForecastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryQueryDefinitionReportQueryForecastArgs:
    def __init__(__self__, *,
                 time_forecast_ended: pulumi.Input[_builtins.str],
                 forecast_type: Optional[pulumi.Input[_builtins.str]] = None,
                 time_forecast_started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_forecast_ended: (Updatable) The forecast end time.
        :param pulumi.Input[_builtins.str] forecast_type: (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param pulumi.Input[_builtins.str] time_forecast_started: (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        if forecast_type is not None:
            pulumi.set(__self__, "forecast_type", forecast_type)
        if time_forecast_started is not None:
            pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @_builtins.property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @time_forecast_ended.setter
    def time_forecast_ended(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_forecast_ended", value)

    @_builtins.property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @forecast_type.setter
    def forecast_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forecast_type", value)

    @_builtins.property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")

    @time_forecast_started.setter
    def time_forecast_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_forecast_started", value)


if not MYPY:
    class QueryQueryDefinitionReportQueryGroupByTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag value.
        """
elif False:
    QueryQueryDefinitionReportQueryGroupByTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryQueryDefinitionReportQueryGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) The tag key.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The tag namespace.
        :param pulumi.Input[_builtins.str] value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduleQueryPropertiesArgsDict(TypedDict):
        date_range: pulumi.Input['ScheduleQueryPropertiesDateRangeArgsDict']
        """
        Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        """
        granularity: pulumi.Input[_builtins.str]
        """
        The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        """
        compartment_depth: NotRequired[pulumi.Input[_builtins.float]]
        """
        The depth level of the compartment.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter object for query usage.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        """
        group_by_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduleQueryPropertiesGroupByTagArgsDict']]]]
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        """
        is_aggregate_by_time: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        query_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
elif False:
    ScheduleQueryPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleQueryPropertiesArgs:
    def __init__(__self__, *,
                 date_range: pulumi.Input['ScheduleQueryPropertiesDateRangeArgs'],
                 granularity: pulumi.Input[_builtins.str],
                 compartment_depth: Optional[pulumi.Input[_builtins.float]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_by_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleQueryPropertiesGroupByTagArgs']]]] = None,
                 is_aggregate_by_time: Optional[pulumi.Input[_builtins.bool]] = None,
                 query_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ScheduleQueryPropertiesDateRangeArgs'] date_range: Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        :param pulumi.Input[_builtins.str] granularity: The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        :param pulumi.Input[_builtins.float] compartment_depth: The depth level of the compartment.
        :param pulumi.Input[_builtins.str] filter: The filter object for query usage.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleQueryPropertiesGroupByTagArgs']]] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        :param pulumi.Input[_builtins.bool] is_aggregate_by_time: Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param pulumi.Input[_builtins.str] query_type: The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        pulumi.set(__self__, "date_range", date_range)
        pulumi.set(__self__, "granularity", granularity)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @_builtins.property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> pulumi.Input['ScheduleQueryPropertiesDateRangeArgs']:
        """
        Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        """
        return pulumi.get(self, "date_range")

    @date_range.setter
    def date_range(self, value: pulumi.Input['ScheduleQueryPropertiesDateRangeArgs']):
        pulumi.set(self, "date_range", value)

    @_builtins.property
    @pulumi.getter
    def granularity(self) -> pulumi.Input[_builtins.str]:
        """
        The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "granularity", value)

    @_builtins.property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The depth level of the compartment.
        """
        return pulumi.get(self, "compartment_depth")

    @compartment_depth.setter
    def compartment_depth(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "compartment_depth", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleQueryPropertiesGroupByTagArgs']]]]:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        """
        return pulumi.get(self, "group_by_tags")

    @group_by_tags.setter
    def group_by_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleQueryPropertiesGroupByTagArgs']]]]):
        pulumi.set(self, "group_by_tags", value)

    @_builtins.property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @is_aggregate_by_time.setter
    def is_aggregate_by_time(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_aggregate_by_time", value)

    @_builtins.property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_type", value)


if not MYPY:
    class ScheduleQueryPropertiesDateRangeArgsDict(TypedDict):
        date_range_type: pulumi.Input[_builtins.str]
        """
        Defines whether the schedule date range is STATIC or DYNAMIC.
        """
        dynamic_date_range_type: NotRequired[pulumi.Input[_builtins.str]]
        time_usage_ended: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage end time.
        """
        time_usage_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage start time.
        """
elif False:
    ScheduleQueryPropertiesDateRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleQueryPropertiesDateRangeArgs:
    def __init__(__self__, *,
                 date_range_type: pulumi.Input[_builtins.str],
                 dynamic_date_range_type: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_ended: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] date_range_type: Defines whether the schedule date range is STATIC or DYNAMIC.
        :param pulumi.Input[_builtins.str] time_usage_ended: The usage end time.
        :param pulumi.Input[_builtins.str] time_usage_started: The usage start time.
        """
        pulumi.set(__self__, "date_range_type", date_range_type)
        if dynamic_date_range_type is not None:
            pulumi.set(__self__, "dynamic_date_range_type", dynamic_date_range_type)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @_builtins.property
    @pulumi.getter(name="dateRangeType")
    def date_range_type(self) -> pulumi.Input[_builtins.str]:
        """
        Defines whether the schedule date range is STATIC or DYNAMIC.
        """
        return pulumi.get(self, "date_range_type")

    @date_range_type.setter
    def date_range_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "date_range_type", value)

    @_builtins.property
    @pulumi.getter(name="dynamicDateRangeType")
    def dynamic_date_range_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dynamic_date_range_type")

    @dynamic_date_range_type.setter
    def dynamic_date_range_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dynamic_date_range_type", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_ended", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_started", value)


if not MYPY:
    class ScheduleQueryPropertiesGroupByTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag value.
        """
elif False:
    ScheduleQueryPropertiesGroupByTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleQueryPropertiesGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] namespace: The tag namespace.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScheduleResultLocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) The bucket name where usage or cost CSVs will be uploaded.
        """
        location_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) The namespace needed to determine the object storage bucket.
        """
        region: pulumi.Input[_builtins.str]
        """
        (Updatable) The destination Object Store Region specified by the customer.
        """
elif False:
    ScheduleResultLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleResultLocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 location_type: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The bucket name where usage or cost CSVs will be uploaded.
        :param pulumi.Input[_builtins.str] location_type: (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The namespace needed to determine the object storage bucket.
        :param pulumi.Input[_builtins.str] region: (Updatable) The destination Object Store Region specified by the customer.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The bucket name where usage or cost CSVs will be uploaded.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
        """
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location_type", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The namespace needed to determine the object storage bucket.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The destination Object Store Region specified by the customer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class UsageCarbonEmissionGroupByTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag value.
        """
elif False:
    UsageCarbonEmissionGroupByTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] namespace: The tag namespace.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsageCarbonEmissionItemArgsDict(TypedDict):
        ad: NotRequired[pulumi.Input[_builtins.str]]
        """
        The availability domain of the usage.
        """
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compartment OCID.
        """
        compartment_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compartment name.
        """
        compartment_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compartment path, starting from root.
        """
        computed_carbon_emission: NotRequired[pulumi.Input[_builtins.float]]
        """
        The carbon emission usage in MTCO2 units.
        """
        emission_calculation_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the method used for emission calculation, such as POWER_BASED or SPEND_BASED
        """
        emission_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of emission, such as MARKET_BASED or LOCATION_BASED.
        """
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        Platform for the cost.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the usage.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource OCID that is incurring the cost.
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource name that is incurring the cost.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service name that is incurring the cost.
        """
        sku_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SKU friendly name.
        """
        sku_part_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SKU part number.
        """
        subscription_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subscription ID.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionItemTagArgsDict']]]]
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tenant ID.
        """
        tenant_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenancy name.
        """
        time_usage_ended: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage end time.
        """
        time_usage_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage start time.
        """
elif False:
    UsageCarbonEmissionItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionItemArgs:
    def __init__(__self__, *,
                 ad: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_name: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_path: Optional[pulumi.Input[_builtins.str]] = None,
                 computed_carbon_emission: Optional[pulumi.Input[_builtins.float]] = None,
                 emission_calculation_method: Optional[pulumi.Input[_builtins.str]] = None,
                 emission_type: Optional[pulumi.Input[_builtins.str]] = None,
                 platform: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 sku_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sku_part_number: Optional[pulumi.Input[_builtins.str]] = None,
                 subscription_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionItemTagArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_name: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_ended: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ad: The availability domain of the usage.
        :param pulumi.Input[_builtins.str] compartment_id: The compartment OCID.
        :param pulumi.Input[_builtins.str] compartment_name: The compartment name.
        :param pulumi.Input[_builtins.str] compartment_path: The compartment path, starting from root.
        :param pulumi.Input[_builtins.float] computed_carbon_emission: The carbon emission usage in MTCO2 units.
        :param pulumi.Input[_builtins.str] emission_calculation_method: Specifies the method used for emission calculation, such as POWER_BASED or SPEND_BASED
        :param pulumi.Input[_builtins.str] emission_type: Specifies the type of emission, such as MARKET_BASED or LOCATION_BASED.
        :param pulumi.Input[_builtins.str] platform: Platform for the cost.
        :param pulumi.Input[_builtins.str] region: The region of the usage.
        :param pulumi.Input[_builtins.str] resource_id: The resource OCID that is incurring the cost.
        :param pulumi.Input[_builtins.str] resource_name: The resource name that is incurring the cost.
        :param pulumi.Input[_builtins.str] service: The service name that is incurring the cost.
        :param pulumi.Input[_builtins.str] sku_name: The SKU friendly name.
        :param pulumi.Input[_builtins.str] sku_part_number: The SKU part number.
        :param pulumi.Input[_builtins.str] subscription_id: The subscription ID.
        :param pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionItemTagArgs']]] tags: For grouping, a tag definition. For filtering, a definition and key.
        :param pulumi.Input[_builtins.str] tenant_id: Tenant ID.
        :param pulumi.Input[_builtins.str] tenant_name: The tenancy name.
        :param pulumi.Input[_builtins.str] time_usage_ended: The usage end time.
        :param pulumi.Input[_builtins.str] time_usage_started: The usage start time.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if compartment_name is not None:
            pulumi.set(__self__, "compartment_name", compartment_name)
        if compartment_path is not None:
            pulumi.set(__self__, "compartment_path", compartment_path)
        if computed_carbon_emission is not None:
            pulumi.set(__self__, "computed_carbon_emission", computed_carbon_emission)
        if emission_calculation_method is not None:
            pulumi.set(__self__, "emission_calculation_method", emission_calculation_method)
        if emission_type is not None:
            pulumi.set(__self__, "emission_type", emission_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if sku_part_number is not None:
            pulumi.set(__self__, "sku_part_number", sku_part_number)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @_builtins.property
    @pulumi.getter
    def ad(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The availability domain of the usage.
        """
        return pulumi.get(self, "ad")

    @ad.setter
    def ad(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ad", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="compartmentName")
    def compartment_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compartment name.
        """
        return pulumi.get(self, "compartment_name")

    @compartment_name.setter
    def compartment_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_name", value)

    @_builtins.property
    @pulumi.getter(name="compartmentPath")
    def compartment_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compartment path, starting from root.
        """
        return pulumi.get(self, "compartment_path")

    @compartment_path.setter
    def compartment_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_path", value)

    @_builtins.property
    @pulumi.getter(name="computedCarbonEmission")
    def computed_carbon_emission(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The carbon emission usage in MTCO2 units.
        """
        return pulumi.get(self, "computed_carbon_emission")

    @computed_carbon_emission.setter
    def computed_carbon_emission(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "computed_carbon_emission", value)

    @_builtins.property
    @pulumi.getter(name="emissionCalculationMethod")
    def emission_calculation_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the method used for emission calculation, such as POWER_BASED or SPEND_BASED
        """
        return pulumi.get(self, "emission_calculation_method")

    @emission_calculation_method.setter
    def emission_calculation_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "emission_calculation_method", value)

    @_builtins.property
    @pulumi.getter(name="emissionType")
    def emission_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of emission, such as MARKET_BASED or LOCATION_BASED.
        """
        return pulumi.get(self, "emission_type")

    @emission_type.setter
    def emission_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "emission_type", value)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Platform for the cost.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the usage.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource OCID that is incurring the cost.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource name that is incurring the cost.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service name that is incurring the cost.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SKU friendly name.
        """
        return pulumi.get(self, "sku_name")

    @sku_name.setter
    def sku_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sku_name", value)

    @_builtins.property
    @pulumi.getter(name="skuPartNumber")
    def sku_part_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SKU part number.
        """
        return pulumi.get(self, "sku_part_number")

    @sku_part_number.setter
    def sku_part_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sku_part_number", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subscription_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionItemTagArgs']]]]:
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionItemTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenancy name.
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_name", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_ended", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_started", value)


if not MYPY:
    class UsageCarbonEmissionItemTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag value.
        """
elif False:
    UsageCarbonEmissionItemTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionItemTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] namespace: The tag namespace.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsageCarbonEmissionsQueryQueryDefinitionArgsDict(TypedDict):
        cost_analysis_ui: pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgsDict']
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        report_query: pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgsDict']
        """
        (Updatable) The request of the generated carbon emissions usage report.
        """
        version: pulumi.Input[_builtins.int]
        """
        (Updatable) The saved query version.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    UsageCarbonEmissionsQueryQueryDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionsQueryQueryDefinitionArgs:
    def __init__(__self__, *,
                 cost_analysis_ui: pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs'],
                 display_name: pulumi.Input[_builtins.str],
                 report_query: pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs'],
                 version: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs'] cost_analysis_ui: (Updatable) The common fields for Cost Analysis UI rendering.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The query display name. Avoid entering confidential information.
        :param pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs'] report_query: (Updatable) The request of the generated carbon emissions usage report.
        :param pulumi.Input[_builtins.int] version: (Updatable) The saved query version.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "cost_analysis_ui", cost_analysis_ui)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_query", report_query)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="costAnalysisUi")
    def cost_analysis_ui(self) -> pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs']:
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_ui")

    @cost_analysis_ui.setter
    def cost_analysis_ui(self, value: pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs']):
        pulumi.set(self, "cost_analysis_ui", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="reportQuery")
    def report_query(self) -> pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs']:
        """
        (Updatable) The request of the generated carbon emissions usage report.
        """
        return pulumi.get(self, "report_query")

    @report_query.setter
    def report_query(self, value: pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs']):
        pulumi.set(self, "report_query", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The saved query version.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "version", value)


if not MYPY:
    class UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgsDict(TypedDict):
        graph: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The graph type.
        """
        is_cumulative_graph: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) A cumulative graph.
        """
elif False:
    UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs:
    def __init__(__self__, *,
                 graph: Optional[pulumi.Input[_builtins.str]] = None,
                 is_cumulative_graph: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] graph: (Updatable) The graph type.
        :param pulumi.Input[_builtins.bool] is_cumulative_graph: (Updatable) A cumulative graph.
        """
        if graph is not None:
            pulumi.set(__self__, "graph", graph)
        if is_cumulative_graph is not None:
            pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @_builtins.property
    @pulumi.getter
    def graph(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The graph type.
        """
        return pulumi.get(self, "graph")

    @graph.setter
    def graph(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "graph", value)

    @_builtins.property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")

    @is_cumulative_graph.setter
    def is_cumulative_graph(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_cumulative_graph", value)


if not MYPY:
    class UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgsDict(TypedDict):
        tenant_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Tenant ID.
        """
        compartment_depth: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The compartment depth level.
        """
        date_range_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The user interface date range, for example, LAST_THREE_MONTHS. Overrides the timeUsageStarted and timeUsageEnded properties.
        """
        emission_calculation_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies the method used for emission calculation, such as POWER_BASED or SPEND_BASED
        """
        emission_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies the type of emission, such as MARKET_BASED or LOCATION_BASED.
        """
        granularity: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The carbon emission granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        group_by_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgsDict']]]]
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        is_aggregate_by_time: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or costs over the query time period are summed.
        """
        time_usage_ended: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The usage end time.
        """
        time_usage_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The usage start time.
        """
        usage_carbon_emissions_query_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The filter object for query usage.
        """
elif False:
    UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs:
    def __init__(__self__, *,
                 tenant_id: pulumi.Input[_builtins.str],
                 compartment_depth: Optional[pulumi.Input[_builtins.int]] = None,
                 date_range_name: Optional[pulumi.Input[_builtins.str]] = None,
                 emission_calculation_method: Optional[pulumi.Input[_builtins.str]] = None,
                 emission_type: Optional[pulumi.Input[_builtins.str]] = None,
                 granularity: Optional[pulumi.Input[_builtins.str]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_by_tags: Optional[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs']]]] = None,
                 is_aggregate_by_time: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_usage_ended: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_started: Optional[pulumi.Input[_builtins.str]] = None,
                 usage_carbon_emissions_query_filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tenant_id: (Updatable) Tenant ID.
        :param pulumi.Input[_builtins.int] compartment_depth: (Updatable) The compartment depth level.
        :param pulumi.Input[_builtins.str] date_range_name: (Updatable) The user interface date range, for example, LAST_THREE_MONTHS. Overrides the timeUsageStarted and timeUsageEnded properties.
        :param pulumi.Input[_builtins.str] emission_calculation_method: (Updatable) Specifies the method used for emission calculation, such as POWER_BASED or SPEND_BASED
        :param pulumi.Input[_builtins.str] emission_type: (Updatable) Specifies the type of emission, such as MARKET_BASED or LOCATION_BASED.
        :param pulumi.Input[_builtins.str] granularity: (Updatable) The carbon emission granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs']]] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param pulumi.Input[_builtins.bool] is_aggregate_by_time: (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or costs over the query time period are summed.
        :param pulumi.Input[_builtins.str] time_usage_ended: (Updatable) The usage end time.
        :param pulumi.Input[_builtins.str] time_usage_started: (Updatable) The usage start time.
        :param pulumi.Input[_builtins.str] usage_carbon_emissions_query_filter: (Updatable) The filter object for query usage.
        """
        pulumi.set(__self__, "tenant_id", tenant_id)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if date_range_name is not None:
            pulumi.set(__self__, "date_range_name", date_range_name)
        if emission_calculation_method is not None:
            pulumi.set(__self__, "emission_calculation_method", emission_calculation_method)
        if emission_type is not None:
            pulumi.set(__self__, "emission_type", emission_type)
        if granularity is not None:
            pulumi.set(__self__, "granularity", granularity)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)
        if usage_carbon_emissions_query_filter is not None:
            pulumi.set(__self__, "usage_carbon_emissions_query_filter", usage_carbon_emissions_query_filter)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @compartment_depth.setter
    def compartment_depth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "compartment_depth", value)

    @_builtins.property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The user interface date range, for example, LAST_THREE_MONTHS. Overrides the timeUsageStarted and timeUsageEnded properties.
        """
        return pulumi.get(self, "date_range_name")

    @date_range_name.setter
    def date_range_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date_range_name", value)

    @_builtins.property
    @pulumi.getter(name="emissionCalculationMethod")
    def emission_calculation_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies the method used for emission calculation, such as POWER_BASED or SPEND_BASED
        """
        return pulumi.get(self, "emission_calculation_method")

    @emission_calculation_method.setter
    def emission_calculation_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "emission_calculation_method", value)

    @_builtins.property
    @pulumi.getter(name="emissionType")
    def emission_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies the type of emission, such as MARKET_BASED or LOCATION_BASED.
        """
        return pulumi.get(self, "emission_type")

    @emission_type.setter
    def emission_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "emission_type", value)

    @_builtins.property
    @pulumi.getter
    def granularity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The carbon emission granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation.
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "granularity", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs']]]]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @group_by_tags.setter
    def group_by_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs']]]]):
        pulumi.set(self, "group_by_tags", value)

    @_builtins.property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or costs over the query time period are summed.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @is_aggregate_by_time.setter
    def is_aggregate_by_time(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_aggregate_by_time", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_ended", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_started", value)

    @_builtins.property
    @pulumi.getter(name="usageCarbonEmissionsQueryFilter")
    def usage_carbon_emissions_query_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The filter object for query usage.
        """
        return pulumi.get(self, "usage_carbon_emissions_query_filter")

    @usage_carbon_emissions_query_filter.setter
    def usage_carbon_emissions_query_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "usage_carbon_emissions_query_filter", value)


if not MYPY:
    class UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tag value.
        """
elif False:
    UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: (Updatable) The tag key.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The tag namespace.
        :param pulumi.Input[_builtins.str] value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsageForecastArgsDict(TypedDict):
        time_forecast_ended: pulumi.Input[_builtins.str]
        """
        The forecast end time.
        """
        forecast_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        time_forecast_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        The forecast start time. Defaults to UTC-1 if not specified.
        """
elif False:
    UsageForecastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageForecastArgs:
    def __init__(__self__, *,
                 time_forecast_ended: pulumi.Input[_builtins.str],
                 forecast_type: Optional[pulumi.Input[_builtins.str]] = None,
                 time_forecast_started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_forecast_ended: The forecast end time.
        :param pulumi.Input[_builtins.str] forecast_type: BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param pulumi.Input[_builtins.str] time_forecast_started: The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        if forecast_type is not None:
            pulumi.set(__self__, "forecast_type", forecast_type)
        if time_forecast_started is not None:
            pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @_builtins.property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> pulumi.Input[_builtins.str]:
        """
        The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @time_forecast_ended.setter
    def time_forecast_ended(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_forecast_ended", value)

    @_builtins.property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @forecast_type.setter
    def forecast_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forecast_type", value)

    @_builtins.property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")

    @time_forecast_started.setter
    def time_forecast_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_forecast_started", value)


if not MYPY:
    class UsageGroupByTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag value.
        """
elif False:
    UsageGroupByTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] namespace: The tag namespace.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsageItemArgsDict(TypedDict):
        ad: NotRequired[pulumi.Input[_builtins.str]]
        """
        The availability domain of the usage.
        """
        attributed_cost: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attributed cost with a max value of 9999999999.999999999999 and a minimum value of 0.
        """
        attributed_usage: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attributed usage with a max value of 9999999999.999999999999 and a minimum value of 0.
        """
        compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compartment OCID.
        """
        compartment_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compartment name.
        """
        compartment_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compartment path, starting from root.
        """
        computed_amount: NotRequired[pulumi.Input[_builtins.float]]
        """
        The computed cost.
        """
        computed_quantity: NotRequired[pulumi.Input[_builtins.float]]
        """
        The usage number.
        """
        currency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The price currency.
        """
        discount: NotRequired[pulumi.Input[_builtins.float]]
        """
        The discretionary discount applied to the SKU.
        """
        is_forecast: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The forecasted data.
        """
        list_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The SKU list rate (not discount).
        """
        overage: NotRequired[pulumi.Input[_builtins.str]]
        """
        The overage usage.
        """
        overages_flag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SPM OverageFlag.
        """
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        Platform for the cost.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the usage.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource OCID that is incurring the cost.
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource name that is incurring the cost.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service name that is incurring the cost.
        """
        shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource shape.
        """
        sku_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SKU friendly name.
        """
        sku_part_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SKU part number.
        """
        subscription_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subscription ID.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsageItemTagArgsDict']]]]
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tenant ID.
        """
        tenant_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenancy name.
        """
        time_usage_ended: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage end time.
        """
        time_usage_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage start time.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The usage unit.
        """
        unit_price: NotRequired[pulumi.Input[_builtins.float]]
        """
        The price per unit.
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The resource size being metered.
        """
elif False:
    UsageItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageItemArgs:
    def __init__(__self__, *,
                 ad: Optional[pulumi.Input[_builtins.str]] = None,
                 attributed_cost: Optional[pulumi.Input[_builtins.str]] = None,
                 attributed_usage: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_name: Optional[pulumi.Input[_builtins.str]] = None,
                 compartment_path: Optional[pulumi.Input[_builtins.str]] = None,
                 computed_amount: Optional[pulumi.Input[_builtins.float]] = None,
                 computed_quantity: Optional[pulumi.Input[_builtins.float]] = None,
                 currency: Optional[pulumi.Input[_builtins.str]] = None,
                 discount: Optional[pulumi.Input[_builtins.float]] = None,
                 is_forecast: Optional[pulumi.Input[_builtins.bool]] = None,
                 list_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 overage: Optional[pulumi.Input[_builtins.str]] = None,
                 overages_flag: Optional[pulumi.Input[_builtins.str]] = None,
                 platform: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 shape: Optional[pulumi.Input[_builtins.str]] = None,
                 sku_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sku_part_number: Optional[pulumi.Input[_builtins.str]] = None,
                 subscription_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['UsageItemTagArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_name: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_ended: Optional[pulumi.Input[_builtins.str]] = None,
                 time_usage_started: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_price: Optional[pulumi.Input[_builtins.float]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] ad: The availability domain of the usage.
        :param pulumi.Input[_builtins.str] attributed_cost: The attributed cost with a max value of 9999999999.999999999999 and a minimum value of 0.
        :param pulumi.Input[_builtins.str] attributed_usage: The attributed usage with a max value of 9999999999.999999999999 and a minimum value of 0.
        :param pulumi.Input[_builtins.str] compartment_id: The compartment OCID.
        :param pulumi.Input[_builtins.str] compartment_name: The compartment name.
        :param pulumi.Input[_builtins.str] compartment_path: The compartment path, starting from root.
        :param pulumi.Input[_builtins.float] computed_amount: The computed cost.
        :param pulumi.Input[_builtins.float] computed_quantity: The usage number.
        :param pulumi.Input[_builtins.str] currency: The price currency.
        :param pulumi.Input[_builtins.float] discount: The discretionary discount applied to the SKU.
        :param pulumi.Input[_builtins.bool] is_forecast: The forecasted data.
        :param pulumi.Input[_builtins.float] list_rate: The SKU list rate (not discount).
        :param pulumi.Input[_builtins.str] overage: The overage usage.
        :param pulumi.Input[_builtins.str] overages_flag: The SPM OverageFlag.
        :param pulumi.Input[_builtins.str] platform: Platform for the cost.
        :param pulumi.Input[_builtins.str] region: The region of the usage.
        :param pulumi.Input[_builtins.str] resource_id: The resource OCID that is incurring the cost.
        :param pulumi.Input[_builtins.str] resource_name: The resource name that is incurring the cost.
        :param pulumi.Input[_builtins.str] service: The service name that is incurring the cost.
        :param pulumi.Input[_builtins.str] shape: The resource shape.
        :param pulumi.Input[_builtins.str] sku_name: The SKU friendly name.
        :param pulumi.Input[_builtins.str] sku_part_number: The SKU part number.
        :param pulumi.Input[_builtins.str] subscription_id: The subscription ID.
        :param pulumi.Input[Sequence[pulumi.Input['UsageItemTagArgs']]] tags: For grouping, a tag definition. For filtering, a definition and key.
        :param pulumi.Input[_builtins.str] tenant_id: Tenant ID.
        :param pulumi.Input[_builtins.str] tenant_name: The tenancy name.
        :param pulumi.Input[_builtins.str] time_usage_ended: The usage end time.
        :param pulumi.Input[_builtins.str] time_usage_started: The usage start time.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] unit: The usage unit.
        :param pulumi.Input[_builtins.float] unit_price: The price per unit.
        :param pulumi.Input[_builtins.float] weight: The resource size being metered.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if attributed_cost is not None:
            pulumi.set(__self__, "attributed_cost", attributed_cost)
        if attributed_usage is not None:
            pulumi.set(__self__, "attributed_usage", attributed_usage)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if compartment_name is not None:
            pulumi.set(__self__, "compartment_name", compartment_name)
        if compartment_path is not None:
            pulumi.set(__self__, "compartment_path", compartment_path)
        if computed_amount is not None:
            pulumi.set(__self__, "computed_amount", computed_amount)
        if computed_quantity is not None:
            pulumi.set(__self__, "computed_quantity", computed_quantity)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if discount is not None:
            pulumi.set(__self__, "discount", discount)
        if is_forecast is not None:
            pulumi.set(__self__, "is_forecast", is_forecast)
        if list_rate is not None:
            pulumi.set(__self__, "list_rate", list_rate)
        if overage is not None:
            pulumi.set(__self__, "overage", overage)
        if overages_flag is not None:
            pulumi.set(__self__, "overages_flag", overages_flag)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if sku_part_number is not None:
            pulumi.set(__self__, "sku_part_number", sku_part_number)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if unit_price is not None:
            pulumi.set(__self__, "unit_price", unit_price)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def ad(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The availability domain of the usage.
        """
        return pulumi.get(self, "ad")

    @ad.setter
    def ad(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ad", value)

    @_builtins.property
    @pulumi.getter(name="attributedCost")
    def attributed_cost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attributed cost with a max value of 9999999999.999999999999 and a minimum value of 0.
        """
        return pulumi.get(self, "attributed_cost")

    @attributed_cost.setter
    def attributed_cost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attributed_cost", value)

    @_builtins.property
    @pulumi.getter(name="attributedUsage")
    def attributed_usage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attributed usage with a max value of 9999999999.999999999999 and a minimum value of 0.
        """
        return pulumi.get(self, "attributed_usage")

    @attributed_usage.setter
    def attributed_usage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attributed_usage", value)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="compartmentName")
    def compartment_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compartment name.
        """
        return pulumi.get(self, "compartment_name")

    @compartment_name.setter
    def compartment_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_name", value)

    @_builtins.property
    @pulumi.getter(name="compartmentPath")
    def compartment_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compartment path, starting from root.
        """
        return pulumi.get(self, "compartment_path")

    @compartment_path.setter
    def compartment_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compartment_path", value)

    @_builtins.property
    @pulumi.getter(name="computedAmount")
    def computed_amount(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The computed cost.
        """
        return pulumi.get(self, "computed_amount")

    @computed_amount.setter
    def computed_amount(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "computed_amount", value)

    @_builtins.property
    @pulumi.getter(name="computedQuantity")
    def computed_quantity(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The usage number.
        """
        return pulumi.get(self, "computed_quantity")

    @computed_quantity.setter
    def computed_quantity(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "computed_quantity", value)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The price currency.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter
    def discount(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The discretionary discount applied to the SKU.
        """
        return pulumi.get(self, "discount")

    @discount.setter
    def discount(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "discount", value)

    @_builtins.property
    @pulumi.getter(name="isForecast")
    def is_forecast(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The forecasted data.
        """
        return pulumi.get(self, "is_forecast")

    @is_forecast.setter
    def is_forecast(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_forecast", value)

    @_builtins.property
    @pulumi.getter(name="listRate")
    def list_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The SKU list rate (not discount).
        """
        return pulumi.get(self, "list_rate")

    @list_rate.setter
    def list_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "list_rate", value)

    @_builtins.property
    @pulumi.getter
    def overage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The overage usage.
        """
        return pulumi.get(self, "overage")

    @overage.setter
    def overage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overage", value)

    @_builtins.property
    @pulumi.getter(name="overagesFlag")
    def overages_flag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SPM OverageFlag.
        """
        return pulumi.get(self, "overages_flag")

    @overages_flag.setter
    def overages_flag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overages_flag", value)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Platform for the cost.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the usage.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource OCID that is incurring the cost.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource name that is incurring the cost.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service name that is incurring the cost.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource shape.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shape", value)

    @_builtins.property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SKU friendly name.
        """
        return pulumi.get(self, "sku_name")

    @sku_name.setter
    def sku_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sku_name", value)

    @_builtins.property
    @pulumi.getter(name="skuPartNumber")
    def sku_part_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SKU part number.
        """
        return pulumi.get(self, "sku_part_number")

    @sku_part_number.setter
    def sku_part_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sku_part_number", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subscription_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsageItemTagArgs']]]]:
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsageItemTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenancy name.
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_name", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_ended", value)

    @_builtins.property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage start time.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_usage_started", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The usage unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter(name="unitPrice")
    def unit_price(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The price per unit.
        """
        return pulumi.get(self, "unit_price")

    @unit_price.setter
    def unit_price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "unit_price", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The resource size being metered.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class UsageItemTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag key.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag namespace.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag value.
        """
elif False:
    UsageItemTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageItemTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] namespace: The tag namespace.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsageStatementEmailRecipientsGroupRecipientsListArgsDict(TypedDict):
        email_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The recipient email address.
        """
        state: pulumi.Input[_builtins.str]
        """
        (Updatable) The email recipient lifecycle state.
        """
        first_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The recipient first name.
        """
        last_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The recipient last name.
        """
elif False:
    UsageStatementEmailRecipientsGroupRecipientsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsageStatementEmailRecipientsGroupRecipientsListArgs:
    def __init__(__self__, *,
                 email_id: pulumi.Input[_builtins.str],
                 state: pulumi.Input[_builtins.str],
                 first_name: Optional[pulumi.Input[_builtins.str]] = None,
                 last_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email_id: (Updatable) The recipient email address.
        :param pulumi.Input[_builtins.str] state: (Updatable) The email recipient lifecycle state.
        :param pulumi.Input[_builtins.str] first_name: (Updatable) The recipient first name.
        :param pulumi.Input[_builtins.str] last_name: (Updatable) The recipient last name.
        """
        pulumi.set(__self__, "email_id", email_id)
        pulumi.set(__self__, "state", state)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)

    @_builtins.property
    @pulumi.getter(name="emailId")
    def email_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The recipient email address.
        """
        return pulumi.get(self, "email_id")

    @email_id.setter
    def email_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The email recipient lifecycle state.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The recipient first name.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The recipient last name.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_name", value)


if not MYPY:
    class GetCustomTablesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetCustomTablesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCustomTablesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetQueriesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetQueriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetQueriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetScheduledRunsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetScheduledRunsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScheduledRunsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSchedulesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The query parameter for filtering by name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSchedulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchedulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The query parameter for filtering by name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The query parameter for filtering by name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUsageCarbonEmissionsQueriesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUsageCarbonEmissionsQueriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsageCarbonEmissionsQueriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUsageStatementEmailRecipientsGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUsageStatementEmailRecipientsGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsageStatementEmailRecipientsGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


