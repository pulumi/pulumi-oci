# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CustomTableSavedCustomTable',
    'CustomTableSavedCustomTableGroupByTag',
    'QueryQueryDefinition',
    'QueryQueryDefinitionCostAnalysisUi',
    'QueryQueryDefinitionReportQuery',
    'QueryQueryDefinitionReportQueryForecast',
    'QueryQueryDefinitionReportQueryGroupByTag',
    'ScheduleQueryProperties',
    'ScheduleQueryPropertiesDateRange',
    'ScheduleQueryPropertiesGroupByTag',
    'ScheduleResultLocation',
    'UsageCarbonEmissionGroupByTag',
    'UsageCarbonEmissionItem',
    'UsageCarbonEmissionItemTag',
    'UsageCarbonEmissionsQueryQueryDefinition',
    'UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi',
    'UsageCarbonEmissionsQueryQueryDefinitionReportQuery',
    'UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTag',
    'UsageForecast',
    'UsageGroupByTag',
    'UsageItem',
    'UsageItemTag',
    'UsageStatementEmailRecipientsGroupRecipientsList',
    'GetConfigurationItemResult',
    'GetCustomTableSavedCustomTableResult',
    'GetCustomTableSavedCustomTableGroupByTagResult',
    'GetCustomTablesCustomTableCollectionResult',
    'GetCustomTablesCustomTableCollectionItemResult',
    'GetCustomTablesCustomTableCollectionItemSavedCustomTableResult',
    'GetCustomTablesCustomTableCollectionItemSavedCustomTableGroupByTagResult',
    'GetCustomTablesFilterResult',
    'GetQueriesFilterResult',
    'GetQueriesQueryCollectionResult',
    'GetQueriesQueryCollectionItemResult',
    'GetQueriesQueryCollectionItemQueryDefinitionResult',
    'GetQueriesQueryCollectionItemQueryDefinitionCostAnalysisUiResult',
    'GetQueriesQueryCollectionItemQueryDefinitionReportQueryResult',
    'GetQueriesQueryCollectionItemQueryDefinitionReportQueryForecastResult',
    'GetQueriesQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult',
    'GetQueryQueryDefinitionResult',
    'GetQueryQueryDefinitionCostAnalysisUiResult',
    'GetQueryQueryDefinitionReportQueryResult',
    'GetQueryQueryDefinitionReportQueryForecastResult',
    'GetQueryQueryDefinitionReportQueryGroupByTagResult',
    'GetScheduleQueryPropertyResult',
    'GetScheduleQueryPropertyDateRangeResult',
    'GetScheduleQueryPropertyGroupByTagResult',
    'GetScheduleResultLocationResult',
    'GetScheduledRunsFilterResult',
    'GetScheduledRunsScheduledRunCollectionResult',
    'GetScheduledRunsScheduledRunCollectionItemResult',
    'GetSchedulesFilterResult',
    'GetSchedulesScheduleCollectionResult',
    'GetSchedulesScheduleCollectionItemResult',
    'GetSchedulesScheduleCollectionItemQueryPropertyResult',
    'GetSchedulesScheduleCollectionItemQueryPropertyDateRangeResult',
    'GetSchedulesScheduleCollectionItemQueryPropertyGroupByTagResult',
    'GetSchedulesScheduleCollectionItemResultLocationResult',
    'GetUsageCarbonEmissionsConfigItemResult',
    'GetUsageCarbonEmissionsQueriesFilterResult',
    'GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionResult',
    'GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemResult',
    'GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionResult',
    'GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionCostAnalysisUiResult',
    'GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryResult',
    'GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult',
    'GetUsageCarbonEmissionsQueryQueryDefinitionResult',
    'GetUsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiResult',
    'GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryResult',
    'GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagResult',
    'GetUsageStatementEmailRecipientsGroupRecipientsListResult',
    'GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionResult',
    'GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemResult',
    'GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemRecipientsListResult',
    'GetUsageStatementEmailRecipientsGroupsFilterResult',
]

@pulumi.output_type
class CustomTableSavedCustomTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "columnGroupBies":
            suggest = "column_group_bies"
        elif key == "compartmentDepth":
            suggest = "compartment_depth"
        elif key == "groupByTags":
            suggest = "group_by_tags"
        elif key == "rowGroupBies":
            suggest = "row_group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomTableSavedCustomTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomTableSavedCustomTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomTableSavedCustomTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str,
                 column_group_bies: Optional[Sequence[str]] = None,
                 compartment_depth: Optional[float] = None,
                 group_by_tags: Optional[Sequence['outputs.CustomTableSavedCustomTableGroupByTag']] = None,
                 row_group_bies: Optional[Sequence[str]] = None,
                 version: Optional[float] = None):
        """
        :param str display_name: (Updatable) The name of the custom table.
        :param Sequence[str] column_group_bies: (Updatable) The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param float compartment_depth: (Updatable) The compartment depth level.
        :param Sequence['CustomTableSavedCustomTableGroupByTagArgs'] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param Sequence[str] row_group_bies: (Updatable) The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param float version: (Updatable) The version of the custom table.
        """
        pulumi.set(__self__, "display_name", display_name)
        if column_group_bies is not None:
            pulumi.set(__self__, "column_group_bies", column_group_bies)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if row_group_bies is not None:
            pulumi.set(__self__, "row_group_bies", row_group_bies)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        (Updatable) The name of the custom table.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="columnGroupBies")
    def column_group_bies(self) -> Optional[Sequence[str]]:
        """
        (Updatable) The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "column_group_bies")

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[float]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[Sequence['outputs.CustomTableSavedCustomTableGroupByTag']]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="rowGroupBies")
    def row_group_bies(self) -> Optional[Sequence[str]]:
        """
        (Updatable) The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "row_group_bies")

    @property
    @pulumi.getter
    def version(self) -> Optional[float]:
        """
        (Updatable) The version of the custom table.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class CustomTableSavedCustomTableGroupByTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: (Updatable) The tag key.
        :param str namespace: (Updatable) The tag namespace.
        :param str value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class QueryQueryDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAnalysisUi":
            suggest = "cost_analysis_ui"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "reportQuery":
            suggest = "report_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryQueryDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryQueryDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryQueryDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_analysis_ui: 'outputs.QueryQueryDefinitionCostAnalysisUi',
                 display_name: str,
                 report_query: 'outputs.QueryQueryDefinitionReportQuery',
                 version: float):
        """
        :param 'QueryQueryDefinitionCostAnalysisUiArgs' cost_analysis_ui: (Updatable) The common fields for Cost Analysis UI rendering.
        :param str display_name: (Updatable) The query display name. Avoid entering confidential information.
        :param 'QueryQueryDefinitionReportQueryArgs' report_query: (Updatable) The request of the generated Cost Analysis report.
        :param float version: (Updatable) The saved query version.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "cost_analysis_ui", cost_analysis_ui)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_query", report_query)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUi")
    def cost_analysis_ui(self) -> 'outputs.QueryQueryDefinitionCostAnalysisUi':
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_ui")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="reportQuery")
    def report_query(self) -> 'outputs.QueryQueryDefinitionReportQuery':
        """
        (Updatable) The request of the generated Cost Analysis report.
        """
        return pulumi.get(self, "report_query")

    @property
    @pulumi.getter
    def version(self) -> float:
        """
        (Updatable) The saved query version.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class QueryQueryDefinitionCostAnalysisUi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isCumulativeGraph":
            suggest = "is_cumulative_graph"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryQueryDefinitionCostAnalysisUi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryQueryDefinitionCostAnalysisUi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryQueryDefinitionCostAnalysisUi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 graph: Optional[str] = None,
                 is_cumulative_graph: Optional[bool] = None):
        """
        :param str graph: (Updatable) The graph type.
        :param bool is_cumulative_graph: (Updatable) A cumulative graph.
        """
        if graph is not None:
            pulumi.set(__self__, "graph", graph)
        if is_cumulative_graph is not None:
            pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> Optional[str]:
        """
        (Updatable) The graph type.
        """
        return pulumi.get(self, "graph")

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> Optional[bool]:
        """
        (Updatable) A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")


@pulumi.output_type
class QueryQueryDefinitionReportQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantId":
            suggest = "tenant_id"
        elif key == "compartmentDepth":
            suggest = "compartment_depth"
        elif key == "dateRangeName":
            suggest = "date_range_name"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupByTags":
            suggest = "group_by_tags"
        elif key == "isAggregateByTime":
            suggest = "is_aggregate_by_time"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "timeUsageEnded":
            suggest = "time_usage_ended"
        elif key == "timeUsageStarted":
            suggest = "time_usage_started"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryQueryDefinitionReportQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryQueryDefinitionReportQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryQueryDefinitionReportQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularity: str,
                 tenant_id: str,
                 compartment_depth: Optional[float] = None,
                 date_range_name: Optional[str] = None,
                 filter: Optional[str] = None,
                 forecast: Optional['outputs.QueryQueryDefinitionReportQueryForecast'] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 group_by_tags: Optional[Sequence['outputs.QueryQueryDefinitionReportQueryGroupByTag']] = None,
                 is_aggregate_by_time: Optional[bool] = None,
                 query_type: Optional[str] = None,
                 time_usage_ended: Optional[str] = None,
                 time_usage_started: Optional[str] = None):
        """
        :param str granularity: (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        :param str tenant_id: (Updatable) Tenant ID.
        :param float compartment_depth: (Updatable) The compartment depth level.
        :param str date_range_name: (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        :param str filter: (Updatable) The filter object for query usage.
        :param 'QueryQueryDefinitionReportQueryForecastArgs' forecast: (Updatable) Forecast configuration of usage/cost.
        :param Sequence[str] group_bies: (Updatable) Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param Sequence['QueryQueryDefinitionReportQueryGroupByTagArgs'] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param bool is_aggregate_by_time: (Updatable) Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        :param str query_type: (Updatable) The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        :param str time_usage_ended: (Updatable) The usage end time.
        :param str time_usage_started: (Updatable) The usage start time.
        """
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if date_range_name is not None:
            pulumi.set(__self__, "date_range_name", date_range_name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if forecast is not None:
            pulumi.set(__self__, "forecast", forecast)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        (Updatable) Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[float]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> Optional[str]:
        """
        (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        """
        return pulumi.get(self, "date_range_name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        (Updatable) The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def forecast(self) -> Optional['outputs.QueryQueryDefinitionReportQueryForecast']:
        """
        (Updatable) Forecast configuration of usage/cost.
        """
        return pulumi.get(self, "forecast")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        (Updatable) Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[Sequence['outputs.QueryQueryDefinitionReportQueryGroupByTag']]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[bool]:
        """
        (Updatable) Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[str]:
        """
        (Updatable) The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[str]:
        """
        (Updatable) The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[str]:
        """
        (Updatable) The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class QueryQueryDefinitionReportQueryForecast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeForecastEnded":
            suggest = "time_forecast_ended"
        elif key == "forecastType":
            suggest = "forecast_type"
        elif key == "timeForecastStarted":
            suggest = "time_forecast_started"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryQueryDefinitionReportQueryForecast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryQueryDefinitionReportQueryForecast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryQueryDefinitionReportQueryForecast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_forecast_ended: str,
                 forecast_type: Optional[str] = None,
                 time_forecast_started: Optional[str] = None):
        """
        :param str time_forecast_ended: (Updatable) The forecast end time.
        :param str forecast_type: (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param str time_forecast_started: (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        if forecast_type is not None:
            pulumi.set(__self__, "forecast_type", forecast_type)
        if time_forecast_started is not None:
            pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> str:
        """
        (Updatable) The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> Optional[str]:
        """
        (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> Optional[str]:
        """
        (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")


@pulumi.output_type
class QueryQueryDefinitionReportQueryGroupByTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: (Updatable) The tag key.
        :param str namespace: (Updatable) The tag namespace.
        :param str value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduleQueryProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRange":
            suggest = "date_range"
        elif key == "compartmentDepth":
            suggest = "compartment_depth"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupByTags":
            suggest = "group_by_tags"
        elif key == "isAggregateByTime":
            suggest = "is_aggregate_by_time"
        elif key == "queryType":
            suggest = "query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleQueryProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleQueryProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleQueryProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_range: 'outputs.ScheduleQueryPropertiesDateRange',
                 granularity: str,
                 compartment_depth: Optional[float] = None,
                 filter: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 group_by_tags: Optional[Sequence['outputs.ScheduleQueryPropertiesGroupByTag']] = None,
                 is_aggregate_by_time: Optional[bool] = None,
                 query_type: Optional[str] = None):
        """
        :param 'ScheduleQueryPropertiesDateRangeArgs' date_range: Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        :param str granularity: The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        :param float compartment_depth: The depth level of the compartment.
        :param str filter: The filter object for query usage.
        :param Sequence[str] group_bies: Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        :param Sequence['ScheduleQueryPropertiesGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        :param bool is_aggregate_by_time: Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param str query_type: The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        pulumi.set(__self__, "date_range", date_range)
        pulumi.set(__self__, "granularity", granularity)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> 'outputs.ScheduleQueryPropertiesDateRange':
        """
        Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        """
        return pulumi.get(self, "date_range")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[float]:
        """
        The depth level of the compartment.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[Sequence['outputs.ScheduleQueryPropertiesGroupByTag']]:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[bool]:
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[str]:
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        return pulumi.get(self, "query_type")


@pulumi.output_type
class ScheduleQueryPropertiesDateRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRangeType":
            suggest = "date_range_type"
        elif key == "dynamicDateRangeType":
            suggest = "dynamic_date_range_type"
        elif key == "timeUsageEnded":
            suggest = "time_usage_ended"
        elif key == "timeUsageStarted":
            suggest = "time_usage_started"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleQueryPropertiesDateRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleQueryPropertiesDateRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleQueryPropertiesDateRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_range_type: str,
                 dynamic_date_range_type: Optional[str] = None,
                 time_usage_ended: Optional[str] = None,
                 time_usage_started: Optional[str] = None):
        """
        :param str date_range_type: Defines whether the schedule date range is STATIC or DYNAMIC.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        """
        pulumi.set(__self__, "date_range_type", date_range_type)
        if dynamic_date_range_type is not None:
            pulumi.set(__self__, "dynamic_date_range_type", dynamic_date_range_type)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter(name="dateRangeType")
    def date_range_type(self) -> str:
        """
        Defines whether the schedule date range is STATIC or DYNAMIC.
        """
        return pulumi.get(self, "date_range_type")

    @property
    @pulumi.getter(name="dynamicDateRangeType")
    def dynamic_date_range_type(self) -> Optional[str]:
        return pulumi.get(self, "dynamic_date_range_type")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[str]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[str]:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class ScheduleQueryPropertiesGroupByTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduleResultLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResultLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResultLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResultLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 location_type: str,
                 namespace: str,
                 region: str):
        """
        :param str bucket: (Updatable) The bucket name where usage or cost CSVs will be uploaded.
        :param str location_type: (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
        :param str namespace: (Updatable) The namespace needed to determine the object storage bucket.
        :param str region: (Updatable) The destination Object Store Region specified by the customer.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        (Updatable) The bucket name where usage or cost CSVs will be uploaded.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> str:
        """
        (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
        """
        return pulumi.get(self, "location_type")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        (Updatable) The namespace needed to determine the object storage bucket.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        (Updatable) The destination Object Store Region specified by the customer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class UsageCarbonEmissionGroupByTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UsageCarbonEmissionItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "compartmentName":
            suggest = "compartment_name"
        elif key == "compartmentPath":
            suggest = "compartment_path"
        elif key == "computedCarbonEmission":
            suggest = "computed_carbon_emission"
        elif key == "emissionCalculationMethod":
            suggest = "emission_calculation_method"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "skuName":
            suggest = "sku_name"
        elif key == "skuPartNumber":
            suggest = "sku_part_number"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "timeUsageEnded":
            suggest = "time_usage_ended"
        elif key == "timeUsageStarted":
            suggest = "time_usage_started"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageCarbonEmissionItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageCarbonEmissionItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageCarbonEmissionItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad: Optional[str] = None,
                 compartment_id: Optional[str] = None,
                 compartment_name: Optional[str] = None,
                 compartment_path: Optional[str] = None,
                 computed_carbon_emission: Optional[float] = None,
                 emission_calculation_method: Optional[str] = None,
                 platform: Optional[str] = None,
                 region: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_name: Optional[str] = None,
                 service: Optional[str] = None,
                 sku_name: Optional[str] = None,
                 sku_part_number: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.UsageCarbonEmissionItemTag']] = None,
                 tenant_id: Optional[str] = None,
                 tenant_name: Optional[str] = None,
                 time_usage_ended: Optional[str] = None,
                 time_usage_started: Optional[str] = None):
        """
        :param str ad: The availability domain of the usage.
        :param str compartment_id: The compartment OCID.
        :param str compartment_name: The compartment name.
        :param str compartment_path: The compartment path, starting from root.
        :param float computed_carbon_emission: The carbon emission in MTCO2 unit.
        :param str emission_calculation_method: The method used to calculate carbon emission.
        :param str platform: Platform for the cost.
        :param str region: The region of the usage.
        :param str resource_id: The resource OCID that is incurring the cost.
        :param str resource_name: The resource name that is incurring the cost.
        :param str service: The service name that is incurring the cost.
        :param str sku_name: The SKU friendly name.
        :param str sku_part_number: The SKU part number.
        :param str subscription_id: The subscription ID.
        :param Sequence['UsageCarbonEmissionItemTagArgs'] tags: For grouping, a tag definition. For filtering, a definition and key.
        :param str tenant_id: Tenant ID.
        :param str tenant_name: The tenancy name.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if compartment_name is not None:
            pulumi.set(__self__, "compartment_name", compartment_name)
        if compartment_path is not None:
            pulumi.set(__self__, "compartment_path", compartment_path)
        if computed_carbon_emission is not None:
            pulumi.set(__self__, "computed_carbon_emission", computed_carbon_emission)
        if emission_calculation_method is not None:
            pulumi.set(__self__, "emission_calculation_method", emission_calculation_method)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if sku_part_number is not None:
            pulumi.set(__self__, "sku_part_number", sku_part_number)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter
    def ad(self) -> Optional[str]:
        """
        The availability domain of the usage.
        """
        return pulumi.get(self, "ad")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        The compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="compartmentName")
    def compartment_name(self) -> Optional[str]:
        """
        The compartment name.
        """
        return pulumi.get(self, "compartment_name")

    @property
    @pulumi.getter(name="compartmentPath")
    def compartment_path(self) -> Optional[str]:
        """
        The compartment path, starting from root.
        """
        return pulumi.get(self, "compartment_path")

    @property
    @pulumi.getter(name="computedCarbonEmission")
    def computed_carbon_emission(self) -> Optional[float]:
        """
        The carbon emission in MTCO2 unit.
        """
        return pulumi.get(self, "computed_carbon_emission")

    @property
    @pulumi.getter(name="emissionCalculationMethod")
    def emission_calculation_method(self) -> Optional[str]:
        """
        The method used to calculate carbon emission.
        """
        return pulumi.get(self, "emission_calculation_method")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        Platform for the cost.
        """
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region of the usage.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The resource OCID that is incurring the cost.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        The resource name that is incurring the cost.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The service name that is incurring the cost.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[str]:
        """
        The SKU friendly name.
        """
        return pulumi.get(self, "sku_name")

    @property
    @pulumi.getter(name="skuPartNumber")
    def sku_part_number(self) -> Optional[str]:
        """
        The SKU part number.
        """
        return pulumi.get(self, "sku_part_number")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.UsageCarbonEmissionItemTag']]:
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[str]:
        """
        The tenancy name.
        """
        return pulumi.get(self, "tenant_name")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[str]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[str]:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class UsageCarbonEmissionItemTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UsageCarbonEmissionsQueryQueryDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAnalysisUi":
            suggest = "cost_analysis_ui"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "reportQuery":
            suggest = "report_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageCarbonEmissionsQueryQueryDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageCarbonEmissionsQueryQueryDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageCarbonEmissionsQueryQueryDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_analysis_ui: 'outputs.UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi',
                 display_name: str,
                 report_query: 'outputs.UsageCarbonEmissionsQueryQueryDefinitionReportQuery',
                 version: int):
        """
        :param 'UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs' cost_analysis_ui: (Updatable) The common fields for Cost Analysis UI rendering.
        :param str display_name: (Updatable) The query display name. Avoid entering confidential information.
        :param 'UsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs' report_query: (Updatable) The request of the generated usage carbon emissions report.
        :param int version: (Updatable) The saved query version.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "cost_analysis_ui", cost_analysis_ui)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_query", report_query)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUi")
    def cost_analysis_ui(self) -> 'outputs.UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi':
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_ui")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="reportQuery")
    def report_query(self) -> 'outputs.UsageCarbonEmissionsQueryQueryDefinitionReportQuery':
        """
        (Updatable) The request of the generated usage carbon emissions report.
        """
        return pulumi.get(self, "report_query")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        (Updatable) The saved query version.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isCumulativeGraph":
            suggest = "is_cumulative_graph"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 graph: Optional[str] = None,
                 is_cumulative_graph: Optional[bool] = None):
        """
        :param str graph: (Updatable) The graph type.
        :param bool is_cumulative_graph: (Updatable) A cumulative graph.
        """
        if graph is not None:
            pulumi.set(__self__, "graph", graph)
        if is_cumulative_graph is not None:
            pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> Optional[str]:
        """
        (Updatable) The graph type.
        """
        return pulumi.get(self, "graph")

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> Optional[bool]:
        """
        (Updatable) A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")


@pulumi.output_type
class UsageCarbonEmissionsQueryQueryDefinitionReportQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantId":
            suggest = "tenant_id"
        elif key == "compartmentDepth":
            suggest = "compartment_depth"
        elif key == "dateRangeName":
            suggest = "date_range_name"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "groupByTags":
            suggest = "group_by_tags"
        elif key == "isAggregateByTime":
            suggest = "is_aggregate_by_time"
        elif key == "timeUsageEnded":
            suggest = "time_usage_ended"
        elif key == "timeUsageStarted":
            suggest = "time_usage_started"
        elif key == "usageCarbonEmissionsQueryFilter":
            suggest = "usage_carbon_emissions_query_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageCarbonEmissionsQueryQueryDefinitionReportQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageCarbonEmissionsQueryQueryDefinitionReportQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageCarbonEmissionsQueryQueryDefinitionReportQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tenant_id: str,
                 compartment_depth: Optional[int] = None,
                 date_range_name: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 group_by_tags: Optional[Sequence['outputs.UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTag']] = None,
                 is_aggregate_by_time: Optional[bool] = None,
                 time_usage_ended: Optional[str] = None,
                 time_usage_started: Optional[str] = None,
                 usage_carbon_emissions_query_filter: Optional[str] = None):
        """
        :param str tenant_id: (Updatable) Tenant ID.
        :param int compartment_depth: (Updatable) The compartment depth level.
        :param str date_range_name: (Updatable) The UI date range, for example, LAST_THREE_MONTHS. It will override timeUsageStarted and timeUsageEnded properties.
        :param Sequence[str] group_bies: (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param Sequence['UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs'] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param bool is_aggregate_by_time: (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param str time_usage_ended: (Updatable) The usage end time.
        :param str time_usage_started: (Updatable) The usage start time.
        :param str usage_carbon_emissions_query_filter: (Updatable) The filter object for query usage.
        """
        pulumi.set(__self__, "tenant_id", tenant_id)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if date_range_name is not None:
            pulumi.set(__self__, "date_range_name", date_range_name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)
        if usage_carbon_emissions_query_filter is not None:
            pulumi.set(__self__, "usage_carbon_emissions_query_filter", usage_carbon_emissions_query_filter)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        (Updatable) Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[int]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> Optional[str]:
        """
        (Updatable) The UI date range, for example, LAST_THREE_MONTHS. It will override timeUsageStarted and timeUsageEnded properties.
        """
        return pulumi.get(self, "date_range_name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        (Updatable) Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[Sequence['outputs.UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTag']]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[bool]:
        """
        (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[str]:
        """
        (Updatable) The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[str]:
        """
        (Updatable) The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @property
    @pulumi.getter(name="usageCarbonEmissionsQueryFilter")
    def usage_carbon_emissions_query_filter(self) -> Optional[str]:
        """
        (Updatable) The filter object for query usage.
        """
        return pulumi.get(self, "usage_carbon_emissions_query_filter")


@pulumi.output_type
class UsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: (Updatable) The tag key.
        :param str namespace: (Updatable) The tag namespace.
        :param str value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UsageForecast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeForecastEnded":
            suggest = "time_forecast_ended"
        elif key == "forecastType":
            suggest = "forecast_type"
        elif key == "timeForecastStarted":
            suggest = "time_forecast_started"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageForecast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageForecast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageForecast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_forecast_ended: str,
                 forecast_type: Optional[str] = None,
                 time_forecast_started: Optional[str] = None):
        """
        :param str time_forecast_ended: The forecast end time.
        :param str forecast_type: BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param str time_forecast_started: The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        if forecast_type is not None:
            pulumi.set(__self__, "forecast_type", forecast_type)
        if time_forecast_started is not None:
            pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> str:
        """
        The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> Optional[str]:
        """
        BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> Optional[str]:
        """
        The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")


@pulumi.output_type
class UsageGroupByTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UsageItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributedCost":
            suggest = "attributed_cost"
        elif key == "attributedUsage":
            suggest = "attributed_usage"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "compartmentName":
            suggest = "compartment_name"
        elif key == "compartmentPath":
            suggest = "compartment_path"
        elif key == "computedAmount":
            suggest = "computed_amount"
        elif key == "computedQuantity":
            suggest = "computed_quantity"
        elif key == "isForecast":
            suggest = "is_forecast"
        elif key == "listRate":
            suggest = "list_rate"
        elif key == "overagesFlag":
            suggest = "overages_flag"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "skuName":
            suggest = "sku_name"
        elif key == "skuPartNumber":
            suggest = "sku_part_number"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "timeUsageEnded":
            suggest = "time_usage_ended"
        elif key == "timeUsageStarted":
            suggest = "time_usage_started"
        elif key == "unitPrice":
            suggest = "unit_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad: Optional[str] = None,
                 attributed_cost: Optional[str] = None,
                 attributed_usage: Optional[str] = None,
                 compartment_id: Optional[str] = None,
                 compartment_name: Optional[str] = None,
                 compartment_path: Optional[str] = None,
                 computed_amount: Optional[float] = None,
                 computed_quantity: Optional[float] = None,
                 currency: Optional[str] = None,
                 discount: Optional[float] = None,
                 is_forecast: Optional[bool] = None,
                 list_rate: Optional[float] = None,
                 overage: Optional[str] = None,
                 overages_flag: Optional[str] = None,
                 platform: Optional[str] = None,
                 region: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_name: Optional[str] = None,
                 service: Optional[str] = None,
                 shape: Optional[str] = None,
                 sku_name: Optional[str] = None,
                 sku_part_number: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.UsageItemTag']] = None,
                 tenant_id: Optional[str] = None,
                 tenant_name: Optional[str] = None,
                 time_usage_ended: Optional[str] = None,
                 time_usage_started: Optional[str] = None,
                 unit: Optional[str] = None,
                 unit_price: Optional[float] = None,
                 weight: Optional[float] = None):
        """
        :param str ad: The availability domain of the usage.
        :param str attributed_cost: The attributed cost with a max value of 9999999999.999999999999 and a minimum value of 0.
        :param str attributed_usage: The attributed usage with a max value of 9999999999.999999999999 and a minimum value of 0.
        :param str compartment_id: The compartment OCID.
        :param str compartment_name: The compartment name.
        :param str compartment_path: The compartment path, starting from root.
        :param float computed_amount: The computed cost.
        :param float computed_quantity: The usage number.
        :param str currency: The price currency.
        :param float discount: The discretionary discount applied to the SKU.
        :param bool is_forecast: The forecasted data.
        :param float list_rate: The SKU list rate (not discount).
        :param str overage: The overage usage.
        :param str overages_flag: The SPM OverageFlag.
        :param str platform: Platform for the cost.
        :param str region: The region of the usage.
        :param str resource_id: The resource OCID that is incurring the cost.
        :param str resource_name: The resource name that is incurring the cost.
        :param str service: The service name that is incurring the cost.
        :param str shape: The resource shape.
        :param str sku_name: The SKU friendly name.
        :param str sku_part_number: The SKU part number.
        :param str subscription_id: The subscription ID.
        :param Sequence['UsageItemTagArgs'] tags: For grouping, a tag definition. For filtering, a definition and key.
        :param str tenant_id: Tenant ID.
        :param str tenant_name: The tenancy name.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param str unit: The usage unit.
        :param float unit_price: The price per unit.
        :param float weight: The resource size being metered.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if attributed_cost is not None:
            pulumi.set(__self__, "attributed_cost", attributed_cost)
        if attributed_usage is not None:
            pulumi.set(__self__, "attributed_usage", attributed_usage)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if compartment_name is not None:
            pulumi.set(__self__, "compartment_name", compartment_name)
        if compartment_path is not None:
            pulumi.set(__self__, "compartment_path", compartment_path)
        if computed_amount is not None:
            pulumi.set(__self__, "computed_amount", computed_amount)
        if computed_quantity is not None:
            pulumi.set(__self__, "computed_quantity", computed_quantity)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if discount is not None:
            pulumi.set(__self__, "discount", discount)
        if is_forecast is not None:
            pulumi.set(__self__, "is_forecast", is_forecast)
        if list_rate is not None:
            pulumi.set(__self__, "list_rate", list_rate)
        if overage is not None:
            pulumi.set(__self__, "overage", overage)
        if overages_flag is not None:
            pulumi.set(__self__, "overages_flag", overages_flag)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if sku_part_number is not None:
            pulumi.set(__self__, "sku_part_number", sku_part_number)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if unit_price is not None:
            pulumi.set(__self__, "unit_price", unit_price)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def ad(self) -> Optional[str]:
        """
        The availability domain of the usage.
        """
        return pulumi.get(self, "ad")

    @property
    @pulumi.getter(name="attributedCost")
    def attributed_cost(self) -> Optional[str]:
        """
        The attributed cost with a max value of 9999999999.999999999999 and a minimum value of 0.
        """
        return pulumi.get(self, "attributed_cost")

    @property
    @pulumi.getter(name="attributedUsage")
    def attributed_usage(self) -> Optional[str]:
        """
        The attributed usage with a max value of 9999999999.999999999999 and a minimum value of 0.
        """
        return pulumi.get(self, "attributed_usage")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        The compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="compartmentName")
    def compartment_name(self) -> Optional[str]:
        """
        The compartment name.
        """
        return pulumi.get(self, "compartment_name")

    @property
    @pulumi.getter(name="compartmentPath")
    def compartment_path(self) -> Optional[str]:
        """
        The compartment path, starting from root.
        """
        return pulumi.get(self, "compartment_path")

    @property
    @pulumi.getter(name="computedAmount")
    def computed_amount(self) -> Optional[float]:
        """
        The computed cost.
        """
        return pulumi.get(self, "computed_amount")

    @property
    @pulumi.getter(name="computedQuantity")
    def computed_quantity(self) -> Optional[float]:
        """
        The usage number.
        """
        return pulumi.get(self, "computed_quantity")

    @property
    @pulumi.getter
    def currency(self) -> Optional[str]:
        """
        The price currency.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter
    def discount(self) -> Optional[float]:
        """
        The discretionary discount applied to the SKU.
        """
        return pulumi.get(self, "discount")

    @property
    @pulumi.getter(name="isForecast")
    def is_forecast(self) -> Optional[bool]:
        """
        The forecasted data.
        """
        return pulumi.get(self, "is_forecast")

    @property
    @pulumi.getter(name="listRate")
    def list_rate(self) -> Optional[float]:
        """
        The SKU list rate (not discount).
        """
        return pulumi.get(self, "list_rate")

    @property
    @pulumi.getter
    def overage(self) -> Optional[str]:
        """
        The overage usage.
        """
        return pulumi.get(self, "overage")

    @property
    @pulumi.getter(name="overagesFlag")
    def overages_flag(self) -> Optional[str]:
        """
        The SPM OverageFlag.
        """
        return pulumi.get(self, "overages_flag")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        Platform for the cost.
        """
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region of the usage.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The resource OCID that is incurring the cost.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        The resource name that is incurring the cost.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The service name that is incurring the cost.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def shape(self) -> Optional[str]:
        """
        The resource shape.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[str]:
        """
        The SKU friendly name.
        """
        return pulumi.get(self, "sku_name")

    @property
    @pulumi.getter(name="skuPartNumber")
    def sku_part_number(self) -> Optional[str]:
        """
        The SKU part number.
        """
        return pulumi.get(self, "sku_part_number")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.UsageItemTag']]:
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[str]:
        """
        The tenancy name.
        """
        return pulumi.get(self, "tenant_name")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[str]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[str]:
        """
        The usage start time.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "time_usage_started")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The usage unit.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="unitPrice")
    def unit_price(self) -> Optional[float]:
        """
        The price per unit.
        """
        return pulumi.get(self, "unit_price")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The resource size being metered.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class UsageItemTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UsageStatementEmailRecipientsGroupRecipientsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailId":
            suggest = "email_id"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsageStatementEmailRecipientsGroupRecipientsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsageStatementEmailRecipientsGroupRecipientsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsageStatementEmailRecipientsGroupRecipientsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_id: str,
                 state: str,
                 first_name: Optional[str] = None,
                 last_name: Optional[str] = None):
        """
        :param str email_id: (Updatable) the email of the recipient.
        :param str state: (Updatable) The email recipient lifecycle state.
        :param str first_name: (Updatable) the first name of the recipient.
        :param str last_name: (Updatable) the last name of the recipient.
        """
        pulumi.set(__self__, "email_id", email_id)
        pulumi.set(__self__, "state", state)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)

    @property
    @pulumi.getter(name="emailId")
    def email_id(self) -> str:
        """
        (Updatable) the email of the recipient.
        """
        return pulumi.get(self, "email_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        (Updatable) The email recipient lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        (Updatable) the first name of the recipient.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        (Updatable) the last name of the recipient.
        """
        return pulumi.get(self, "last_name")


@pulumi.output_type
class GetConfigurationItemResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The configuration key.
        :param Sequence[str] values: The configuration value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The configuration key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The configuration value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCustomTableSavedCustomTableResult(dict):
    def __init__(__self__, *,
                 column_group_bies: Sequence[str],
                 compartment_depth: float,
                 display_name: str,
                 group_by_tags: Sequence['outputs.GetCustomTableSavedCustomTableGroupByTagResult'],
                 row_group_bies: Sequence[str],
                 version: float):
        """
        :param Sequence[str] column_group_bies: The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param float compartment_depth: The compartment depth level.
        :param str display_name: The name of the custom table.
        :param Sequence['GetCustomTableSavedCustomTableGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param Sequence[str] row_group_bies: The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param float version: The version of the custom table.
        """
        pulumi.set(__self__, "column_group_bies", column_group_bies)
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "row_group_bies", row_group_bies)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="columnGroupBies")
    def column_group_bies(self) -> Sequence[str]:
        """
        The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "column_group_bies")

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> float:
        """
        The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The name of the custom table.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetCustomTableSavedCustomTableGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="rowGroupBies")
    def row_group_bies(self) -> Sequence[str]:
        """
        The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "row_group_bies")

    @property
    @pulumi.getter
    def version(self) -> float:
        """
        The version of the custom table.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetCustomTableSavedCustomTableGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCustomTablesCustomTableCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetCustomTablesCustomTableCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetCustomTablesCustomTableCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetCustomTablesCustomTableCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 id: str,
                 saved_custom_tables: Sequence['outputs.GetCustomTablesCustomTableCollectionItemSavedCustomTableResult'],
                 saved_report_id: str):
        """
        :param str compartment_id: The compartment ID in which to list resources.
        :param str id: The custom table OCID.
        :param Sequence['GetCustomTablesCustomTableCollectionItemSavedCustomTableArgs'] saved_custom_tables: The custom table for Cost Analysis UI rendering.
        :param str saved_report_id: The saved report ID in which to list resources.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "saved_custom_tables", saved_custom_tables)
        pulumi.set(__self__, "saved_report_id", saved_report_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment ID in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The custom table OCID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="savedCustomTables")
    def saved_custom_tables(self) -> Sequence['outputs.GetCustomTablesCustomTableCollectionItemSavedCustomTableResult']:
        """
        The custom table for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "saved_custom_tables")

    @property
    @pulumi.getter(name="savedReportId")
    def saved_report_id(self) -> str:
        """
        The saved report ID in which to list resources.
        """
        return pulumi.get(self, "saved_report_id")


@pulumi.output_type
class GetCustomTablesCustomTableCollectionItemSavedCustomTableResult(dict):
    def __init__(__self__, *,
                 column_group_bies: Sequence[str],
                 compartment_depth: float,
                 display_name: str,
                 group_by_tags: Sequence['outputs.GetCustomTablesCustomTableCollectionItemSavedCustomTableGroupByTagResult'],
                 row_group_bies: Sequence[str],
                 version: float):
        """
        :param Sequence[str] column_group_bies: The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param float compartment_depth: The compartment depth level.
        :param str display_name: The name of the custom table.
        :param Sequence['GetCustomTablesCustomTableCollectionItemSavedCustomTableGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param Sequence[str] row_group_bies: The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param float version: The version of the custom table.
        """
        pulumi.set(__self__, "column_group_bies", column_group_bies)
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "row_group_bies", row_group_bies)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="columnGroupBies")
    def column_group_bies(self) -> Sequence[str]:
        """
        The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "column_group_bies")

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> float:
        """
        The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The name of the custom table.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetCustomTablesCustomTableCollectionItemSavedCustomTableGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="rowGroupBies")
    def row_group_bies(self) -> Sequence[str]:
        """
        The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "row_group_bies")

    @property
    @pulumi.getter
    def version(self) -> float:
        """
        The version of the custom table.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetCustomTablesCustomTableCollectionItemSavedCustomTableGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCustomTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetQueriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetQueriesQueryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetQueriesQueryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetQueriesQueryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetQueriesQueryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 id: str,
                 query_definitions: Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionResult']):
        """
        :param str compartment_id: The compartment ID in which to list resources.
        :param str id: The query OCID.
        :param Sequence['GetQueriesQueryCollectionItemQueryDefinitionArgs'] query_definitions: The common fields for queries.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query_definitions", query_definitions)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment ID in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The query OCID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="queryDefinitions")
    def query_definitions(self) -> Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionResult']:
        """
        The common fields for queries.
        """
        return pulumi.get(self, "query_definitions")


@pulumi.output_type
class GetQueriesQueryCollectionItemQueryDefinitionResult(dict):
    def __init__(__self__, *,
                 cost_analysis_uis: Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionCostAnalysisUiResult'],
                 display_name: str,
                 report_queries: Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionReportQueryResult'],
                 version: float):
        """
        :param Sequence['GetQueriesQueryCollectionItemQueryDefinitionCostAnalysisUiArgs'] cost_analysis_uis: The common fields for Cost Analysis UI rendering.
        :param str display_name: The query display name. Avoid entering confidential information.
        :param Sequence['GetQueriesQueryCollectionItemQueryDefinitionReportQueryArgs'] report_queries: The request of the generated Cost Analysis report.
        :param float version: The saved query version.
        """
        pulumi.set(__self__, "cost_analysis_uis", cost_analysis_uis)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_queries", report_queries)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUis")
    def cost_analysis_uis(self) -> Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionCostAnalysisUiResult']:
        """
        The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_uis")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="reportQueries")
    def report_queries(self) -> Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionReportQueryResult']:
        """
        The request of the generated Cost Analysis report.
        """
        return pulumi.get(self, "report_queries")

    @property
    @pulumi.getter
    def version(self) -> float:
        """
        The saved query version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetQueriesQueryCollectionItemQueryDefinitionCostAnalysisUiResult(dict):
    def __init__(__self__, *,
                 graph: str,
                 is_cumulative_graph: bool):
        """
        :param str graph: The graph type.
        :param bool is_cumulative_graph: A cumulative graph.
        """
        pulumi.set(__self__, "graph", graph)
        pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> str:
        """
        The graph type.
        """
        return pulumi.get(self, "graph")

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> bool:
        """
        A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")


@pulumi.output_type
class GetQueriesQueryCollectionItemQueryDefinitionReportQueryResult(dict):
    def __init__(__self__, *,
                 compartment_depth: float,
                 date_range_name: str,
                 filter: str,
                 forecasts: Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionReportQueryForecastResult'],
                 granularity: str,
                 group_bies: Sequence[str],
                 group_by_tags: Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult'],
                 is_aggregate_by_time: bool,
                 query_type: str,
                 tenant_id: str,
                 time_usage_ended: str,
                 time_usage_started: str):
        """
        :param float compartment_depth: The compartment depth level.
        :param str date_range_name: The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        :param str filter: The filter object for query usage.
        :param Sequence['GetQueriesQueryCollectionItemQueryDefinitionReportQueryForecastArgs'] forecasts: Forecast configuration of usage/cost.
        :param str granularity: The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        :param Sequence[str] group_bies: Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param Sequence['GetQueriesQueryCollectionItemQueryDefinitionReportQueryGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param bool is_aggregate_by_time: Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        :param str query_type: The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        :param str tenant_id: Tenant ID.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        """
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "date_range_name", date_range_name)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "forecasts", forecasts)
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        pulumi.set(__self__, "query_type", query_type)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> float:
        """
        The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> str:
        """
        The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        """
        return pulumi.get(self, "date_range_name")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def forecasts(self) -> Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionReportQueryForecastResult']:
        """
        Forecast configuration of usage/cost.
        """
        return pulumi.get(self, "forecasts")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetQueriesQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> bool:
        """
        Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> str:
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> str:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> str:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class GetQueriesQueryCollectionItemQueryDefinitionReportQueryForecastResult(dict):
    def __init__(__self__, *,
                 forecast_type: str,
                 time_forecast_ended: str,
                 time_forecast_started: str):
        """
        :param str forecast_type: BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param str time_forecast_ended: The forecast end time.
        :param str time_forecast_started: The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "forecast_type", forecast_type)
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> str:
        """
        BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> str:
        """
        The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> str:
        """
        The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")


@pulumi.output_type
class GetQueriesQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetQueryQueryDefinitionResult(dict):
    def __init__(__self__, *,
                 cost_analysis_uis: Sequence['outputs.GetQueryQueryDefinitionCostAnalysisUiResult'],
                 display_name: str,
                 report_queries: Sequence['outputs.GetQueryQueryDefinitionReportQueryResult'],
                 version: float):
        """
        :param Sequence['GetQueryQueryDefinitionCostAnalysisUiArgs'] cost_analysis_uis: The common fields for Cost Analysis UI rendering.
        :param str display_name: The query display name. Avoid entering confidential information.
        :param Sequence['GetQueryQueryDefinitionReportQueryArgs'] report_queries: The request of the generated Cost Analysis report.
        :param float version: The saved query version.
        """
        pulumi.set(__self__, "cost_analysis_uis", cost_analysis_uis)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_queries", report_queries)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUis")
    def cost_analysis_uis(self) -> Sequence['outputs.GetQueryQueryDefinitionCostAnalysisUiResult']:
        """
        The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_uis")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="reportQueries")
    def report_queries(self) -> Sequence['outputs.GetQueryQueryDefinitionReportQueryResult']:
        """
        The request of the generated Cost Analysis report.
        """
        return pulumi.get(self, "report_queries")

    @property
    @pulumi.getter
    def version(self) -> float:
        """
        The saved query version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetQueryQueryDefinitionCostAnalysisUiResult(dict):
    def __init__(__self__, *,
                 graph: str,
                 is_cumulative_graph: bool):
        """
        :param str graph: The graph type.
        :param bool is_cumulative_graph: A cumulative graph.
        """
        pulumi.set(__self__, "graph", graph)
        pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> str:
        """
        The graph type.
        """
        return pulumi.get(self, "graph")

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> bool:
        """
        A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")


@pulumi.output_type
class GetQueryQueryDefinitionReportQueryResult(dict):
    def __init__(__self__, *,
                 compartment_depth: float,
                 date_range_name: str,
                 filter: str,
                 forecasts: Sequence['outputs.GetQueryQueryDefinitionReportQueryForecastResult'],
                 granularity: str,
                 group_bies: Sequence[str],
                 group_by_tags: Sequence['outputs.GetQueryQueryDefinitionReportQueryGroupByTagResult'],
                 is_aggregate_by_time: bool,
                 query_type: str,
                 tenant_id: str,
                 time_usage_ended: str,
                 time_usage_started: str):
        """
        :param float compartment_depth: The compartment depth level.
        :param str date_range_name: The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        :param str filter: The filter object for query usage.
        :param Sequence['GetQueryQueryDefinitionReportQueryForecastArgs'] forecasts: Forecast configuration of usage/cost.
        :param str granularity: The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        :param Sequence[str] group_bies: Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param Sequence['GetQueryQueryDefinitionReportQueryGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param bool is_aggregate_by_time: Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        :param str query_type: The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        :param str tenant_id: Tenant ID.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        """
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "date_range_name", date_range_name)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "forecasts", forecasts)
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        pulumi.set(__self__, "query_type", query_type)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> float:
        """
        The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> str:
        """
        The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        """
        return pulumi.get(self, "date_range_name")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def forecasts(self) -> Sequence['outputs.GetQueryQueryDefinitionReportQueryForecastResult']:
        """
        Forecast configuration of usage/cost.
        """
        return pulumi.get(self, "forecasts")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetQueryQueryDefinitionReportQueryGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> bool:
        """
        Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> str:
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> str:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> str:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class GetQueryQueryDefinitionReportQueryForecastResult(dict):
    def __init__(__self__, *,
                 forecast_type: str,
                 time_forecast_ended: str,
                 time_forecast_started: str):
        """
        :param str forecast_type: BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param str time_forecast_ended: The forecast end time.
        :param str time_forecast_started: The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "forecast_type", forecast_type)
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> str:
        """
        BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> str:
        """
        The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> str:
        """
        The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")


@pulumi.output_type
class GetQueryQueryDefinitionReportQueryGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetScheduleQueryPropertyResult(dict):
    def __init__(__self__, *,
                 compartment_depth: float,
                 date_ranges: Sequence['outputs.GetScheduleQueryPropertyDateRangeResult'],
                 filter: str,
                 granularity: str,
                 group_bies: Sequence[str],
                 group_by_tags: Sequence['outputs.GetScheduleQueryPropertyGroupByTagResult'],
                 is_aggregate_by_time: bool,
                 query_type: str):
        """
        :param float compartment_depth: The depth level of the compartment.
        :param Sequence['GetScheduleQueryPropertyDateRangeArgs'] date_ranges: Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        :param str filter: The filter object for query usage.
        :param str granularity: The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        :param Sequence[str] group_bies: Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        :param Sequence['GetScheduleQueryPropertyGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        :param bool is_aggregate_by_time: Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param str query_type: The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "date_ranges", date_ranges)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> float:
        """
        The depth level of the compartment.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRanges")
    def date_ranges(self) -> Sequence['outputs.GetScheduleQueryPropertyDateRangeResult']:
        """
        Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        """
        return pulumi.get(self, "date_ranges")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetScheduleQueryPropertyGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> bool:
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> str:
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        return pulumi.get(self, "query_type")


@pulumi.output_type
class GetScheduleQueryPropertyDateRangeResult(dict):
    def __init__(__self__, *,
                 date_range_type: str,
                 dynamic_date_range_type: str,
                 time_usage_ended: str,
                 time_usage_started: str):
        """
        :param str date_range_type: Defines whether the schedule date range is STATIC or DYNAMIC.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        """
        pulumi.set(__self__, "date_range_type", date_range_type)
        pulumi.set(__self__, "dynamic_date_range_type", dynamic_date_range_type)
        pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter(name="dateRangeType")
    def date_range_type(self) -> str:
        """
        Defines whether the schedule date range is STATIC or DYNAMIC.
        """
        return pulumi.get(self, "date_range_type")

    @property
    @pulumi.getter(name="dynamicDateRangeType")
    def dynamic_date_range_type(self) -> str:
        return pulumi.get(self, "dynamic_date_range_type")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> str:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> str:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class GetScheduleQueryPropertyGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The namespace needed to determine the object storage bucket.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace needed to determine the object storage bucket.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetScheduleResultLocationResult(dict):
    def __init__(__self__, *,
                 bucket: str,
                 location_type: str,
                 namespace: str,
                 region: str):
        """
        :param str bucket: The bucket name where usage or cost CSVs will be uploaded.
        :param str location_type: Defines the type of location where the usage or cost CSVs will be stored.
        :param str namespace: The namespace needed to determine the object storage bucket.
        :param str region: The destination Object Store Region specified by the customer.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The bucket name where usage or cost CSVs will be uploaded.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> str:
        """
        Defines the type of location where the usage or cost CSVs will be stored.
        """
        return pulumi.get(self, "location_type")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace needed to determine the object storage bucket.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The destination Object Store Region specified by the customer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetScheduledRunsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetScheduledRunsScheduledRunCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetScheduledRunsScheduledRunCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetScheduledRunsScheduledRunCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetScheduledRunsScheduledRunCollectionItemResult(dict):
    def __init__(__self__, *,
                 id: str,
                 lifecycle_details: str,
                 schedule_id: str,
                 state: str,
                 time_created: str,
                 time_finished: str):
        """
        :param str id: The ocid representing unique shedule run
        :param str lifecycle_details: Additional details about scheduled run failure
        :param str schedule_id: The unique ID of a schedule.
        :param str state: Specifies if the schedule job was run successfully or not.
        :param str time_created: The time when schedule started executing
        :param str time_finished: The time when schedule finished executing
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "schedule_id", schedule_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_finished", time_finished)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ocid representing unique shedule run
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional details about scheduled run failure
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> str:
        """
        The unique ID of a schedule.
        """
        return pulumi.get(self, "schedule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Specifies if the schedule job was run successfully or not.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time when schedule started executing
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> str:
        """
        The time when schedule finished executing
        """
        return pulumi.get(self, "time_finished")


@pulumi.output_type
class GetSchedulesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Query parameter for filtering by name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Query parameter for filtering by name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSchedulesScheduleCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSchedulesScheduleCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSchedulesScheduleCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSchedulesScheduleCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, str],
                 description: str,
                 freeform_tags: Mapping[str, str],
                 id: str,
                 name: str,
                 output_file_format: str,
                 query_properties: Sequence['outputs.GetSchedulesScheduleCollectionItemQueryPropertyResult'],
                 result_locations: Sequence['outputs.GetSchedulesScheduleCollectionItemResultLocationResult'],
                 saved_report_id: str,
                 schedule_recurrences: str,
                 state: str,
                 system_tags: Mapping[str, str],
                 time_created: str,
                 time_next_run: str,
                 time_scheduled: str):
        """
        :param str compartment_id: The compartment ID in which to list resources.
        :param Mapping[str, str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: The description of the schedule.
        :param Mapping[str, str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"bar-key": "value"}`
        :param str id: The OCID representing a unique shedule.
        :param str name: Query parameter for filtering by name
        :param str output_file_format: Specifies the supported output file format.
        :param Sequence['GetSchedulesScheduleCollectionItemQueryPropertyArgs'] query_properties: The query properties.
        :param Sequence['GetSchedulesScheduleCollectionItemResultLocationArgs'] result_locations: The location where usage or cost CSVs will be uploaded defined by `locationType`, which corresponds with type-specific characteristics.
        :param str saved_report_id: The saved report ID which can also be used to generate a query.
        :param str schedule_recurrences: Specifies the frequency according to when the schedule will be run, in the x-obmcs-recurring-time format described in [RFC 5545 section 3.3.10](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10). Supported values are : ONE_TIME, DAILY, WEEKLY and MONTHLY.
        :param str state: The schedule lifecycle state.
        :param Mapping[str, str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the schedule was created.
        :param str time_next_run: The date and time of the next job execution.
        :param str time_scheduled: The date and time of the first time job execution.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_file_format", output_file_format)
        pulumi.set(__self__, "query_properties", query_properties)
        pulumi.set(__self__, "result_locations", result_locations)
        pulumi.set(__self__, "saved_report_id", saved_report_id)
        pulumi.set(__self__, "schedule_recurrences", schedule_recurrences)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_next_run", time_next_run)
        pulumi.set(__self__, "time_scheduled", time_scheduled)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment ID in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the schedule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID representing a unique shedule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Query parameter for filtering by name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outputFileFormat")
    def output_file_format(self) -> str:
        """
        Specifies the supported output file format.
        """
        return pulumi.get(self, "output_file_format")

    @property
    @pulumi.getter(name="queryProperties")
    def query_properties(self) -> Sequence['outputs.GetSchedulesScheduleCollectionItemQueryPropertyResult']:
        """
        The query properties.
        """
        return pulumi.get(self, "query_properties")

    @property
    @pulumi.getter(name="resultLocations")
    def result_locations(self) -> Sequence['outputs.GetSchedulesScheduleCollectionItemResultLocationResult']:
        """
        The location where usage or cost CSVs will be uploaded defined by `locationType`, which corresponds with type-specific characteristics.
        """
        return pulumi.get(self, "result_locations")

    @property
    @pulumi.getter(name="savedReportId")
    def saved_report_id(self) -> str:
        """
        The saved report ID which can also be used to generate a query.
        """
        return pulumi.get(self, "saved_report_id")

    @property
    @pulumi.getter(name="scheduleRecurrences")
    def schedule_recurrences(self) -> str:
        """
        Specifies the frequency according to when the schedule will be run, in the x-obmcs-recurring-time format described in [RFC 5545 section 3.3.10](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10). Supported values are : ONE_TIME, DAILY, WEEKLY and MONTHLY.
        """
        return pulumi.get(self, "schedule_recurrences")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The schedule lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. See [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the schedule was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeNextRun")
    def time_next_run(self) -> str:
        """
        The date and time of the next job execution.
        """
        return pulumi.get(self, "time_next_run")

    @property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> str:
        """
        The date and time of the first time job execution.
        """
        return pulumi.get(self, "time_scheduled")


@pulumi.output_type
class GetSchedulesScheduleCollectionItemQueryPropertyResult(dict):
    def __init__(__self__, *,
                 compartment_depth: float,
                 date_ranges: Sequence['outputs.GetSchedulesScheduleCollectionItemQueryPropertyDateRangeResult'],
                 filter: str,
                 granularity: str,
                 group_bies: Sequence[str],
                 group_by_tags: Sequence['outputs.GetSchedulesScheduleCollectionItemQueryPropertyGroupByTagResult'],
                 is_aggregate_by_time: bool,
                 query_type: str):
        """
        :param float compartment_depth: The depth level of the compartment.
        :param Sequence['GetSchedulesScheduleCollectionItemQueryPropertyDateRangeArgs'] date_ranges: Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        :param str filter: The filter object for query usage.
        :param str granularity: The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        :param Sequence[str] group_bies: Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        :param Sequence['GetSchedulesScheduleCollectionItemQueryPropertyGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        :param bool is_aggregate_by_time: Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param str query_type: The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "date_ranges", date_ranges)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        pulumi.set(__self__, "query_type", query_type)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> float:
        """
        The depth level of the compartment.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRanges")
    def date_ranges(self) -> Sequence['outputs.GetSchedulesScheduleCollectionItemQueryPropertyDateRangeResult']:
        """
        Static or dynamic date range `dateRangeType`, which corresponds with type-specific characteristics.
        """
        return pulumi.get(self, "date_ranges")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetSchedulesScheduleCollectionItemQueryPropertyGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> bool:
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> str:
        """
        The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
        """
        return pulumi.get(self, "query_type")


@pulumi.output_type
class GetSchedulesScheduleCollectionItemQueryPropertyDateRangeResult(dict):
    def __init__(__self__, *,
                 date_range_type: str,
                 dynamic_date_range_type: str,
                 time_usage_ended: str,
                 time_usage_started: str):
        """
        :param str date_range_type: Defines whether the schedule date range is STATIC or DYNAMIC.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        """
        pulumi.set(__self__, "date_range_type", date_range_type)
        pulumi.set(__self__, "dynamic_date_range_type", dynamic_date_range_type)
        pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter(name="dateRangeType")
    def date_range_type(self) -> str:
        """
        Defines whether the schedule date range is STATIC or DYNAMIC.
        """
        return pulumi.get(self, "date_range_type")

    @property
    @pulumi.getter(name="dynamicDateRangeType")
    def dynamic_date_range_type(self) -> str:
        return pulumi.get(self, "dynamic_date_range_type")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> str:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> str:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")


@pulumi.output_type
class GetSchedulesScheduleCollectionItemQueryPropertyGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The namespace needed to determine the object storage bucket.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace needed to determine the object storage bucket.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSchedulesScheduleCollectionItemResultLocationResult(dict):
    def __init__(__self__, *,
                 bucket: str,
                 location_type: str,
                 namespace: str,
                 region: str):
        """
        :param str bucket: The bucket name where usage or cost CSVs will be uploaded.
        :param str location_type: Defines the type of location where the usage or cost CSVs will be stored.
        :param str namespace: The namespace needed to determine the object storage bucket.
        :param str region: The destination Object Store Region specified by the customer.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The bucket name where usage or cost CSVs will be uploaded.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> str:
        """
        Defines the type of location where the usage or cost CSVs will be stored.
        """
        return pulumi.get(self, "location_type")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace needed to determine the object storage bucket.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The destination Object Store Region specified by the customer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetUsageCarbonEmissionsConfigItemResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The configuration key.
        :param Sequence[str] values: The configuration value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The configuration key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The configuration value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 id: str,
                 query_definitions: Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionResult']):
        """
        :param str compartment_id: The compartment ID in which to list resources.
        :param str id: The query OCID.
        :param Sequence['GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionArgs'] query_definitions: The common fields for queries.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query_definitions", query_definitions)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment ID in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The query OCID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="queryDefinitions")
    def query_definitions(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionResult']:
        """
        The common fields for queries.
        """
        return pulumi.get(self, "query_definitions")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionResult(dict):
    def __init__(__self__, *,
                 cost_analysis_uis: Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionCostAnalysisUiResult'],
                 display_name: str,
                 report_queries: Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryResult'],
                 version: int):
        """
        :param Sequence['GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionCostAnalysisUiArgs'] cost_analysis_uis: The common fields for Cost Analysis UI rendering.
        :param str display_name: The query display name. Avoid entering confidential information.
        :param Sequence['GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryArgs'] report_queries: The request of the generated usage carbon emissions report.
        :param int version: The saved query version.
        """
        pulumi.set(__self__, "cost_analysis_uis", cost_analysis_uis)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_queries", report_queries)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUis")
    def cost_analysis_uis(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionCostAnalysisUiResult']:
        """
        The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_uis")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="reportQueries")
    def report_queries(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryResult']:
        """
        The request of the generated usage carbon emissions report.
        """
        return pulumi.get(self, "report_queries")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        The saved query version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionCostAnalysisUiResult(dict):
    def __init__(__self__, *,
                 graph: str,
                 is_cumulative_graph: bool):
        """
        :param str graph: The graph type.
        :param bool is_cumulative_graph: A cumulative graph.
        """
        pulumi.set(__self__, "graph", graph)
        pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> str:
        """
        The graph type.
        """
        return pulumi.get(self, "graph")

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> bool:
        """
        A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryResult(dict):
    def __init__(__self__, *,
                 compartment_depth: int,
                 date_range_name: str,
                 group_bies: Sequence[str],
                 group_by_tags: Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult'],
                 is_aggregate_by_time: bool,
                 tenant_id: str,
                 time_usage_ended: str,
                 time_usage_started: str,
                 usage_carbon_emissions_query_filter: str):
        """
        :param int compartment_depth: The compartment depth level.
        :param str date_range_name: The UI date range, for example, LAST_THREE_MONTHS. It will override timeUsageStarted and timeUsageEnded properties.
        :param Sequence[str] group_bies: Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param Sequence['GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param bool is_aggregate_by_time: Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param str tenant_id: Tenant ID.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        :param str usage_carbon_emissions_query_filter: The filter object for query usage.
        """
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "date_range_name", date_range_name)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        pulumi.set(__self__, "time_usage_started", time_usage_started)
        pulumi.set(__self__, "usage_carbon_emissions_query_filter", usage_carbon_emissions_query_filter)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> int:
        """
        The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> str:
        """
        The UI date range, for example, LAST_THREE_MONTHS. It will override timeUsageStarted and timeUsageEnded properties.
        """
        return pulumi.get(self, "date_range_name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> bool:
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> str:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> str:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @property
    @pulumi.getter(name="usageCarbonEmissionsQueryFilter")
    def usage_carbon_emissions_query_filter(self) -> str:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "usage_carbon_emissions_query_filter")


@pulumi.output_type
class GetUsageCarbonEmissionsQueriesUsageCarbonEmissionsQueryCollectionItemQueryDefinitionReportQueryGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetUsageCarbonEmissionsQueryQueryDefinitionResult(dict):
    def __init__(__self__, *,
                 cost_analysis_uis: Sequence['outputs.GetUsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiResult'],
                 display_name: str,
                 report_queries: Sequence['outputs.GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryResult'],
                 version: int):
        """
        :param Sequence['GetUsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiArgs'] cost_analysis_uis: The common fields for Cost Analysis UI rendering.
        :param str display_name: The query display name. Avoid entering confidential information.
        :param Sequence['GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryArgs'] report_queries: The request of the generated usage carbon emissions report.
        :param int version: The saved query version.
        """
        pulumi.set(__self__, "cost_analysis_uis", cost_analysis_uis)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_queries", report_queries)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUis")
    def cost_analysis_uis(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiResult']:
        """
        The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_uis")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="reportQueries")
    def report_queries(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryResult']:
        """
        The request of the generated usage carbon emissions report.
        """
        return pulumi.get(self, "report_queries")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        The saved query version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetUsageCarbonEmissionsQueryQueryDefinitionCostAnalysisUiResult(dict):
    def __init__(__self__, *,
                 graph: str,
                 is_cumulative_graph: bool):
        """
        :param str graph: The graph type.
        :param bool is_cumulative_graph: A cumulative graph.
        """
        pulumi.set(__self__, "graph", graph)
        pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> str:
        """
        The graph type.
        """
        return pulumi.get(self, "graph")

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> bool:
        """
        A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")


@pulumi.output_type
class GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryResult(dict):
    def __init__(__self__, *,
                 compartment_depth: int,
                 date_range_name: str,
                 group_bies: Sequence[str],
                 group_by_tags: Sequence['outputs.GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagResult'],
                 is_aggregate_by_time: bool,
                 tenant_id: str,
                 time_usage_ended: str,
                 time_usage_started: str,
                 usage_carbon_emissions_query_filter: str):
        """
        :param int compartment_depth: The compartment depth level.
        :param str date_range_name: The UI date range, for example, LAST_THREE_MONTHS. It will override timeUsageStarted and timeUsageEnded properties.
        :param Sequence[str] group_bies: Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param Sequence['GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagArgs'] group_by_tags: GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param bool is_aggregate_by_time: Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        :param str tenant_id: Tenant ID.
        :param str time_usage_ended: The usage end time.
        :param str time_usage_started: The usage start time.
        :param str usage_carbon_emissions_query_filter: The filter object for query usage.
        """
        pulumi.set(__self__, "compartment_depth", compartment_depth)
        pulumi.set(__self__, "date_range_name", date_range_name)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_by_tags", group_by_tags)
        pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        pulumi.set(__self__, "time_usage_started", time_usage_started)
        pulumi.set(__self__, "usage_carbon_emissions_query_filter", usage_carbon_emissions_query_filter)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> int:
        """
        The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> str:
        """
        The UI date range, for example, LAST_THREE_MONTHS. It will override timeUsageStarted and timeUsageEnded properties.
        """
        return pulumi.get(self, "date_range_name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[str]:
        """
        Specifies what to aggregate the result by. For example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Sequence['outputs.GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagResult']:
        """
        GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> bool:
        """
        Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> str:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> str:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @property
    @pulumi.getter(name="usageCarbonEmissionsQueryFilter")
    def usage_carbon_emissions_query_filter(self) -> str:
        """
        The filter object for query usage.
        """
        return pulumi.get(self, "usage_carbon_emissions_query_filter")


@pulumi.output_type
class GetUsageCarbonEmissionsQueryQueryDefinitionReportQueryGroupByTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 namespace: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str namespace: The tag namespace.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetUsageStatementEmailRecipientsGroupRecipientsListResult(dict):
    def __init__(__self__, *,
                 email_id: str,
                 first_name: str,
                 last_name: str,
                 state: str):
        """
        :param str email_id: the email of the recipient.
        :param str first_name: the first name of the recipient.
        :param str last_name: the last name of the recipient.
        :param str state: The email recipient group lifecycle state.
        """
        pulumi.set(__self__, "email_id", email_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="emailId")
    def email_id(self) -> str:
        """
        the email of the recipient.
        """
        return pulumi.get(self, "email_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        the first name of the recipient.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        the last name of the recipient.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The email recipient group lifecycle state.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 email_recipients_group_id: str,
                 id: str,
                 recipients_lists: Sequence['outputs.GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemRecipientsListResult'],
                 state: str,
                 subscription_id: str):
        """
        :param str compartment_id: The compartment ID in which to list resources.
        :param str id: The usage statement email recipients group OCID.
        :param Sequence['GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemRecipientsListArgs'] recipients_lists: The list of recipient will receive the usage statement email.
        :param str state: The email recipient group lifecycle state.
        :param str subscription_id: The UsageStatement Subscription unique OCID.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "email_recipients_group_id", email_recipients_group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "recipients_lists", recipients_lists)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment ID in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="emailRecipientsGroupId")
    def email_recipients_group_id(self) -> str:
        return pulumi.get(self, "email_recipients_group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The usage statement email recipients group OCID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="recipientsLists")
    def recipients_lists(self) -> Sequence['outputs.GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemRecipientsListResult']:
        """
        The list of recipient will receive the usage statement email.
        """
        return pulumi.get(self, "recipients_lists")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The email recipient group lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        The UsageStatement Subscription unique OCID.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class GetUsageStatementEmailRecipientsGroupsEmailRecipientsGroupCollectionItemRecipientsListResult(dict):
    def __init__(__self__, *,
                 email_id: str,
                 first_name: str,
                 last_name: str,
                 state: str):
        """
        :param str email_id: the email of the recipient.
        :param str first_name: the first name of the recipient.
        :param str last_name: the last name of the recipient.
        :param str state: The email recipient group lifecycle state.
        """
        pulumi.set(__self__, "email_id", email_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="emailId")
    def email_id(self) -> str:
        """
        the email of the recipient.
        """
        return pulumi.get(self, "email_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        the first name of the recipient.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        the last name of the recipient.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The email recipient group lifecycle state.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetUsageStatementEmailRecipientsGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


