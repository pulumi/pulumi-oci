# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AnalyticsClusterClusterNode',
    'ChannelSource',
    'ChannelSourceSslCaCertificate',
    'ChannelTarget',
    'HeatWaveClusterClusterNode',
    'MysqlBackupDbSystemSnapshot',
    'MysqlBackupDbSystemSnapshotBackupPolicy',
    'MysqlBackupDbSystemSnapshotDeletionPolicy',
    'MysqlBackupDbSystemSnapshotEndpoint',
    'MysqlBackupDbSystemSnapshotMaintenance',
    'MysqlDbSystemAnalyticsCluster',
    'MysqlDbSystemBackupPolicy',
    'MysqlDbSystemChannel',
    'MysqlDbSystemChannelSource',
    'MysqlDbSystemChannelSourceSslCaCertificate',
    'MysqlDbSystemChannelTarget',
    'MysqlDbSystemCurrentPlacement',
    'MysqlDbSystemDeletionPolicy',
    'MysqlDbSystemEndpoint',
    'MysqlDbSystemHeatWaveCluster',
    'MysqlDbSystemMaintenance',
    'MysqlDbSystemSource',
    'GetAnalyticsClusterClusterNodeResult',
    'GetChannelSourceResult',
    'GetChannelSourceSslCaCertificateResult',
    'GetChannelTargetResult',
    'GetChannelsChannelResult',
    'GetChannelsChannelSourceResult',
    'GetChannelsChannelSourceSslCaCertificateResult',
    'GetChannelsChannelTargetResult',
    'GetChannelsFilterResult',
    'GetHeatWaveClusterClusterNodeResult',
    'GetMysqlBackupDbSystemSnapshotResult',
    'GetMysqlBackupDbSystemSnapshotBackupPolicyResult',
    'GetMysqlBackupDbSystemSnapshotDeletionPolicyResult',
    'GetMysqlBackupDbSystemSnapshotEndpointResult',
    'GetMysqlBackupDbSystemSnapshotMaintenanceResult',
    'GetMysqlBackupsBackupResult',
    'GetMysqlBackupsBackupDbSystemSnapshotResult',
    'GetMysqlBackupsBackupDbSystemSnapshotBackupPolicyResult',
    'GetMysqlBackupsBackupDbSystemSnapshotDeletionPolicyResult',
    'GetMysqlBackupsBackupDbSystemSnapshotEndpointResult',
    'GetMysqlBackupsBackupDbSystemSnapshotMaintenanceResult',
    'GetMysqlBackupsFilterResult',
    'GetMysqlConfigurationVariableResult',
    'GetMysqlConfigurationsConfigurationResult',
    'GetMysqlConfigurationsConfigurationVariablesResult',
    'GetMysqlConfigurationsFilterResult',
    'GetMysqlDbSystemAnalyticsClusterResult',
    'GetMysqlDbSystemBackupPolicyResult',
    'GetMysqlDbSystemChannelResult',
    'GetMysqlDbSystemChannelSourceResult',
    'GetMysqlDbSystemChannelSourceSslCaCertificateResult',
    'GetMysqlDbSystemChannelTargetResult',
    'GetMysqlDbSystemCurrentPlacementResult',
    'GetMysqlDbSystemDeletionPolicyResult',
    'GetMysqlDbSystemEndpointResult',
    'GetMysqlDbSystemHeatWaveClusterResult',
    'GetMysqlDbSystemMaintenanceResult',
    'GetMysqlDbSystemSourceResult',
    'GetMysqlDbSystemsDbSystemResult',
    'GetMysqlDbSystemsDbSystemAnalyticsClusterResult',
    'GetMysqlDbSystemsDbSystemBackupPolicyResult',
    'GetMysqlDbSystemsDbSystemChannelResult',
    'GetMysqlDbSystemsDbSystemChannelSourceResult',
    'GetMysqlDbSystemsDbSystemChannelSourceSslCaCertificateResult',
    'GetMysqlDbSystemsDbSystemChannelTargetResult',
    'GetMysqlDbSystemsDbSystemCurrentPlacementResult',
    'GetMysqlDbSystemsDbSystemDeletionPolicyResult',
    'GetMysqlDbSystemsDbSystemEndpointResult',
    'GetMysqlDbSystemsDbSystemHeatWaveClusterResult',
    'GetMysqlDbSystemsDbSystemMaintenanceResult',
    'GetMysqlDbSystemsDbSystemSourceResult',
    'GetMysqlDbSystemsFilterResult',
    'GetMysqlVersionFilterResult',
    'GetMysqlVersionVersionResult',
    'GetMysqlVersionVersionVersionResult',
    'GetShapesFilterResult',
    'GetShapesShapeResult',
]

@pulumi.output_type
class AnalyticsClusterClusterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeId":
            suggest = "node_id"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalyticsClusterClusterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalyticsClusterClusterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalyticsClusterClusterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_id: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str node_id: The ID of the node within MySQL Analytics Cluster.
        :param str state: (Updatable) The target state for the Analytics Cluster. Could be set to `ACTIVE` or `INACTIVE`.
        :param str time_created: The date and time the Analytics Cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str time_updated: The time the Analytics Cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        """
        The ID of the node within MySQL Analytics Cluster.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The target state for the Analytics Cluster. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the Analytics Cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The time the Analytics Cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class ChannelSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "sslCaCertificate":
            suggest = "ssl_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 password: str,
                 source_type: str,
                 ssl_mode: str,
                 username: str,
                 port: Optional[int] = None,
                 ssl_ca_certificate: Optional['outputs.ChannelSourceSslCaCertificate'] = None):
        """
        :param str hostname: (Updatable) The network address of the MySQL instance.
        :param str password: (Updatable) The password for the replication user. The password must be between 8 and 32 characters long, and must contain at least 1 numeric character, 1 lowercase character, 1 uppercase character, and 1 special (nonalphanumeric) character.
        :param str source_type: (Updatable) The specific source identifier.
        :param str ssl_mode: (Updatable) The SSL mode of the Channel.
        :param str username: (Updatable) The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        :param int port: (Updatable) The port the source MySQL instance listens on.
        :param 'ChannelSourceSslCaCertificateArgs' ssl_ca_certificate: (Updatable) The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_mode", ssl_mode)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl_ca_certificate is not None:
            pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        (Updatable) The network address of the MySQL instance.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        (Updatable) The password for the replication user. The password must be between 8 and 32 characters long, and must contain at least 1 numeric character, 1 lowercase character, 1 uppercase character, and 1 special (nonalphanumeric) character.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        (Updatable) The specific source identifier.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        (Updatable) The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        (Updatable) The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        (Updatable) The port the source MySQL instance listens on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> Optional['outputs.ChannelSourceSslCaCertificate']:
        """
        (Updatable) The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificate")


@pulumi.output_type
class ChannelSourceSslCaCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelSourceSslCaCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelSourceSslCaCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelSourceSslCaCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: str,
                 contents: str):
        """
        :param str certificate_type: (Updatable) The type of CA certificate.
        :param str contents: (Updatable) The string containing the CA certificate in PEM format.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        (Updatable) The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter
    def contents(self) -> str:
        """
        (Updatable) The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class ChannelTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "applierUsername":
            suggest = "applier_username"
        elif key == "channelName":
            suggest = "channel_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_system_id: str,
                 target_type: str,
                 applier_username: Optional[str] = None,
                 channel_name: Optional[str] = None):
        """
        :param str db_system_id: The OCID of the target DB System.
        :param str target_type: (Updatable) The specific target identifier.
        :param str applier_username: (Updatable) The username for the replication applier of the target MySQL DB System.
        :param str channel_name: (Updatable) The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "target_type", target_type)
        if applier_username is not None:
            pulumi.set(__self__, "applier_username", applier_username)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The OCID of the target DB System.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        (Updatable) The specific target identifier.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> Optional[str]:
        """
        (Updatable) The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[str]:
        """
        (Updatable) The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")


@pulumi.output_type
class HeatWaveClusterClusterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeId":
            suggest = "node_id"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeatWaveClusterClusterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeatWaveClusterClusterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeatWaveClusterClusterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_id: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str node_id: The ID of the node within MySQL HeatWave cluster.
        :param str state: (Updatable) The target state for the HeatWave cluster. Could be set to `ACTIVE` or `INACTIVE`.
        :param str time_created: The date and time the HeatWave cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str time_updated: The time the HeatWave cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        """
        The ID of the node within MySQL HeatWave cluster.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The target state for the HeatWave cluster. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the HeatWave cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The time the HeatWave cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class MysqlBackupDbSystemSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "backupPolicies":
            suggest = "backup_policies"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "configurationId":
            suggest = "configuration_id"
        elif key == "crashRecovery":
            suggest = "crash_recovery"
        elif key == "dataStorageSizeInGb":
            suggest = "data_storage_size_in_gb"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "deletionPolicies":
            suggest = "deletion_policies"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "faultDomain":
            suggest = "fault_domain"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "hostnameLabel":
            suggest = "hostname_label"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "isHighlyAvailable":
            suggest = "is_highly_available"
        elif key == "mysqlVersion":
            suggest = "mysql_version"
        elif key == "portX":
            suggest = "port_x"
        elif key == "shapeName":
            suggest = "shape_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlBackupDbSystemSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlBackupDbSystemSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlBackupDbSystemSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: Optional[str] = None,
                 availability_domain: Optional[str] = None,
                 backup_policies: Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotBackupPolicy']] = None,
                 compartment_id: Optional[str] = None,
                 configuration_id: Optional[str] = None,
                 crash_recovery: Optional[str] = None,
                 data_storage_size_in_gb: Optional[int] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 deletion_policies: Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotDeletionPolicy']] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotEndpoint']] = None,
                 fault_domain: Optional[str] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 hostname_label: Optional[str] = None,
                 id: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 is_highly_available: Optional[bool] = None,
                 maintenances: Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotMaintenance']] = None,
                 mysql_version: Optional[str] = None,
                 port: Optional[int] = None,
                 port_x: Optional[int] = None,
                 shape_name: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str admin_username: The username for the administrative user.
        :param str availability_domain: The Availability Domain where the primary DB System should be located.
        :param Sequence['MysqlBackupDbSystemSnapshotBackupPolicyArgs'] backup_policies: The Backup policy for the DB System.
        :param str compartment_id: (Updatable) The OCID of the compartment.
        :param str configuration_id: The OCID of the Configuration to be used for Instances in this DB System.
        :param str crash_recovery: Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        :param int data_storage_size_in_gb: Initial size of the data volume in GiBs that will be created and attached.
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Sequence['MysqlBackupDbSystemSnapshotDeletionPolicyArgs'] deletion_policies: The Deletion policy for the DB System.
        :param str description: (Updatable) A user-supplied description for the backup.
        :param str display_name: (Updatable) A user-supplied display name for the backup.
        :param Sequence['MysqlBackupDbSystemSnapshotEndpointArgs'] endpoints: The network endpoints available for this DB System.
        :param str fault_domain: The name of the Fault Domain the DB System is located in.
        :param Mapping[str, Any] freeform_tags: (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str hostname_label: The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        :param str id: OCID of the backup itself
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param bool is_highly_available: If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        :param Sequence['MysqlBackupDbSystemSnapshotMaintenanceArgs'] maintenances: The Maintenance Policy for the DB System.
        :param str mysql_version: The MySQL server version of the DB System used for backup.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str shape_name: The shape of the DB System instance used for backup.
        :param str subnet_id: The OCID of the subnet the DB System is associated with.
        """
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if backup_policies is not None:
            pulumi.set(__self__, "backup_policies", backup_policies)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if configuration_id is not None:
            pulumi.set(__self__, "configuration_id", configuration_id)
        if crash_recovery is not None:
            pulumi.set(__self__, "crash_recovery", crash_recovery)
        if data_storage_size_in_gb is not None:
            pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if deletion_policies is not None:
            pulumi.set(__self__, "deletion_policies", deletion_policies)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if hostname_label is not None:
            pulumi.set(__self__, "hostname_label", hostname_label)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_highly_available is not None:
            pulumi.set(__self__, "is_highly_available", is_highly_available)
        if maintenances is not None:
            pulumi.set(__self__, "maintenances", maintenances)
        if mysql_version is not None:
            pulumi.set(__self__, "mysql_version", mysql_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_x is not None:
            pulumi.set(__self__, "port_x", port_x)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        The username for the administrative user.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[str]:
        """
        The Availability Domain where the primary DB System should be located.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupPolicies")
    def backup_policies(self) -> Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotBackupPolicy']]:
        """
        The Backup policy for the DB System.
        """
        return pulumi.get(self, "backup_policies")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="configurationId")
    def configuration_id(self) -> Optional[str]:
        """
        The OCID of the Configuration to be used for Instances in this DB System.
        """
        return pulumi.get(self, "configuration_id")

    @property
    @pulumi.getter(name="crashRecovery")
    def crash_recovery(self) -> Optional[str]:
        """
        Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        """
        return pulumi.get(self, "crash_recovery")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> Optional[int]:
        """
        Initial size of the data volume in GiBs that will be created and attached.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="deletionPolicies")
    def deletion_policies(self) -> Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotDeletionPolicy']]:
        """
        The Deletion policy for the DB System.
        """
        return pulumi.get(self, "deletion_policies")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) A user-supplied description for the backup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) A user-supplied display name for the backup.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotEndpoint']]:
        """
        The network endpoints available for this DB System.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[str]:
        """
        The name of the Fault Domain the DB System is located in.
        """
        return pulumi.get(self, "fault_domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[str]:
        """
        The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        """
        return pulumi.get(self, "hostname_label")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        OCID of the backup itself
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="isHighlyAvailable")
    def is_highly_available(self) -> Optional[bool]:
        """
        If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        """
        return pulumi.get(self, "is_highly_available")

    @property
    @pulumi.getter
    def maintenances(self) -> Optional[Sequence['outputs.MysqlBackupDbSystemSnapshotMaintenance']]:
        """
        The Maintenance Policy for the DB System.
        """
        return pulumi.get(self, "maintenances")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> Optional[str]:
        """
        The MySQL server version of the DB System used for backup.
        """
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> Optional[int]:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[str]:
        """
        The shape of the DB System instance used for backup.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The OCID of the subnet the DB System is associated with.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MysqlBackupDbSystemSnapshotBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlBackupDbSystemSnapshotBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlBackupDbSystemSnapshotBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlBackupDbSystemSnapshotBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 is_enabled: Optional[bool] = None,
                 retention_in_days: Optional[int] = None,
                 window_start_time: Optional[str] = None):
        """
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, Any] freeform_tags: (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param bool is_enabled: If automated backups are enabled or disabled.
        :param int retention_in_days: (Updatable) Number of days to retain this backup.
        :param str window_start_time: The start time of the maintenance window.
        """
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If automated backups are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        (Updatable) Number of days to retain this backup.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[str]:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class MysqlBackupDbSystemSnapshotDeletionPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticBackupRetention":
            suggest = "automatic_backup_retention"
        elif key == "finalBackup":
            suggest = "final_backup"
        elif key == "isDeleteProtected":
            suggest = "is_delete_protected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlBackupDbSystemSnapshotDeletionPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlBackupDbSystemSnapshotDeletionPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlBackupDbSystemSnapshotDeletionPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_backup_retention: Optional[str] = None,
                 final_backup: Optional[str] = None,
                 is_delete_protected: Optional[bool] = None):
        """
        :param str automatic_backup_retention: Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        :param str final_backup: Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        :param bool is_delete_protected: Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        if automatic_backup_retention is not None:
            pulumi.set(__self__, "automatic_backup_retention", automatic_backup_retention)
        if final_backup is not None:
            pulumi.set(__self__, "final_backup", final_backup)
        if is_delete_protected is not None:
            pulumi.set(__self__, "is_delete_protected", is_delete_protected)

    @property
    @pulumi.getter(name="automaticBackupRetention")
    def automatic_backup_retention(self) -> Optional[str]:
        """
        Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        """
        return pulumi.get(self, "automatic_backup_retention")

    @property
    @pulumi.getter(name="finalBackup")
    def final_backup(self) -> Optional[str]:
        """
        Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        """
        return pulumi.get(self, "final_backup")

    @property
    @pulumi.getter(name="isDeleteProtected")
    def is_delete_protected(self) -> Optional[bool]:
        """
        Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        return pulumi.get(self, "is_delete_protected")


@pulumi.output_type
class MysqlBackupDbSystemSnapshotEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "portX":
            suggest = "port_x"
        elif key == "statusDetails":
            suggest = "status_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlBackupDbSystemSnapshotEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlBackupDbSystemSnapshotEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlBackupDbSystemSnapshotEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 modes: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 port_x: Optional[int] = None,
                 status: Optional[str] = None,
                 status_details: Optional[str] = None):
        """
        :param str hostname: The network address of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param Sequence[str] modes: The access modes from the client that this endpoint supports.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param str status_details: Additional information about the current endpoint status.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_x is not None:
            pulumi.set(__self__, "port_x", port_x)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_details is not None:
            pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def modes(self) -> Optional[Sequence[str]]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> Optional[int]:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> Optional[str]:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")


@pulumi.output_type
class MysqlBackupDbSystemSnapshotMaintenance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlBackupDbSystemSnapshotMaintenance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlBackupDbSystemSnapshotMaintenance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlBackupDbSystemSnapshotMaintenance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_start_time: Optional[str] = None):
        """
        :param str window_start_time: The start time of the maintenance window.
        """
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[str]:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class MysqlDbSystemAnalyticsCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterSize":
            suggest = "cluster_size"
        elif key == "shapeName":
            suggest = "shape_name"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemAnalyticsCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemAnalyticsCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemAnalyticsCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_size: Optional[int] = None,
                 shape_name: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param int cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param str shape_name: The name of the shape. The shape determines the resources allocated
               * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        :param str state: (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[int]:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[str]:
        """
        The name of the shape. The shape determines the resources allocated
        * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class MysqlDbSystemBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 is_enabled: Optional[bool] = None,
                 retention_in_days: Optional[int] = None,
                 window_start_time: Optional[str] = None):
        """
        :param Mapping[str, Any] defined_tags: (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, Any] freeform_tags: (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param bool is_enabled: (Updatable) Specifies if automatic backups are enabled.
        :param int retention_in_days: (Updatable) Number of days to retain an automatic backup.
        :param str window_start_time: (Updatable) The start of the 2 hour maintenance window.
        """
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        (Updatable) Specifies if automatic backups are enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        (Updatable) Number of days to retain an automatic backup.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[str]:
        """
        (Updatable) The start of the 2 hour maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class MysqlDbSystemChannel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemChannel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemChannel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemChannel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 display_name: Optional[str] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 lifecycle_details: Optional[str] = None,
                 sources: Optional[Sequence['outputs.MysqlDbSystemChannelSource']] = None,
                 state: Optional[str] = None,
                 targets: Optional[Sequence['outputs.MysqlDbSystemChannelTarget']] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str compartment_id: The OCID of the compartment.
        :param Mapping[str, Any] defined_tags: (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: (Updatable) The user-friendly name for the DB System. It does not have to be unique.
        :param Mapping[str, Any] freeform_tags: (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The OCID of the DB System.
        :param bool is_enabled: (Updatable) Specifies if automatic backups are enabled.
        :param str lifecycle_details: Additional information about the current lifecycleState.
        :param Sequence['MysqlDbSystemChannelSourceArgs'] sources: Parameters detailing how to provision the initial data of the system.
        :param str state: (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        :param Sequence['MysqlDbSystemChannelTargetArgs'] targets: Details about the Channel target.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) The user-friendly name for the DB System. It does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The OCID of the DB System.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        (Updatable) Specifies if automatic backups are enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycleState.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.MysqlDbSystemChannelSource']]:
        """
        Parameters detailing how to provision the initial data of the system.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.MysqlDbSystemChannelTarget']]:
        """
        Details about the Channel target.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class MysqlDbSystemChannelSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "sslCaCertificates":
            suggest = "ssl_ca_certificates"
        elif key == "sslMode":
            suggest = "ssl_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemChannelSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemChannelSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemChannelSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 port: Optional[int] = None,
                 source_type: Optional[str] = None,
                 ssl_ca_certificates: Optional[Sequence['outputs.MysqlDbSystemChannelSourceSslCaCertificate']] = None,
                 ssl_mode: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The network address of the DB System.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param str source_type: The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        :param Sequence['MysqlDbSystemChannelSourceSslCaCertificateArgs'] ssl_ca_certificates: The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        :param str ssl_mode: The SSL mode of the Channel.
        :param str username: The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if ssl_ca_certificates is not None:
            pulumi.set(__self__, "ssl_ca_certificates", ssl_ca_certificates)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[str]:
        """
        The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslCaCertificates")
    def ssl_ca_certificates(self) -> Optional[Sequence['outputs.MysqlDbSystemChannelSourceSslCaCertificate']]:
        """
        The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificates")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[str]:
        """
        The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class MysqlDbSystemChannelSourceSslCaCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemChannelSourceSslCaCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemChannelSourceSslCaCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemChannelSourceSslCaCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: Optional[str] = None,
                 contents: Optional[str] = None):
        """
        :param str certificate_type: The type of CA certificate.
        :param str contents: The string containing the CA certificate in PEM format.
        """
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[str]:
        """
        The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter
    def contents(self) -> Optional[str]:
        """
        The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class MysqlDbSystemChannelTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applierUsername":
            suggest = "applier_username"
        elif key == "channelName":
            suggest = "channel_name"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "targetType":
            suggest = "target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemChannelTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemChannelTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemChannelTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applier_username: Optional[str] = None,
                 channel_name: Optional[str] = None,
                 db_system_id: Optional[str] = None,
                 target_type: Optional[str] = None):
        """
        :param str applier_username: The username for the replication applier of the target MySQL DB System.
        :param str channel_name: The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        :param str db_system_id: The OCID of the source DB System.
        :param str target_type: The specific target identifier.
        """
        if applier_username is not None:
            pulumi.set(__self__, "applier_username", applier_username)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> Optional[str]:
        """
        The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[str]:
        """
        The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[str]:
        """
        The OCID of the source DB System.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        The specific target identifier.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class MysqlDbSystemCurrentPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "faultDomain":
            suggest = "fault_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemCurrentPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemCurrentPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemCurrentPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain: Optional[str] = None,
                 fault_domain: Optional[str] = None):
        """
        :param str availability_domain: The availability domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        :param str fault_domain: The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[str]:
        """
        The availability domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[str]:
        """
        The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "fault_domain")


@pulumi.output_type
class MysqlDbSystemDeletionPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticBackupRetention":
            suggest = "automatic_backup_retention"
        elif key == "finalBackup":
            suggest = "final_backup"
        elif key == "isDeleteProtected":
            suggest = "is_delete_protected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemDeletionPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemDeletionPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemDeletionPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_backup_retention: Optional[str] = None,
                 final_backup: Optional[str] = None,
                 is_delete_protected: Optional[bool] = None):
        """
        :param str automatic_backup_retention: (Updatable) Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        :param str final_backup: (Updatable) Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        :param bool is_delete_protected: (Updatable) Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        if automatic_backup_retention is not None:
            pulumi.set(__self__, "automatic_backup_retention", automatic_backup_retention)
        if final_backup is not None:
            pulumi.set(__self__, "final_backup", final_backup)
        if is_delete_protected is not None:
            pulumi.set(__self__, "is_delete_protected", is_delete_protected)

    @property
    @pulumi.getter(name="automaticBackupRetention")
    def automatic_backup_retention(self) -> Optional[str]:
        """
        (Updatable) Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        """
        return pulumi.get(self, "automatic_backup_retention")

    @property
    @pulumi.getter(name="finalBackup")
    def final_backup(self) -> Optional[str]:
        """
        (Updatable) Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        """
        return pulumi.get(self, "final_backup")

    @property
    @pulumi.getter(name="isDeleteProtected")
    def is_delete_protected(self) -> Optional[bool]:
        """
        (Updatable) Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        return pulumi.get(self, "is_delete_protected")


@pulumi.output_type
class MysqlDbSystemEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "portX":
            suggest = "port_x"
        elif key == "statusDetails":
            suggest = "status_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 modes: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 port_x: Optional[int] = None,
                 status: Optional[str] = None,
                 status_details: Optional[str] = None):
        """
        :param str hostname: The network address of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of your choice to assign to the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This should be a "dotted-quad" style IPv4 address.
        :param Sequence[str] modes: The access modes from the client that this endpoint supports.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The TCP network port on which X Plugin listens for connections. This is the X Plugin equivalent of port.
        :param str status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param str status_details: Additional information about the current endpoint status.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_x is not None:
            pulumi.set(__self__, "port_x", port_x)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_details is not None:
            pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address the DB System is configured to listen on. A private IP address of your choice to assign to the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This should be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def modes(self) -> Optional[Sequence[str]]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> Optional[int]:
        """
        The TCP network port on which X Plugin listens for connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> Optional[str]:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")


@pulumi.output_type
class MysqlDbSystemHeatWaveCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterSize":
            suggest = "cluster_size"
        elif key == "shapeName":
            suggest = "shape_name"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemHeatWaveCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemHeatWaveCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemHeatWaveCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_size: Optional[int] = None,
                 shape_name: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param int cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param str shape_name: The name of the shape. The shape determines the resources allocated
               * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        :param str state: (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[int]:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[str]:
        """
        The name of the shape. The shape determines the resources allocated
        * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class MysqlDbSystemMaintenance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemMaintenance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemMaintenance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemMaintenance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_start_time: str):
        """
        :param str window_start_time: (Updatable) The start of the 2 hour maintenance window.
        """
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        (Updatable) The start of the 2 hour maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class MysqlDbSystemSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "backupId":
            suggest = "backup_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlDbSystemSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlDbSystemSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlDbSystemSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 backup_id: Optional[str] = None):
        """
        :param str source_type: The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        :param str backup_id: The OCID of the backup to be used as the source for the new DB System.
        """
        pulumi.set(__self__, "source_type", source_type)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        The OCID of the backup to be used as the source for the new DB System.
        """
        return pulumi.get(self, "backup_id")


@pulumi.output_type
class GetAnalyticsClusterClusterNodeResult(dict):
    def __init__(__self__, *,
                 node_id: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str node_id: The ID of the node within MySQL Analytics Cluster.
        :param str state: The current state of the Analytics Cluster.
        :param str time_created: The date and time the Analytics Cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str time_updated: The time the Analytics Cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        The ID of the node within MySQL Analytics Cluster.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Analytics Cluster.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Analytics Cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the Analytics Cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetChannelSourceResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 password: str,
                 port: int,
                 source_type: str,
                 ssl_ca_certificates: Sequence['outputs.GetChannelSourceSslCaCertificateResult'],
                 ssl_mode: str,
                 username: str):
        """
        :param str hostname: The network address of the MySQL instance.
        :param int port: The port the source MySQL instance listens on.
        :param str source_type: The specific source identifier.
        :param Sequence['GetChannelSourceSslCaCertificateArgs'] ssl_ca_certificates: The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        :param str ssl_mode: The SSL mode of the Channel.
        :param str username: The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_ca_certificates", ssl_ca_certificates)
        pulumi.set(__self__, "ssl_mode", ssl_mode)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the MySQL instance.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port the source MySQL instance listens on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslCaCertificates")
    def ssl_ca_certificates(self) -> Sequence['outputs.GetChannelSourceSslCaCertificateResult']:
        """
        The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificates")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetChannelSourceSslCaCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_type: str,
                 contents: str):
        """
        :param str certificate_type: The type of CA certificate.
        :param str contents: The string containing the CA certificate in PEM format.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter
    def contents(self) -> str:
        """
        The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class GetChannelTargetResult(dict):
    def __init__(__self__, *,
                 applier_username: str,
                 channel_name: str,
                 db_system_id: str,
                 target_type: str):
        """
        :param str applier_username: The username for the replication applier of the target MySQL DB System.
        :param str channel_name: The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        :param str db_system_id: The OCID of the source DB System.
        :param str target_type: The specific target identifier.
        """
        pulumi.set(__self__, "applier_username", applier_username)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> str:
        """
        The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The OCID of the source DB System.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        The specific target identifier.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class GetChannelsChannelResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_enabled: bool,
                 lifecycle_details: str,
                 sources: Sequence['outputs.GetChannelsChannelSourceResult'],
                 state: str,
                 targets: Sequence['outputs.GetChannelsChannelTargetResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: User provided description of the Channel.
        :param str display_name: A filter to return only the resource matching the given display name exactly.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The OCID of the Channel.
        :param bool is_enabled: If true, returns only Channels that are enabled. If false, returns only Channels that are disabled.
        :param str lifecycle_details: A message describing the state of the Channel.
        :param Sequence['GetChannelsChannelSourceArgs'] sources: Parameters detailing how to provision the source for the given Channel.
        :param str state: The LifecycleState of the Channel.
        :param Sequence['GetChannelsChannelTargetArgs'] targets: Details about the Channel target.
        :param str time_created: The date and time the Channel was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str time_updated: The time the Channel was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "targets", targets)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        User provided description of the Channel.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only the resource matching the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Channel.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        If true, returns only Channels that are enabled. If false, returns only Channels that are disabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the state of the Channel.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetChannelsChannelSourceResult']:
        """
        Parameters detailing how to provision the source for the given Channel.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The LifecycleState of the Channel.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetChannelsChannelTargetResult']:
        """
        Details about the Channel target.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Channel was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the Channel was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetChannelsChannelSourceResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 password: str,
                 port: int,
                 source_type: str,
                 ssl_ca_certificates: Sequence['outputs.GetChannelsChannelSourceSslCaCertificateResult'],
                 ssl_mode: str,
                 username: str):
        """
        :param str hostname: The network address of the MySQL instance.
        :param int port: The port the source MySQL instance listens on.
        :param str source_type: The specific source identifier.
        :param Sequence['GetChannelsChannelSourceSslCaCertificateArgs'] ssl_ca_certificates: The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        :param str ssl_mode: The SSL mode of the Channel.
        :param str username: The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_ca_certificates", ssl_ca_certificates)
        pulumi.set(__self__, "ssl_mode", ssl_mode)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the MySQL instance.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port the source MySQL instance listens on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslCaCertificates")
    def ssl_ca_certificates(self) -> Sequence['outputs.GetChannelsChannelSourceSslCaCertificateResult']:
        """
        The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificates")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetChannelsChannelSourceSslCaCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_type: str,
                 contents: str):
        """
        :param str certificate_type: The type of CA certificate.
        :param str contents: The string containing the CA certificate in PEM format.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter
    def contents(self) -> str:
        """
        The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class GetChannelsChannelTargetResult(dict):
    def __init__(__self__, *,
                 applier_username: str,
                 channel_name: str,
                 db_system_id: str,
                 target_type: str):
        """
        :param str applier_username: The username for the replication applier of the target MySQL DB System.
        :param str channel_name: The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        :param str db_system_id: The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str target_type: The specific target identifier.
        """
        pulumi.set(__self__, "applier_username", applier_username)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> str:
        """
        The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        The specific target identifier.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class GetChannelsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetHeatWaveClusterClusterNodeResult(dict):
    def __init__(__self__, *,
                 node_id: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str node_id: The ID of the node within MySQL HeatWave cluster.
        :param str state: The current state of the HeatWave cluster.
        :param str time_created: The date and time the HeatWave cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str time_updated: The time the HeatWave cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        The ID of the node within MySQL HeatWave cluster.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the HeatWave cluster.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the HeatWave cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the HeatWave cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlBackupDbSystemSnapshotResult(dict):
    def __init__(__self__, *,
                 admin_username: str,
                 availability_domain: str,
                 backup_policies: Sequence['outputs.GetMysqlBackupDbSystemSnapshotBackupPolicyResult'],
                 compartment_id: str,
                 configuration_id: str,
                 crash_recovery: str,
                 data_storage_size_in_gb: int,
                 defined_tags: Mapping[str, Any],
                 deletion_policies: Sequence['outputs.GetMysqlBackupDbSystemSnapshotDeletionPolicyResult'],
                 description: str,
                 display_name: str,
                 endpoints: Sequence['outputs.GetMysqlBackupDbSystemSnapshotEndpointResult'],
                 fault_domain: str,
                 freeform_tags: Mapping[str, Any],
                 hostname_label: str,
                 id: str,
                 ip_address: str,
                 is_highly_available: bool,
                 maintenances: Sequence['outputs.GetMysqlBackupDbSystemSnapshotMaintenanceResult'],
                 mysql_version: str,
                 port: int,
                 port_x: int,
                 shape_name: str,
                 subnet_id: str):
        """
        :param str admin_username: The username for the administrative user.
        :param str availability_domain: The Availability Domain where the primary DB System should be located.
        :param Sequence['GetMysqlBackupDbSystemSnapshotBackupPolicyArgs'] backup_policies: The Backup policy for the DB System.
        :param str compartment_id: The OCID of the compartment the DB System belongs in.
        :param str configuration_id: The OCID of the Configuration to be used for Instances in this DB System.
        :param str crash_recovery: Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        :param int data_storage_size_in_gb: Initial size of the data volume in GiBs that will be created and attached.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Sequence['GetMysqlBackupDbSystemSnapshotDeletionPolicyArgs'] deletion_policies: The Deletion policy for the DB System.
        :param str description: A user-supplied description for the backup.
        :param str display_name: A user-supplied display name for the backup.
        :param Sequence['GetMysqlBackupDbSystemSnapshotEndpointArgs'] endpoints: The network endpoints available for this DB System.
        :param str fault_domain: The name of the Fault Domain the DB System is located in.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str hostname_label: The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        :param str id: OCID of the backup itself
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param bool is_highly_available: If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        :param Sequence['GetMysqlBackupDbSystemSnapshotMaintenanceArgs'] maintenances: The Maintenance Policy for the DB System.
        :param str mysql_version: The MySQL server version of the DB System used for backup.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str shape_name: The shape of the DB System instance used for backup.
        :param str subnet_id: The OCID of the subnet the DB System is associated with.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_policies", backup_policies)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "configuration_id", configuration_id)
        pulumi.set(__self__, "crash_recovery", crash_recovery)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "deletion_policies", deletion_policies)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "fault_domain", fault_domain)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname_label", hostname_label)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_highly_available", is_highly_available)
        pulumi.set(__self__, "maintenances", maintenances)
        pulumi.set(__self__, "mysql_version", mysql_version)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The username for the administrative user.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The Availability Domain where the primary DB System should be located.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupPolicies")
    def backup_policies(self) -> Sequence['outputs.GetMysqlBackupDbSystemSnapshotBackupPolicyResult']:
        """
        The Backup policy for the DB System.
        """
        return pulumi.get(self, "backup_policies")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the DB System belongs in.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="configurationId")
    def configuration_id(self) -> str:
        """
        The OCID of the Configuration to be used for Instances in this DB System.
        """
        return pulumi.get(self, "configuration_id")

    @property
    @pulumi.getter(name="crashRecovery")
    def crash_recovery(self) -> str:
        """
        Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        """
        return pulumi.get(self, "crash_recovery")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        Initial size of the data volume in GiBs that will be created and attached.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="deletionPolicies")
    def deletion_policies(self) -> Sequence['outputs.GetMysqlBackupDbSystemSnapshotDeletionPolicyResult']:
        """
        The Deletion policy for the DB System.
        """
        return pulumi.get(self, "deletion_policies")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A user-supplied description for the backup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-supplied display name for the backup.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetMysqlBackupDbSystemSnapshotEndpointResult']:
        """
        The network endpoints available for this DB System.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> str:
        """
        The name of the Fault Domain the DB System is located in.
        """
        return pulumi.get(self, "fault_domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> str:
        """
        The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        """
        return pulumi.get(self, "hostname_label")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        OCID of the backup itself
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="isHighlyAvailable")
    def is_highly_available(self) -> bool:
        """
        If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        """
        return pulumi.get(self, "is_highly_available")

    @property
    @pulumi.getter
    def maintenances(self) -> Sequence['outputs.GetMysqlBackupDbSystemSnapshotMaintenanceResult']:
        """
        The Maintenance Policy for the DB System.
        """
        return pulumi.get(self, "maintenances")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> str:
        """
        The MySQL server version of the DB System used for backup.
        """
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the DB System instance used for backup.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of the subnet the DB System is associated with.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetMysqlBackupDbSystemSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 is_enabled: bool,
                 retention_in_days: int,
                 window_start_time: str):
        """
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param bool is_enabled: If automated backups are enabled or disabled.
        :param int retention_in_days: Number of days to retain this backup.
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        If automated backups are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        Number of days to retain this backup.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlBackupDbSystemSnapshotDeletionPolicyResult(dict):
    def __init__(__self__, *,
                 automatic_backup_retention: str,
                 final_backup: str,
                 is_delete_protected: bool):
        """
        :param str automatic_backup_retention: Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        :param str final_backup: Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        :param bool is_delete_protected: Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        pulumi.set(__self__, "automatic_backup_retention", automatic_backup_retention)
        pulumi.set(__self__, "final_backup", final_backup)
        pulumi.set(__self__, "is_delete_protected", is_delete_protected)

    @property
    @pulumi.getter(name="automaticBackupRetention")
    def automatic_backup_retention(self) -> str:
        """
        Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        """
        return pulumi.get(self, "automatic_backup_retention")

    @property
    @pulumi.getter(name="finalBackup")
    def final_backup(self) -> str:
        """
        Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        """
        return pulumi.get(self, "final_backup")

    @property
    @pulumi.getter(name="isDeleteProtected")
    def is_delete_protected(self) -> bool:
        """
        Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        return pulumi.get(self, "is_delete_protected")


@pulumi.output_type
class GetMysqlBackupDbSystemSnapshotEndpointResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ip_address: str,
                 modes: Sequence[str],
                 port: int,
                 port_x: int,
                 status: str,
                 status_details: str):
        """
        :param str hostname: The network address of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param Sequence[str] modes: The access modes from the client that this endpoint supports.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param str status_details: Additional information about the current endpoint status.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "modes", modes)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def modes(self) -> Sequence[str]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")


@pulumi.output_type
class GetMysqlBackupDbSystemSnapshotMaintenanceResult(dict):
    def __init__(__self__, *,
                 window_start_time: str):
        """
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlBackupsBackupResult(dict):
    def __init__(__self__, *,
                 backup_size_in_gbs: int,
                 backup_type: str,
                 compartment_id: str,
                 creation_type: str,
                 data_storage_size_in_gb: int,
                 db_system_id: str,
                 db_system_snapshots: Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotResult'],
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 mysql_version: str,
                 retention_in_days: int,
                 shape_name: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param int backup_size_in_gbs: The size of the backup in base-2 (IEC) gibibytes. (GiB).
        :param str backup_type: The type of backup.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str creation_type: Backup creationType
        :param int data_storage_size_in_gb: Initial size of the data volume in GiBs that will be created and attached.
        :param str db_system_id: The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetMysqlBackupsBackupDbSystemSnapshotArgs'] db_system_snapshots: Snapshot of the DbSystem details at the time of the backup
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: A user-supplied description for the backup.
        :param str display_name: A filter to return only the resource matching the given display name exactly.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: OCID of the backup itself
        :param str lifecycle_details: Additional information about the current lifecycleState.
        :param str mysql_version: The MySQL server version of the DB System used for backup.
        :param int retention_in_days: Number of days to retain this backup.
        :param str shape_name: The shape of the DB System instance used for backup.
        :param str state: Backup Lifecycle State
        :param str time_created: The time the backup record was created.
        :param str time_updated: The time at which the backup was updated.
        """
        pulumi.set(__self__, "backup_size_in_gbs", backup_size_in_gbs)
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "db_system_snapshots", db_system_snapshots)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "mysql_version", mysql_version)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="backupSizeInGbs")
    def backup_size_in_gbs(self) -> int:
        """
        The size of the backup in base-2 (IEC) gibibytes. (GiB).
        """
        return pulumi.get(self, "backup_size_in_gbs")

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> str:
        """
        The type of backup.
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> str:
        """
        Backup creationType
        """
        return pulumi.get(self, "creation_type")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        Initial size of the data volume in GiBs that will be created and attached.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="dbSystemSnapshots")
    def db_system_snapshots(self) -> Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotResult']:
        """
        Snapshot of the DbSystem details at the time of the backup
        """
        return pulumi.get(self, "db_system_snapshots")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A user-supplied description for the backup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only the resource matching the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        OCID of the backup itself
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> str:
        """
        The MySQL server version of the DB System used for backup.
        """
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        Number of days to retain this backup.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the DB System instance used for backup.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Backup Lifecycle State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time the backup record was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time at which the backup was updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlBackupsBackupDbSystemSnapshotResult(dict):
    def __init__(__self__, *,
                 admin_username: str,
                 availability_domain: str,
                 backup_policies: Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotBackupPolicyResult'],
                 compartment_id: str,
                 configuration_id: str,
                 crash_recovery: str,
                 data_storage_size_in_gb: int,
                 defined_tags: Mapping[str, Any],
                 deletion_policies: Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotDeletionPolicyResult'],
                 description: str,
                 display_name: str,
                 endpoints: Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotEndpointResult'],
                 fault_domain: str,
                 freeform_tags: Mapping[str, Any],
                 hostname_label: str,
                 id: str,
                 ip_address: str,
                 is_highly_available: bool,
                 maintenances: Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotMaintenanceResult'],
                 mysql_version: str,
                 port: int,
                 port_x: int,
                 shape_name: str,
                 subnet_id: str):
        """
        :param str admin_username: The username for the administrative user.
        :param str availability_domain: The Availability Domain where the primary DB System should be located.
        :param Sequence['GetMysqlBackupsBackupDbSystemSnapshotBackupPolicyArgs'] backup_policies: The Backup policy for the DB System.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str configuration_id: The OCID of the Configuration to be used for Instances in this DB System.
        :param str crash_recovery: Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        :param int data_storage_size_in_gb: Initial size of the data volume in GiBs that will be created and attached.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Sequence['GetMysqlBackupsBackupDbSystemSnapshotDeletionPolicyArgs'] deletion_policies: The Deletion policy for the DB System.
        :param str description: A user-supplied description for the backup.
        :param str display_name: A filter to return only the resource matching the given display name exactly.
        :param Sequence['GetMysqlBackupsBackupDbSystemSnapshotEndpointArgs'] endpoints: The network endpoints available for this DB System.
        :param str fault_domain: The name of the Fault Domain the DB System is located in.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str hostname_label: The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        :param str id: OCID of the backup itself
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param bool is_highly_available: If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        :param Sequence['GetMysqlBackupsBackupDbSystemSnapshotMaintenanceArgs'] maintenances: The Maintenance Policy for the DB System.
        :param str mysql_version: The MySQL server version of the DB System used for backup.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str shape_name: The shape of the DB System instance used for backup.
        :param str subnet_id: The OCID of the subnet the DB System is associated with.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_policies", backup_policies)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "configuration_id", configuration_id)
        pulumi.set(__self__, "crash_recovery", crash_recovery)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "deletion_policies", deletion_policies)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "fault_domain", fault_domain)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "hostname_label", hostname_label)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_highly_available", is_highly_available)
        pulumi.set(__self__, "maintenances", maintenances)
        pulumi.set(__self__, "mysql_version", mysql_version)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The username for the administrative user.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The Availability Domain where the primary DB System should be located.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupPolicies")
    def backup_policies(self) -> Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotBackupPolicyResult']:
        """
        The Backup policy for the DB System.
        """
        return pulumi.get(self, "backup_policies")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="configurationId")
    def configuration_id(self) -> str:
        """
        The OCID of the Configuration to be used for Instances in this DB System.
        """
        return pulumi.get(self, "configuration_id")

    @property
    @pulumi.getter(name="crashRecovery")
    def crash_recovery(self) -> str:
        """
        Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        """
        return pulumi.get(self, "crash_recovery")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        Initial size of the data volume in GiBs that will be created and attached.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="deletionPolicies")
    def deletion_policies(self) -> Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotDeletionPolicyResult']:
        """
        The Deletion policy for the DB System.
        """
        return pulumi.get(self, "deletion_policies")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A user-supplied description for the backup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only the resource matching the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotEndpointResult']:
        """
        The network endpoints available for this DB System.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> str:
        """
        The name of the Fault Domain the DB System is located in.
        """
        return pulumi.get(self, "fault_domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> str:
        """
        The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        """
        return pulumi.get(self, "hostname_label")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        OCID of the backup itself
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="isHighlyAvailable")
    def is_highly_available(self) -> bool:
        """
        If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        """
        return pulumi.get(self, "is_highly_available")

    @property
    @pulumi.getter
    def maintenances(self) -> Sequence['outputs.GetMysqlBackupsBackupDbSystemSnapshotMaintenanceResult']:
        """
        The Maintenance Policy for the DB System.
        """
        return pulumi.get(self, "maintenances")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> str:
        """
        The MySQL server version of the DB System used for backup.
        """
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the DB System instance used for backup.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of the subnet the DB System is associated with.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetMysqlBackupsBackupDbSystemSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 is_enabled: bool,
                 retention_in_days: int,
                 window_start_time: str):
        """
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param bool is_enabled: If automated backups are enabled or disabled.
        :param int retention_in_days: Number of days to retain this backup.
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        If automated backups are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        Number of days to retain this backup.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlBackupsBackupDbSystemSnapshotDeletionPolicyResult(dict):
    def __init__(__self__, *,
                 automatic_backup_retention: str,
                 final_backup: str,
                 is_delete_protected: bool):
        """
        :param str automatic_backup_retention: Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        :param str final_backup: Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        :param bool is_delete_protected: Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        pulumi.set(__self__, "automatic_backup_retention", automatic_backup_retention)
        pulumi.set(__self__, "final_backup", final_backup)
        pulumi.set(__self__, "is_delete_protected", is_delete_protected)

    @property
    @pulumi.getter(name="automaticBackupRetention")
    def automatic_backup_retention(self) -> str:
        """
        Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        """
        return pulumi.get(self, "automatic_backup_retention")

    @property
    @pulumi.getter(name="finalBackup")
    def final_backup(self) -> str:
        """
        Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        """
        return pulumi.get(self, "final_backup")

    @property
    @pulumi.getter(name="isDeleteProtected")
    def is_delete_protected(self) -> bool:
        """
        Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        return pulumi.get(self, "is_delete_protected")


@pulumi.output_type
class GetMysqlBackupsBackupDbSystemSnapshotEndpointResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ip_address: str,
                 modes: Sequence[str],
                 port: int,
                 port_x: int,
                 status: str,
                 status_details: str):
        """
        :param str hostname: The network address of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param Sequence[str] modes: The access modes from the client that this endpoint supports.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param str status_details: Additional information about the current endpoint status.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "modes", modes)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def modes(self) -> Sequence[str]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")


@pulumi.output_type
class GetMysqlBackupsBackupDbSystemSnapshotMaintenanceResult(dict):
    def __init__(__self__, *,
                 window_start_time: str):
        """
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMysqlConfigurationVariableResult(dict):
    def __init__(__self__, *,
                 autocommit: bool,
                 binlog_expire_logs_seconds: int,
                 binlog_row_metadata: str,
                 binlog_row_value_options: str,
                 binlog_transaction_compression: bool,
                 completion_type: str,
                 connect_timeout: int,
                 cte_max_recursion_depth: int,
                 default_authentication_plugin: str,
                 foreign_key_checks: bool,
                 generated_random_password_length: int,
                 group_replication_consistency: str,
                 information_schema_stats_expiry: int,
                 innodb_buffer_pool_instances: int,
                 innodb_buffer_pool_size: str,
                 innodb_ft_enable_stopword: bool,
                 innodb_ft_max_token_size: int,
                 innodb_ft_min_token_size: int,
                 innodb_ft_num_word_optimize: int,
                 innodb_ft_result_cache_limit: int,
                 innodb_ft_server_stopword_table: str,
                 innodb_lock_wait_timeout: int,
                 innodb_max_purge_lag: int,
                 innodb_max_purge_lag_delay: int,
                 local_infile: bool,
                 mandatory_roles: str,
                 max_connections: int,
                 max_execution_time: int,
                 max_prepared_stmt_count: int,
                 mysql_firewall_mode: bool,
                 mysql_zstd_default_compression_level: int,
                 mysqlx_connect_timeout: int,
                 mysqlx_deflate_default_compression_level: int,
                 mysqlx_deflate_max_client_compression_level: int,
                 mysqlx_document_id_unique_prefix: int,
                 mysqlx_enable_hello_notice: bool,
                 mysqlx_idle_worker_thread_timeout: int,
                 mysqlx_interactive_timeout: int,
                 mysqlx_lz4default_compression_level: int,
                 mysqlx_lz4max_client_compression_level: int,
                 mysqlx_max_allowed_packet: int,
                 mysqlx_min_worker_threads: int,
                 mysqlx_read_timeout: int,
                 mysqlx_wait_timeout: int,
                 mysqlx_write_timeout: int,
                 mysqlx_zstd_default_compression_level: int,
                 mysqlx_zstd_max_client_compression_level: int,
                 parser_max_mem_size: int,
                 query_alloc_block_size: int,
                 query_prealloc_size: int,
                 sql_mode: str,
                 sql_require_primary_key: bool,
                 sql_warnings: bool,
                 transaction_isolation: str):
        """
        :param bool autocommit: ("autocommit")
        :param int binlog_expire_logs_seconds: Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable [binlog_expire_logs_seconds](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_expire_logs_seconds).
        :param str binlog_row_metadata: Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable [binlog_row_metadata](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_metadata).
        :param str binlog_row_value_options: When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable [binlog_row_value_options](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_value_options).
        :param bool binlog_transaction_compression: Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable [binlog_transaction_compression](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_compression).
        :param str completion_type: ("completion_type")
        :param int connect_timeout: ("connect_timeout")
        :param int cte_max_recursion_depth: ("cte_max_recursion_depth")
        :param str default_authentication_plugin: ("default_authentication_plugin")
        :param bool foreign_key_checks: ("foreign_key_checks")
        :param int generated_random_password_length: ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
        :param str group_replication_consistency: * EVENTUAL: Both RO and RW transactions do not wait for preceding transactions to be applied before executing. A RW transaction does not wait for other members to apply a transaction. This means that a transaction could be externalized on one member before the others. This also means that in the event of a primary failover, the new primary can accept new RO and RW transactions before the previous primary transactions are all applied. RO transactions could result in outdated values, RW transactions could result in a rollback due to conflicts.
               * BEFORE_ON_PRIMARY_FAILOVER: New RO or RW transactions with a newly elected primary that is applying backlog from the old primary are held (not applied) until any backlog has been applied. This ensures that when a primary failover happens, intentionally or not, clients always see the latest value on the primary. This guarantees consistency, but means that clients must be able to handle the delay in the event that a backlog is being applied. Usually this delay should be minimal, but does depend on the size of the backlog.
               * BEFORE: A RW transaction waits for all preceding transactions to complete before being applied. A RO transaction waits for all preceding transactions to complete before being executed. This ensures that this transaction reads the latest value by only affecting the latency of the transaction. This reduces the overhead of synchronization on every RW transaction, by ensuring synchronization is used only on RO transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
               * AFTER: A RW transaction waits until its changes have been applied to all of the other members. This value has no effect on RO transactions. This mode ensures that when a transaction is committed on the local member, any subsequent transaction reads the written value or a more recent value on any group member. Use this mode with a group that is used for predominantly RO operations to ensure that applied RW transactions are applied everywhere once they commit. This could be used by your application to ensure that subsequent reads fetch the latest data which includes the latest writes. This reduces the overhead of synchronization on every RO transaction, by ensuring synchronization is used only on RW transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
               * BEFORE_AND_AFTER: A RW transaction waits for 1) all preceding transactions to complete before being applied and 2) until its changes have been applied on other members. A RO transaction waits for all preceding transactions to complete before execution takes place. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        :param int information_schema_stats_expiry: ("information_schema_stats_expiry")
        :param int innodb_buffer_pool_instances: ("innodb_buffer_pool_instances")
        :param str innodb_buffer_pool_size: ("innodb_buffer_pool_size")
        :param bool innodb_ft_enable_stopword: ("innodb_ft_enable_stopword")
        :param int innodb_ft_max_token_size: ("innodb_ft_max_token_size")
        :param int innodb_ft_min_token_size: ("innodb_ft_min_token_size")
        :param int innodb_ft_num_word_optimize: ("innodb_ft_num_word_optimize")
        :param int innodb_ft_result_cache_limit: ("innodb_ft_result_cache_limit")
        :param str innodb_ft_server_stopword_table: ("innodb_ft_server_stopword_table")
        :param int innodb_lock_wait_timeout: ("innodb_lock_wait_timeout")
        :param int innodb_max_purge_lag: ("innodb_max_purge_lag")
        :param int innodb_max_purge_lag_delay: ("innodb_max_purge_lag_delay")
        :param bool local_infile: ("local_infile")
        :param str mandatory_roles: ("mandatory_roles")
        :param int max_connections: ("max_connections")
        :param int max_execution_time: ("max_execution_time")
        :param int max_prepared_stmt_count: ("max_prepared_stmt_count")
        :param bool mysql_firewall_mode: ("mysql_firewall_mode")
        :param int mysql_zstd_default_compression_level: DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
        :param int mysqlx_connect_timeout: ("mysqlx_connect_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_deflate_default_compression_level: Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
        :param int mysqlx_deflate_max_client_compression_level: Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
        :param int mysqlx_document_id_unique_prefix: ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
        :param bool mysqlx_enable_hello_notice: ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_idle_worker_thread_timeout: ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_interactive_timeout: ("mysqlx_interactive_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_lz4default_compression_level: Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
        :param int mysqlx_lz4max_client_compression_level: Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
        :param int mysqlx_max_allowed_packet: ("mysqlx_max_allowed_packet") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_min_worker_threads: ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_read_timeout: ("mysqlx_read_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_wait_timeout: ("mysqlx_wait_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_write_timeout: ("mysqlx_write_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_zstd_default_compression_level: Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
        :param int mysqlx_zstd_max_client_compression_level: Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
        :param int parser_max_mem_size: ("parser_max_mem_size")
        :param int query_alloc_block_size: ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
        :param int query_prealloc_size: ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
        :param str sql_mode: ("sql_mode")
        :param bool sql_require_primary_key: ("sql_require_primary_key")
        :param bool sql_warnings: ("sql_warnings")
        :param str transaction_isolation: ("transaction_isolation")
        """
        pulumi.set(__self__, "autocommit", autocommit)
        pulumi.set(__self__, "binlog_expire_logs_seconds", binlog_expire_logs_seconds)
        pulumi.set(__self__, "binlog_row_metadata", binlog_row_metadata)
        pulumi.set(__self__, "binlog_row_value_options", binlog_row_value_options)
        pulumi.set(__self__, "binlog_transaction_compression", binlog_transaction_compression)
        pulumi.set(__self__, "completion_type", completion_type)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "cte_max_recursion_depth", cte_max_recursion_depth)
        pulumi.set(__self__, "default_authentication_plugin", default_authentication_plugin)
        pulumi.set(__self__, "foreign_key_checks", foreign_key_checks)
        pulumi.set(__self__, "generated_random_password_length", generated_random_password_length)
        pulumi.set(__self__, "group_replication_consistency", group_replication_consistency)
        pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        pulumi.set(__self__, "innodb_buffer_pool_instances", innodb_buffer_pool_instances)
        pulumi.set(__self__, "innodb_buffer_pool_size", innodb_buffer_pool_size)
        pulumi.set(__self__, "innodb_ft_enable_stopword", innodb_ft_enable_stopword)
        pulumi.set(__self__, "innodb_ft_max_token_size", innodb_ft_max_token_size)
        pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        pulumi.set(__self__, "innodb_ft_num_word_optimize", innodb_ft_num_word_optimize)
        pulumi.set(__self__, "innodb_ft_result_cache_limit", innodb_ft_result_cache_limit)
        pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        pulumi.set(__self__, "innodb_max_purge_lag", innodb_max_purge_lag)
        pulumi.set(__self__, "innodb_max_purge_lag_delay", innodb_max_purge_lag_delay)
        pulumi.set(__self__, "local_infile", local_infile)
        pulumi.set(__self__, "mandatory_roles", mandatory_roles)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_execution_time", max_execution_time)
        pulumi.set(__self__, "max_prepared_stmt_count", max_prepared_stmt_count)
        pulumi.set(__self__, "mysql_firewall_mode", mysql_firewall_mode)
        pulumi.set(__self__, "mysql_zstd_default_compression_level", mysql_zstd_default_compression_level)
        pulumi.set(__self__, "mysqlx_connect_timeout", mysqlx_connect_timeout)
        pulumi.set(__self__, "mysqlx_deflate_default_compression_level", mysqlx_deflate_default_compression_level)
        pulumi.set(__self__, "mysqlx_deflate_max_client_compression_level", mysqlx_deflate_max_client_compression_level)
        pulumi.set(__self__, "mysqlx_document_id_unique_prefix", mysqlx_document_id_unique_prefix)
        pulumi.set(__self__, "mysqlx_enable_hello_notice", mysqlx_enable_hello_notice)
        pulumi.set(__self__, "mysqlx_idle_worker_thread_timeout", mysqlx_idle_worker_thread_timeout)
        pulumi.set(__self__, "mysqlx_interactive_timeout", mysqlx_interactive_timeout)
        pulumi.set(__self__, "mysqlx_lz4default_compression_level", mysqlx_lz4default_compression_level)
        pulumi.set(__self__, "mysqlx_lz4max_client_compression_level", mysqlx_lz4max_client_compression_level)
        pulumi.set(__self__, "mysqlx_max_allowed_packet", mysqlx_max_allowed_packet)
        pulumi.set(__self__, "mysqlx_min_worker_threads", mysqlx_min_worker_threads)
        pulumi.set(__self__, "mysqlx_read_timeout", mysqlx_read_timeout)
        pulumi.set(__self__, "mysqlx_wait_timeout", mysqlx_wait_timeout)
        pulumi.set(__self__, "mysqlx_write_timeout", mysqlx_write_timeout)
        pulumi.set(__self__, "mysqlx_zstd_default_compression_level", mysqlx_zstd_default_compression_level)
        pulumi.set(__self__, "mysqlx_zstd_max_client_compression_level", mysqlx_zstd_max_client_compression_level)
        pulumi.set(__self__, "parser_max_mem_size", parser_max_mem_size)
        pulumi.set(__self__, "query_alloc_block_size", query_alloc_block_size)
        pulumi.set(__self__, "query_prealloc_size", query_prealloc_size)
        pulumi.set(__self__, "sql_mode", sql_mode)
        pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        pulumi.set(__self__, "sql_warnings", sql_warnings)
        pulumi.set(__self__, "transaction_isolation", transaction_isolation)

    @property
    @pulumi.getter
    def autocommit(self) -> bool:
        """
        ("autocommit")
        """
        return pulumi.get(self, "autocommit")

    @property
    @pulumi.getter(name="binlogExpireLogsSeconds")
    def binlog_expire_logs_seconds(self) -> int:
        """
        Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable [binlog_expire_logs_seconds](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_expire_logs_seconds).
        """
        return pulumi.get(self, "binlog_expire_logs_seconds")

    @property
    @pulumi.getter(name="binlogRowMetadata")
    def binlog_row_metadata(self) -> str:
        """
        Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable [binlog_row_metadata](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_metadata).
        """
        return pulumi.get(self, "binlog_row_metadata")

    @property
    @pulumi.getter(name="binlogRowValueOptions")
    def binlog_row_value_options(self) -> str:
        """
        When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable [binlog_row_value_options](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_value_options).
        """
        return pulumi.get(self, "binlog_row_value_options")

    @property
    @pulumi.getter(name="binlogTransactionCompression")
    def binlog_transaction_compression(self) -> bool:
        """
        Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable [binlog_transaction_compression](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_compression).
        """
        return pulumi.get(self, "binlog_transaction_compression")

    @property
    @pulumi.getter(name="completionType")
    def completion_type(self) -> str:
        """
        ("completion_type")
        """
        return pulumi.get(self, "completion_type")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        ("connect_timeout")
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="cteMaxRecursionDepth")
    def cte_max_recursion_depth(self) -> int:
        """
        ("cte_max_recursion_depth")
        """
        return pulumi.get(self, "cte_max_recursion_depth")

    @property
    @pulumi.getter(name="defaultAuthenticationPlugin")
    def default_authentication_plugin(self) -> str:
        """
        ("default_authentication_plugin")
        """
        return pulumi.get(self, "default_authentication_plugin")

    @property
    @pulumi.getter(name="foreignKeyChecks")
    def foreign_key_checks(self) -> bool:
        """
        ("foreign_key_checks")
        """
        return pulumi.get(self, "foreign_key_checks")

    @property
    @pulumi.getter(name="generatedRandomPasswordLength")
    def generated_random_password_length(self) -> int:
        """
        ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "generated_random_password_length")

    @property
    @pulumi.getter(name="groupReplicationConsistency")
    def group_replication_consistency(self) -> str:
        """
        * EVENTUAL: Both RO and RW transactions do not wait for preceding transactions to be applied before executing. A RW transaction does not wait for other members to apply a transaction. This means that a transaction could be externalized on one member before the others. This also means that in the event of a primary failover, the new primary can accept new RO and RW transactions before the previous primary transactions are all applied. RO transactions could result in outdated values, RW transactions could result in a rollback due to conflicts.
        * BEFORE_ON_PRIMARY_FAILOVER: New RO or RW transactions with a newly elected primary that is applying backlog from the old primary are held (not applied) until any backlog has been applied. This ensures that when a primary failover happens, intentionally or not, clients always see the latest value on the primary. This guarantees consistency, but means that clients must be able to handle the delay in the event that a backlog is being applied. Usually this delay should be minimal, but does depend on the size of the backlog.
        * BEFORE: A RW transaction waits for all preceding transactions to complete before being applied. A RO transaction waits for all preceding transactions to complete before being executed. This ensures that this transaction reads the latest value by only affecting the latency of the transaction. This reduces the overhead of synchronization on every RW transaction, by ensuring synchronization is used only on RO transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        * AFTER: A RW transaction waits until its changes have been applied to all of the other members. This value has no effect on RO transactions. This mode ensures that when a transaction is committed on the local member, any subsequent transaction reads the written value or a more recent value on any group member. Use this mode with a group that is used for predominantly RO operations to ensure that applied RW transactions are applied everywhere once they commit. This could be used by your application to ensure that subsequent reads fetch the latest data which includes the latest writes. This reduces the overhead of synchronization on every RO transaction, by ensuring synchronization is used only on RW transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        * BEFORE_AND_AFTER: A RW transaction waits for 1) all preceding transactions to complete before being applied and 2) until its changes have been applied on other members. A RO transaction waits for all preceding transactions to complete before execution takes place. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        """
        return pulumi.get(self, "group_replication_consistency")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> int:
        """
        ("information_schema_stats_expiry")
        """
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbBufferPoolInstances")
    def innodb_buffer_pool_instances(self) -> int:
        """
        ("innodb_buffer_pool_instances")
        """
        return pulumi.get(self, "innodb_buffer_pool_instances")

    @property
    @pulumi.getter(name="innodbBufferPoolSize")
    def innodb_buffer_pool_size(self) -> str:
        """
        ("innodb_buffer_pool_size")
        """
        return pulumi.get(self, "innodb_buffer_pool_size")

    @property
    @pulumi.getter(name="innodbFtEnableStopword")
    def innodb_ft_enable_stopword(self) -> bool:
        """
        ("innodb_ft_enable_stopword")
        """
        return pulumi.get(self, "innodb_ft_enable_stopword")

    @property
    @pulumi.getter(name="innodbFtMaxTokenSize")
    def innodb_ft_max_token_size(self) -> int:
        """
        ("innodb_ft_max_token_size")
        """
        return pulumi.get(self, "innodb_ft_max_token_size")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> int:
        """
        ("innodb_ft_min_token_size")
        """
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtNumWordOptimize")
    def innodb_ft_num_word_optimize(self) -> int:
        """
        ("innodb_ft_num_word_optimize")
        """
        return pulumi.get(self, "innodb_ft_num_word_optimize")

    @property
    @pulumi.getter(name="innodbFtResultCacheLimit")
    def innodb_ft_result_cache_limit(self) -> int:
        """
        ("innodb_ft_result_cache_limit")
        """
        return pulumi.get(self, "innodb_ft_result_cache_limit")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> str:
        """
        ("innodb_ft_server_stopword_table")
        """
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> int:
        """
        ("innodb_lock_wait_timeout")
        """
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbMaxPurgeLag")
    def innodb_max_purge_lag(self) -> int:
        """
        ("innodb_max_purge_lag")
        """
        return pulumi.get(self, "innodb_max_purge_lag")

    @property
    @pulumi.getter(name="innodbMaxPurgeLagDelay")
    def innodb_max_purge_lag_delay(self) -> int:
        """
        ("innodb_max_purge_lag_delay")
        """
        return pulumi.get(self, "innodb_max_purge_lag_delay")

    @property
    @pulumi.getter(name="localInfile")
    def local_infile(self) -> bool:
        """
        ("local_infile")
        """
        return pulumi.get(self, "local_infile")

    @property
    @pulumi.getter(name="mandatoryRoles")
    def mandatory_roles(self) -> str:
        """
        ("mandatory_roles")
        """
        return pulumi.get(self, "mandatory_roles")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        """
        ("max_connections")
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> int:
        """
        ("max_execution_time")
        """
        return pulumi.get(self, "max_execution_time")

    @property
    @pulumi.getter(name="maxPreparedStmtCount")
    def max_prepared_stmt_count(self) -> int:
        """
        ("max_prepared_stmt_count")
        """
        return pulumi.get(self, "max_prepared_stmt_count")

    @property
    @pulumi.getter(name="mysqlFirewallMode")
    def mysql_firewall_mode(self) -> bool:
        """
        ("mysql_firewall_mode")
        """
        return pulumi.get(self, "mysql_firewall_mode")

    @property
    @pulumi.getter(name="mysqlZstdDefaultCompressionLevel")
    def mysql_zstd_default_compression_level(self) -> int:
        """
        DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
        """
        return pulumi.get(self, "mysql_zstd_default_compression_level")

    @property
    @pulumi.getter(name="mysqlxConnectTimeout")
    def mysqlx_connect_timeout(self) -> int:
        """
        ("mysqlx_connect_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_connect_timeout")

    @property
    @pulumi.getter(name="mysqlxDeflateDefaultCompressionLevel")
    def mysqlx_deflate_default_compression_level(self) -> int:
        """
        Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
        """
        return pulumi.get(self, "mysqlx_deflate_default_compression_level")

    @property
    @pulumi.getter(name="mysqlxDeflateMaxClientCompressionLevel")
    def mysqlx_deflate_max_client_compression_level(self) -> int:
        """
        Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
        """
        return pulumi.get(self, "mysqlx_deflate_max_client_compression_level")

    @property
    @pulumi.getter(name="mysqlxDocumentIdUniquePrefix")
    def mysqlx_document_id_unique_prefix(self) -> int:
        """
        ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_document_id_unique_prefix")

    @property
    @pulumi.getter(name="mysqlxEnableHelloNotice")
    def mysqlx_enable_hello_notice(self) -> bool:
        """
        ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_enable_hello_notice")

    @property
    @pulumi.getter(name="mysqlxIdleWorkerThreadTimeout")
    def mysqlx_idle_worker_thread_timeout(self) -> int:
        """
        ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_idle_worker_thread_timeout")

    @property
    @pulumi.getter(name="mysqlxInteractiveTimeout")
    def mysqlx_interactive_timeout(self) -> int:
        """
        ("mysqlx_interactive_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_interactive_timeout")

    @property
    @pulumi.getter(name="mysqlxLz4defaultCompressionLevel")
    def mysqlx_lz4default_compression_level(self) -> int:
        """
        Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
        """
        return pulumi.get(self, "mysqlx_lz4default_compression_level")

    @property
    @pulumi.getter(name="mysqlxLz4maxClientCompressionLevel")
    def mysqlx_lz4max_client_compression_level(self) -> int:
        """
        Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
        """
        return pulumi.get(self, "mysqlx_lz4max_client_compression_level")

    @property
    @pulumi.getter(name="mysqlxMaxAllowedPacket")
    def mysqlx_max_allowed_packet(self) -> int:
        """
        ("mysqlx_max_allowed_packet") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_max_allowed_packet")

    @property
    @pulumi.getter(name="mysqlxMinWorkerThreads")
    def mysqlx_min_worker_threads(self) -> int:
        """
        ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_min_worker_threads")

    @property
    @pulumi.getter(name="mysqlxReadTimeout")
    def mysqlx_read_timeout(self) -> int:
        """
        ("mysqlx_read_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_read_timeout")

    @property
    @pulumi.getter(name="mysqlxWaitTimeout")
    def mysqlx_wait_timeout(self) -> int:
        """
        ("mysqlx_wait_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_wait_timeout")

    @property
    @pulumi.getter(name="mysqlxWriteTimeout")
    def mysqlx_write_timeout(self) -> int:
        """
        ("mysqlx_write_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_write_timeout")

    @property
    @pulumi.getter(name="mysqlxZstdDefaultCompressionLevel")
    def mysqlx_zstd_default_compression_level(self) -> int:
        """
        Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
        """
        return pulumi.get(self, "mysqlx_zstd_default_compression_level")

    @property
    @pulumi.getter(name="mysqlxZstdMaxClientCompressionLevel")
    def mysqlx_zstd_max_client_compression_level(self) -> int:
        """
        Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
        """
        return pulumi.get(self, "mysqlx_zstd_max_client_compression_level")

    @property
    @pulumi.getter(name="parserMaxMemSize")
    def parser_max_mem_size(self) -> int:
        """
        ("parser_max_mem_size")
        """
        return pulumi.get(self, "parser_max_mem_size")

    @property
    @pulumi.getter(name="queryAllocBlockSize")
    def query_alloc_block_size(self) -> int:
        """
        ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "query_alloc_block_size")

    @property
    @pulumi.getter(name="queryPreallocSize")
    def query_prealloc_size(self) -> int:
        """
        ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "query_prealloc_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> str:
        """
        ("sql_mode")
        """
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> bool:
        """
        ("sql_require_primary_key")
        """
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="sqlWarnings")
    def sql_warnings(self) -> bool:
        """
        ("sql_warnings")
        """
        return pulumi.get(self, "sql_warnings")

    @property
    @pulumi.getter(name="transactionIsolation")
    def transaction_isolation(self) -> str:
        """
        ("transaction_isolation")
        """
        return pulumi.get(self, "transaction_isolation")


@pulumi.output_type
class GetMysqlConfigurationsConfigurationResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 parent_configuration_id: str,
                 shape_name: str,
                 state: str,
                 time_created: str,
                 time_updated: str,
                 type: str,
                 variables: 'outputs.GetMysqlConfigurationsConfigurationVariablesResult'):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: User-provided data about the Configuration.
        :param str display_name: A filter to return only the resource matching the given display name exactly.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The OCID of the Configuration.
        :param str parent_configuration_id: The OCID of the Configuration from which this Configuration is "derived". This is entirely a metadata relationship. There is no relation between the values in this Configuration and its parent.
        :param str shape_name: The requested Shape name.
        :param str state: Configuration Lifecycle State
        :param str time_created: The date and time the Configuration was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str time_updated: The date and time the Configuration was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param str type: The requested Configuration types.
        :param 'GetMysqlConfigurationsConfigurationVariablesArgs' variables: User controllable service variables.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "parent_configuration_id", parent_configuration_id)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        User-provided data about the Configuration.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only the resource matching the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Configuration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="parentConfigurationId")
    def parent_configuration_id(self) -> str:
        """
        The OCID of the Configuration from which this Configuration is "derived". This is entirely a metadata relationship. There is no relation between the values in this Configuration and its parent.
        """
        return pulumi.get(self, "parent_configuration_id")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The requested Shape name.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Configuration Lifecycle State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Configuration was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the Configuration was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The requested Configuration types.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def variables(self) -> 'outputs.GetMysqlConfigurationsConfigurationVariablesResult':
        """
        User controllable service variables.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class GetMysqlConfigurationsConfigurationVariablesResult(dict):
    def __init__(__self__, *,
                 autocommit: bool,
                 binlog_expire_logs_seconds: int,
                 binlog_row_metadata: str,
                 binlog_row_value_options: str,
                 binlog_transaction_compression: bool,
                 completion_type: str,
                 connect_timeout: int,
                 cte_max_recursion_depth: int,
                 default_authentication_plugin: str,
                 foreign_key_checks: bool,
                 generated_random_password_length: int,
                 group_replication_consistency: str,
                 information_schema_stats_expiry: int,
                 innodb_buffer_pool_instances: int,
                 innodb_buffer_pool_size: str,
                 innodb_ft_enable_stopword: bool,
                 innodb_ft_max_token_size: int,
                 innodb_ft_min_token_size: int,
                 innodb_ft_num_word_optimize: int,
                 innodb_ft_result_cache_limit: int,
                 innodb_ft_server_stopword_table: str,
                 innodb_lock_wait_timeout: int,
                 innodb_max_purge_lag: int,
                 innodb_max_purge_lag_delay: int,
                 local_infile: bool,
                 mandatory_roles: str,
                 max_connections: int,
                 max_execution_time: int,
                 max_prepared_stmt_count: int,
                 mysql_firewall_mode: bool,
                 mysql_zstd_default_compression_level: int,
                 mysqlx_connect_timeout: int,
                 mysqlx_deflate_default_compression_level: int,
                 mysqlx_deflate_max_client_compression_level: int,
                 mysqlx_document_id_unique_prefix: int,
                 mysqlx_enable_hello_notice: bool,
                 mysqlx_idle_worker_thread_timeout: int,
                 mysqlx_interactive_timeout: int,
                 mysqlx_lz4default_compression_level: int,
                 mysqlx_lz4max_client_compression_level: int,
                 mysqlx_max_allowed_packet: int,
                 mysqlx_min_worker_threads: int,
                 mysqlx_read_timeout: int,
                 mysqlx_wait_timeout: int,
                 mysqlx_write_timeout: int,
                 mysqlx_zstd_default_compression_level: int,
                 mysqlx_zstd_max_client_compression_level: int,
                 parser_max_mem_size: int,
                 query_alloc_block_size: int,
                 query_prealloc_size: int,
                 sql_mode: str,
                 sql_require_primary_key: bool,
                 sql_warnings: bool,
                 transaction_isolation: str):
        """
        :param bool autocommit: ("autocommit")
        :param int binlog_expire_logs_seconds: Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable [binlog_expire_logs_seconds](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_expire_logs_seconds).
        :param str binlog_row_metadata: Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable [binlog_row_metadata](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_metadata).
        :param str binlog_row_value_options: When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable [binlog_row_value_options](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_value_options).
        :param bool binlog_transaction_compression: Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable [binlog_transaction_compression](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_compression).
        :param str completion_type: ("completion_type")
        :param int connect_timeout: ("connect_timeout")
        :param int cte_max_recursion_depth: ("cte_max_recursion_depth")
        :param str default_authentication_plugin: ("default_authentication_plugin")
        :param bool foreign_key_checks: ("foreign_key_checks")
        :param int generated_random_password_length: ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
        :param str group_replication_consistency: * EVENTUAL: Both RO and RW transactions do not wait for preceding transactions to be applied before executing. A RW transaction does not wait for other members to apply a transaction. This means that a transaction could be externalized on one member before the others. This also means that in the event of a primary failover, the new primary can accept new RO and RW transactions before the previous primary transactions are all applied. RO transactions could result in outdated values, RW transactions could result in a rollback due to conflicts.
               * BEFORE_ON_PRIMARY_FAILOVER: New RO or RW transactions with a newly elected primary that is applying backlog from the old primary are held (not applied) until any backlog has been applied. This ensures that when a primary failover happens, intentionally or not, clients always see the latest value on the primary. This guarantees consistency, but means that clients must be able to handle the delay in the event that a backlog is being applied. Usually this delay should be minimal, but does depend on the size of the backlog.
               * BEFORE: A RW transaction waits for all preceding transactions to complete before being applied. A RO transaction waits for all preceding transactions to complete before being executed. This ensures that this transaction reads the latest value by only affecting the latency of the transaction. This reduces the overhead of synchronization on every RW transaction, by ensuring synchronization is used only on RO transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
               * AFTER: A RW transaction waits until its changes have been applied to all of the other members. This value has no effect on RO transactions. This mode ensures that when a transaction is committed on the local member, any subsequent transaction reads the written value or a more recent value on any group member. Use this mode with a group that is used for predominantly RO operations to ensure that applied RW transactions are applied everywhere once they commit. This could be used by your application to ensure that subsequent reads fetch the latest data which includes the latest writes. This reduces the overhead of synchronization on every RO transaction, by ensuring synchronization is used only on RW transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
               * BEFORE_AND_AFTER: A RW transaction waits for 1) all preceding transactions to complete before being applied and 2) until its changes have been applied on other members. A RO transaction waits for all preceding transactions to complete before execution takes place. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        :param int information_schema_stats_expiry: ("information_schema_stats_expiry")
        :param int innodb_buffer_pool_instances: ("innodb_buffer_pool_instances")
        :param str innodb_buffer_pool_size: ("innodb_buffer_pool_size")
        :param bool innodb_ft_enable_stopword: ("innodb_ft_enable_stopword")
        :param int innodb_ft_max_token_size: ("innodb_ft_max_token_size")
        :param int innodb_ft_min_token_size: ("innodb_ft_min_token_size")
        :param int innodb_ft_num_word_optimize: ("innodb_ft_num_word_optimize")
        :param int innodb_ft_result_cache_limit: ("innodb_ft_result_cache_limit")
        :param str innodb_ft_server_stopword_table: ("innodb_ft_server_stopword_table")
        :param int innodb_lock_wait_timeout: ("innodb_lock_wait_timeout")
        :param int innodb_max_purge_lag: ("innodb_max_purge_lag")
        :param int innodb_max_purge_lag_delay: ("innodb_max_purge_lag_delay")
        :param bool local_infile: ("local_infile")
        :param str mandatory_roles: ("mandatory_roles")
        :param int max_connections: ("max_connections")
        :param int max_execution_time: ("max_execution_time")
        :param int max_prepared_stmt_count: ("max_prepared_stmt_count")
        :param bool mysql_firewall_mode: ("mysql_firewall_mode")
        :param int mysql_zstd_default_compression_level: DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
        :param int mysqlx_connect_timeout: ("mysqlx_connect_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_deflate_default_compression_level: Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
        :param int mysqlx_deflate_max_client_compression_level: Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
        :param int mysqlx_document_id_unique_prefix: ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
        :param bool mysqlx_enable_hello_notice: ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_idle_worker_thread_timeout: ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_interactive_timeout: ("mysqlx_interactive_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_lz4default_compression_level: Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
        :param int mysqlx_lz4max_client_compression_level: Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
        :param int mysqlx_max_allowed_packet: ("mysqlx_max_allowed_packet") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_min_worker_threads: ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_read_timeout: ("mysqlx_read_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_wait_timeout: ("mysqlx_wait_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_write_timeout: ("mysqlx_write_timeout") DEPRECATED -- variable should not be settable and will be ignored
        :param int mysqlx_zstd_default_compression_level: Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
        :param int mysqlx_zstd_max_client_compression_level: Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
        :param int parser_max_mem_size: ("parser_max_mem_size")
        :param int query_alloc_block_size: ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
        :param int query_prealloc_size: ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
        :param str sql_mode: ("sql_mode")
        :param bool sql_require_primary_key: ("sql_require_primary_key")
        :param bool sql_warnings: ("sql_warnings")
        :param str transaction_isolation: ("transaction_isolation")
        """
        pulumi.set(__self__, "autocommit", autocommit)
        pulumi.set(__self__, "binlog_expire_logs_seconds", binlog_expire_logs_seconds)
        pulumi.set(__self__, "binlog_row_metadata", binlog_row_metadata)
        pulumi.set(__self__, "binlog_row_value_options", binlog_row_value_options)
        pulumi.set(__self__, "binlog_transaction_compression", binlog_transaction_compression)
        pulumi.set(__self__, "completion_type", completion_type)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "cte_max_recursion_depth", cte_max_recursion_depth)
        pulumi.set(__self__, "default_authentication_plugin", default_authentication_plugin)
        pulumi.set(__self__, "foreign_key_checks", foreign_key_checks)
        pulumi.set(__self__, "generated_random_password_length", generated_random_password_length)
        pulumi.set(__self__, "group_replication_consistency", group_replication_consistency)
        pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        pulumi.set(__self__, "innodb_buffer_pool_instances", innodb_buffer_pool_instances)
        pulumi.set(__self__, "innodb_buffer_pool_size", innodb_buffer_pool_size)
        pulumi.set(__self__, "innodb_ft_enable_stopword", innodb_ft_enable_stopword)
        pulumi.set(__self__, "innodb_ft_max_token_size", innodb_ft_max_token_size)
        pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        pulumi.set(__self__, "innodb_ft_num_word_optimize", innodb_ft_num_word_optimize)
        pulumi.set(__self__, "innodb_ft_result_cache_limit", innodb_ft_result_cache_limit)
        pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        pulumi.set(__self__, "innodb_max_purge_lag", innodb_max_purge_lag)
        pulumi.set(__self__, "innodb_max_purge_lag_delay", innodb_max_purge_lag_delay)
        pulumi.set(__self__, "local_infile", local_infile)
        pulumi.set(__self__, "mandatory_roles", mandatory_roles)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_execution_time", max_execution_time)
        pulumi.set(__self__, "max_prepared_stmt_count", max_prepared_stmt_count)
        pulumi.set(__self__, "mysql_firewall_mode", mysql_firewall_mode)
        pulumi.set(__self__, "mysql_zstd_default_compression_level", mysql_zstd_default_compression_level)
        pulumi.set(__self__, "mysqlx_connect_timeout", mysqlx_connect_timeout)
        pulumi.set(__self__, "mysqlx_deflate_default_compression_level", mysqlx_deflate_default_compression_level)
        pulumi.set(__self__, "mysqlx_deflate_max_client_compression_level", mysqlx_deflate_max_client_compression_level)
        pulumi.set(__self__, "mysqlx_document_id_unique_prefix", mysqlx_document_id_unique_prefix)
        pulumi.set(__self__, "mysqlx_enable_hello_notice", mysqlx_enable_hello_notice)
        pulumi.set(__self__, "mysqlx_idle_worker_thread_timeout", mysqlx_idle_worker_thread_timeout)
        pulumi.set(__self__, "mysqlx_interactive_timeout", mysqlx_interactive_timeout)
        pulumi.set(__self__, "mysqlx_lz4default_compression_level", mysqlx_lz4default_compression_level)
        pulumi.set(__self__, "mysqlx_lz4max_client_compression_level", mysqlx_lz4max_client_compression_level)
        pulumi.set(__self__, "mysqlx_max_allowed_packet", mysqlx_max_allowed_packet)
        pulumi.set(__self__, "mysqlx_min_worker_threads", mysqlx_min_worker_threads)
        pulumi.set(__self__, "mysqlx_read_timeout", mysqlx_read_timeout)
        pulumi.set(__self__, "mysqlx_wait_timeout", mysqlx_wait_timeout)
        pulumi.set(__self__, "mysqlx_write_timeout", mysqlx_write_timeout)
        pulumi.set(__self__, "mysqlx_zstd_default_compression_level", mysqlx_zstd_default_compression_level)
        pulumi.set(__self__, "mysqlx_zstd_max_client_compression_level", mysqlx_zstd_max_client_compression_level)
        pulumi.set(__self__, "parser_max_mem_size", parser_max_mem_size)
        pulumi.set(__self__, "query_alloc_block_size", query_alloc_block_size)
        pulumi.set(__self__, "query_prealloc_size", query_prealloc_size)
        pulumi.set(__self__, "sql_mode", sql_mode)
        pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        pulumi.set(__self__, "sql_warnings", sql_warnings)
        pulumi.set(__self__, "transaction_isolation", transaction_isolation)

    @property
    @pulumi.getter
    def autocommit(self) -> bool:
        """
        ("autocommit")
        """
        return pulumi.get(self, "autocommit")

    @property
    @pulumi.getter(name="binlogExpireLogsSeconds")
    def binlog_expire_logs_seconds(self) -> int:
        """
        Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable [binlog_expire_logs_seconds](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_expire_logs_seconds).
        """
        return pulumi.get(self, "binlog_expire_logs_seconds")

    @property
    @pulumi.getter(name="binlogRowMetadata")
    def binlog_row_metadata(self) -> str:
        """
        Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable [binlog_row_metadata](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_metadata).
        """
        return pulumi.get(self, "binlog_row_metadata")

    @property
    @pulumi.getter(name="binlogRowValueOptions")
    def binlog_row_value_options(self) -> str:
        """
        When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable [binlog_row_value_options](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_row_value_options).
        """
        return pulumi.get(self, "binlog_row_value_options")

    @property
    @pulumi.getter(name="binlogTransactionCompression")
    def binlog_transaction_compression(self) -> bool:
        """
        Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable [binlog_transaction_compression](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_compression).
        """
        return pulumi.get(self, "binlog_transaction_compression")

    @property
    @pulumi.getter(name="completionType")
    def completion_type(self) -> str:
        """
        ("completion_type")
        """
        return pulumi.get(self, "completion_type")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        ("connect_timeout")
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="cteMaxRecursionDepth")
    def cte_max_recursion_depth(self) -> int:
        """
        ("cte_max_recursion_depth")
        """
        return pulumi.get(self, "cte_max_recursion_depth")

    @property
    @pulumi.getter(name="defaultAuthenticationPlugin")
    def default_authentication_plugin(self) -> str:
        """
        ("default_authentication_plugin")
        """
        return pulumi.get(self, "default_authentication_plugin")

    @property
    @pulumi.getter(name="foreignKeyChecks")
    def foreign_key_checks(self) -> bool:
        """
        ("foreign_key_checks")
        """
        return pulumi.get(self, "foreign_key_checks")

    @property
    @pulumi.getter(name="generatedRandomPasswordLength")
    def generated_random_password_length(self) -> int:
        """
        ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "generated_random_password_length")

    @property
    @pulumi.getter(name="groupReplicationConsistency")
    def group_replication_consistency(self) -> str:
        """
        * EVENTUAL: Both RO and RW transactions do not wait for preceding transactions to be applied before executing. A RW transaction does not wait for other members to apply a transaction. This means that a transaction could be externalized on one member before the others. This also means that in the event of a primary failover, the new primary can accept new RO and RW transactions before the previous primary transactions are all applied. RO transactions could result in outdated values, RW transactions could result in a rollback due to conflicts.
        * BEFORE_ON_PRIMARY_FAILOVER: New RO or RW transactions with a newly elected primary that is applying backlog from the old primary are held (not applied) until any backlog has been applied. This ensures that when a primary failover happens, intentionally or not, clients always see the latest value on the primary. This guarantees consistency, but means that clients must be able to handle the delay in the event that a backlog is being applied. Usually this delay should be minimal, but does depend on the size of the backlog.
        * BEFORE: A RW transaction waits for all preceding transactions to complete before being applied. A RO transaction waits for all preceding transactions to complete before being executed. This ensures that this transaction reads the latest value by only affecting the latency of the transaction. This reduces the overhead of synchronization on every RW transaction, by ensuring synchronization is used only on RO transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        * AFTER: A RW transaction waits until its changes have been applied to all of the other members. This value has no effect on RO transactions. This mode ensures that when a transaction is committed on the local member, any subsequent transaction reads the written value or a more recent value on any group member. Use this mode with a group that is used for predominantly RO operations to ensure that applied RW transactions are applied everywhere once they commit. This could be used by your application to ensure that subsequent reads fetch the latest data which includes the latest writes. This reduces the overhead of synchronization on every RO transaction, by ensuring synchronization is used only on RW transactions. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        * BEFORE_AND_AFTER: A RW transaction waits for 1) all preceding transactions to complete before being applied and 2) until its changes have been applied on other members. A RO transaction waits for all preceding transactions to complete before execution takes place. This consistency level also includes the consistency guarantees provided by BEFORE_ON_PRIMARY_FAILOVER.
        """
        return pulumi.get(self, "group_replication_consistency")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> int:
        """
        ("information_schema_stats_expiry")
        """
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbBufferPoolInstances")
    def innodb_buffer_pool_instances(self) -> int:
        """
        ("innodb_buffer_pool_instances")
        """
        return pulumi.get(self, "innodb_buffer_pool_instances")

    @property
    @pulumi.getter(name="innodbBufferPoolSize")
    def innodb_buffer_pool_size(self) -> str:
        """
        ("innodb_buffer_pool_size")
        """
        return pulumi.get(self, "innodb_buffer_pool_size")

    @property
    @pulumi.getter(name="innodbFtEnableStopword")
    def innodb_ft_enable_stopword(self) -> bool:
        """
        ("innodb_ft_enable_stopword")
        """
        return pulumi.get(self, "innodb_ft_enable_stopword")

    @property
    @pulumi.getter(name="innodbFtMaxTokenSize")
    def innodb_ft_max_token_size(self) -> int:
        """
        ("innodb_ft_max_token_size")
        """
        return pulumi.get(self, "innodb_ft_max_token_size")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> int:
        """
        ("innodb_ft_min_token_size")
        """
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtNumWordOptimize")
    def innodb_ft_num_word_optimize(self) -> int:
        """
        ("innodb_ft_num_word_optimize")
        """
        return pulumi.get(self, "innodb_ft_num_word_optimize")

    @property
    @pulumi.getter(name="innodbFtResultCacheLimit")
    def innodb_ft_result_cache_limit(self) -> int:
        """
        ("innodb_ft_result_cache_limit")
        """
        return pulumi.get(self, "innodb_ft_result_cache_limit")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> str:
        """
        ("innodb_ft_server_stopword_table")
        """
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> int:
        """
        ("innodb_lock_wait_timeout")
        """
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbMaxPurgeLag")
    def innodb_max_purge_lag(self) -> int:
        """
        ("innodb_max_purge_lag")
        """
        return pulumi.get(self, "innodb_max_purge_lag")

    @property
    @pulumi.getter(name="innodbMaxPurgeLagDelay")
    def innodb_max_purge_lag_delay(self) -> int:
        """
        ("innodb_max_purge_lag_delay")
        """
        return pulumi.get(self, "innodb_max_purge_lag_delay")

    @property
    @pulumi.getter(name="localInfile")
    def local_infile(self) -> bool:
        """
        ("local_infile")
        """
        return pulumi.get(self, "local_infile")

    @property
    @pulumi.getter(name="mandatoryRoles")
    def mandatory_roles(self) -> str:
        """
        ("mandatory_roles")
        """
        return pulumi.get(self, "mandatory_roles")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        """
        ("max_connections")
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> int:
        """
        ("max_execution_time")
        """
        return pulumi.get(self, "max_execution_time")

    @property
    @pulumi.getter(name="maxPreparedStmtCount")
    def max_prepared_stmt_count(self) -> int:
        """
        ("max_prepared_stmt_count")
        """
        return pulumi.get(self, "max_prepared_stmt_count")

    @property
    @pulumi.getter(name="mysqlFirewallMode")
    def mysql_firewall_mode(self) -> bool:
        """
        ("mysql_firewall_mode")
        """
        return pulumi.get(self, "mysql_firewall_mode")

    @property
    @pulumi.getter(name="mysqlZstdDefaultCompressionLevel")
    def mysql_zstd_default_compression_level(self) -> int:
        """
        DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
        """
        return pulumi.get(self, "mysql_zstd_default_compression_level")

    @property
    @pulumi.getter(name="mysqlxConnectTimeout")
    def mysqlx_connect_timeout(self) -> int:
        """
        ("mysqlx_connect_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_connect_timeout")

    @property
    @pulumi.getter(name="mysqlxDeflateDefaultCompressionLevel")
    def mysqlx_deflate_default_compression_level(self) -> int:
        """
        Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
        """
        return pulumi.get(self, "mysqlx_deflate_default_compression_level")

    @property
    @pulumi.getter(name="mysqlxDeflateMaxClientCompressionLevel")
    def mysqlx_deflate_max_client_compression_level(self) -> int:
        """
        Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
        """
        return pulumi.get(self, "mysqlx_deflate_max_client_compression_level")

    @property
    @pulumi.getter(name="mysqlxDocumentIdUniquePrefix")
    def mysqlx_document_id_unique_prefix(self) -> int:
        """
        ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_document_id_unique_prefix")

    @property
    @pulumi.getter(name="mysqlxEnableHelloNotice")
    def mysqlx_enable_hello_notice(self) -> bool:
        """
        ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_enable_hello_notice")

    @property
    @pulumi.getter(name="mysqlxIdleWorkerThreadTimeout")
    def mysqlx_idle_worker_thread_timeout(self) -> int:
        """
        ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_idle_worker_thread_timeout")

    @property
    @pulumi.getter(name="mysqlxInteractiveTimeout")
    def mysqlx_interactive_timeout(self) -> int:
        """
        ("mysqlx_interactive_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_interactive_timeout")

    @property
    @pulumi.getter(name="mysqlxLz4defaultCompressionLevel")
    def mysqlx_lz4default_compression_level(self) -> int:
        """
        Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
        """
        return pulumi.get(self, "mysqlx_lz4default_compression_level")

    @property
    @pulumi.getter(name="mysqlxLz4maxClientCompressionLevel")
    def mysqlx_lz4max_client_compression_level(self) -> int:
        """
        Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
        """
        return pulumi.get(self, "mysqlx_lz4max_client_compression_level")

    @property
    @pulumi.getter(name="mysqlxMaxAllowedPacket")
    def mysqlx_max_allowed_packet(self) -> int:
        """
        ("mysqlx_max_allowed_packet") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_max_allowed_packet")

    @property
    @pulumi.getter(name="mysqlxMinWorkerThreads")
    def mysqlx_min_worker_threads(self) -> int:
        """
        ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_min_worker_threads")

    @property
    @pulumi.getter(name="mysqlxReadTimeout")
    def mysqlx_read_timeout(self) -> int:
        """
        ("mysqlx_read_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_read_timeout")

    @property
    @pulumi.getter(name="mysqlxWaitTimeout")
    def mysqlx_wait_timeout(self) -> int:
        """
        ("mysqlx_wait_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_wait_timeout")

    @property
    @pulumi.getter(name="mysqlxWriteTimeout")
    def mysqlx_write_timeout(self) -> int:
        """
        ("mysqlx_write_timeout") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "mysqlx_write_timeout")

    @property
    @pulumi.getter(name="mysqlxZstdDefaultCompressionLevel")
    def mysqlx_zstd_default_compression_level(self) -> int:
        """
        Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
        """
        return pulumi.get(self, "mysqlx_zstd_default_compression_level")

    @property
    @pulumi.getter(name="mysqlxZstdMaxClientCompressionLevel")
    def mysqlx_zstd_max_client_compression_level(self) -> int:
        """
        Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
        """
        return pulumi.get(self, "mysqlx_zstd_max_client_compression_level")

    @property
    @pulumi.getter(name="parserMaxMemSize")
    def parser_max_mem_size(self) -> int:
        """
        ("parser_max_mem_size")
        """
        return pulumi.get(self, "parser_max_mem_size")

    @property
    @pulumi.getter(name="queryAllocBlockSize")
    def query_alloc_block_size(self) -> int:
        """
        ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "query_alloc_block_size")

    @property
    @pulumi.getter(name="queryPreallocSize")
    def query_prealloc_size(self) -> int:
        """
        ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
        """
        return pulumi.get(self, "query_prealloc_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> str:
        """
        ("sql_mode")
        """
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> bool:
        """
        ("sql_require_primary_key")
        """
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="sqlWarnings")
    def sql_warnings(self) -> bool:
        """
        ("sql_warnings")
        """
        return pulumi.get(self, "sql_warnings")

    @property
    @pulumi.getter(name="transactionIsolation")
    def transaction_isolation(self) -> str:
        """
        ("transaction_isolation")
        """
        return pulumi.get(self, "transaction_isolation")


@pulumi.output_type
class GetMysqlConfigurationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMysqlDbSystemAnalyticsClusterResult(dict):
    def __init__(__self__, *,
                 cluster_size: int,
                 shape_name: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param int cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param str shape_name: The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        :param str state: The current state of the DB System.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "cluster_size", cluster_size)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> int:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the DB System.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemBackupPolicyResult(dict):
    def __init__(__self__, *,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 is_enabled: bool,
                 retention_in_days: int,
                 window_start_time: str):
        """
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param bool is_enabled: Whether the Channel has been enabled by the user.
        :param int retention_in_days: The number of days automated backups are retained.
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Whether the Channel has been enabled by the user.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days automated backups are retained.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlDbSystemChannelResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_enabled: bool,
                 lifecycle_details: str,
                 sources: Sequence['outputs.GetMysqlDbSystemChannelSourceResult'],
                 state: str,
                 targets: Sequence['outputs.GetMysqlDbSystemChannelTargetResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The OCID of the compartment the DB System belongs in.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: The user-friendly name for the DB System. It does not have to be unique.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The OCID of the DB System.
        :param bool is_enabled: Whether the Channel has been enabled by the user.
        :param str lifecycle_details: Additional information about the current lifecycleState.
        :param Sequence['GetMysqlDbSystemChannelSourceArgs'] sources: Parameters detailing how to provision the initial data of the DB System.
        :param str state: The current state of the DB System.
        :param Sequence['GetMysqlDbSystemChannelTargetArgs'] targets: Details about the Channel target.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "targets", targets)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment the DB System belongs in.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the DB System. It does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the DB System.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Whether the Channel has been enabled by the user.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetMysqlDbSystemChannelSourceResult']:
        """
        Parameters detailing how to provision the initial data of the DB System.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the DB System.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetMysqlDbSystemChannelTargetResult']:
        """
        Details about the Channel target.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemChannelSourceResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 source_type: str,
                 ssl_ca_certificates: Sequence['outputs.GetMysqlDbSystemChannelSourceSslCaCertificateResult'],
                 ssl_mode: str,
                 username: str):
        """
        :param str hostname: The network address of the DB System.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param str source_type: The specific source identifier.
        :param Sequence['GetMysqlDbSystemChannelSourceSslCaCertificateArgs'] ssl_ca_certificates: The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        :param str ssl_mode: The SSL mode of the Channel.
        :param str username: The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_ca_certificates", ssl_ca_certificates)
        pulumi.set(__self__, "ssl_mode", ssl_mode)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslCaCertificates")
    def ssl_ca_certificates(self) -> Sequence['outputs.GetMysqlDbSystemChannelSourceSslCaCertificateResult']:
        """
        The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificates")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetMysqlDbSystemChannelSourceSslCaCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_type: str,
                 contents: str):
        """
        :param str certificate_type: The type of CA certificate.
        :param str contents: The string containing the CA certificate in PEM format.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter
    def contents(self) -> str:
        """
        The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class GetMysqlDbSystemChannelTargetResult(dict):
    def __init__(__self__, *,
                 applier_username: str,
                 channel_name: str,
                 db_system_id: str,
                 target_type: str):
        """
        :param str applier_username: The username for the replication applier of the target MySQL DB System.
        :param str channel_name: The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        :param str db_system_id: The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str target_type: The specific target identifier.
        """
        pulumi.set(__self__, "applier_username", applier_username)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> str:
        """
        The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        The specific target identifier.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class GetMysqlDbSystemCurrentPlacementResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 fault_domain: str):
        """
        :param str availability_domain: The availability domain in which the DB System is placed.
        :param str fault_domain: The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "fault_domain", fault_domain)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The availability domain in which the DB System is placed.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> str:
        """
        The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "fault_domain")


@pulumi.output_type
class GetMysqlDbSystemDeletionPolicyResult(dict):
    def __init__(__self__, *,
                 automatic_backup_retention: str,
                 final_backup: str,
                 is_delete_protected: bool):
        """
        :param str automatic_backup_retention: Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        :param str final_backup: Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        :param bool is_delete_protected: Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        pulumi.set(__self__, "automatic_backup_retention", automatic_backup_retention)
        pulumi.set(__self__, "final_backup", final_backup)
        pulumi.set(__self__, "is_delete_protected", is_delete_protected)

    @property
    @pulumi.getter(name="automaticBackupRetention")
    def automatic_backup_retention(self) -> str:
        """
        Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        """
        return pulumi.get(self, "automatic_backup_retention")

    @property
    @pulumi.getter(name="finalBackup")
    def final_backup(self) -> str:
        """
        Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        """
        return pulumi.get(self, "final_backup")

    @property
    @pulumi.getter(name="isDeleteProtected")
    def is_delete_protected(self) -> bool:
        """
        Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        return pulumi.get(self, "is_delete_protected")


@pulumi.output_type
class GetMysqlDbSystemEndpointResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ip_address: str,
                 modes: Sequence[str],
                 port: int,
                 port_x: int,
                 status: str,
                 status_details: str):
        """
        :param str hostname: The network address of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param Sequence[str] modes: The access modes from the client that this endpoint supports.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param str status_details: Additional information about the current endpoint status.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "modes", modes)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def modes(self) -> Sequence[str]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")


@pulumi.output_type
class GetMysqlDbSystemHeatWaveClusterResult(dict):
    def __init__(__self__, *,
                 cluster_size: int,
                 shape_name: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param int cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param str shape_name: The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        :param str state: The current state of the DB System.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "cluster_size", cluster_size)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> int:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the DB System.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemMaintenanceResult(dict):
    def __init__(__self__, *,
                 window_start_time: str):
        """
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlDbSystemSourceResult(dict):
    def __init__(__self__, *,
                 backup_id: str,
                 source_type: str):
        """
        :param str backup_id: The OCID of the backup to be used as the source for the new DB System.
        :param str source_type: The specific source identifier.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        """
        The OCID of the backup to be used as the source for the new DB System.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 admin_username: str,
                 analytics_clusters: Sequence['outputs.GetMysqlDbSystemsDbSystemAnalyticsClusterResult'],
                 availability_domain: str,
                 backup_policies: Sequence['outputs.GetMysqlDbSystemsDbSystemBackupPolicyResult'],
                 channels: Sequence['outputs.GetMysqlDbSystemsDbSystemChannelResult'],
                 compartment_id: str,
                 configuration_id: str,
                 crash_recovery: str,
                 current_placements: Sequence['outputs.GetMysqlDbSystemsDbSystemCurrentPlacementResult'],
                 data_storage_size_in_gb: int,
                 defined_tags: Mapping[str, Any],
                 deletion_policies: Sequence['outputs.GetMysqlDbSystemsDbSystemDeletionPolicyResult'],
                 description: str,
                 display_name: str,
                 endpoints: Sequence['outputs.GetMysqlDbSystemsDbSystemEndpointResult'],
                 fault_domain: str,
                 freeform_tags: Mapping[str, Any],
                 heat_wave_clusters: Sequence['outputs.GetMysqlDbSystemsDbSystemHeatWaveClusterResult'],
                 hostname_label: str,
                 id: str,
                 ip_address: str,
                 is_analytics_cluster_attached: bool,
                 is_heat_wave_cluster_attached: bool,
                 is_highly_available: bool,
                 lifecycle_details: str,
                 maintenances: Sequence['outputs.GetMysqlDbSystemsDbSystemMaintenanceResult'],
                 mysql_version: str,
                 port: int,
                 port_x: int,
                 shape_name: str,
                 shutdown_type: str,
                 sources: Sequence['outputs.GetMysqlDbSystemsDbSystemSourceResult'],
                 state: str,
                 subnet_id: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence['GetMysqlDbSystemsDbSystemAnalyticsClusterArgs'] analytics_clusters: DEPRECATED -- please use HeatWave API instead. A summary of an Analytics Cluster.
        :param str availability_domain: The availability domain in which the DB System is placed.
        :param Sequence['GetMysqlDbSystemsDbSystemBackupPolicyArgs'] backup_policies: The Backup policy for the DB System.
        :param Sequence['GetMysqlDbSystemsDbSystemChannelArgs'] channels: A list with a summary of all the Channels attached to the DB System.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str configuration_id: The requested Configuration instance.
        :param str crash_recovery: Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        :param Sequence['GetMysqlDbSystemsDbSystemCurrentPlacementArgs'] current_placements: The availability domain and fault domain a DB System is placed in.
        :param int data_storage_size_in_gb: Initial size of the data volume in GiBs that will be created and attached.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Sequence['GetMysqlDbSystemsDbSystemDeletionPolicyArgs'] deletion_policies: The Deletion policy for the DB System.
        :param str description: User-provided data about the DB System.
        :param str display_name: A filter to return only the resource matching the given display name exactly.
        :param Sequence['GetMysqlDbSystemsDbSystemEndpointArgs'] endpoints: The network endpoints available for this DB System.
        :param str fault_domain: The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param Sequence['GetMysqlDbSystemsDbSystemHeatWaveClusterArgs'] heat_wave_clusters: A summary of a HeatWave cluster.
        :param str hostname_label: The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        :param str id: The OCID of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param bool is_analytics_cluster_attached: DEPRECATED -- please use HeatWave API instead. If true, return only DB Systems with an Analytics Cluster attached, if false return only DB Systems with no Analytics Cluster attached. If not present, return all DB Systems.
        :param bool is_heat_wave_cluster_attached: If true, return only DB Systems with a HeatWave cluster attached, if false return only DB Systems with no HeatWave cluster attached. If not present, return all DB Systems.
        :param bool is_highly_available: If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        :param str lifecycle_details: Additional information about the current lifecycleState.
        :param Sequence['GetMysqlDbSystemsDbSystemMaintenanceArgs'] maintenances: The Maintenance Policy for the DB System.
        :param str mysql_version: Name of the MySQL Version in use for the DB System.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str shape_name: The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        :param Sequence['GetMysqlDbSystemsDbSystemSourceArgs'] sources: Parameters detailing how to provision the initial data of the DB System.
        :param str state: DbSystem Lifecycle State
        :param str subnet_id: The OCID of the subnet the DB System is associated with.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "analytics_clusters", analytics_clusters)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "backup_policies", backup_policies)
        pulumi.set(__self__, "channels", channels)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "configuration_id", configuration_id)
        pulumi.set(__self__, "crash_recovery", crash_recovery)
        pulumi.set(__self__, "current_placements", current_placements)
        pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "deletion_policies", deletion_policies)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "fault_domain", fault_domain)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "heat_wave_clusters", heat_wave_clusters)
        pulumi.set(__self__, "hostname_label", hostname_label)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_analytics_cluster_attached", is_analytics_cluster_attached)
        pulumi.set(__self__, "is_heat_wave_cluster_attached", is_heat_wave_cluster_attached)
        pulumi.set(__self__, "is_highly_available", is_highly_available)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "maintenances", maintenances)
        pulumi.set(__self__, "mysql_version", mysql_version)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "shutdown_type", shutdown_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="analyticsClusters")
    def analytics_clusters(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemAnalyticsClusterResult']:
        """
        DEPRECATED -- please use HeatWave API instead. A summary of an Analytics Cluster.
        """
        return pulumi.get(self, "analytics_clusters")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The availability domain in which the DB System is placed.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupPolicies")
    def backup_policies(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemBackupPolicyResult']:
        """
        The Backup policy for the DB System.
        """
        return pulumi.get(self, "backup_policies")

    @property
    @pulumi.getter
    def channels(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemChannelResult']:
        """
        A list with a summary of all the Channels attached to the DB System.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="configurationId")
    def configuration_id(self) -> str:
        """
        The requested Configuration instance.
        """
        return pulumi.get(self, "configuration_id")

    @property
    @pulumi.getter(name="crashRecovery")
    def crash_recovery(self) -> str:
        """
        Whether to run the DB System with InnoDB Redo Logs and the Double Write Buffer enabled or disabled, and whether to enable or disable syncing of the Binary Logs.
        """
        return pulumi.get(self, "crash_recovery")

    @property
    @pulumi.getter(name="currentPlacements")
    def current_placements(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemCurrentPlacementResult']:
        """
        The availability domain and fault domain a DB System is placed in.
        """
        return pulumi.get(self, "current_placements")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        Initial size of the data volume in GiBs that will be created and attached.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="deletionPolicies")
    def deletion_policies(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemDeletionPolicyResult']:
        """
        The Deletion policy for the DB System.
        """
        return pulumi.get(self, "deletion_policies")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        User-provided data about the DB System.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only the resource matching the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemEndpointResult']:
        """
        The network endpoints available for this DB System.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> str:
        """
        The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "fault_domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="heatWaveClusters")
    def heat_wave_clusters(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemHeatWaveClusterResult']:
        """
        A summary of a HeatWave cluster.
        """
        return pulumi.get(self, "heat_wave_clusters")

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> str:
        """
        The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        """
        return pulumi.get(self, "hostname_label")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the DB System.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="isAnalyticsClusterAttached")
    def is_analytics_cluster_attached(self) -> bool:
        """
        DEPRECATED -- please use HeatWave API instead. If true, return only DB Systems with an Analytics Cluster attached, if false return only DB Systems with no Analytics Cluster attached. If not present, return all DB Systems.
        """
        return pulumi.get(self, "is_analytics_cluster_attached")

    @property
    @pulumi.getter(name="isHeatWaveClusterAttached")
    def is_heat_wave_cluster_attached(self) -> bool:
        """
        If true, return only DB Systems with a HeatWave cluster attached, if false return only DB Systems with no HeatWave cluster attached. If not present, return all DB Systems.
        """
        return pulumi.get(self, "is_heat_wave_cluster_attached")

    @property
    @pulumi.getter(name="isHighlyAvailable")
    def is_highly_available(self) -> bool:
        """
        If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        """
        return pulumi.get(self, "is_highly_available")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def maintenances(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemMaintenanceResult']:
        """
        The Maintenance Policy for the DB System.
        """
        return pulumi.get(self, "maintenances")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> str:
        """
        Name of the MySQL Version in use for the DB System.
        """
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter(name="shutdownType")
    def shutdown_type(self) -> str:
        return pulumi.get(self, "shutdown_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemSourceResult']:
        """
        Parameters detailing how to provision the initial data of the DB System.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        DbSystem Lifecycle State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of the subnet the DB System is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemAnalyticsClusterResult(dict):
    def __init__(__self__, *,
                 cluster_size: int,
                 shape_name: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param int cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param str shape_name: The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        :param str state: DbSystem Lifecycle State
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "cluster_size", cluster_size)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> int:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        DbSystem Lifecycle State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemBackupPolicyResult(dict):
    def __init__(__self__, *,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 is_enabled: bool,
                 retention_in_days: int,
                 window_start_time: str):
        """
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param bool is_enabled: Whether the Channel has been enabled by the user.
        :param int retention_in_days: The number of days automated backups are retained.
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Whether the Channel has been enabled by the user.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days automated backups are retained.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemChannelResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_enabled: bool,
                 lifecycle_details: str,
                 sources: Sequence['outputs.GetMysqlDbSystemsDbSystemChannelSourceResult'],
                 state: str,
                 targets: Sequence['outputs.GetMysqlDbSystemsDbSystemChannelTargetResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: A filter to return only the resource matching the given display name exactly.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The OCID of the DB System.
        :param bool is_enabled: Whether the Channel has been enabled by the user.
        :param str lifecycle_details: Additional information about the current lifecycleState.
        :param Sequence['GetMysqlDbSystemsDbSystemChannelSourceArgs'] sources: Parameters detailing how to provision the initial data of the DB System.
        :param str state: DbSystem Lifecycle State
        :param Sequence['GetMysqlDbSystemsDbSystemChannelTargetArgs'] targets: Details about the Channel target.
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "targets", targets)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only the resource matching the given display name exactly.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the DB System.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Whether the Channel has been enabled by the user.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemChannelSourceResult']:
        """
        Parameters detailing how to provision the initial data of the DB System.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        DbSystem Lifecycle State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemChannelTargetResult']:
        """
        Details about the Channel target.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemChannelSourceResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 source_type: str,
                 ssl_ca_certificates: Sequence['outputs.GetMysqlDbSystemsDbSystemChannelSourceSslCaCertificateResult'],
                 ssl_mode: str,
                 username: str):
        """
        :param str hostname: The network address of the DB System.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param str source_type: The specific source identifier.
        :param Sequence['GetMysqlDbSystemsDbSystemChannelSourceSslCaCertificateArgs'] ssl_ca_certificates: The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        :param str ssl_mode: The SSL mode of the Channel.
        :param str username: The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_ca_certificates", ssl_ca_certificates)
        pulumi.set(__self__, "ssl_mode", ssl_mode)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslCaCertificates")
    def ssl_ca_certificates(self) -> Sequence['outputs.GetMysqlDbSystemsDbSystemChannelSourceSslCaCertificateResult']:
        """
        The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificates")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemChannelSourceSslCaCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_type: str,
                 contents: str):
        """
        :param str certificate_type: The type of CA certificate.
        :param str contents: The string containing the CA certificate in PEM format.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter
    def contents(self) -> str:
        """
        The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemChannelTargetResult(dict):
    def __init__(__self__, *,
                 applier_username: str,
                 channel_name: str,
                 db_system_id: str,
                 target_type: str):
        """
        :param str applier_username: The username for the replication applier of the target MySQL DB System.
        :param str channel_name: The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        :param str db_system_id: The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str target_type: The specific target identifier.
        """
        pulumi.set(__self__, "applier_username", applier_username)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> str:
        """
        The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The DB System [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        The specific target identifier.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemCurrentPlacementResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 fault_domain: str):
        """
        :param str availability_domain: The availability domain in which the DB System is placed.
        :param str fault_domain: The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "fault_domain", fault_domain)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The availability domain in which the DB System is placed.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> str:
        """
        The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "fault_domain")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemDeletionPolicyResult(dict):
    def __init__(__self__, *,
                 automatic_backup_retention: str,
                 final_backup: str,
                 is_delete_protected: bool):
        """
        :param str automatic_backup_retention: Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        :param str final_backup: Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        :param bool is_delete_protected: Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        pulumi.set(__self__, "automatic_backup_retention", automatic_backup_retention)
        pulumi.set(__self__, "final_backup", final_backup)
        pulumi.set(__self__, "is_delete_protected", is_delete_protected)

    @property
    @pulumi.getter(name="automaticBackupRetention")
    def automatic_backup_retention(self) -> str:
        """
        Specifies if any automatic backups created for a DB System should be retained or deleted when the DB System is deleted.
        """
        return pulumi.get(self, "automatic_backup_retention")

    @property
    @pulumi.getter(name="finalBackup")
    def final_backup(self) -> str:
        """
        Specifies whether or not a backup is taken when the DB System is deleted. REQUIRE_FINAL_BACKUP: a backup is taken if the DB System is deleted. SKIP_FINAL_BACKUP: a backup is not taken if the DB System is deleted.
        """
        return pulumi.get(self, "final_backup")

    @property
    @pulumi.getter(name="isDeleteProtected")
    def is_delete_protected(self) -> bool:
        """
        Specifies whether the DB System can be deleted. Set to true to prevent deletion, false (default) to allow.
        """
        return pulumi.get(self, "is_delete_protected")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemEndpointResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ip_address: str,
                 modes: Sequence[str],
                 port: int,
                 port_x: int,
                 status: str,
                 status_details: str):
        """
        :param str hostname: The network address of the DB System.
        :param str ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param Sequence[str] modes: The access modes from the client that this endpoint supports.
        :param int port: The port for primary endpoint of the DB System to listen on.
        :param int port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param str status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param str status_details: Additional information about the current endpoint status.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "modes", modes)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_x", port_x)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def modes(self) -> Sequence[str]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> int:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemHeatWaveClusterResult(dict):
    def __init__(__self__, *,
                 cluster_size: int,
                 shape_name: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param int cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param str shape_name: The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        :param str state: DbSystem Lifecycle State
        :param str time_created: The date and time the DB System was created.
        :param str time_updated: The time the DB System was last updated.
        """
        pulumi.set(__self__, "cluster_size", cluster_size)
        pulumi.set(__self__, "shape_name", shape_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> int:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> str:
        """
        The shape of the primary instances of the DB System. The shape determines resources allocated to a DB System - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use (the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20181021/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        DbSystem Lifecycle State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemMaintenanceResult(dict):
    def __init__(__self__, *,
                 window_start_time: str):
        """
        :param str window_start_time: The start time of the maintenance window.
        """
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> str:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetMysqlDbSystemsDbSystemSourceResult(dict):
    def __init__(__self__, *,
                 backup_id: str,
                 source_type: str):
        """
        :param str backup_id: The OCID of the backup to be used as the source for the new DB System.
        :param str source_type: The specific source identifier.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        """
        The OCID of the backup to be used as the source for the new DB System.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The specific source identifier.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class GetMysqlDbSystemsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMysqlVersionFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMysqlVersionVersionResult(dict):
    def __init__(__self__, *,
                 version_family: str,
                 versions: Sequence['outputs.GetMysqlVersionVersionVersionResult']):
        """
        :param str version_family: A descriptive summary of a group of versions.
        :param Sequence['GetMysqlVersionVersionVersionArgs'] versions: The list of supported MySQL Versions.
        """
        pulumi.set(__self__, "version_family", version_family)
        pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter(name="versionFamily")
    def version_family(self) -> str:
        """
        A descriptive summary of a group of versions.
        """
        return pulumi.get(self, "version_family")

    @property
    @pulumi.getter
    def versions(self) -> Sequence['outputs.GetMysqlVersionVersionVersionResult']:
        """
        The list of supported MySQL Versions.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetMysqlVersionVersionVersionResult(dict):
    def __init__(__self__, *,
                 description: str,
                 version: str):
        """
        :param str description: A link to a page describing the version.
        :param str version: The specific version identifier
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A link to a page describing the version.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The specific version identifier
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetShapesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetShapesShapeResult(dict):
    def __init__(__self__, *,
                 cpu_core_count: int,
                 is_supported_fors: Sequence[str],
                 memory_size_in_gbs: int,
                 name: str):
        """
        :param int cpu_core_count: The number of CPU Cores the Instance provides. These are "OCPU"s.
        :param Sequence[str] is_supported_fors: Return shapes that are supported by the service feature.
        :param int memory_size_in_gbs: The amount of RAM the Instance provides. This is an IEC base-2 number.
        :param str name: Name
        """
        pulumi.set(__self__, "cpu_core_count", cpu_core_count)
        pulumi.set(__self__, "is_supported_fors", is_supported_fors)
        pulumi.set(__self__, "memory_size_in_gbs", memory_size_in_gbs)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU Cores the Instance provides. These are "OCPU"s.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="isSupportedFors")
    def is_supported_fors(self) -> Sequence[str]:
        """
        Return shapes that are supported by the service feature.
        """
        return pulumi.get(self, "is_supported_fors")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The amount of RAM the Instance provides. This is an IEC base-2 number.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name
        """
        return pulumi.get(self, "name")


