# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'NetworkFirewallNatConfiguration',
    'NetworkFirewallPolicyDecryptionRuleCondition',
    'NetworkFirewallPolicyDecryptionRulePosition',
    'NetworkFirewallPolicyNatRuleCondition',
    'NetworkFirewallPolicyNatRulePosition',
    'NetworkFirewallPolicySecurityRuleCondition',
    'NetworkFirewallPolicySecurityRulePosition',
    'NetworkFirewallPolicyServicePortRange',
    'NetworkFirewallPolicyTunnelInspectionRuleCondition',
    'NetworkFirewallPolicyTunnelInspectionRulePosition',
    'NetworkFirewallPolicyTunnelInspectionRuleProfile',
    'NetworkFirewallPolicyUrlListUrl',
    'GetNetworkFirewallNatConfigurationResult',
    'GetNetworkFirewallPoliciesFilterResult',
    'GetNetworkFirewallPoliciesNetworkFirewallPolicySummaryCollectionResult',
    'GetNetworkFirewallPoliciesNetworkFirewallPolicySummaryCollectionItemResult',
    'GetNetworkFirewallPolicyAddressListsAddressListSummaryCollectionResult',
    'GetNetworkFirewallPolicyAddressListsAddressListSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyAddressListsFilterResult',
    'GetNetworkFirewallPolicyApplicationGroupsApplicationGroupSummaryCollectionResult',
    'GetNetworkFirewallPolicyApplicationGroupsApplicationGroupSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyApplicationGroupsFilterResult',
    'GetNetworkFirewallPolicyApplicationsApplicationSummaryCollectionResult',
    'GetNetworkFirewallPolicyApplicationsApplicationSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyApplicationsFilterResult',
    'GetNetworkFirewallPolicyDecryptionProfilesDecryptionProfileSummaryCollectionResult',
    'GetNetworkFirewallPolicyDecryptionProfilesDecryptionProfileSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyDecryptionProfilesFilterResult',
    'GetNetworkFirewallPolicyDecryptionRuleConditionResult',
    'GetNetworkFirewallPolicyDecryptionRulePositionResult',
    'GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionResult',
    'GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemConditionResult',
    'GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemPositionResult',
    'GetNetworkFirewallPolicyDecryptionRulesFilterResult',
    'GetNetworkFirewallPolicyMappedSecretsMappedSecretSummaryCollectionResult',
    'GetNetworkFirewallPolicyMappedSecretsMappedSecretSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyNatRuleConditionResult',
    'GetNetworkFirewallPolicyNatRulePositionResult',
    'GetNetworkFirewallPolicyNatRulesFilterResult',
    'GetNetworkFirewallPolicyNatRulesNatRuleCollectionResult',
    'GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemResult',
    'GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemConditionResult',
    'GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemPositionResult',
    'GetNetworkFirewallPolicySecurityRuleConditionResult',
    'GetNetworkFirewallPolicySecurityRulePositionResult',
    'GetNetworkFirewallPolicySecurityRulesFilterResult',
    'GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionResult',
    'GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemResult',
    'GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemConditionResult',
    'GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemPositionResult',
    'GetNetworkFirewallPolicyServiceListsFilterResult',
    'GetNetworkFirewallPolicyServiceListsServiceListSummaryCollectionResult',
    'GetNetworkFirewallPolicyServiceListsServiceListSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyServicePortRangeResult',
    'GetNetworkFirewallPolicyServicesFilterResult',
    'GetNetworkFirewallPolicyServicesServiceSummaryCollectionResult',
    'GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemPortRangeResult',
    'GetNetworkFirewallPolicyTunnelInspectionRuleConditionResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulePositionResult',
    'GetNetworkFirewallPolicyTunnelInspectionRuleProfileResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulesFilterResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemConditionResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemPositionResult',
    'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemProfileResult',
    'GetNetworkFirewallPolicyUrlListUrlResult',
    'GetNetworkFirewallPolicyUrlListsFilterResult',
    'GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionResult',
    'GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemResult',
    'GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemUrlResult',
    'GetNetworkFirewallsFilterResult',
    'GetNetworkFirewallsNetworkFirewallCollectionResult',
    'GetNetworkFirewallsNetworkFirewallCollectionItemResult',
    'GetNetworkFirewallsNetworkFirewallCollectionItemNatConfigurationResult',
]

@pulumi.output_type
class NetworkFirewallNatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mustEnablePrivateNat":
            suggest = "must_enable_private_nat"
        elif key == "natIpAddressLists":
            suggest = "nat_ip_address_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallNatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallNatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallNatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 must_enable_private_nat: _builtins.bool,
                 nat_ip_address_lists: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool must_enable_private_nat: (Updatable) To allocate private NAT IPs to the firewall. The attached network firewall policy must also have NAT rules to enable NAT on any traffic passing through the firewall. The value of this field can not be false to release the NAT IPs given that the attached network firewall policy does not contains any NAT rules. The value of this field should be set to true if the network firewall policy being applied contains NAT rules.
        :param Sequence[_builtins.str] nat_ip_address_lists: An array of NAT IP addresses that are associated with the Network Firewall. These IPs are reserved for NAT and shouldn't be used for any other purpose in the subnet.
        """
        pulumi.set(__self__, "must_enable_private_nat", must_enable_private_nat)
        if nat_ip_address_lists is not None:
            pulumi.set(__self__, "nat_ip_address_lists", nat_ip_address_lists)

    @_builtins.property
    @pulumi.getter(name="mustEnablePrivateNat")
    def must_enable_private_nat(self) -> _builtins.bool:
        """
        (Updatable) To allocate private NAT IPs to the firewall. The attached network firewall policy must also have NAT rules to enable NAT on any traffic passing through the firewall. The value of this field can not be false to release the NAT IPs given that the attached network firewall policy does not contains any NAT rules. The value of this field should be set to true if the network firewall policy being applied contains NAT rules.
        """
        return pulumi.get(self, "must_enable_private_nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddressLists")
    def nat_ip_address_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of NAT IP addresses that are associated with the Network Firewall. These IPs are reserved for NAT and shouldn't be used for any other purpose in the subnet.
        """
        return pulumi.get(self, "nat_ip_address_lists")


@pulumi.output_type
class NetworkFirewallPolicyDecryptionRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyDecryptionRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyDecryptionRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyDecryptionRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: (Updatable) An array of address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] source_addresses: (Updatable) An array of address list names to be evaluated against the traffic source address.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class NetworkFirewallPolicyDecryptionRulePosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterRule":
            suggest = "after_rule"
        elif key == "beforeRule":
            suggest = "before_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyDecryptionRulePosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyDecryptionRulePosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyDecryptionRulePosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_rule: Optional[_builtins.str] = None,
                 before_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str after_rule: (Updatable) Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: (Updatable) Identifier for rule before which this rule lies.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if after_rule is not None:
            pulumi.set(__self__, "after_rule", after_rule)
        if before_rule is not None:
            pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule before which this rule lies.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class NetworkFirewallPolicyNatRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyNatRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyNatRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyNatRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 service: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: (Updatable) An array of IP address list names to be evaluated against the traffic destination address.
        :param _builtins.str service: (Updatable) A Service name to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] source_addresses: (Updatable) An array of IP address list names to be evaluated against the traffic source address.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        (Updatable) A Service name to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class NetworkFirewallPolicyNatRulePosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterRule":
            suggest = "after_rule"
        elif key == "beforeRule":
            suggest = "before_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyNatRulePosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyNatRulePosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyNatRulePosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_rule: Optional[_builtins.str] = None,
                 before_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str after_rule: (Updatable) Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: (Updatable) Identifier for rule before which this rule lies.
        """
        if after_rule is not None:
            pulumi.set(__self__, "after_rule", after_rule)
        if before_rule is not None:
            pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class NetworkFirewallPolicySecurityRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicySecurityRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicySecurityRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicySecurityRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence[_builtins.str]] = None,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 urls: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] applications: (Updatable) An array of application group names to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] destination_addresses: (Updatable) An array of address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] services: (Updatable) An array of service list names to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] source_addresses: (Updatable) An array of address list names to be evaluated against the traffic source address.
        :param Sequence[_builtins.str] urls: (Updatable) An array of URL list names to be evaluated against the HTTP(S) request target.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of application group names to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of service list names to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of URL list names to be evaluated against the HTTP(S) request target.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class NetworkFirewallPolicySecurityRulePosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterRule":
            suggest = "after_rule"
        elif key == "beforeRule":
            suggest = "before_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicySecurityRulePosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicySecurityRulePosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicySecurityRulePosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_rule: Optional[_builtins.str] = None,
                 before_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str after_rule: (Updatable) Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: (Updatable) Identifier for rule before which this rule lies.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if after_rule is not None:
            pulumi.set(__self__, "after_rule", after_rule)
        if before_rule is not None:
            pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule before which this rule lies.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class NetworkFirewallPolicyServicePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumPort":
            suggest = "minimum_port"
        elif key == "maximumPort":
            suggest = "maximum_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyServicePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyServicePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyServicePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_port: _builtins.int,
                 maximum_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int minimum_port: (Updatable) The minimum port in the range (inclusive), or the sole port of a single-port range.
        :param _builtins.int maximum_port: (Updatable) The maximum port in the range (inclusive), which may be absent for a single-port range.
        """
        pulumi.set(__self__, "minimum_port", minimum_port)
        if maximum_port is not None:
            pulumi.set(__self__, "maximum_port", maximum_port)

    @_builtins.property
    @pulumi.getter(name="minimumPort")
    def minimum_port(self) -> _builtins.int:
        """
        (Updatable) The minimum port in the range (inclusive), or the sole port of a single-port range.
        """
        return pulumi.get(self, "minimum_port")

    @_builtins.property
    @pulumi.getter(name="maximumPort")
    def maximum_port(self) -> Optional[_builtins.int]:
        """
        (Updatable) The maximum port in the range (inclusive), which may be absent for a single-port range.
        """
        return pulumi.get(self, "maximum_port")


@pulumi.output_type
class NetworkFirewallPolicyTunnelInspectionRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyTunnelInspectionRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyTunnelInspectionRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyTunnelInspectionRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: (Updatable) An array of address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] source_addresses: (Updatable) An array of address list names to be evaluated against the traffic source address.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Updatable) An array of address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class NetworkFirewallPolicyTunnelInspectionRulePosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterRule":
            suggest = "after_rule"
        elif key == "beforeRule":
            suggest = "before_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyTunnelInspectionRulePosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyTunnelInspectionRulePosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyTunnelInspectionRulePosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_rule: Optional[_builtins.str] = None,
                 before_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str after_rule: (Updatable) Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: (Updatable) Identifier for rule before which this rule lies.
        """
        if after_rule is not None:
            pulumi.set(__self__, "after_rule", after_rule)
        if before_rule is not None:
            pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> Optional[_builtins.str]:
        """
        (Updatable) Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class NetworkFirewallPolicyTunnelInspectionRuleProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mustReturnTrafficToSource":
            suggest = "must_return_traffic_to_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyTunnelInspectionRuleProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyTunnelInspectionRuleProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyTunnelInspectionRuleProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 must_return_traffic_to_source: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool must_return_traffic_to_source: (Updatable) Return scanned VXLAN tunnel traffic to source.
        """
        if must_return_traffic_to_source is not None:
            pulumi.set(__self__, "must_return_traffic_to_source", must_return_traffic_to_source)

    @_builtins.property
    @pulumi.getter(name="mustReturnTrafficToSource")
    def must_return_traffic_to_source(self) -> Optional[_builtins.bool]:
        """
        (Updatable) Return scanned VXLAN tunnel traffic to source.
        """
        return pulumi.get(self, "must_return_traffic_to_source")


@pulumi.output_type
class NetworkFirewallPolicyUrlListUrl(dict):
    def __init__(__self__, *,
                 pattern: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str pattern: (Updatable) A string consisting of a concatenation of optional host component and optional path component. The host component may start with `*.` to match the case-insensitive domain and all its subdomains. The path component must start with a `/`, and may end with `*` to match all paths of which it is a case-sensitive prefix. A missing host component matches all request domains, and a missing path component matches all request paths. An empty value matches all requests.
        :param _builtins.str type: (Updatable) The type of pattern.
               * SIMPLE - The only accepted value is `SIMPLE`. A simple pattern with optional subdomain and/or path suffix wildcards.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> _builtins.str:
        """
        (Updatable) A string consisting of a concatenation of optional host component and optional path component. The host component may start with `*.` to match the case-insensitive domain and all its subdomains. The path component must start with a `/`, and may end with `*` to match all paths of which it is a case-sensitive prefix. A missing host component matches all request domains, and a missing path component matches all request paths. An empty value matches all requests.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (Updatable) The type of pattern.
        * SIMPLE - The only accepted value is `SIMPLE`. A simple pattern with optional subdomain and/or path suffix wildcards.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallNatConfigurationResult(dict):
    def __init__(__self__, *,
                 must_enable_private_nat: _builtins.bool,
                 nat_ip_address_lists: Sequence[_builtins.str]):
        """
        :param _builtins.bool must_enable_private_nat: To allocate private NAT IPs to the firewall. The attached network firewall policy must also have NAT rules to enable NAT on any traffic passing through the firewall.
        :param Sequence[_builtins.str] nat_ip_address_lists: An array of NAT IP addresses that are associated with the Network Firewall. These IPs are reserved for NAT and shouldn't be used for any other purpose in the subnet.
        """
        pulumi.set(__self__, "must_enable_private_nat", must_enable_private_nat)
        pulumi.set(__self__, "nat_ip_address_lists", nat_ip_address_lists)

    @_builtins.property
    @pulumi.getter(name="mustEnablePrivateNat")
    def must_enable_private_nat(self) -> _builtins.bool:
        """
        To allocate private NAT IPs to the firewall. The attached network firewall policy must also have NAT rules to enable NAT on any traffic passing through the firewall.
        """
        return pulumi.get(self, "must_enable_private_nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddressLists")
    def nat_ip_address_lists(self) -> Sequence[_builtins.str]:
        """
        An array of NAT IP addresses that are associated with the Network Firewall. These IPs are reserved for NAT and shouldn't be used for any other purpose in the subnet.
        """
        return pulumi.get(self, "nat_ip_address_lists")


@pulumi.output_type
class GetNetworkFirewallPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPoliciesNetworkFirewallPolicySummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPoliciesNetworkFirewallPolicySummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPoliciesNetworkFirewallPolicySummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPoliciesNetworkFirewallPolicySummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 attached_network_firewall_count: _builtins.int,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.int attached_network_firewall_count: Count of number of Network Firewall attached to the Policy.
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        :param _builtins.str id: Unique Network Firewall Policy identifier
        :param _builtins.str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param _builtins.str state: A filter to return only resources with a lifecycleState matching the given value.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param _builtins.str time_created: The time instant at which the Network Firewall Policy was created in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        :param _builtins.str time_updated: The time instant at which the Network Firewall Policy was updated in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        pulumi.set(__self__, "attached_network_firewall_count", attached_network_firewall_count)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="attachedNetworkFirewallCount")
    def attached_network_firewall_count(self) -> _builtins.int:
        """
        Count of number of Network Firewall attached to the Policy.
        """
        return pulumi.get(self, "attached_network_firewall_count")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources with a lifecycleState matching the given value.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time instant at which the Network Firewall Policy was created in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time instant at which the Network Firewall Policy was updated in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetNetworkFirewallPolicyAddressListsAddressListSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyAddressListsAddressListSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyAddressListsAddressListSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyAddressListsAddressListSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 total_addresses: _builtins.int,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] addresses: List of addresses.
        :param _builtins.str name: Unique name to identify the group of addresses to be used in the policy rules.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this Address List belongs to.
        :param _builtins.int total_addresses: Count of total Addresses in the AddressList
        :param _builtins.str type: Type of address list.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "total_addresses", total_addresses)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        List of addresses.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name to identify the group of addresses to be used in the policy rules.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this Address List belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter(name="totalAddresses")
    def total_addresses(self) -> _builtins.int:
        """
        Count of total Addresses in the AddressList
        """
        return pulumi.get(self, "total_addresses")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of address list.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallPolicyAddressListsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name to identify the group of addresses to be used in the policy rules.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name to identify the group of addresses to be used in the policy rules.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyApplicationGroupsApplicationGroupSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyApplicationGroupsApplicationGroupSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyApplicationGroupsApplicationGroupSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyApplicationGroupsApplicationGroupSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 apps: Sequence[_builtins.str],
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 total_apps: _builtins.int):
        """
        :param Sequence[_builtins.str] apps: List of apps in the group.
        :param _builtins.str name: Name of the application Group.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this application group belongs to.
        :param _builtins.int total_apps: Count of total applications in the given application group.
        """
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "total_apps", total_apps)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Sequence[_builtins.str]:
        """
        List of apps in the group.
        """
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the application Group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this application group belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter(name="totalApps")
    def total_apps(self) -> _builtins.int:
        """
        Count of total applications in the given application group.
        """
        return pulumi.get(self, "total_apps")


@pulumi.output_type
class GetNetworkFirewallPolicyApplicationGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the application Group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the application Group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyApplicationsApplicationSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyApplicationsApplicationSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyApplicationsApplicationSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyApplicationsApplicationSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 icmp_code: _builtins.int,
                 icmp_type: _builtins.int,
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int icmp_code: The value of the ICMP6 message Code (subtype) field as defined by [RFC 4443](https://www.rfc-editor.org/rfc/rfc4443.html#section-2.1).
        :param _builtins.int icmp_type: The value of the ICMP6 message Type field as defined by [RFC 4443](https://www.rfc-editor.org/rfc/rfc4443.html#section-2.1).
        :param _builtins.str name: Name of the application.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this application belongs to.
        :param _builtins.str type: Describes the type of Application.
        """
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> _builtins.int:
        """
        The value of the ICMP6 message Code (subtype) field as defined by [RFC 4443](https://www.rfc-editor.org/rfc/rfc4443.html#section-2.1).
        """
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> _builtins.int:
        """
        The value of the ICMP6 message Type field as defined by [RFC 4443](https://www.rfc-editor.org/rfc/rfc4443.html#section-2.1).
        """
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the application.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this application belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Describes the type of Application.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallPolicyApplicationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the application.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionProfilesDecryptionProfileSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyDecryptionProfilesDecryptionProfileSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyDecryptionProfilesDecryptionProfileSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionProfilesDecryptionProfileSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 are_certificate_extensions_restricted: _builtins.bool,
                 is_auto_include_alt_name: _builtins.bool,
                 is_expired_certificate_blocked: _builtins.bool,
                 is_out_of_capacity_blocked: _builtins.bool,
                 is_revocation_status_timeout_blocked: _builtins.bool,
                 is_unknown_revocation_status_blocked: _builtins.bool,
                 is_unsupported_cipher_blocked: _builtins.bool,
                 is_unsupported_version_blocked: _builtins.bool,
                 is_untrusted_issuer_blocked: _builtins.bool,
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.bool are_certificate_extensions_restricted: Whether to block sessions if the server's certificate uses extensions other than key usage and/or extended key usage.
        :param _builtins.bool is_auto_include_alt_name: Whether to automatically append SAN to impersonating certificate if server certificate is missing SAN.
        :param _builtins.bool is_expired_certificate_blocked: Whether to block sessions if server's certificate is expired.
        :param _builtins.bool is_out_of_capacity_blocked: Whether to block sessions if the firewall is temporarily unable to decrypt their traffic.
        :param _builtins.bool is_revocation_status_timeout_blocked: Whether to block sessions if the revocation status check for server's certificate does not succeed within the maximum allowed time (defaulting to 5 seconds).
        :param _builtins.bool is_unknown_revocation_status_blocked: Whether to block sessions if the revocation status check for server's certificate results in "unknown".
        :param _builtins.bool is_unsupported_cipher_blocked: Whether to block sessions if SSL cipher suite is not supported.
        :param _builtins.bool is_unsupported_version_blocked: Whether to block sessions if SSL version is not supported.
        :param _builtins.bool is_untrusted_issuer_blocked: Whether to block sessions if server's certificate is issued by an untrusted certificate authority (CA).
        :param _builtins.str name: Unique Name of the decryption profile.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this decryption profile belongs to.
        :param _builtins.str type: Describes the type of Decryption Profile SslForwardProxy or SslInboundInspection.
        """
        pulumi.set(__self__, "are_certificate_extensions_restricted", are_certificate_extensions_restricted)
        pulumi.set(__self__, "is_auto_include_alt_name", is_auto_include_alt_name)
        pulumi.set(__self__, "is_expired_certificate_blocked", is_expired_certificate_blocked)
        pulumi.set(__self__, "is_out_of_capacity_blocked", is_out_of_capacity_blocked)
        pulumi.set(__self__, "is_revocation_status_timeout_blocked", is_revocation_status_timeout_blocked)
        pulumi.set(__self__, "is_unknown_revocation_status_blocked", is_unknown_revocation_status_blocked)
        pulumi.set(__self__, "is_unsupported_cipher_blocked", is_unsupported_cipher_blocked)
        pulumi.set(__self__, "is_unsupported_version_blocked", is_unsupported_version_blocked)
        pulumi.set(__self__, "is_untrusted_issuer_blocked", is_untrusted_issuer_blocked)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="areCertificateExtensionsRestricted")
    def are_certificate_extensions_restricted(self) -> _builtins.bool:
        """
        Whether to block sessions if the server's certificate uses extensions other than key usage and/or extended key usage.
        """
        return pulumi.get(self, "are_certificate_extensions_restricted")

    @_builtins.property
    @pulumi.getter(name="isAutoIncludeAltName")
    def is_auto_include_alt_name(self) -> _builtins.bool:
        """
        Whether to automatically append SAN to impersonating certificate if server certificate is missing SAN.
        """
        return pulumi.get(self, "is_auto_include_alt_name")

    @_builtins.property
    @pulumi.getter(name="isExpiredCertificateBlocked")
    def is_expired_certificate_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if server's certificate is expired.
        """
        return pulumi.get(self, "is_expired_certificate_blocked")

    @_builtins.property
    @pulumi.getter(name="isOutOfCapacityBlocked")
    def is_out_of_capacity_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if the firewall is temporarily unable to decrypt their traffic.
        """
        return pulumi.get(self, "is_out_of_capacity_blocked")

    @_builtins.property
    @pulumi.getter(name="isRevocationStatusTimeoutBlocked")
    def is_revocation_status_timeout_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if the revocation status check for server's certificate does not succeed within the maximum allowed time (defaulting to 5 seconds).
        """
        return pulumi.get(self, "is_revocation_status_timeout_blocked")

    @_builtins.property
    @pulumi.getter(name="isUnknownRevocationStatusBlocked")
    def is_unknown_revocation_status_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if the revocation status check for server's certificate results in "unknown".
        """
        return pulumi.get(self, "is_unknown_revocation_status_blocked")

    @_builtins.property
    @pulumi.getter(name="isUnsupportedCipherBlocked")
    def is_unsupported_cipher_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if SSL cipher suite is not supported.
        """
        return pulumi.get(self, "is_unsupported_cipher_blocked")

    @_builtins.property
    @pulumi.getter(name="isUnsupportedVersionBlocked")
    def is_unsupported_version_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if SSL version is not supported.
        """
        return pulumi.get(self, "is_unsupported_version_blocked")

    @_builtins.property
    @pulumi.getter(name="isUntrustedIssuerBlocked")
    def is_untrusted_issuer_blocked(self) -> _builtins.bool:
        """
        Whether to block sessions if server's certificate is issued by an untrusted certificate authority (CA).
        """
        return pulumi.get(self, "is_untrusted_issuer_blocked")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique Name of the decryption profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this decryption profile belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Describes the type of Decryption Profile SslForwardProxy or SslInboundInspection.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionProfilesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique Name of the decryption profile.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique Name of the decryption profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRuleConditionResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 source_addresses: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] destination_addresses: An array of IP address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] source_addresses: An array of IP address list names to be evaluated against the traffic source address.
        """
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRulePositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 condition: 'outputs.GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemConditionResult',
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 position: 'outputs.GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemPositionResult',
                 decryption_profile: Optional[_builtins.str] = None,
                 priority_order: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Action:
               * NO_DECRYPT - Matching traffic is not decrypted.
               * DECRYPT - Matching traffic is decrypted with the specified `secret` according to the specified `decryptionProfile`.
        :param 'GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemConditionArgs' condition: Match criteria used in Decryption Rule used on the firewall policy rules.
        :param _builtins.str name: Name for the decryption rule, must be unique within the policy.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this decryption rule belongs to.
        :param 'GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemPositionArgs' position: An object which defines the position of the rule.
        :param _builtins.str decryption_profile: The name of the decryption profile to use.
        :param _builtins.str secret: The name of a mapped secret. Its `type` must match that of the specified decryption profile.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "position", position)
        if decryption_profile is not None:
            pulumi.set(__self__, "decryption_profile", decryption_profile)
        if priority_order is not None:
            pulumi.set(__self__, "priority_order", priority_order)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action:
        * NO_DECRYPT - Matching traffic is not decrypted.
        * DECRYPT - Matching traffic is decrypted with the specified `secret` according to the specified `decryptionProfile`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemConditionResult':
        """
        Match criteria used in Decryption Rule used on the firewall policy rules.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the decryption rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this decryption rule belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> 'outputs.GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemPositionResult':
        """
        An object which defines the position of the rule.
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="decryptionProfile")
    def decryption_profile(self) -> Optional[_builtins.str]:
        """
        The name of the decryption profile to use.
        """
        return pulumi.get(self, "decryption_profile")

    @_builtins.property
    @pulumi.getter(name="priorityOrder")
    def priority_order(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "priority_order")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The name of a mapped secret. Its `type` must match that of the specified decryption profile.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemConditionResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: An array of IP address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] source_addresses: An array of IP address list names to be evaluated against the traffic source address.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRulesDecryptionRuleSummaryCollectionItemPositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicyDecryptionRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name for the decryption rule, must be unique within the policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the decryption rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyMappedSecretsMappedSecretSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyMappedSecretsMappedSecretSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyMappedSecretsMappedSecretSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyMappedSecretsMappedSecretSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 source: _builtins.str,
                 type: _builtins.str,
                 vault_secret_id: _builtins.str,
                 version_number: _builtins.int):
        """
        :param _builtins.str name: Name of the secret.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this Mapped Secret belongs to.
        :param _builtins.str source: Source of the secrets, where the secrets are stored.
        :param _builtins.str type: Type of the secrets mapped based on the policy.
               * `SSL_INBOUND_INSPECTION`: For Inbound inspection of SSL traffic.
               * `SSL_FORWARD_PROXY`: For forward proxy certificates for SSL inspection.
        :param _builtins.str vault_secret_id: OCID for the Vault Secret to be used.
        :param _builtins.int version_number: Version number of the secret to be used.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_secret_id", vault_secret_id)
        pulumi.set(__self__, "version_number", version_number)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the secret.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this Mapped Secret belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Source of the secrets, where the secrets are stored.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the secrets mapped based on the policy.
        * `SSL_INBOUND_INSPECTION`: For Inbound inspection of SSL traffic.
        * `SSL_FORWARD_PROXY`: For forward proxy certificates for SSL inspection.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultSecretId")
    def vault_secret_id(self) -> _builtins.str:
        """
        OCID for the Vault Secret to be used.
        """
        return pulumi.get(self, "vault_secret_id")

    @_builtins.property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> _builtins.int:
        """
        Version number of the secret to be used.
        """
        return pulumi.get(self, "version_number")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRuleConditionResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 service: _builtins.str,
                 source_addresses: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] destination_addresses: An array of IP address list names to be evaluated against the traffic destination address.
        :param _builtins.str service: A Service name to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] source_addresses: An array of IP address list names to be evaluated against the traffic source address.
        """
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        A Service name to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRulePositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name for the NAT rule, must be unique within the policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the NAT rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRulesNatRuleCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 condition: 'outputs.GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemConditionResult',
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 position: 'outputs.GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemPositionResult',
                 priority_order: _builtins.str,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: action:
               * DIPP_SRC_NAT - Dynamic-ip-port source NAT.
        :param 'GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemConditionArgs' condition: Match criteria used in NAT Rule used on the firewall policy.
        :param _builtins.str name: Name for the NAT rule, must be unique within the policy.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this decryption profile belongs to.
        :param 'GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemPositionArgs' position: An object which defines the position of the rule.
        :param _builtins.str priority_order: The priority order in which this rule should be evaluated
        :param _builtins.str type: NAT type:
               * NATV4 - NATV4 type NAT.
        :param _builtins.str description: Description of a NAT rule. This field can be used to add additional info.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "priority_order", priority_order)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        action:
        * DIPP_SRC_NAT - Dynamic-ip-port source NAT.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemConditionResult':
        """
        Match criteria used in NAT Rule used on the firewall policy.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the NAT rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this decryption profile belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> 'outputs.GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemPositionResult':
        """
        An object which defines the position of the rule.
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="priorityOrder")
    def priority_order(self) -> _builtins.str:
        """
        The priority order in which this rule should be evaluated
        """
        return pulumi.get(self, "priority_order")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        NAT type:
        * NATV4 - NATV4 type NAT.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of a NAT rule. This field can be used to add additional info.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemConditionResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 service: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: An array of IP address list names to be evaluated against the traffic destination address.
        :param _builtins.str service: A Service name to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] source_addresses: An array of IP address list names to be evaluated against the traffic source address.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        A Service name to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class GetNetworkFirewallPolicyNatRulesNatRuleCollectionItemPositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRuleConditionResult(dict):
    def __init__(__self__, *,
                 applications: Sequence[_builtins.str],
                 destination_addresses: Sequence[_builtins.str],
                 services: Sequence[_builtins.str],
                 source_addresses: Sequence[_builtins.str],
                 urls: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] applications: An array of application list names to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] destination_addresses: An array of IP address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] services: An array of service list names to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] source_addresses: An array of IP address list names to be evaluated against the traffic source address.
        :param Sequence[_builtins.str] urls: An array of URL pattern list names to be evaluated against the HTTP(S) request target.
        """
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Sequence[_builtins.str]:
        """
        An array of application list names to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        """
        An array of service list names to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence[_builtins.str]:
        """
        An array of URL pattern list names to be evaluated against the HTTP(S) request target.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRulePositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name for the Security rule, must be unique within the policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the Security rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 condition: 'outputs.GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemConditionResult',
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 positions: Sequence['outputs.GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemPositionResult'],
                 inspection: Optional[_builtins.str] = None,
                 priority_order: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Types of Action on the Traffic flow.
               * ALLOW - Allows the traffic.
               * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
               * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
               * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
        :param 'GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemConditionArgs' condition: Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic.
        :param _builtins.str name: Name for the Security rule, must be unique within the policy.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this security rule belongs to.
        :param Sequence['GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemPositionArgs'] positions: An object which defines the position of the rule.
        :param _builtins.str inspection: Type of inspection to affect the Traffic flow. This is only applicable if action is INSPECT.
               * INTRUSION_DETECTION - Intrusion Detection.
               * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "positions", positions)
        if inspection is not None:
            pulumi.set(__self__, "inspection", inspection)
        if priority_order is not None:
            pulumi.set(__self__, "priority_order", priority_order)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Types of Action on the Traffic flow.
        * ALLOW - Allows the traffic.
        * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
        * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
        * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemConditionResult':
        """
        Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the Security rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this security rule belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def positions(self) -> Sequence['outputs.GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemPositionResult']:
        """
        An object which defines the position of the rule.
        """
        return pulumi.get(self, "positions")

    @_builtins.property
    @pulumi.getter
    def inspection(self) -> Optional[_builtins.str]:
        """
        Type of inspection to affect the Traffic flow. This is only applicable if action is INSPECT.
        * INTRUSION_DETECTION - Intrusion Detection.
        * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
        """
        return pulumi.get(self, "inspection")

    @_builtins.property
    @pulumi.getter(name="priorityOrder")
    def priority_order(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "priority_order")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemConditionResult(dict):
    def __init__(__self__, *,
                 applications: Optional[Sequence[_builtins.str]] = None,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 urls: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] applications: An array of application list names to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] destination_addresses: An array of IP address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] services: An array of service list names to be evaluated against the traffic protocol and protocol-specific parameters.
        :param Sequence[_builtins.str] source_addresses: An array of IP address list names to be evaluated against the traffic source address.
        :param Sequence[_builtins.str] urls: An array of URL pattern list names to be evaluated against the HTTP(S) request target.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of application list names to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of IP address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of service list names to be evaluated against the traffic protocol and protocol-specific parameters.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of IP address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of URL pattern list names to be evaluated against the HTTP(S) request target.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetNetworkFirewallPolicySecurityRulesSecurityRuleSummaryCollectionItemPositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicyServiceListsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the service Group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the service Group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyServiceListsServiceListSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyServiceListsServiceListSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyServiceListsServiceListSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyServiceListsServiceListSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 services: Sequence[_builtins.str],
                 total_services: _builtins.int):
        """
        :param _builtins.str name: Name of the service Group.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this serviceList belongs to.
        :param Sequence[_builtins.str] services: List of services in the group.
        :param _builtins.int total_services: Count of total services in the given service List.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "total_services", total_services)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the service Group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this serviceList belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        """
        List of services in the group.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="totalServices")
    def total_services(self) -> _builtins.int:
        """
        Count of total services in the given service List.
        """
        return pulumi.get(self, "total_services")


@pulumi.output_type
class GetNetworkFirewallPolicyServicePortRangeResult(dict):
    def __init__(__self__, *,
                 maximum_port: _builtins.int,
                 minimum_port: _builtins.int):
        """
        :param _builtins.int maximum_port: The maximum port in the range (inclusive), which may be absent for a single-port range.
        :param _builtins.int minimum_port: The minimum port in the range (inclusive), or the sole port of a single-port range.
        """
        pulumi.set(__self__, "maximum_port", maximum_port)
        pulumi.set(__self__, "minimum_port", minimum_port)

    @_builtins.property
    @pulumi.getter(name="maximumPort")
    def maximum_port(self) -> _builtins.int:
        """
        The maximum port in the range (inclusive), which may be absent for a single-port range.
        """
        return pulumi.get(self, "maximum_port")

    @_builtins.property
    @pulumi.getter(name="minimumPort")
    def minimum_port(self) -> _builtins.int:
        """
        The minimum port in the range (inclusive), or the sole port of a single-port range.
        """
        return pulumi.get(self, "minimum_port")


@pulumi.output_type
class GetNetworkFirewallPolicyServicesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the service.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the service.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyServicesServiceSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemPortRangeResult'],
                 type: _builtins.str):
        """
        :param _builtins.str name: Name of the service.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this service belongs to.
        :param Sequence['GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemPortRangeArgs'] port_ranges: List of port-ranges used.
        :param _builtins.str type: Describes the type of Service.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the service.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this service belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemPortRangeResult']:
        """
        List of port-ranges used.
        """
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Describes the type of Service.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallPolicyServicesServiceSummaryCollectionItemPortRangeResult(dict):
    def __init__(__self__, *,
                 maximum_port: _builtins.int,
                 minimum_port: _builtins.int):
        """
        :param _builtins.int maximum_port: The maximum port in the range (inclusive), which may be absent for a single-port range.
        :param _builtins.int minimum_port: The minimum port in the range (inclusive), or the sole port of a single-port range.
        """
        pulumi.set(__self__, "maximum_port", maximum_port)
        pulumi.set(__self__, "minimum_port", minimum_port)

    @_builtins.property
    @pulumi.getter(name="maximumPort")
    def maximum_port(self) -> _builtins.int:
        """
        The maximum port in the range (inclusive), which may be absent for a single-port range.
        """
        return pulumi.get(self, "maximum_port")

    @_builtins.property
    @pulumi.getter(name="minimumPort")
    def minimum_port(self) -> _builtins.int:
        """
        The minimum port in the range (inclusive), or the sole port of a single-port range.
        """
        return pulumi.get(self, "minimum_port")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRuleConditionResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 source_addresses: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] destination_addresses: An array of address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] source_addresses: An array of address list names to be evaluated against the traffic source address.
        """
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulePositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRuleProfileResult(dict):
    def __init__(__self__, *,
                 must_return_traffic_to_source: _builtins.bool):
        """
        :param _builtins.bool must_return_traffic_to_source: Return scanned VXLAN tunnel traffic to source.
        """
        pulumi.set(__self__, "must_return_traffic_to_source", must_return_traffic_to_source)

    @_builtins.property
    @pulumi.getter(name="mustReturnTrafficToSource")
    def must_return_traffic_to_source(self) -> _builtins.bool:
        """
        Return scanned VXLAN tunnel traffic to source.
        """
        return pulumi.get(self, "must_return_traffic_to_source")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name for the Tunnel Inspection Rule, must be unique within the policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the Tunnel Inspection Rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 condition: 'outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemConditionResult',
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 position: 'outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemPositionResult',
                 priority_order: _builtins.str,
                 profile: 'outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemProfileResult',
                 protocol: _builtins.str):
        """
        :param _builtins.str action: Types of Inspect Action on the Traffic flow.
               * INSPECT - Inspect the traffic.
               * INSPECT_AND_CAPTURE_LOG - Inspect and capture logs for the traffic.
        :param 'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemConditionArgs' condition: Criteria to evaluate against incoming network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic.
        :param _builtins.str name: Name for the Tunnel Inspection Rule, must be unique within the policy.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this Tunnel Inspection Rule belongs to.
        :param 'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemPositionArgs' position: An object which defines the position of the rule.
        :param _builtins.str priority_order: The priority order in which this rule should be evaluated
        :param 'GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemProfileArgs' profile: Vxlan Inspect profile used in Vxlan Tunnel Inspection Rules.
        :param _builtins.str protocol: Types of Tunnel Inspection Protocol to be applied on the traffic.
               * VXLAN - VXLAN Tunnel Inspection Protocol will be applied on the traffic.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "priority_order", priority_order)
        pulumi.set(__self__, "profile", profile)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Types of Inspect Action on the Traffic flow.
        * INSPECT - Inspect the traffic.
        * INSPECT_AND_CAPTURE_LOG - Inspect and capture logs for the traffic.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemConditionResult':
        """
        Criteria to evaluate against incoming network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the Tunnel Inspection Rule, must be unique within the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this Tunnel Inspection Rule belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> 'outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemPositionResult':
        """
        An object which defines the position of the rule.
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="priorityOrder")
    def priority_order(self) -> _builtins.str:
        """
        The priority order in which this rule should be evaluated
        """
        return pulumi.get(self, "priority_order")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> 'outputs.GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemProfileResult':
        """
        Vxlan Inspect profile used in Vxlan Tunnel Inspection Rules.
        """
        return pulumi.get(self, "profile")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Types of Tunnel Inspection Protocol to be applied on the traffic.
        * VXLAN - VXLAN Tunnel Inspection Protocol will be applied on the traffic.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemConditionResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 source_addresses: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] destination_addresses: An array of address list names to be evaluated against the traffic destination address.
        :param Sequence[_builtins.str] source_addresses: An array of address list names to be evaluated against the traffic source address.
        """
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of address list names to be evaluated against the traffic destination address.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        """
        An array of address list names to be evaluated against the traffic source address.
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemPositionResult(dict):
    def __init__(__self__, *,
                 after_rule: _builtins.str,
                 before_rule: _builtins.str):
        """
        :param _builtins.str after_rule: Identifier for rule after which this rule lies.
        :param _builtins.str before_rule: Identifier for rule before which this rule lies.
        """
        pulumi.set(__self__, "after_rule", after_rule)
        pulumi.set(__self__, "before_rule", before_rule)

    @_builtins.property
    @pulumi.getter(name="afterRule")
    def after_rule(self) -> _builtins.str:
        """
        Identifier for rule after which this rule lies.
        """
        return pulumi.get(self, "after_rule")

    @_builtins.property
    @pulumi.getter(name="beforeRule")
    def before_rule(self) -> _builtins.str:
        """
        Identifier for rule before which this rule lies.
        """
        return pulumi.get(self, "before_rule")


@pulumi.output_type
class GetNetworkFirewallPolicyTunnelInspectionRulesTunnelInspectionRuleSummaryCollectionItemProfileResult(dict):
    def __init__(__self__, *,
                 must_return_traffic_to_source: _builtins.bool):
        """
        :param _builtins.bool must_return_traffic_to_source: Return scanned VXLAN tunnel traffic to source.
        """
        pulumi.set(__self__, "must_return_traffic_to_source", must_return_traffic_to_source)

    @_builtins.property
    @pulumi.getter(name="mustReturnTrafficToSource")
    def must_return_traffic_to_source(self) -> _builtins.bool:
        """
        Return scanned VXLAN tunnel traffic to source.
        """
        return pulumi.get(self, "must_return_traffic_to_source")


@pulumi.output_type
class GetNetworkFirewallPolicyUrlListUrlResult(dict):
    def __init__(__self__, *,
                 pattern: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str pattern: A string consisting of a concatenation of optional host component and optional path component. The host component may start with `*.` to match the case-insensitive domain and all its subdomains. The path component must start with a `/`, and may end with `*` to match all paths of which it is a case-sensitive prefix. A missing host component matches all request domains, and a missing path component matches all request paths. An empty value matches all requests.
        :param _builtins.str type: The type of pattern.
               * SIMPLE - A simple pattern with optional subdomain and/or path suffix wildcards.
        """
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> _builtins.str:
        """
        A string consisting of a concatenation of optional host component and optional path component. The host component may start with `*.` to match the case-insensitive domain and all its subdomains. The path component must start with a `/`, and may end with `*` to match all paths of which it is a case-sensitive prefix. A missing host component matches all request domains, and a missing path component matches all request paths. An empty value matches all requests.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of pattern.
        * SIMPLE - A simple pattern with optional subdomain and/or path suffix wildcards.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallPolicyUrlListsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name identifier for the URL list.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name identifier for the URL list.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 network_firewall_policy_id: _builtins.str,
                 parent_resource_id: _builtins.str,
                 total_urls: _builtins.int,
                 urls: Sequence['outputs.GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemUrlResult']):
        """
        :param _builtins.str name: Unique name identifier for the URL list.
        :param _builtins.str network_firewall_policy_id: Unique Network Firewall Policy identifier
        :param _builtins.str parent_resource_id: OCID of the Network Firewall Policy this URL List belongs to.
        :param _builtins.int total_urls: Total count of URLs in the URL List
        :param Sequence['GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemUrlArgs'] urls: List of urls.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "parent_resource_id", parent_resource_id)
        pulumi.set(__self__, "total_urls", total_urls)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name identifier for the URL list.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        Unique Network Firewall Policy identifier
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="parentResourceId")
    def parent_resource_id(self) -> _builtins.str:
        """
        OCID of the Network Firewall Policy this URL List belongs to.
        """
        return pulumi.get(self, "parent_resource_id")

    @_builtins.property
    @pulumi.getter(name="totalUrls")
    def total_urls(self) -> _builtins.int:
        """
        Total count of URLs in the URL List
        """
        return pulumi.get(self, "total_urls")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence['outputs.GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemUrlResult']:
        """
        List of urls.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetNetworkFirewallPolicyUrlListsUrlListSummaryCollectionItemUrlResult(dict):
    def __init__(__self__, *,
                 pattern: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str pattern: A string consisting of a concatenation of optional host component and optional path component. The host component may start with `*.` to match the case-insensitive domain and all its subdomains. The path component must start with a `/`, and may end with `*` to match all paths of which it is a case-sensitive prefix. A missing host component matches all request domains, and a missing path component matches all request paths. An empty value matches all requests.
        :param _builtins.str type: The type of pattern.
               * SIMPLE - A simple pattern with optional subdomain and/or path suffix wildcards.
        """
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> _builtins.str:
        """
        A string consisting of a concatenation of optional host component and optional path component. The host component may start with `*.` to match the case-insensitive domain and all its subdomains. The path component must start with a `/`, and may end with `*` to match all paths of which it is a case-sensitive prefix. A missing host component matches all request domains, and a missing path component matches all request paths. An empty value matches all requests.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of pattern.
        * SIMPLE - A simple pattern with optional subdomain and/or path suffix wildcards.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkFirewallsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetNetworkFirewallsNetworkFirewallCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetNetworkFirewallsNetworkFirewallCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetNetworkFirewallsNetworkFirewallCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetNetworkFirewallsNetworkFirewallCollectionItemResult(dict):
    def __init__(__self__, *,
                 availability_domain: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 ipv4address: _builtins.str,
                 ipv6address: _builtins.str,
                 lifecycle_details: _builtins.str,
                 nat_configurations: Sequence['outputs.GetNetworkFirewallsNetworkFirewallCollectionItemNatConfigurationResult'],
                 network_firewall_policy_id: _builtins.str,
                 network_security_group_ids: Sequence[_builtins.str],
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str availability_domain: A filter to return only resources that are present within the specified availability domain. To get a list of availability domains for a tenancy, use [ListAvailabilityDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/AvailabilityDomain/ListAvailabilityDomains) operation. Example: `kIdk:PHX-AD-1`
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        :param _builtins.str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Network Firewall resource.
        :param _builtins.str ipv4address: IPv4 address for the Network Firewall.
        :param _builtins.str ipv6address: IPv6 address for the Network Firewall.
        :param _builtins.str lifecycle_details: A message describing the current state in more detail. For example, it can be used to provide actionable information for a resource in 'FAILED' state.
        :param Sequence['GetNetworkFirewallsNetworkFirewallCollectionItemNatConfigurationArgs'] nat_configurations: Nat Configuration response.
        :param _builtins.str network_firewall_policy_id: A filter to return only resources that match the entire networkFirewallPolicyId given.
        :param Sequence[_builtins.str] network_security_group_ids: An array of network security groups [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) associated with the Network Firewall.
        :param _builtins.str state: A filter to return only resources with a lifecycleState matching the given value.
        :param _builtins.str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the Network Firewall.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param _builtins.str time_created: The time at which the Network Firewall was created in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        :param _builtins.str time_updated: The time at which the Network Firewall was updated in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv4address", ipv4address)
        pulumi.set(__self__, "ipv6address", ipv6address)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "nat_configurations", nat_configurations)
        pulumi.set(__self__, "network_firewall_policy_id", network_firewall_policy_id)
        pulumi.set(__self__, "network_security_group_ids", network_security_group_ids)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        A filter to return only resources that are present within the specified availability domain. To get a list of availability domains for a tenancy, use [ListAvailabilityDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/AvailabilityDomain/ListAvailabilityDomains) operation. Example: `kIdk:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Network Firewall resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ipv4address(self) -> _builtins.str:
        """
        IPv4 address for the Network Firewall.
        """
        return pulumi.get(self, "ipv4address")

    @_builtins.property
    @pulumi.getter
    def ipv6address(self) -> _builtins.str:
        """
        IPv6 address for the Network Firewall.
        """
        return pulumi.get(self, "ipv6address")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A message describing the current state in more detail. For example, it can be used to provide actionable information for a resource in 'FAILED' state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="natConfigurations")
    def nat_configurations(self) -> Sequence['outputs.GetNetworkFirewallsNetworkFirewallCollectionItemNatConfigurationResult']:
        """
        Nat Configuration response.
        """
        return pulumi.get(self, "nat_configurations")

    @_builtins.property
    @pulumi.getter(name="networkFirewallPolicyId")
    def network_firewall_policy_id(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire networkFirewallPolicyId given.
        """
        return pulumi.get(self, "network_firewall_policy_id")

    @_builtins.property
    @pulumi.getter(name="networkSecurityGroupIds")
    def network_security_group_ids(self) -> Sequence[_builtins.str]:
        """
        An array of network security groups [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) associated with the Network Firewall.
        """
        return pulumi.get(self, "network_security_group_ids")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources with a lifecycleState matching the given value.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the Network Firewall.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time at which the Network Firewall was created in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time at which the Network Firewall was updated in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetNetworkFirewallsNetworkFirewallCollectionItemNatConfigurationResult(dict):
    def __init__(__self__, *,
                 must_enable_private_nat: _builtins.bool,
                 nat_ip_address_lists: Sequence[_builtins.str]):
        """
        :param _builtins.bool must_enable_private_nat: To allocate private NAT IPs to the firewall. The attached network firewall policy must also have NAT rules to enable NAT on any traffic passing through the firewall.
        :param Sequence[_builtins.str] nat_ip_address_lists: An array of NAT IP addresses that are associated with the Network Firewall. These IPs are reserved for NAT and shouldn't be used for any other purpose in the subnet.
        """
        pulumi.set(__self__, "must_enable_private_nat", must_enable_private_nat)
        pulumi.set(__self__, "nat_ip_address_lists", nat_ip_address_lists)

    @_builtins.property
    @pulumi.getter(name="mustEnablePrivateNat")
    def must_enable_private_nat(self) -> _builtins.bool:
        """
        To allocate private NAT IPs to the firewall. The attached network firewall policy must also have NAT rules to enable NAT on any traffic passing through the firewall.
        """
        return pulumi.get(self, "must_enable_private_nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddressLists")
    def nat_ip_address_lists(self) -> Sequence[_builtins.str]:
        """
        An array of NAT IP addresses that are associated with the Network Firewall. These IPs are reserved for NAT and shouldn't be used for any other purpose in the subnet.
        """
        return pulumi.get(self, "nat_ip_address_lists")


