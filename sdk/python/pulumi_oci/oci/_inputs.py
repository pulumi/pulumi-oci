# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiPlatformApiPlatformInstanceIdcsAppArgs',
    'ApiPlatformApiPlatformInstanceIdcsAppArgsDict',
    'ApiPlatformApiPlatformInstanceUriArgs',
    'ApiPlatformApiPlatformInstanceUriArgsDict',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgs',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict',
    'DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgs',
    'DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict',
    'ManagedKafkaKafkaClusterAccessSubnetArgs',
    'ManagedKafkaKafkaClusterAccessSubnetArgsDict',
    'ManagedKafkaKafkaClusterBrokerShapeArgs',
    'ManagedKafkaKafkaClusterBrokerShapeArgsDict',
    'ManagedKafkaKafkaClusterConfigLatestConfigArgs',
    'ManagedKafkaKafkaClusterConfigLatestConfigArgsDict',
    'ManagedKafkaKafkaClusterKafkaBootstrapUrlArgs',
    'ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict',
    'GetApiPlatformApiPlatformInstancesFilterArgs',
    'GetApiPlatformApiPlatformInstancesFilterArgsDict',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict',
    'GetApiaccesscontrolApiMetadatasFilterArgs',
    'GetApiaccesscontrolApiMetadatasFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgs',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureKeysFilterArgs',
    'GetDbmulticloudOracleDbAzureKeysFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgs',
    'GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpKeyRingsFilterArgs',
    'GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpKeysFilterArgs',
    'GetDbmulticloudOracleDbGcpKeysFilterArgsDict',
    'GetManagedKafkaKafkaClusterConfigVersionsFilterArgs',
    'GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict',
    'GetManagedKafkaKafkaClusterConfigsFilterArgs',
    'GetManagedKafkaKafkaClusterConfigsFilterArgsDict',
    'GetManagedKafkaKafkaClustersFilterArgs',
    'GetManagedKafkaKafkaClustersFilterArgsDict',
    'GetWlmsManagedInstanceScanResultsFilterArgs',
    'GetWlmsManagedInstanceScanResultsFilterArgsDict',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgs',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict',
    'GetWlmsManagedInstanceServersFilterArgs',
    'GetWlmsManagedInstanceServersFilterArgsDict',
    'GetWlmsManagedInstancesFilterArgs',
    'GetWlmsManagedInstancesFilterArgsDict',
    'GetWlmsWlsDomainAgreementRecordsFilterArgs',
    'GetWlmsWlsDomainAgreementRecordsFilterArgsDict',
    'GetWlmsWlsDomainApplicablePatchesFilterArgs',
    'GetWlmsWlsDomainApplicablePatchesFilterArgsDict',
    'GetWlmsWlsDomainScanResultsFilterArgs',
    'GetWlmsWlsDomainScanResultsFilterArgsDict',
    'GetWlmsWlsDomainServerBackupsFilterArgs',
    'GetWlmsWlsDomainServerBackupsFilterArgsDict',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgs',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict',
    'GetWlmsWlsDomainServersFilterArgs',
    'GetWlmsWlsDomainServersFilterArgsDict',
    'GetWlmsWlsDomainsFilterArgs',
    'GetWlmsWlsDomainsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApiPlatformApiPlatformInstanceIdcsAppArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        IDCS URL of the app
        """
elif False:
    ApiPlatformApiPlatformInstanceIdcsAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceIdcsAppArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: IDCS URL of the app
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IDCS URL of the app
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApiPlatformApiPlatformInstanceUriArgsDict(TypedDict):
        developers_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Developer's Portal URI of the instance (/developers)
        """
        management_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Portal URI of the instance (/apiplatform)
        """
elif False:
    ApiPlatformApiPlatformInstanceUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceUriArgs:
    def __init__(__self__, *,
                 developers_portal_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 management_portal_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] developers_portal_uri: Developer's Portal URI of the instance (/developers)
        :param pulumi.Input[_builtins.str] management_portal_uri: Management Portal URI of the instance (/apiplatform)
        """
        if developers_portal_uri is not None:
            pulumi.set(__self__, "developers_portal_uri", developers_portal_uri)
        if management_portal_uri is not None:
            pulumi.set(__self__, "management_portal_uri", management_portal_uri)

    @_builtins.property
    @pulumi.getter(name="developersPortalUri")
    def developers_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Developer's Portal URI of the instance (/developers)
        """
        return pulumi.get(self, "developers_portal_uri")

    @developers_portal_uri.setter
    def developers_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "developers_portal_uri", value)

    @_builtins.property
    @pulumi.getter(name="managementPortalUri")
    def management_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Portal URI of the instance (/apiplatform)
        """
        return pulumi.get(self, "management_portal_uri")

    @management_portal_uri.setter
    def management_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_portal_uri", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        (Updatable) name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) type of the entity which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: (Updatable) name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: (Updatable) list of attributes belonging to the above api which needs to be protected.
        :param pulumi.Input[_builtins.str] entity_type: (Updatable) type of the entity which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) type of the entity which needs to be protected.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict(TypedDict):
        approval_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action done by the approver.
        """
        approval_comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment specified by the approver of the request.
        """
        approver_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The userId of the approver.
        """
        time_approved_for_access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        time_of_authorization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs:
    def __init__(__self__, *,
                 approval_action: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_comment: Optional[pulumi.Input[_builtins.str]] = None,
                 approver_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_approved_for_access: Optional[pulumi.Input[_builtins.str]] = None,
                 time_of_authorization: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_action: The action done by the approver.
        :param pulumi.Input[_builtins.str] approval_comment: Comment specified by the approver of the request.
        :param pulumi.Input[_builtins.str] approver_id: The userId of the approver.
        :param pulumi.Input[_builtins.str] time_approved_for_access: Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        :param pulumi.Input[_builtins.str] time_of_authorization: Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        if approval_action is not None:
            pulumi.set(__self__, "approval_action", approval_action)
        if approval_comment is not None:
            pulumi.set(__self__, "approval_comment", approval_comment)
        if approver_id is not None:
            pulumi.set(__self__, "approver_id", approver_id)
        if time_approved_for_access is not None:
            pulumi.set(__self__, "time_approved_for_access", time_approved_for_access)
        if time_of_authorization is not None:
            pulumi.set(__self__, "time_of_authorization", time_of_authorization)

    @_builtins.property
    @pulumi.getter(name="approvalAction")
    def approval_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action done by the approver.
        """
        return pulumi.get(self, "approval_action")

    @approval_action.setter
    def approval_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_action", value)

    @_builtins.property
    @pulumi.getter(name="approvalComment")
    def approval_comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment specified by the approver of the request.
        """
        return pulumi.get(self, "approval_comment")

    @approval_comment.setter
    def approval_comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_comment", value)

    @_builtins.property
    @pulumi.getter(name="approverId")
    def approver_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The userId of the approver.
        """
        return pulumi.get(self, "approver_id")

    @approver_id.setter
    def approver_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approver_id", value)

    @_builtins.property
    @pulumi.getter(name="timeApprovedForAccess")
    def time_approved_for_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_approved_for_access")

    @time_approved_for_access.setter
    def time_approved_for_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_approved_for_access", value)

    @_builtins.property
    @pulumi.getter(name="timeOfAuthorization")
    def time_of_authorization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_of_authorization")

    @time_of_authorization.setter
    def time_of_authorization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_of_authorization", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of attributes belonging to the above api which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: list of attributes belonging to the above api which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)


if not MYPY:
    class DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Discovered Resource.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Location.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Name.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Discovered Resource's properties.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Group Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Type.
        """
elif False:
    DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudMultiCloudResourceDiscoveryResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Discovered Resource.
        :param pulumi.Input[_builtins.str] location: Discovered Resource Location.
        :param pulumi.Input[_builtins.str] name: Discovered Resource Name.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: Discovered Resource's properties.
        :param pulumi.Input[_builtins.str] resource_group: Discovered Resource Group Name.
        :param pulumi.Input[_builtins.str] type: Discovered Resource Type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Discovered Resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Discovered Resource's properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Group Name.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict(TypedDict):
        current_arc_agent_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        """
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name or Azure Arc Agent name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the Azure Arc Agent resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs:
    def __init__(__self__, *,
                 current_arc_agent_version: Optional[pulumi.Input[_builtins.str]] = None,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_arc_agent_version: Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host name or Azure Arc Agent name.
        :param pulumi.Input[_builtins.str] status: The current status of the Azure Arc Agent resource.
        :param pulumi.Input[_builtins.str] time_last_checked: Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if current_arc_agent_version is not None:
            pulumi.set(__self__, "current_arc_agent_version", current_arc_agent_version)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="currentArcAgentVersion")
    def current_arc_agent_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        """
        return pulumi.get(self, "current_arc_agent_version")

    @current_arc_agent_version.setter
    def current_arc_agent_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_arc_agent_version", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name or Azure Arc Agent name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the Azure Arc Agent resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict(TypedDict):
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host Name or Identity Connector name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the GCP Identity Connector resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgs:
    def __init__(__self__, *,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host Name or Identity Connector name.
        :param pulumi.Input[_builtins.str] status: The current status of the GCP Identity Connector resource.
        :param pulumi.Input[_builtins.str] time_last_checked: time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host Name or Identity Connector name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the GCP Identity Connector resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class ManagedKafkaKafkaClusterAccessSubnetArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) Subnets OCIDs
        """
elif False:
    ManagedKafkaKafkaClusterAccessSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterAccessSubnetArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: (Updatable) Subnets OCIDs
        """
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Subnets OCIDs
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ManagedKafkaKafkaClusterBrokerShapeArgsDict(TypedDict):
        node_count: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of Kafka broker nodes
        """
        ocpu_count: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of OCPUs per nodes
        """
        storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Size of the storage per nodes.
        """
elif False:
    ManagedKafkaKafkaClusterBrokerShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterBrokerShapeArgs:
    def __init__(__self__, *,
                 node_count: pulumi.Input[_builtins.int],
                 ocpu_count: pulumi.Input[_builtins.int],
                 storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] node_count: (Updatable) Number of Kafka broker nodes
        :param pulumi.Input[_builtins.int] ocpu_count: (Updatable) Number of OCPUs per nodes
        :param pulumi.Input[_builtins.int] storage_size_in_gbs: (Updatable) Size of the storage per nodes.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        if storage_size_in_gbs is not None:
            pulumi.set(__self__, "storage_size_in_gbs", storage_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of Kafka broker nodes
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "node_count", value)

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of OCPUs per nodes
        """
        return pulumi.get(self, "ocpu_count")

    @ocpu_count.setter
    def ocpu_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpu_count", value)

    @_builtins.property
    @pulumi.getter(name="storageSizeInGbs")
    def storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Size of the storage per nodes.
        """
        return pulumi.get(self, "storage_size_in_gbs")

    @storage_size_in_gbs.setter
    def storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_size_in_gbs", value)


if not MYPY:
    class ManagedKafkaKafkaClusterConfigLatestConfigArgsDict(TypedDict):
        properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) Cluster configuration key-value pairs
        """
        config_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) ID cluster configuration
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        version_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Version of the cluster configuration


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedKafkaKafkaClusterConfigLatestConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterConfigLatestConfigArgs:
    def __init__(__self__, *,
                 properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 config_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 version_number: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: (Updatable) Cluster configuration key-value pairs
        :param pulumi.Input[_builtins.str] config_id: (Updatable) ID cluster configuration
        :param pulumi.Input[_builtins.str] time_created: (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        :param pulumi.Input[_builtins.int] version_number: (Updatable) Version of the cluster configuration
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "properties", properties)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if version_number is not None:
            pulumi.set(__self__, "version_number", version_number)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Cluster configuration key-value pairs
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) ID cluster configuration
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Version of the cluster configuration


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version_number")

    @version_number.setter
    def version_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version_number", value)


if not MYPY:
    class ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bootstrap URL
        """
elif False:
    ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterKafkaBootstrapUrlArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Kafka listener providing this bootstrap URL
        :param pulumi.Input[_builtins.str] url: Bootstrap URL
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bootstrap URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetApiPlatformApiPlatformInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiPlatformApiPlatformInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiPlatformApiPlatformInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadatasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadatasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadatasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiControlsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiRequestsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Discovered Resource Name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Discovered Resource Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobContainersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobMountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpKeyRingsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClusterConfigVersionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClusterConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClusterConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClusterConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClustersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClustersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the Kafka listener providing this bootstrap URL
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainAgreementRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainAgreementRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainAgreementRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainApplicablePatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainApplicablePatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainApplicablePatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerBackupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerBackupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


