# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiPlatformApiPlatformInstanceIdcsAppArgs',
    'ApiPlatformApiPlatformInstanceIdcsAppArgsDict',
    'ApiPlatformApiPlatformInstanceUriArgs',
    'ApiPlatformApiPlatformInstanceUriArgsDict',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict',
    'BatchBatchContextFleetArgs',
    'BatchBatchContextFleetArgsDict',
    'BatchBatchContextFleetShapeArgs',
    'BatchBatchContextFleetShapeArgsDict',
    'BatchBatchContextJobPriorityConfigurationArgs',
    'BatchBatchContextJobPriorityConfigurationArgsDict',
    'BatchBatchContextLoggingConfigurationArgs',
    'BatchBatchContextLoggingConfigurationArgsDict',
    'BatchBatchContextNetworkArgs',
    'BatchBatchContextNetworkArgsDict',
    'BatchBatchContextNetworkVnicArgs',
    'BatchBatchContextNetworkVnicArgsDict',
    'BatchBatchTaskEnvironmentSecurityContextArgs',
    'BatchBatchTaskEnvironmentSecurityContextArgsDict',
    'BatchBatchTaskEnvironmentVolumeArgs',
    'BatchBatchTaskEnvironmentVolumeArgsDict',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgs',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict',
    'DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailArgs',
    'DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailArgsDict',
    'DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgs',
    'DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgsDict',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict',
    'DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgs',
    'DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict',
    'DifStackAdbArgs',
    'DifStackAdbArgsDict',
    'DifStackAdbDbCredentialArgs',
    'DifStackAdbDbCredentialArgsDict',
    'DifStackAidataplatformArgs',
    'DifStackAidataplatformArgsDict',
    'DifStackDataflowArgs',
    'DifStackDataflowArgsDict',
    'DifStackDataflowConnectionsArgs',
    'DifStackDataflowConnectionsArgsDict',
    'DifStackDataflowConnectionsConnectionDetailsArgs',
    'DifStackDataflowConnectionsConnectionDetailsArgsDict',
    'DifStackDataflowConnectionsConnectionDetailsDifDependencyArgs',
    'DifStackDataflowConnectionsConnectionDetailsDifDependencyArgsDict',
    'DifStackDataflowDriverShapeConfigArgs',
    'DifStackDataflowDriverShapeConfigArgsDict',
    'DifStackDataflowExecutorShapeConfigArgs',
    'DifStackDataflowExecutorShapeConfigArgsDict',
    'DifStackGenaiArgs',
    'DifStackGenaiArgsDict',
    'DifStackGenaiEndpointArgs',
    'DifStackGenaiEndpointArgsDict',
    'DifStackGgcArgs',
    'DifStackGgcArgsDict',
    'DifStackGgcConnectionArgs',
    'DifStackGgcConnectionArgsDict',
    'DifStackGgcConnectionDifDependencyArgs',
    'DifStackGgcConnectionDifDependencyArgsDict',
    'DifStackGgcSourceArgs',
    'DifStackGgcSourceArgsDict',
    'DifStackGgcTargetArgs',
    'DifStackGgcTargetArgsDict',
    'DifStackGgcUserArgs',
    'DifStackGgcUserArgsDict',
    'DifStackObjectstorageArgs',
    'DifStackObjectstorageArgsDict',
    'DifStackOkeArgs',
    'DifStackOkeArgsDict',
    'DifStackOkeComponentValueOverrideArgs',
    'DifStackOkeComponentValueOverrideArgsDict',
    'DifStackOkeSecretArgs',
    'DifStackOkeSecretArgsDict',
    'DifStackOkeSecretSecretDataArgs',
    'DifStackOkeSecretSecretDataArgsDict',
    'DifStackOmkArgs',
    'DifStackOmkArgsDict',
    'DifStackOmkComponentValueOverrideArgs',
    'DifStackOmkComponentValueOverrideArgsDict',
    'DifStackOmkSecretArgs',
    'DifStackOmkSecretArgsDict',
    'DifStackOmkSecretSecretDataArgs',
    'DifStackOmkSecretSecretDataArgsDict',
    'DifStackServiceDetailArgs',
    'DifStackServiceDetailArgsDict',
    'DifStackServiceDetailAdditionalDetailArgs',
    'DifStackServiceDetailAdditionalDetailArgsDict',
    'DifStackServiceDetailAdditionalDetailAssignedConnectionArgs',
    'DifStackServiceDetailAdditionalDetailAssignedConnectionArgsDict',
    'DifStackServiceDetailAdditionalDetailEndpointDetailArgs',
    'DifStackServiceDetailAdditionalDetailEndpointDetailArgsDict',
    'IotDigitalTwinAdapterInboundEnvelopeArgs',
    'IotDigitalTwinAdapterInboundEnvelopeArgsDict',
    'IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs',
    'IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict',
    'IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs',
    'IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict',
    'IotDigitalTwinAdapterInboundRouteArgs',
    'IotDigitalTwinAdapterInboundRouteArgsDict',
    'IotDigitalTwinAdapterInboundRouteReferencePayloadArgs',
    'IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict',
    'IotIotDomainDataRetentionPeriodsInDayArgs',
    'IotIotDomainDataRetentionPeriodsInDayArgsDict',
    'ManagedKafkaKafkaClusterAccessSubnetArgs',
    'ManagedKafkaKafkaClusterAccessSubnetArgsDict',
    'ManagedKafkaKafkaClusterBrokerShapeArgs',
    'ManagedKafkaKafkaClusterBrokerShapeArgsDict',
    'ManagedKafkaKafkaClusterConfigLatestConfigArgs',
    'ManagedKafkaKafkaClusterConfigLatestConfigArgsDict',
    'ManagedKafkaKafkaClusterKafkaBootstrapUrlArgs',
    'ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict',
    'ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgs',
    'ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgsDict',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgs',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgsDict',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict',
    'GetAiDataPlatformAiDataPlatformsFilterArgs',
    'GetAiDataPlatformAiDataPlatformsFilterArgsDict',
    'GetApiPlatformApiPlatformInstancesFilterArgs',
    'GetApiPlatformApiPlatformInstancesFilterArgsDict',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict',
    'GetApiaccesscontrolApiMetadatasFilterArgs',
    'GetApiaccesscontrolApiMetadatasFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict',
    'GetBatchBatchContextShapesFilterArgs',
    'GetBatchBatchContextShapesFilterArgsDict',
    'GetBatchBatchContextsFilterArgs',
    'GetBatchBatchContextsFilterArgsDict',
    'GetBatchBatchJobPoolsFilterArgs',
    'GetBatchBatchJobPoolsFilterArgsDict',
    'GetBatchBatchTaskEnvironmentsFilterArgs',
    'GetBatchBatchTaskEnvironmentsFilterArgsDict',
    'GetBatchBatchTaskProfilesFilterArgs',
    'GetBatchBatchTaskProfilesFilterArgsDict',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict',
    'GetDbmulticloudOracleDbAwsIdentityConnectorsFilterArgs',
    'GetDbmulticloudOracleDbAwsIdentityConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbAwsKeysFilterArgs',
    'GetDbmulticloudOracleDbAwsKeysFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgs',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureKeysFilterArgs',
    'GetDbmulticloudOracleDbAzureKeysFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgs',
    'GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpKeyRingsFilterArgs',
    'GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpKeysFilterArgs',
    'GetDbmulticloudOracleDbGcpKeysFilterArgsDict',
    'GetDifStacksFilterArgs',
    'GetDifStacksFilterArgsDict',
    'GetIotDigitalTwinAdaptersFilterArgs',
    'GetIotDigitalTwinAdaptersFilterArgsDict',
    'GetIotDigitalTwinInstancesFilterArgs',
    'GetIotDigitalTwinInstancesFilterArgsDict',
    'GetIotDigitalTwinModelsFilterArgs',
    'GetIotDigitalTwinModelsFilterArgsDict',
    'GetIotDigitalTwinRelationshipsFilterArgs',
    'GetIotDigitalTwinRelationshipsFilterArgsDict',
    'GetIotIotDomainGroupsFilterArgs',
    'GetIotIotDomainGroupsFilterArgsDict',
    'GetIotIotDomainsFilterArgs',
    'GetIotIotDomainsFilterArgsDict',
    'GetManagedKafkaKafkaClusterConfigVersionsFilterArgs',
    'GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict',
    'GetManagedKafkaKafkaClusterConfigsFilterArgs',
    'GetManagedKafkaKafkaClusterConfigsFilterArgsDict',
    'GetManagedKafkaKafkaClustersFilterArgs',
    'GetManagedKafkaKafkaClustersFilterArgsDict',
    'GetManagedKafkaNodeShapesFilterArgs',
    'GetManagedKafkaNodeShapesFilterArgsDict',
    'GetMulticloudExternalLocationMappingMetadataFilterArgs',
    'GetMulticloudExternalLocationMappingMetadataFilterArgsDict',
    'GetMulticloudExternalLocationSummariesMetadataFilterArgs',
    'GetMulticloudExternalLocationSummariesMetadataFilterArgsDict',
    'GetMulticloudExternalLocationsMetadataFilterArgs',
    'GetMulticloudExternalLocationsMetadataFilterArgsDict',
    'GetMulticloudMulticloudsubscriptionsFilterArgs',
    'GetMulticloudMulticloudsubscriptionsFilterArgsDict',
    'GetMulticloudOmHubMulticloudResourcesFilterArgs',
    'GetMulticloudOmHubMulticloudResourcesFilterArgsDict',
    'GetMulticloudResourceAnchorsFilterArgs',
    'GetMulticloudResourceAnchorsFilterArgsDict',
    'GetPsaPrivateServiceAccessesFilterArgs',
    'GetPsaPrivateServiceAccessesFilterArgsDict',
    'GetPsaPsaServicesFilterArgs',
    'GetPsaPsaServicesFilterArgsDict',
    'GetPsaPsaWorkRequestErrorsFilterArgs',
    'GetPsaPsaWorkRequestErrorsFilterArgsDict',
    'GetPsaPsaWorkRequestLogsFilterArgs',
    'GetPsaPsaWorkRequestLogsFilterArgsDict',
    'GetPsaPsaWorkRequestsFilterArgs',
    'GetPsaPsaWorkRequestsFilterArgsDict',
    'GetResourceAnalyticsMonitoredRegionsFilterArgs',
    'GetResourceAnalyticsMonitoredRegionsFilterArgsDict',
    'GetResourceAnalyticsResourceAnalyticsInstancesFilterArgs',
    'GetResourceAnalyticsResourceAnalyticsInstancesFilterArgsDict',
    'GetResourceAnalyticsTenancyAttachmentsFilterArgs',
    'GetResourceAnalyticsTenancyAttachmentsFilterArgsDict',
    'GetWlmsManagedInstanceScanResultsFilterArgs',
    'GetWlmsManagedInstanceScanResultsFilterArgsDict',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgs',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict',
    'GetWlmsManagedInstanceServersFilterArgs',
    'GetWlmsManagedInstanceServersFilterArgsDict',
    'GetWlmsManagedInstancesFilterArgs',
    'GetWlmsManagedInstancesFilterArgsDict',
    'GetWlmsWlsDomainAgreementRecordsFilterArgs',
    'GetWlmsWlsDomainAgreementRecordsFilterArgsDict',
    'GetWlmsWlsDomainApplicablePatchesFilterArgs',
    'GetWlmsWlsDomainApplicablePatchesFilterArgsDict',
    'GetWlmsWlsDomainScanResultsFilterArgs',
    'GetWlmsWlsDomainScanResultsFilterArgsDict',
    'GetWlmsWlsDomainServerBackupsFilterArgs',
    'GetWlmsWlsDomainServerBackupsFilterArgsDict',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgs',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict',
    'GetWlmsWlsDomainServersFilterArgs',
    'GetWlmsWlsDomainServersFilterArgsDict',
    'GetWlmsWlsDomainsFilterArgs',
    'GetWlmsWlsDomainsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApiPlatformApiPlatformInstanceIdcsAppArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        IDCS URL of the app
        """
elif False:
    ApiPlatformApiPlatformInstanceIdcsAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceIdcsAppArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: IDCS URL of the app
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IDCS URL of the app
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApiPlatformApiPlatformInstanceUriArgsDict(TypedDict):
        developers_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Developer's Portal URI of the instance (/developers)
        """
        management_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Portal URI of the instance (/apiplatform)
        """
elif False:
    ApiPlatformApiPlatformInstanceUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceUriArgs:
    def __init__(__self__, *,
                 developers_portal_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 management_portal_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] developers_portal_uri: Developer's Portal URI of the instance (/developers)
        :param pulumi.Input[_builtins.str] management_portal_uri: Management Portal URI of the instance (/apiplatform)
        """
        if developers_portal_uri is not None:
            pulumi.set(__self__, "developers_portal_uri", developers_portal_uri)
        if management_portal_uri is not None:
            pulumi.set(__self__, "management_portal_uri", management_portal_uri)

    @_builtins.property
    @pulumi.getter(name="developersPortalUri")
    def developers_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Developer's Portal URI of the instance (/developers)
        """
        return pulumi.get(self, "developers_portal_uri")

    @developers_portal_uri.setter
    def developers_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "developers_portal_uri", value)

    @_builtins.property
    @pulumi.getter(name="managementPortalUri")
    def management_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Portal URI of the instance (/apiplatform)
        """
        return pulumi.get(self, "management_portal_uri")

    @management_portal_uri.setter
    def management_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_portal_uri", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        (Updatable) name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) type of the entity which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: (Updatable) name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: (Updatable) list of attributes belonging to the above api which needs to be protected.
        :param pulumi.Input[_builtins.str] entity_type: (Updatable) type of the entity which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) type of the entity which needs to be protected.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict(TypedDict):
        approval_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action done by the approver.
        """
        approval_comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment specified by the approver of the request.
        """
        approver_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The userId of the approver.
        """
        time_approved_for_access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        time_of_authorization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs:
    def __init__(__self__, *,
                 approval_action: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_comment: Optional[pulumi.Input[_builtins.str]] = None,
                 approver_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_approved_for_access: Optional[pulumi.Input[_builtins.str]] = None,
                 time_of_authorization: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_action: The action done by the approver.
        :param pulumi.Input[_builtins.str] approval_comment: Comment specified by the approver of the request.
        :param pulumi.Input[_builtins.str] approver_id: The userId of the approver.
        :param pulumi.Input[_builtins.str] time_approved_for_access: Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        :param pulumi.Input[_builtins.str] time_of_authorization: Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        if approval_action is not None:
            pulumi.set(__self__, "approval_action", approval_action)
        if approval_comment is not None:
            pulumi.set(__self__, "approval_comment", approval_comment)
        if approver_id is not None:
            pulumi.set(__self__, "approver_id", approver_id)
        if time_approved_for_access is not None:
            pulumi.set(__self__, "time_approved_for_access", time_approved_for_access)
        if time_of_authorization is not None:
            pulumi.set(__self__, "time_of_authorization", time_of_authorization)

    @_builtins.property
    @pulumi.getter(name="approvalAction")
    def approval_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action done by the approver.
        """
        return pulumi.get(self, "approval_action")

    @approval_action.setter
    def approval_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_action", value)

    @_builtins.property
    @pulumi.getter(name="approvalComment")
    def approval_comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment specified by the approver of the request.
        """
        return pulumi.get(self, "approval_comment")

    @approval_comment.setter
    def approval_comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_comment", value)

    @_builtins.property
    @pulumi.getter(name="approverId")
    def approver_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The userId of the approver.
        """
        return pulumi.get(self, "approver_id")

    @approver_id.setter
    def approver_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approver_id", value)

    @_builtins.property
    @pulumi.getter(name="timeApprovedForAccess")
    def time_approved_for_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_approved_for_access")

    @time_approved_for_access.setter
    def time_approved_for_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_approved_for_access", value)

    @_builtins.property
    @pulumi.getter(name="timeOfAuthorization")
    def time_of_authorization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_of_authorization")

    @time_of_authorization.setter
    def time_of_authorization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_of_authorization", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of attributes belonging to the above api which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: list of attributes belonging to the above api which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)


if not MYPY:
    class BatchBatchContextFleetArgsDict(TypedDict):
        max_concurrent_tasks: pulumi.Input[_builtins.int]
        """
        Maximum number of concurrent tasks for the service managed fleet.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the service managed fleet.
        """
        shape: pulumi.Input['BatchBatchContextFleetShapeArgsDict']
        """
        Shape of the fleet. Describes hardware resources of each node in the fleet.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of the fleet. Also serves as a discriminator for sub-entities.
        """
        details: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message that describes the current state of the service manage fleet configuration in more detail.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The target state for the Batch Context. Could be set to `ACTIVE` or `INACTIVE`. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    BatchBatchContextFleetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchContextFleetArgs:
    def __init__(__self__, *,
                 max_concurrent_tasks: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 shape: pulumi.Input['BatchBatchContextFleetShapeArgs'],
                 type: pulumi.Input[_builtins.str],
                 details: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] max_concurrent_tasks: Maximum number of concurrent tasks for the service managed fleet.
        :param pulumi.Input[_builtins.str] name: Name of the service managed fleet.
        :param pulumi.Input['BatchBatchContextFleetShapeArgs'] shape: Shape of the fleet. Describes hardware resources of each node in the fleet.
        :param pulumi.Input[_builtins.str] type: Type of the fleet. Also serves as a discriminator for sub-entities.
        :param pulumi.Input[_builtins.str] details: A message that describes the current state of the service manage fleet configuration in more detail.
        :param pulumi.Input[_builtins.str] state: (Updatable) The target state for the Batch Context. Could be set to `ACTIVE` or `INACTIVE`. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "max_concurrent_tasks", max_concurrent_tasks)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "type", type)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentTasks")
    def max_concurrent_tasks(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of concurrent tasks for the service managed fleet.
        """
        return pulumi.get(self, "max_concurrent_tasks")

    @max_concurrent_tasks.setter
    def max_concurrent_tasks(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_concurrent_tasks", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the service managed fleet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> pulumi.Input['BatchBatchContextFleetShapeArgs']:
        """
        Shape of the fleet. Describes hardware resources of each node in the fleet.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input['BatchBatchContextFleetShapeArgs']):
        pulumi.set(self, "shape", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the fleet. Also serves as a discriminator for sub-entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message that describes the current state of the service manage fleet configuration in more detail.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The target state for the Batch Context. Could be set to `ACTIVE` or `INACTIVE`. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class BatchBatchContextFleetShapeArgsDict(TypedDict):
        memory_in_gbs: pulumi.Input[_builtins.int]
        """
        Amount of memory in GBs required by the shape.
        """
        ocpus: pulumi.Input[_builtins.int]
        """
        Number of OCPUs required by the shape.
        """
        shape_name: pulumi.Input[_builtins.str]
        """
        The name of the shape.
        """
elif False:
    BatchBatchContextFleetShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchContextFleetShapeArgs:
    def __init__(__self__, *,
                 memory_in_gbs: pulumi.Input[_builtins.int],
                 ocpus: pulumi.Input[_builtins.int],
                 shape_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] memory_in_gbs: Amount of memory in GBs required by the shape.
        :param pulumi.Input[_builtins.int] ocpus: Number of OCPUs required by the shape.
        :param pulumi.Input[_builtins.str] shape_name: The name of the shape.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "ocpus", ocpus)
        pulumi.set(__self__, "shape_name", shape_name)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        Amount of memory in GBs required by the shape.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> pulumi.Input[_builtins.int]:
        """
        Number of OCPUs required by the shape.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpus", value)

    @_builtins.property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the shape.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "shape_name", value)


if not MYPY:
    class BatchBatchContextJobPriorityConfigurationArgsDict(TypedDict):
        tag_key: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the tag key.
        """
        tag_namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the corresponding tag namespace.
        """
        values: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) Mapping of tag value to its priority.
        """
        weight: pulumi.Input[_builtins.int]
        """
        (Updatable) Weight associated with the tag key. Percentage point is the unit of measurement.
        """
elif False:
    BatchBatchContextJobPriorityConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchContextJobPriorityConfigurationArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[_builtins.str],
                 tag_namespace: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 weight: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] tag_key: (Updatable) Name of the tag key.
        :param pulumi.Input[_builtins.str] tag_namespace: (Updatable) Name of the corresponding tag namespace.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] values: (Updatable) Mapping of tag value to its priority.
        :param pulumi.Input[_builtins.int] weight: (Updatable) Weight associated with the tag key. Percentage point is the unit of measurement.
        """
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_namespace", tag_namespace)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the tag key.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="tagNamespace")
    def tag_namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the corresponding tag namespace.
        """
        return pulumi.get(self, "tag_namespace")

    @tag_namespace.setter
    def tag_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_namespace", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Mapping of tag value to its priority.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Weight associated with the tag key. Percentage point is the unit of measurement.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class BatchBatchContextLoggingConfigurationArgsDict(TypedDict):
        log_group_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        log_id: pulumi.Input[_builtins.str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        type: pulumi.Input[_builtins.str]
        """
        Discriminator for sub-entities.
        """
elif False:
    BatchBatchContextLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchContextLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[_builtins.str],
                 log_id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        :param pulumi.Input[_builtins.str] log_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        :param pulumi.Input[_builtins.str] type: Discriminator for sub-entities.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_id", log_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logId")
    def log_id(self) -> pulumi.Input[_builtins.str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Discriminator for sub-entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class BatchBatchContextNetworkArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of associated subnet.
        """
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of associated network security groups.
        """
        vnics: NotRequired[pulumi.Input[Sequence[pulumi.Input['BatchBatchContextNetworkVnicArgsDict']]]]
        """
        A list of private endpoint's VNICs.
        """
elif False:
    BatchBatchContextNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchContextNetworkArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vnics: Optional[pulumi.Input[Sequence[pulumi.Input['BatchBatchContextNetworkVnicArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of associated subnet.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nsg_ids: A list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of associated network security groups.
        :param pulumi.Input[Sequence[pulumi.Input['BatchBatchContextNetworkVnicArgs']]] vnics: A list of private endpoint's VNICs.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if vnics is not None:
            pulumi.set(__self__, "vnics", vnics)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of associated subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of associated network security groups.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @_builtins.property
    @pulumi.getter
    def vnics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BatchBatchContextNetworkVnicArgs']]]]:
        """
        A list of private endpoint's VNICs.
        """
        return pulumi.get(self, "vnics")

    @vnics.setter
    def vnics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BatchBatchContextNetworkVnicArgs']]]]):
        pulumi.set(self, "vnics", value)


if not MYPY:
    class BatchBatchContextNetworkVnicArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the private endpoint's VNIC, which resides in the customer's VCN.
        """
        source_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of private IP addresses (in the customer's VCN) that represent access points for the service.
        """
elif False:
    BatchBatchContextNetworkVnicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchContextNetworkVnicArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the private endpoint's VNIC, which resides in the customer's VCN.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_ips: A list of private IP addresses (in the customer's VCN) that represent access points for the service.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if source_ips is not None:
            pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the private endpoint's VNIC, which resides in the customer's VCN.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of private IP addresses (in the customer's VCN) that represent access points for the service.
        """
        return pulumi.get(self, "source_ips")

    @source_ips.setter
    def source_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_ips", value)


if not MYPY:
    class BatchBatchTaskEnvironmentSecurityContextArgsDict(TypedDict):
        fs_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        A special supplemental group ID that applies to all containers in a pod.
        """
        run_as_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        Group ID for running processes inside the container.
        """
        run_as_user: NotRequired[pulumi.Input[_builtins.int]]
        """
        User ID for running processes inside the container.
        """
elif False:
    BatchBatchTaskEnvironmentSecurityContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchTaskEnvironmentSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_user: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] fs_group: A special supplemental group ID that applies to all containers in a pod.
        :param pulumi.Input[_builtins.int] run_as_group: Group ID for running processes inside the container.
        :param pulumi.Input[_builtins.int] run_as_user: User ID for running processes inside the container.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)

    @_builtins.property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A special supplemental group ID that applies to all containers in a pod.
        """
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fs_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Group ID for running processes inside the container.
        """
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        User ID for running processes inside the container.
        """
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_user", value)


if not MYPY:
    class BatchBatchTaskEnvironmentVolumeArgsDict(TypedDict):
        local_mount_directory_path: pulumi.Input[_builtins.str]
        """
        The local path to mount the NFS share to.
        """
        mount_target_export_path: pulumi.Input[_builtins.str]
        """
        The path to the directory on the NFS server to be mounted.
        """
        mount_target_fqdn: pulumi.Input[_builtins.str]
        """
        The FQDN of the NFS server to connect to.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the NfsVolume.
        """
        type: pulumi.Input[_builtins.str]
        """
        Discriminator for sub-entities.
        """
elif False:
    BatchBatchTaskEnvironmentVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchBatchTaskEnvironmentVolumeArgs:
    def __init__(__self__, *,
                 local_mount_directory_path: pulumi.Input[_builtins.str],
                 mount_target_export_path: pulumi.Input[_builtins.str],
                 mount_target_fqdn: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] local_mount_directory_path: The local path to mount the NFS share to.
        :param pulumi.Input[_builtins.str] mount_target_export_path: The path to the directory on the NFS server to be mounted.
        :param pulumi.Input[_builtins.str] mount_target_fqdn: The FQDN of the NFS server to connect to.
        :param pulumi.Input[_builtins.str] name: The name of the NfsVolume.
        :param pulumi.Input[_builtins.str] type: Discriminator for sub-entities.
        """
        pulumi.set(__self__, "local_mount_directory_path", local_mount_directory_path)
        pulumi.set(__self__, "mount_target_export_path", mount_target_export_path)
        pulumi.set(__self__, "mount_target_fqdn", mount_target_fqdn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="localMountDirectoryPath")
    def local_mount_directory_path(self) -> pulumi.Input[_builtins.str]:
        """
        The local path to mount the NFS share to.
        """
        return pulumi.get(self, "local_mount_directory_path")

    @local_mount_directory_path.setter
    def local_mount_directory_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_directory_path", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetExportPath")
    def mount_target_export_path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to the directory on the NFS server to be mounted.
        """
        return pulumi.get(self, "mount_target_export_path")

    @mount_target_export_path.setter
    def mount_target_export_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_target_export_path", value)

    @_builtins.property
    @pulumi.getter(name="mountTargetFqdn")
    def mount_target_fqdn(self) -> pulumi.Input[_builtins.str]:
        """
        The FQDN of the NFS server to connect to.
        """
        return pulumi.get(self, "mount_target_fqdn")

    @mount_target_fqdn.setter
    def mount_target_fqdn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_target_fqdn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the NfsVolume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Discriminator for sub-entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Discovered Resource.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Location.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Name.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Discovered Resource's properties.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Group Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Type.
        """
elif False:
    DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudMultiCloudResourceDiscoveryResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Discovered Resource.
        :param pulumi.Input[_builtins.str] location: Discovered Resource Location.
        :param pulumi.Input[_builtins.str] name: Discovered Resource Name.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: Discovered Resource's properties.
        :param pulumi.Input[_builtins.str] resource_group: Discovered Resource Group Name.
        :param pulumi.Input[_builtins.str] type: Discovered Resource Type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Discovered Resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Discovered Resource's properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Group Name.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        """
        (Updatable) Amazon resource name AWSof the IAM role.
        """
        service_private_endpoint: pulumi.Input[_builtins.str]
        """
        (Updatable) Private endpoint of the AWS service.
        """
        service_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of service.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        assume_role_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Assume role  status.
        """
        aws_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgsDict']]]]
        """
        List of all VMs where AWS Identity Connector is configured for Oracle DB Cloud VM Cluster.
        """
elif False:
    DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 service_private_endpoint: pulumi.Input[_builtins.str],
                 service_type: pulumi.Input[_builtins.str],
                 assume_role_status: Optional[pulumi.Input[_builtins.str]] = None,
                 aws_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] role_arn: (Updatable) Amazon resource name AWSof the IAM role.
        :param pulumi.Input[_builtins.str] service_private_endpoint: (Updatable) Private endpoint of the AWS service.
        :param pulumi.Input[_builtins.str] service_type: (Updatable) Type of service.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] assume_role_status: Assume role  status.
        :param pulumi.Input[Sequence[pulumi.Input['DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgs']]] aws_nodes: List of all VMs where AWS Identity Connector is configured for Oracle DB Cloud VM Cluster.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "service_private_endpoint", service_private_endpoint)
        pulumi.set(__self__, "service_type", service_type)
        if assume_role_status is not None:
            pulumi.set(__self__, "assume_role_status", assume_role_status)
        if aws_nodes is not None:
            pulumi.set(__self__, "aws_nodes", aws_nodes)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Amazon resource name AWSof the IAM role.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="servicePrivateEndpoint")
    def service_private_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Private endpoint of the AWS service.
        """
        return pulumi.get(self, "service_private_endpoint")

    @service_private_endpoint.setter
    def service_private_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_private_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of service.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_type", value)

    @_builtins.property
    @pulumi.getter(name="assumeRoleStatus")
    def assume_role_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Assume role  status.
        """
        return pulumi.get(self, "assume_role_status")

    @assume_role_status.setter
    def assume_role_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "assume_role_status", value)

    @_builtins.property
    @pulumi.getter(name="awsNodes")
    def aws_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgs']]]]:
        """
        List of all VMs where AWS Identity Connector is configured for Oracle DB Cloud VM Cluster.
        """
        return pulumi.get(self, "aws_nodes")

    @aws_nodes.setter
    def aws_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgs']]]]):
        pulumi.set(self, "aws_nodes", value)


if not MYPY:
    class DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgsDict(TypedDict):
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Host name or Identity Connector name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the AWS Identity Connector resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the AWS Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'.
        """
elif False:
    DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbAwsIdentityConnectorServiceRoleDetailAwsNodeArgs:
    def __init__(__self__, *,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_id: AWS host ID.
        :param pulumi.Input[_builtins.str] host_name: AWS Host name or Identity Connector name.
        :param pulumi.Input[_builtins.str] status: The current status of the AWS Identity Connector resource.
        :param pulumi.Input[_builtins.str] time_last_checked: Time when the AWS Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'.
        """
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Host name or Identity Connector name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the AWS Identity Connector resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the AWS Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'.
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict(TypedDict):
        current_arc_agent_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        """
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name or Azure Arc Agent name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the Azure Arc Agent resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs:
    def __init__(__self__, *,
                 current_arc_agent_version: Optional[pulumi.Input[_builtins.str]] = None,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_arc_agent_version: Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host name or Azure Arc Agent name.
        :param pulumi.Input[_builtins.str] status: The current status of the Azure Arc Agent resource.
        :param pulumi.Input[_builtins.str] time_last_checked: Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if current_arc_agent_version is not None:
            pulumi.set(__self__, "current_arc_agent_version", current_arc_agent_version)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="currentArcAgentVersion")
    def current_arc_agent_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        """
        return pulumi.get(self, "current_arc_agent_version")

    @current_arc_agent_version.setter
    def current_arc_agent_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_arc_agent_version", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name or Azure Arc Agent name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the Azure Arc Agent resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict(TypedDict):
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host Name or Identity Connector name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the GCP Identity Connector resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgs:
    def __init__(__self__, *,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host Name or Identity Connector name.
        :param pulumi.Input[_builtins.str] status: The current status of the GCP Identity Connector resource.
        :param pulumi.Input[_builtins.str] time_last_checked: time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host Name or Identity Connector name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the GCP Identity Connector resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class DifStackAdbArgsDict(TypedDict):
        admin_password_id: pulumi.Input[_builtins.str]
        """
        The Oracle Cloud Infrastructure vault secret [/Content/General/Concepts/identifiers.htm]OCID for admin password.
        """
        data_storage_size_in_tbs: pulumi.Input[_builtins.int]
        """
        (Updatable) The size, in terabytes, of the data volume that will be created and attached to the database.
        """
        db_version: pulumi.Input[_builtins.str]
        """
        (Updatable) A valid Oracle Database version for Autonomous Database.
        """
        db_workload: pulumi.Input[_builtins.str]
        """
        DB Workload to be used with ADB. Accepted values are OLTP, DW.
        """
        ecpu: pulumi.Input[_builtins.int]
        """
        (Updatable) The compute amount (ECPUs) available to the database.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        Id for the adw instance.
        """
        artifact_object_storage_path: NotRequired[pulumi.Input[_builtins.str]]
        db_credentials: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackAdbDbCredentialArgsDict']]]]
        """
        DB credential details.
        """
        is_mtls_connection_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies if the Autonomous Database requires mTLS connections.
        """
        is_public: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true then subnetId should not be provided.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OCID of the subnet the Autonomous Database is associated with.
        """
        tools_public_access: NotRequired[pulumi.Input[_builtins.str]]
        """
        This is an array of CIDR (classless inter-domain routing) notations for a subnet or VCN OCID (virtual cloud network Oracle Cloud ID). Allowed only when subnetId is provided (private ADB).
        """
elif False:
    DifStackAdbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackAdbArgs:
    def __init__(__self__, *,
                 admin_password_id: pulumi.Input[_builtins.str],
                 data_storage_size_in_tbs: pulumi.Input[_builtins.int],
                 db_version: pulumi.Input[_builtins.str],
                 db_workload: pulumi.Input[_builtins.str],
                 ecpu: pulumi.Input[_builtins.int],
                 instance_id: pulumi.Input[_builtins.str],
                 artifact_object_storage_path: Optional[pulumi.Input[_builtins.str]] = None,
                 db_credentials: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackAdbDbCredentialArgs']]]] = None,
                 is_mtls_connection_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_public: Optional[pulumi.Input[_builtins.bool]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tools_public_access: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] admin_password_id: The Oracle Cloud Infrastructure vault secret [/Content/General/Concepts/identifiers.htm]OCID for admin password.
        :param pulumi.Input[_builtins.int] data_storage_size_in_tbs: (Updatable) The size, in terabytes, of the data volume that will be created and attached to the database.
        :param pulumi.Input[_builtins.str] db_version: (Updatable) A valid Oracle Database version for Autonomous Database.
        :param pulumi.Input[_builtins.str] db_workload: DB Workload to be used with ADB. Accepted values are OLTP, DW.
        :param pulumi.Input[_builtins.int] ecpu: (Updatable) The compute amount (ECPUs) available to the database.
        :param pulumi.Input[_builtins.str] instance_id: Id for the adw instance.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackAdbDbCredentialArgs']]] db_credentials: DB credential details.
        :param pulumi.Input[_builtins.bool] is_mtls_connection_required: (Updatable) Specifies if the Autonomous Database requires mTLS connections.
        :param pulumi.Input[_builtins.bool] is_public: If true then subnetId should not be provided.
        :param pulumi.Input[_builtins.str] subnet_id: The OCID of the subnet the Autonomous Database is associated with.
        :param pulumi.Input[_builtins.str] tools_public_access: This is an array of CIDR (classless inter-domain routing) notations for a subnet or VCN OCID (virtual cloud network Oracle Cloud ID). Allowed only when subnetId is provided (private ADB).
        """
        pulumi.set(__self__, "admin_password_id", admin_password_id)
        pulumi.set(__self__, "data_storage_size_in_tbs", data_storage_size_in_tbs)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "db_workload", db_workload)
        pulumi.set(__self__, "ecpu", ecpu)
        pulumi.set(__self__, "instance_id", instance_id)
        if artifact_object_storage_path is not None:
            pulumi.set(__self__, "artifact_object_storage_path", artifact_object_storage_path)
        if db_credentials is not None:
            pulumi.set(__self__, "db_credentials", db_credentials)
        if is_mtls_connection_required is not None:
            pulumi.set(__self__, "is_mtls_connection_required", is_mtls_connection_required)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tools_public_access is not None:
            pulumi.set(__self__, "tools_public_access", tools_public_access)

    @_builtins.property
    @pulumi.getter(name="adminPasswordId")
    def admin_password_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Oracle Cloud Infrastructure vault secret [/Content/General/Concepts/identifiers.htm]OCID for admin password.
        """
        return pulumi.get(self, "admin_password_id")

    @admin_password_id.setter
    def admin_password_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "admin_password_id", value)

    @_builtins.property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The size, in terabytes, of the data volume that will be created and attached to the database.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @data_storage_size_in_tbs.setter
    def data_storage_size_in_tbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "data_storage_size_in_tbs", value)

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "db_version", value)

    @_builtins.property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> pulumi.Input[_builtins.str]:
        """
        DB Workload to be used with ADB. Accepted values are OLTP, DW.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "db_workload", value)

    @_builtins.property
    @pulumi.getter
    def ecpu(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The compute amount (ECPUs) available to the database.
        """
        return pulumi.get(self, "ecpu")

    @ecpu.setter
    def ecpu(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ecpu", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id for the adw instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="artifactObjectStoragePath")
    def artifact_object_storage_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_object_storage_path")

    @artifact_object_storage_path.setter
    def artifact_object_storage_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_object_storage_path", value)

    @_builtins.property
    @pulumi.getter(name="dbCredentials")
    def db_credentials(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackAdbDbCredentialArgs']]]]:
        """
        DB credential details.
        """
        return pulumi.get(self, "db_credentials")

    @db_credentials.setter
    def db_credentials(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackAdbDbCredentialArgs']]]]):
        pulumi.set(self, "db_credentials", value)

    @_builtins.property
    @pulumi.getter(name="isMtlsConnectionRequired")
    def is_mtls_connection_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies if the Autonomous Database requires mTLS connections.
        """
        return pulumi.get(self, "is_mtls_connection_required")

    @is_mtls_connection_required.setter
    def is_mtls_connection_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_mtls_connection_required", value)

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true then subnetId should not be provided.
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_public", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OCID of the subnet the Autonomous Database is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="toolsPublicAccess")
    def tools_public_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This is an array of CIDR (classless inter-domain routing) notations for a subnet or VCN OCID (virtual cloud network Oracle Cloud ID). Allowed only when subnetId is provided (private ADB).
        """
        return pulumi.get(self, "tools_public_access")

    @tools_public_access.setter
    def tools_public_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tools_public_access", value)


if not MYPY:
    class DifStackAdbDbCredentialArgsDict(TypedDict):
        secret_id: pulumi.Input[_builtins.str]
        """
        Vault secret OCID containing the corresponding user password.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Username for ADB to be created or updated.
        """
        user_type: pulumi.Input[_builtins.str]
        """
        Type of the user. Allowed values are "ADMIN" or "CUSTOM" or "GGCS".
        """
elif False:
    DifStackAdbDbCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackAdbDbCredentialArgs:
    def __init__(__self__, *,
                 secret_id: pulumi.Input[_builtins.str],
                 user_name: pulumi.Input[_builtins.str],
                 user_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] secret_id: Vault secret OCID containing the corresponding user password.
        :param pulumi.Input[_builtins.str] user_name: Username for ADB to be created or updated.
        :param pulumi.Input[_builtins.str] user_type: Type of the user. Allowed values are "ADMIN" or "CUSTOM" or "GGCS".
        """
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "user_type", user_type)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        Vault secret OCID containing the corresponding user password.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Username for ADB to be created or updated.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter(name="userType")
    def user_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the user. Allowed values are "ADMIN" or "CUSTOM" or "GGCS".
        """
        return pulumi.get(self, "user_type")

    @user_type.setter
    def user_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_type", value)


if not MYPY:
    class DifStackAidataplatformArgsDict(TypedDict):
        default_workspace_name: pulumi.Input[_builtins.str]
        """
        A default workspace will be created with this name.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        Identifier for AIDP instance to be provisioned.
        """
elif False:
    DifStackAidataplatformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackAidataplatformArgs:
    def __init__(__self__, *,
                 default_workspace_name: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] default_workspace_name: A default workspace will be created with this name.
        :param pulumi.Input[_builtins.str] instance_id: Identifier for AIDP instance to be provisioned.
        """
        pulumi.set(__self__, "default_workspace_name", default_workspace_name)
        pulumi.set(__self__, "instance_id", instance_id)

    @_builtins.property
    @pulumi.getter(name="defaultWorkspaceName")
    def default_workspace_name(self) -> pulumi.Input[_builtins.str]:
        """
        A default workspace will be created with this name.
        """
        return pulumi.get(self, "default_workspace_name")

    @default_workspace_name.setter
    def default_workspace_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_workspace_name", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier for AIDP instance to be provisioned.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)


if not MYPY:
    class DifStackDataflowArgsDict(TypedDict):
        driver_shape: pulumi.Input[_builtins.str]
        """
        (Updatable) The VM shape for the driver. Sets the driver cores and memory.
        """
        executor_shape: pulumi.Input[_builtins.str]
        """
        (Updatable) The VM shape for the executors. Sets the executor cores and memory.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        Id for dataflow instance
        """
        log_bucket_instance_id: pulumi.Input[_builtins.str]
        """
        (Updatable) InstanceId of log bucket created as part of objectstorage service in stack. Used for storing application run logs.
        """
        num_executors: pulumi.Input[_builtins.int]
        """
        (Updatable) The number of executor VMs requested.
        """
        spark_version: pulumi.Input[_builtins.str]
        """
        (Updatable) The Spark version utilized to run the application.
        """
        archive_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains the archive from object storage bucket which can be added as dependency to data flow application.
        """
        connections: NotRequired[pulumi.Input['DifStackDataflowConnectionsArgsDict']]
        """
        (Updatable) Details for connections to other services from Dataflow.
        """
        driver_shape_config: NotRequired[pulumi.Input['DifStackDataflowDriverShapeConfigArgsDict']]
        """
        (Updatable) This is used to configure the shape of the driver or executor if a flexible shape is used.
        """
        execute: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains the main file (py/jar) along with parameters & configuration to be passed to the DataFlow run.
        """
        executor_shape_config: NotRequired[pulumi.Input['DifStackDataflowExecutorShapeConfigArgsDict']]
        """
        (Updatable) This is used to configure the shape of the driver or executor if a flexible shape is used.
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of the already provisioned dataflow private endpoint.
        """
        warehouse_bucket_instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) InstanceId of warehouse bucket created as part of objectstorage service in stack. Mandatory for SQL applications.
        """
elif False:
    DifStackDataflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackDataflowArgs:
    def __init__(__self__, *,
                 driver_shape: pulumi.Input[_builtins.str],
                 executor_shape: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str],
                 log_bucket_instance_id: pulumi.Input[_builtins.str],
                 num_executors: pulumi.Input[_builtins.int],
                 spark_version: pulumi.Input[_builtins.str],
                 archive_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 connections: Optional[pulumi.Input['DifStackDataflowConnectionsArgs']] = None,
                 driver_shape_config: Optional[pulumi.Input['DifStackDataflowDriverShapeConfigArgs']] = None,
                 execute: Optional[pulumi.Input[_builtins.str]] = None,
                 executor_shape_config: Optional[pulumi.Input['DifStackDataflowExecutorShapeConfigArgs']] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 warehouse_bucket_instance_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] driver_shape: (Updatable) The VM shape for the driver. Sets the driver cores and memory.
        :param pulumi.Input[_builtins.str] executor_shape: (Updatable) The VM shape for the executors. Sets the executor cores and memory.
        :param pulumi.Input[_builtins.str] instance_id: Id for dataflow instance
        :param pulumi.Input[_builtins.str] log_bucket_instance_id: (Updatable) InstanceId of log bucket created as part of objectstorage service in stack. Used for storing application run logs.
        :param pulumi.Input[_builtins.int] num_executors: (Updatable) The number of executor VMs requested.
        :param pulumi.Input[_builtins.str] spark_version: (Updatable) The Spark version utilized to run the application.
        :param pulumi.Input[_builtins.str] archive_uri: Contains the archive from object storage bucket which can be added as dependency to data flow application.
        :param pulumi.Input['DifStackDataflowConnectionsArgs'] connections: (Updatable) Details for connections to other services from Dataflow.
        :param pulumi.Input['DifStackDataflowDriverShapeConfigArgs'] driver_shape_config: (Updatable) This is used to configure the shape of the driver or executor if a flexible shape is used.
        :param pulumi.Input[_builtins.str] execute: Contains the main file (py/jar) along with parameters & configuration to be passed to the DataFlow run.
        :param pulumi.Input['DifStackDataflowExecutorShapeConfigArgs'] executor_shape_config: (Updatable) This is used to configure the shape of the driver or executor if a flexible shape is used.
        :param pulumi.Input[_builtins.str] private_endpoint_id: (Updatable) OCID of the already provisioned dataflow private endpoint.
        :param pulumi.Input[_builtins.str] warehouse_bucket_instance_id: (Updatable) InstanceId of warehouse bucket created as part of objectstorage service in stack. Mandatory for SQL applications.
        """
        pulumi.set(__self__, "driver_shape", driver_shape)
        pulumi.set(__self__, "executor_shape", executor_shape)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "log_bucket_instance_id", log_bucket_instance_id)
        pulumi.set(__self__, "num_executors", num_executors)
        pulumi.set(__self__, "spark_version", spark_version)
        if archive_uri is not None:
            pulumi.set(__self__, "archive_uri", archive_uri)
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if driver_shape_config is not None:
            pulumi.set(__self__, "driver_shape_config", driver_shape_config)
        if execute is not None:
            pulumi.set(__self__, "execute", execute)
        if executor_shape_config is not None:
            pulumi.set(__self__, "executor_shape_config", executor_shape_config)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        if warehouse_bucket_instance_id is not None:
            pulumi.set(__self__, "warehouse_bucket_instance_id", warehouse_bucket_instance_id)

    @_builtins.property
    @pulumi.getter(name="driverShape")
    def driver_shape(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The VM shape for the driver. Sets the driver cores and memory.
        """
        return pulumi.get(self, "driver_shape")

    @driver_shape.setter
    def driver_shape(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "driver_shape", value)

    @_builtins.property
    @pulumi.getter(name="executorShape")
    def executor_shape(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The VM shape for the executors. Sets the executor cores and memory.
        """
        return pulumi.get(self, "executor_shape")

    @executor_shape.setter
    def executor_shape(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "executor_shape", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id for dataflow instance
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="logBucketInstanceId")
    def log_bucket_instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) InstanceId of log bucket created as part of objectstorage service in stack. Used for storing application run logs.
        """
        return pulumi.get(self, "log_bucket_instance_id")

    @log_bucket_instance_id.setter
    def log_bucket_instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_bucket_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="numExecutors")
    def num_executors(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The number of executor VMs requested.
        """
        return pulumi.get(self, "num_executors")

    @num_executors.setter
    def num_executors(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "num_executors", value)

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Spark version utilized to run the application.
        """
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "spark_version", value)

    @_builtins.property
    @pulumi.getter(name="archiveUri")
    def archive_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains the archive from object storage bucket which can be added as dependency to data flow application.
        """
        return pulumi.get(self, "archive_uri")

    @archive_uri.setter
    def archive_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "archive_uri", value)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input['DifStackDataflowConnectionsArgs']]:
        """
        (Updatable) Details for connections to other services from Dataflow.
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input['DifStackDataflowConnectionsArgs']]):
        pulumi.set(self, "connections", value)

    @_builtins.property
    @pulumi.getter(name="driverShapeConfig")
    def driver_shape_config(self) -> Optional[pulumi.Input['DifStackDataflowDriverShapeConfigArgs']]:
        """
        (Updatable) This is used to configure the shape of the driver or executor if a flexible shape is used.
        """
        return pulumi.get(self, "driver_shape_config")

    @driver_shape_config.setter
    def driver_shape_config(self, value: Optional[pulumi.Input['DifStackDataflowDriverShapeConfigArgs']]):
        pulumi.set(self, "driver_shape_config", value)

    @_builtins.property
    @pulumi.getter
    def execute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains the main file (py/jar) along with parameters & configuration to be passed to the DataFlow run.
        """
        return pulumi.get(self, "execute")

    @execute.setter
    def execute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execute", value)

    @_builtins.property
    @pulumi.getter(name="executorShapeConfig")
    def executor_shape_config(self) -> Optional[pulumi.Input['DifStackDataflowExecutorShapeConfigArgs']]:
        """
        (Updatable) This is used to configure the shape of the driver or executor if a flexible shape is used.
        """
        return pulumi.get(self, "executor_shape_config")

    @executor_shape_config.setter
    def executor_shape_config(self, value: Optional[pulumi.Input['DifStackDataflowExecutorShapeConfigArgs']]):
        pulumi.set(self, "executor_shape_config", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of the already provisioned dataflow private endpoint.
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="warehouseBucketInstanceId")
    def warehouse_bucket_instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) InstanceId of warehouse bucket created as part of objectstorage service in stack. Mandatory for SQL applications.
        """
        return pulumi.get(self, "warehouse_bucket_instance_id")

    @warehouse_bucket_instance_id.setter
    def warehouse_bucket_instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warehouse_bucket_instance_id", value)


if not MYPY:
    class DifStackDataflowConnectionsArgsDict(TypedDict):
        connection_details: pulumi.Input['DifStackDataflowConnectionsConnectionDetailsArgsDict']
        """
        (Updatable) Details of services to create private endpoint.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        OCID of the private subnet
        """
elif False:
    DifStackDataflowConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackDataflowConnectionsArgs:
    def __init__(__self__, *,
                 connection_details: pulumi.Input['DifStackDataflowConnectionsConnectionDetailsArgs'],
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['DifStackDataflowConnectionsConnectionDetailsArgs'] connection_details: (Updatable) Details of services to create private endpoint.
        :param pulumi.Input[_builtins.str] subnet_id: OCID of the private subnet
        """
        pulumi.set(__self__, "connection_details", connection_details)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="connectionDetails")
    def connection_details(self) -> pulumi.Input['DifStackDataflowConnectionsConnectionDetailsArgs']:
        """
        (Updatable) Details of services to create private endpoint.
        """
        return pulumi.get(self, "connection_details")

    @connection_details.setter
    def connection_details(self, value: pulumi.Input['DifStackDataflowConnectionsConnectionDetailsArgs']):
        pulumi.set(self, "connection_details", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of the private subnet
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DifStackDataflowConnectionsConnectionDetailsArgsDict(TypedDict):
        dif_dependencies: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackDataflowConnectionsConnectionDetailsDifDependencyArgsDict']]]]
        """
        (Updatable) List of DIF Service Dependency Details to create private endpoint.
        """
        domain_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) An array of DNS zone names.
        """
elif False:
    DifStackDataflowConnectionsConnectionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackDataflowConnectionsConnectionDetailsArgs:
    def __init__(__self__, *,
                 dif_dependencies: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackDataflowConnectionsConnectionDetailsDifDependencyArgs']]]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DifStackDataflowConnectionsConnectionDetailsDifDependencyArgs']]] dif_dependencies: (Updatable) List of DIF Service Dependency Details to create private endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domain_names: (Updatable) An array of DNS zone names.
        """
        if dif_dependencies is not None:
            pulumi.set(__self__, "dif_dependencies", dif_dependencies)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)

    @_builtins.property
    @pulumi.getter(name="difDependencies")
    def dif_dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackDataflowConnectionsConnectionDetailsDifDependencyArgs']]]]:
        """
        (Updatable) List of DIF Service Dependency Details to create private endpoint.
        """
        return pulumi.get(self, "dif_dependencies")

    @dif_dependencies.setter
    def dif_dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackDataflowConnectionsConnectionDetailsDifDependencyArgs']]]]):
        pulumi.set(self, "dif_dependencies", value)

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) An array of DNS zone names.
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domain_names", value)


if not MYPY:
    class DifStackDataflowConnectionsConnectionDetailsDifDependencyArgsDict(TypedDict):
        service_instance_id: pulumi.Input[_builtins.str]
        """
        (Updatable) InstanceId of service which is part of the Stack.
        """
        service_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Supported service name.
        """
elif False:
    DifStackDataflowConnectionsConnectionDetailsDifDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackDataflowConnectionsConnectionDetailsDifDependencyArgs:
    def __init__(__self__, *,
                 service_instance_id: pulumi.Input[_builtins.str],
                 service_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service_instance_id: (Updatable) InstanceId of service which is part of the Stack.
        :param pulumi.Input[_builtins.str] service_type: (Updatable) Supported service name.
        """
        pulumi.set(__self__, "service_instance_id", service_instance_id)
        pulumi.set(__self__, "service_type", service_type)

    @_builtins.property
    @pulumi.getter(name="serviceInstanceId")
    def service_instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) InstanceId of service which is part of the Stack.
        """
        return pulumi.get(self, "service_instance_id")

    @service_instance_id.setter
    def service_instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Supported service name.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_type", value)


if not MYPY:
    class DifStackDataflowDriverShapeConfigArgsDict(TypedDict):
        memory_in_gbs: pulumi.Input[_builtins.int]
        """
        (Updatable) The amount of memory used for the driver or executors.
        """
        ocpus: pulumi.Input[_builtins.int]
        """
        (Updatable) The total number of OCPUs used for the driver or executors. See here for details.
        """
elif False:
    DifStackDataflowDriverShapeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackDataflowDriverShapeConfigArgs:
    def __init__(__self__, *,
                 memory_in_gbs: pulumi.Input[_builtins.int],
                 ocpus: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] memory_in_gbs: (Updatable) The amount of memory used for the driver or executors.
        :param pulumi.Input[_builtins.int] ocpus: (Updatable) The total number of OCPUs used for the driver or executors. See here for details.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The amount of memory used for the driver or executors.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The total number of OCPUs used for the driver or executors. See here for details.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class DifStackDataflowExecutorShapeConfigArgsDict(TypedDict):
        memory_in_gbs: pulumi.Input[_builtins.int]
        """
        (Updatable) The amount of memory used for the driver or executors.
        """
        ocpus: pulumi.Input[_builtins.int]
        """
        (Updatable) The total number of OCPUs used for the driver or executors. See here for details.
        """
elif False:
    DifStackDataflowExecutorShapeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackDataflowExecutorShapeConfigArgs:
    def __init__(__self__, *,
                 memory_in_gbs: pulumi.Input[_builtins.int],
                 ocpus: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] memory_in_gbs: (Updatable) The amount of memory used for the driver or executors.
        :param pulumi.Input[_builtins.int] ocpus: (Updatable) The total number of OCPUs used for the driver or executors. See here for details.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The amount of memory used for the driver or executors.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "memory_in_gbs", value)

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The total number of OCPUs used for the driver or executors. See here for details.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpus", value)


if not MYPY:
    class DifStackGenaiArgsDict(TypedDict):
        base_model: pulumi.Input[_builtins.str]
        """
        Name of the base model.
        """
        cluster_type: pulumi.Input[_builtins.str]
        """
        The dedicated AI cluster type.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Id for the GenAi instance to be provisioned.
        """
        oci_region: pulumi.Input[_builtins.str]
        """
        Region on which the cluster end endpoint will be provisioned.
        """
        unit_count: pulumi.Input[_builtins.int]
        """
        (Updatable) No of replicas of base model to be used for hosting.
        """
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackGenaiEndpointArgsDict']]]]
        """
        (Updatable) List of endpoints to provision for the GENAI cluster.
        """
elif False:
    DifStackGenaiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGenaiArgs:
    def __init__(__self__, *,
                 base_model: pulumi.Input[_builtins.str],
                 cluster_type: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str],
                 oci_region: pulumi.Input[_builtins.str],
                 unit_count: pulumi.Input[_builtins.int],
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGenaiEndpointArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] base_model: Name of the base model.
        :param pulumi.Input[_builtins.str] cluster_type: The dedicated AI cluster type.
        :param pulumi.Input[_builtins.str] instance_id: (Updatable) Id for the GenAi instance to be provisioned.
        :param pulumi.Input[_builtins.str] oci_region: Region on which the cluster end endpoint will be provisioned.
        :param pulumi.Input[_builtins.int] unit_count: (Updatable) No of replicas of base model to be used for hosting.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackGenaiEndpointArgs']]] endpoints: (Updatable) List of endpoints to provision for the GENAI cluster.
        """
        pulumi.set(__self__, "base_model", base_model)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "oci_region", oci_region)
        pulumi.set(__self__, "unit_count", unit_count)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter(name="baseModel")
    def base_model(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the base model.
        """
        return pulumi.get(self, "base_model")

    @base_model.setter
    def base_model(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_model", value)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> pulumi.Input[_builtins.str]:
        """
        The dedicated AI cluster type.
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Id for the GenAi instance to be provisioned.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="ociRegion")
    def oci_region(self) -> pulumi.Input[_builtins.str]:
        """
        Region on which the cluster end endpoint will be provisioned.
        """
        return pulumi.get(self, "oci_region")

    @oci_region.setter
    def oci_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oci_region", value)

    @_builtins.property
    @pulumi.getter(name="unitCount")
    def unit_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) No of replicas of base model to be used for hosting.
        """
        return pulumi.get(self, "unit_count")

    @unit_count.setter
    def unit_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "unit_count", value)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGenaiEndpointArgs']]]]:
        """
        (Updatable) List of endpoints to provision for the GENAI cluster.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGenaiEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class DifStackGenaiEndpointArgsDict(TypedDict):
        endpoint_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Identifier for each endpoint.
        """
        is_content_moderation_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) Helps remove toxic and biased content from responses.
        """
elif False:
    DifStackGenaiEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGenaiEndpointArgs:
    def __init__(__self__, *,
                 endpoint_name: pulumi.Input[_builtins.str],
                 is_content_moderation_enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.str] endpoint_name: (Updatable) Identifier for each endpoint.
        :param pulumi.Input[_builtins.bool] is_content_moderation_enabled: (Updatable) Helps remove toxic and biased content from responses.
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "is_content_moderation_enabled", is_content_moderation_enabled)

    @_builtins.property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Identifier for each endpoint.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_name", value)

    @_builtins.property
    @pulumi.getter(name="isContentModerationEnabled")
    def is_content_moderation_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) Helps remove toxic and biased content from responses.
        """
        return pulumi.get(self, "is_content_moderation_enabled")

    @is_content_moderation_enabled.setter
    def is_content_moderation_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_content_moderation_enabled", value)


if not MYPY:
    class DifStackGgcArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        Id for the GGCS instance to provision.
        """
        ocpu: pulumi.Input[_builtins.int]
        """
        (Updatable) The Minimum number of OCPUs to be made available for this Deployment.
        """
        password_secret_id: pulumi.Input[_builtins.str]
        """
        The OCID of the Secret where the deployment password is stored.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        The OCID of the subnet of the GGCS deployment's private endpoint.
        """
        artifact_object_storage_path: NotRequired[pulumi.Input[_builtins.str]]
        connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionArgsDict']]]]
        """
        (Updatable) Connection details to be associated with the Goldengate deployment.
        """
        ogg_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of OGG.
        """
        public_subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The OCID of a public subnet in the customer tenancy. Can be provided only for public GGCS deployments.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackGgcSourceArgsDict']]]]
        """
        Source Detail to configure existing or new datasource.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackGgcTargetArgsDict']]]]
        """
        Target Detail to configure existing or new datasource.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackGgcUserArgsDict']]]]
        """
        Ggcs user details to be created or updated.
        """
elif False:
    DifStackGgcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGgcArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 ocpu: pulumi.Input[_builtins.int],
                 password_secret_id: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str],
                 artifact_object_storage_path: Optional[pulumi.Input[_builtins.str]] = None,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionArgs']]]] = None,
                 ogg_version: Optional[pulumi.Input[_builtins.str]] = None,
                 public_subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcSourceArgs']]]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcTargetArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcUserArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_id: Id for the GGCS instance to provision.
        :param pulumi.Input[_builtins.int] ocpu: (Updatable) The Minimum number of OCPUs to be made available for this Deployment.
        :param pulumi.Input[_builtins.str] password_secret_id: The OCID of the Secret where the deployment password is stored.
        :param pulumi.Input[_builtins.str] subnet_id: The OCID of the subnet of the GGCS deployment's private endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionArgs']]] connections: (Updatable) Connection details to be associated with the Goldengate deployment.
        :param pulumi.Input[_builtins.str] ogg_version: Version of OGG.
        :param pulumi.Input[_builtins.str] public_subnet_id: (Updatable) The OCID of a public subnet in the customer tenancy. Can be provided only for public GGCS deployments.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackGgcSourceArgs']]] sources: Source Detail to configure existing or new datasource.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackGgcTargetArgs']]] targets: Target Detail to configure existing or new datasource.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackGgcUserArgs']]] users: Ggcs user details to be created or updated.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "ocpu", ocpu)
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if artifact_object_storage_path is not None:
            pulumi.set(__self__, "artifact_object_storage_path", artifact_object_storage_path)
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if ogg_version is not None:
            pulumi.set(__self__, "ogg_version", ogg_version)
        if public_subnet_id is not None:
            pulumi.set(__self__, "public_subnet_id", public_subnet_id)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id for the GGCS instance to provision.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def ocpu(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The Minimum number of OCPUs to be made available for this Deployment.
        """
        return pulumi.get(self, "ocpu")

    @ocpu.setter
    def ocpu(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpu", value)

    @_builtins.property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        The OCID of the Secret where the deployment password is stored.
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        The OCID of the subnet of the GGCS deployment's private endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="artifactObjectStoragePath")
    def artifact_object_storage_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "artifact_object_storage_path")

    @artifact_object_storage_path.setter
    def artifact_object_storage_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "artifact_object_storage_path", value)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionArgs']]]]:
        """
        (Updatable) Connection details to be associated with the Goldengate deployment.
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionArgs']]]]):
        pulumi.set(self, "connections", value)

    @_builtins.property
    @pulumi.getter(name="oggVersion")
    def ogg_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of OGG.
        """
        return pulumi.get(self, "ogg_version")

    @ogg_version.setter
    def ogg_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ogg_version", value)

    @_builtins.property
    @pulumi.getter(name="publicSubnetId")
    def public_subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The OCID of a public subnet in the customer tenancy. Can be provided only for public GGCS deployments.
        """
        return pulumi.get(self, "public_subnet_id")

    @public_subnet_id.setter
    def public_subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcSourceArgs']]]]:
        """
        Source Detail to configure existing or new datasource.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcTargetArgs']]]]:
        """
        Target Detail to configure existing or new datasource.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcTargetArgs']]]]):
        pulumi.set(self, "targets", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcUserArgs']]]]:
        """
        Ggcs user details to be created or updated.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class DifStackGgcConnectionArgsDict(TypedDict):
        connection_name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name of the connection to be created.
        """
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) OCID of pre-created Oracle GoldenGate connection.
        """
        dif_dependencies: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionDifDependencyArgsDict']]]]
        """
        (Updatable) List of Service Dependency Details for connection creation.
        """
        gg_admin_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Vault secret OCID containing password that Oracle GoldenGate uses to connect the associated system of the given technology.
        """
elif False:
    DifStackGgcConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGgcConnectionArgs:
    def __init__(__self__, *,
                 connection_name: pulumi.Input[_builtins.str],
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 dif_dependencies: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionDifDependencyArgs']]]] = None,
                 gg_admin_secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_name: (Updatable) Name of the connection to be created.
        :param pulumi.Input[_builtins.str] connection_id: (Updatable) OCID of pre-created Oracle GoldenGate connection.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionDifDependencyArgs']]] dif_dependencies: (Updatable) List of Service Dependency Details for connection creation.
        :param pulumi.Input[_builtins.str] gg_admin_secret_id: (Updatable) Vault secret OCID containing password that Oracle GoldenGate uses to connect the associated system of the given technology.
        """
        pulumi.set(__self__, "connection_name", connection_name)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if dif_dependencies is not None:
            pulumi.set(__self__, "dif_dependencies", dif_dependencies)
        if gg_admin_secret_id is not None:
            pulumi.set(__self__, "gg_admin_secret_id", gg_admin_secret_id)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name of the connection to be created.
        """
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) OCID of pre-created Oracle GoldenGate connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="difDependencies")
    def dif_dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionDifDependencyArgs']]]]:
        """
        (Updatable) List of Service Dependency Details for connection creation.
        """
        return pulumi.get(self, "dif_dependencies")

    @dif_dependencies.setter
    def dif_dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackGgcConnectionDifDependencyArgs']]]]):
        pulumi.set(self, "dif_dependencies", value)

    @_builtins.property
    @pulumi.getter(name="ggAdminSecretId")
    def gg_admin_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Vault secret OCID containing password that Oracle GoldenGate uses to connect the associated system of the given technology.
        """
        return pulumi.get(self, "gg_admin_secret_id")

    @gg_admin_secret_id.setter
    def gg_admin_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gg_admin_secret_id", value)


if not MYPY:
    class DifStackGgcConnectionDifDependencyArgsDict(TypedDict):
        service_instance_id: pulumi.Input[_builtins.str]
        """
        (Updatable) InstanceId of service which is part of the Stack.
        """
        service_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Supported service name.
        """
elif False:
    DifStackGgcConnectionDifDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGgcConnectionDifDependencyArgs:
    def __init__(__self__, *,
                 service_instance_id: pulumi.Input[_builtins.str],
                 service_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service_instance_id: (Updatable) InstanceId of service which is part of the Stack.
        :param pulumi.Input[_builtins.str] service_type: (Updatable) Supported service name.
        """
        pulumi.set(__self__, "service_instance_id", service_instance_id)
        pulumi.set(__self__, "service_type", service_type)

    @_builtins.property
    @pulumi.getter(name="serviceInstanceId")
    def service_instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) InstanceId of service which is part of the Stack.
        """
        return pulumi.get(self, "service_instance_id")

    @service_instance_id.setter
    def service_instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Supported service name.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_type", value)


if not MYPY:
    class DifStackGgcSourceArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        should_start_source_operations: pulumi.Input[_builtins.bool]
        """
        Boolean value that determines source operations should start or not.
        """
        source_id: pulumi.Input[_builtins.str]
        """
        Ggcs source artifact id.
        """
        target_connection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of assigned connection for the source.
        """
        target_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target uri for the GoldenGate deployment where distribution path needs to be configured.
        """
elif False:
    DifStackGgcSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGgcSourceArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 should_start_source_operations: pulumi.Input[_builtins.bool],
                 source_id: pulumi.Input[_builtins.str],
                 target_connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        :param pulumi.Input[_builtins.bool] should_start_source_operations: Boolean value that determines source operations should start or not.
        :param pulumi.Input[_builtins.str] source_id: Ggcs source artifact id.
        :param pulumi.Input[_builtins.str] target_connection_name: Name of assigned connection for the source.
        :param pulumi.Input[_builtins.str] target_uri: Target uri for the GoldenGate deployment where distribution path needs to be configured.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "should_start_source_operations", should_start_source_operations)
        pulumi.set(__self__, "source_id", source_id)
        if target_connection_name is not None:
            pulumi.set(__self__, "target_connection_name", target_connection_name)
        if target_uri is not None:
            pulumi.set(__self__, "target_uri", target_uri)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="shouldStartSourceOperations")
    def should_start_source_operations(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean value that determines source operations should start or not.
        """
        return pulumi.get(self, "should_start_source_operations")

    @should_start_source_operations.setter
    def should_start_source_operations(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "should_start_source_operations", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> pulumi.Input[_builtins.str]:
        """
        Ggcs source artifact id.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_id", value)

    @_builtins.property
    @pulumi.getter(name="targetConnectionName")
    def target_connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of assigned connection for the source.
        """
        return pulumi.get(self, "target_connection_name")

    @target_connection_name.setter
    def target_connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_connection_name", value)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target uri for the GoldenGate deployment where distribution path needs to be configured.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_uri", value)


if not MYPY:
    class DifStackGgcTargetArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        should_start_target_operations: pulumi.Input[_builtins.bool]
        """
        Boolean value that determines target operations should start or not.
        """
        target_id: pulumi.Input[_builtins.str]
        """
        GGCS target artifact id.
        """
        source_connection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of assigned connection for the target.
        """
        source_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source uri for the GoldenGate deployment from where the collector path needs to be configured.
        """
elif False:
    DifStackGgcTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGgcTargetArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 should_start_target_operations: pulumi.Input[_builtins.bool],
                 target_id: pulumi.Input[_builtins.str],
                 source_connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 source_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        :param pulumi.Input[_builtins.bool] should_start_target_operations: Boolean value that determines target operations should start or not.
        :param pulumi.Input[_builtins.str] target_id: GGCS target artifact id.
        :param pulumi.Input[_builtins.str] source_connection_name: Name of assigned connection for the target.
        :param pulumi.Input[_builtins.str] source_uri: Source uri for the GoldenGate deployment from where the collector path needs to be configured.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "should_start_target_operations", should_start_target_operations)
        pulumi.set(__self__, "target_id", target_id)
        if source_connection_name is not None:
            pulumi.set(__self__, "source_connection_name", source_connection_name)
        if source_uri is not None:
            pulumi.set(__self__, "source_uri", source_uri)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="shouldStartTargetOperations")
    def should_start_target_operations(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean value that determines target operations should start or not.
        """
        return pulumi.get(self, "should_start_target_operations")

    @should_start_target_operations.setter
    def should_start_target_operations(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "should_start_target_operations", value)

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> pulumi.Input[_builtins.str]:
        """
        GGCS target artifact id.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceConnectionName")
    def source_connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of assigned connection for the target.
        """
        return pulumi.get(self, "source_connection_name")

    @source_connection_name.setter
    def source_connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_connection_name", value)

    @_builtins.property
    @pulumi.getter(name="sourceUri")
    def source_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source uri for the GoldenGate deployment from where the collector path needs to be configured.
        """
        return pulumi.get(self, "source_uri")

    @source_uri.setter
    def source_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_uri", value)


if not MYPY:
    class DifStackGgcUserArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        secret_id: pulumi.Input[_builtins.str]
        user_name: pulumi.Input[_builtins.str]
        user_type: pulumi.Input[_builtins.str]
elif False:
    DifStackGgcUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackGgcUserArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 secret_id: pulumi.Input[_builtins.str],
                 user_name: pulumi.Input[_builtins.str],
                 user_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "user_type", user_type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to be done over the user. Allowed values are "CREATE" or "UPDATE".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter(name="userType")
    def user_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "user_type")

    @user_type.setter
    def user_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_type", value)


if not MYPY:
    class DifStackObjectstorageArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        (Updatable) Id for Object Storage instance to be provisioned.
        """
        object_versioning: pulumi.Input[_builtins.str]
        """
        (Updatable) Mentions whether the object versioning to be enabled or not,Allowed values are "ENABLED" / "DISABLED"/"SUSPENDED"
        """
        storage_tier: pulumi.Input[_builtins.str]
        """
        Mentions which storage tier to use for the bucket,Allowed values are "STANDARD" / "ARCHIVE"
        """
        auto_tiering: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) It sets the auto-tiering status on the bucket.Allowed values are "DISABLED" / "INFREQUENTACCESS"
        """
elif False:
    DifStackObjectstorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackObjectstorageArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 object_versioning: pulumi.Input[_builtins.str],
                 storage_tier: pulumi.Input[_builtins.str],
                 auto_tiering: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_id: (Updatable) Id for Object Storage instance to be provisioned.
        :param pulumi.Input[_builtins.str] object_versioning: (Updatable) Mentions whether the object versioning to be enabled or not,Allowed values are "ENABLED" / "DISABLED"/"SUSPENDED"
        :param pulumi.Input[_builtins.str] storage_tier: Mentions which storage tier to use for the bucket,Allowed values are "STANDARD" / "ARCHIVE"
        :param pulumi.Input[_builtins.str] auto_tiering: (Updatable) It sets the auto-tiering status on the bucket.Allowed values are "DISABLED" / "INFREQUENTACCESS"
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "object_versioning", object_versioning)
        pulumi.set(__self__, "storage_tier", storage_tier)
        if auto_tiering is not None:
            pulumi.set(__self__, "auto_tiering", auto_tiering)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Id for Object Storage instance to be provisioned.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="objectVersioning")
    def object_versioning(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Mentions whether the object versioning to be enabled or not,Allowed values are "ENABLED" / "DISABLED"/"SUSPENDED"
        """
        return pulumi.get(self, "object_versioning")

    @object_versioning.setter
    def object_versioning(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_versioning", value)

    @_builtins.property
    @pulumi.getter(name="storageTier")
    def storage_tier(self) -> pulumi.Input[_builtins.str]:
        """
        Mentions which storage tier to use for the bucket,Allowed values are "STANDARD" / "ARCHIVE"
        """
        return pulumi.get(self, "storage_tier")

    @storage_tier.setter
    def storage_tier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_tier", value)

    @_builtins.property
    @pulumi.getter(name="autoTiering")
    def auto_tiering(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) It sets the auto-tiering status on the bucket.Allowed values are "DISABLED" / "INFREQUENTACCESS"
        """
        return pulumi.get(self, "auto_tiering")

    @auto_tiering.setter
    def auto_tiering(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_tiering", value)


if not MYPY:
    class DifStackOkeArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        OCID of existing OKE cluster.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        Unique identifier for an oke instance.
        """
        namespace_name: pulumi.Input[_builtins.str]
        """
        Kubernetes namespace-name of OKE cluster.
        """
        component_value_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackOkeComponentValueOverrideArgsDict']]]]
        """
        Component overrides for stack specific parameters applied during artifact template rendering.
        """
        manifest_object_storage_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object storage path for the deployment manifest.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretArgsDict']]]]
        """
        List of kubernetes secrets to create or update in the namespace-name of the target cluster. Each entry source secret values from OCI vault.
        """
elif False:
    DifStackOkeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOkeArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str],
                 namespace_name: pulumi.Input[_builtins.str],
                 component_value_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOkeComponentValueOverrideArgs']]]] = None,
                 manifest_object_storage_path: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: OCID of existing OKE cluster.
        :param pulumi.Input[_builtins.str] instance_id: Unique identifier for an oke instance.
        :param pulumi.Input[_builtins.str] namespace_name: Kubernetes namespace-name of OKE cluster.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackOkeComponentValueOverrideArgs']]] component_value_overrides: Component overrides for stack specific parameters applied during artifact template rendering.
        :param pulumi.Input[_builtins.str] manifest_object_storage_path: Object storage path for the deployment manifest.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretArgs']]] secrets: List of kubernetes secrets to create or update in the namespace-name of the target cluster. Each entry source secret values from OCI vault.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "namespace_name", namespace_name)
        if component_value_overrides is not None:
            pulumi.set(__self__, "component_value_overrides", component_value_overrides)
        if manifest_object_storage_path is not None:
            pulumi.set(__self__, "manifest_object_storage_path", manifest_object_storage_path)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of existing OKE cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for an oke instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes namespace-name of OKE cluster.
        """
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace_name", value)

    @_builtins.property
    @pulumi.getter(name="componentValueOverrides")
    def component_value_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOkeComponentValueOverrideArgs']]]]:
        """
        Component overrides for stack specific parameters applied during artifact template rendering.
        """
        return pulumi.get(self, "component_value_overrides")

    @component_value_overrides.setter
    def component_value_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOkeComponentValueOverrideArgs']]]]):
        pulumi.set(self, "component_value_overrides", value)

    @_builtins.property
    @pulumi.getter(name="manifestObjectStoragePath")
    def manifest_object_storage_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object storage path for the deployment manifest.
        """
        return pulumi.get(self, "manifest_object_storage_path")

    @manifest_object_storage_path.setter
    def manifest_object_storage_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "manifest_object_storage_path", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretArgs']]]]:
        """
        List of kubernetes secrets to create or update in the namespace-name of the target cluster. Each entry source secret values from OCI vault.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class DifStackOkeComponentValueOverrideArgsDict(TypedDict):
        component_name: pulumi.Input[_builtins.str]
        """
        Logical name of the grouping independently deployable kubernetes resource artifacts for the current deployment.
        """
        value_overrides: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Free-form value overrides for the component. Each tag is a simple key-value pair with no predefined name, type, or namespace.
        Used for overriding the values in value.yaml artifact of the component.
        Example: `{"WORKER_THREADS": "8"}`
        """
elif False:
    DifStackOkeComponentValueOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOkeComponentValueOverrideArgs:
    def __init__(__self__, *,
                 component_name: pulumi.Input[_builtins.str],
                 value_overrides: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] component_name: Logical name of the grouping independently deployable kubernetes resource artifacts for the current deployment.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] value_overrides: Free-form value overrides for the component. Each tag is a simple key-value pair with no predefined name, type, or namespace.
               Used for overriding the values in value.yaml artifact of the component.
               Example: `{"WORKER_THREADS": "8"}`
        """
        pulumi.set(__self__, "component_name", component_name)
        pulumi.set(__self__, "value_overrides", value_overrides)

    @_builtins.property
    @pulumi.getter(name="componentName")
    def component_name(self) -> pulumi.Input[_builtins.str]:
        """
        Logical name of the grouping independently deployable kubernetes resource artifacts for the current deployment.
        """
        return pulumi.get(self, "component_name")

    @component_name.setter
    def component_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "component_name", value)

    @_builtins.property
    @pulumi.getter(name="valueOverrides")
    def value_overrides(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Free-form value overrides for the component. Each tag is a simple key-value pair with no predefined name, type, or namespace.
        Used for overriding the values in value.yaml artifact of the component.
        Example: `{"WORKER_THREADS": "8"}`
        """
        return pulumi.get(self, "value_overrides")

    @value_overrides.setter
    def value_overrides(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "value_overrides", value)


if not MYPY:
    class DifStackOkeSecretArgsDict(TypedDict):
        secret_datas: pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretSecretDataArgsDict']]]
        """
        List of kubernetes secret data.
        """
        secret_name: pulumi.Input[_builtins.str]
        """
        Name of the kubernetes secret of max length 63 and contain only lowercase alphanumeric characters or '-' and start and end with an alphabetic character.
        """
        template_object_storage_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object storage path for the secret template to be used for creating secret otherwise it will be created with default template.
        """
elif False:
    DifStackOkeSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOkeSecretArgs:
    def __init__(__self__, *,
                 secret_datas: pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretSecretDataArgs']]],
                 secret_name: pulumi.Input[_builtins.str],
                 template_object_storage_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretSecretDataArgs']]] secret_datas: List of kubernetes secret data.
        :param pulumi.Input[_builtins.str] secret_name: Name of the kubernetes secret of max length 63 and contain only lowercase alphanumeric characters or '-' and start and end with an alphabetic character.
        :param pulumi.Input[_builtins.str] template_object_storage_path: Object storage path for the secret template to be used for creating secret otherwise it will be created with default template.
        """
        pulumi.set(__self__, "secret_datas", secret_datas)
        pulumi.set(__self__, "secret_name", secret_name)
        if template_object_storage_path is not None:
            pulumi.set(__self__, "template_object_storage_path", template_object_storage_path)

    @_builtins.property
    @pulumi.getter(name="secretDatas")
    def secret_datas(self) -> pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretSecretDataArgs']]]:
        """
        List of kubernetes secret data.
        """
        return pulumi.get(self, "secret_datas")

    @secret_datas.setter
    def secret_datas(self, value: pulumi.Input[Sequence[pulumi.Input['DifStackOkeSecretSecretDataArgs']]]):
        pulumi.set(self, "secret_datas", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the kubernetes secret of max length 63 and contain only lowercase alphanumeric characters or '-' and start and end with an alphabetic character.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter(name="templateObjectStoragePath")
    def template_object_storage_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object storage path for the secret template to be used for creating secret otherwise it will be created with default template.
        """
        return pulumi.get(self, "template_object_storage_path")

    @template_object_storage_path.setter
    def template_object_storage_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_object_storage_path", value)


if not MYPY:
    class DifStackOkeSecretSecretDataArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Data key in the kubernetes secret.
        """
        secret_id: pulumi.Input[_builtins.str]
        """
        OCID of the Oci vault secret that provides the value for this key. The latest active secret version is used at deploy time unless otherwise configured.
        """
elif False:
    DifStackOkeSecretSecretDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOkeSecretSecretDataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Data key in the kubernetes secret.
        :param pulumi.Input[_builtins.str] secret_id: OCID of the Oci vault secret that provides the value for this key. The latest active secret version is used at deploy time unless otherwise configured.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Data key in the kubernetes secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of the Oci vault secret that provides the value for this key. The latest active secret version is used at deploy time unless otherwise configured.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class DifStackOmkArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        OCID of cluster assigned to OMK cluster-namespace.
        """
        cluster_namespace_id: pulumi.Input[_builtins.str]
        """
        OCID of existing OMK cluster-namespace.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        Unique identifier for an omk instance.
        """
        namespace_name: pulumi.Input[_builtins.str]
        """
        Kubernetes namespace-name of OMK cluster-namespace.
        """
        component_value_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackOmkComponentValueOverrideArgsDict']]]]
        """
        Component overrides for stack specific parameters applied during artifact template rendering.
        """
        manifest_object_storage_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object storage path for the deployment manifest.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretArgsDict']]]]
        """
        List of kubernetes secrets to create or update in the namespace-name of target cluster-namespace. Each entry source secret values from OCI vault.
        """
elif False:
    DifStackOmkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOmkArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 cluster_namespace_id: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str],
                 namespace_name: pulumi.Input[_builtins.str],
                 component_value_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOmkComponentValueOverrideArgs']]]] = None,
                 manifest_object_storage_path: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: OCID of cluster assigned to OMK cluster-namespace.
        :param pulumi.Input[_builtins.str] cluster_namespace_id: OCID of existing OMK cluster-namespace.
        :param pulumi.Input[_builtins.str] instance_id: Unique identifier for an omk instance.
        :param pulumi.Input[_builtins.str] namespace_name: Kubernetes namespace-name of OMK cluster-namespace.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackOmkComponentValueOverrideArgs']]] component_value_overrides: Component overrides for stack specific parameters applied during artifact template rendering.
        :param pulumi.Input[_builtins.str] manifest_object_storage_path: Object storage path for the deployment manifest.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretArgs']]] secrets: List of kubernetes secrets to create or update in the namespace-name of target cluster-namespace. Each entry source secret values from OCI vault.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_namespace_id", cluster_namespace_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "namespace_name", namespace_name)
        if component_value_overrides is not None:
            pulumi.set(__self__, "component_value_overrides", component_value_overrides)
        if manifest_object_storage_path is not None:
            pulumi.set(__self__, "manifest_object_storage_path", manifest_object_storage_path)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of cluster assigned to OMK cluster-namespace.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="clusterNamespaceId")
    def cluster_namespace_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of existing OMK cluster-namespace.
        """
        return pulumi.get(self, "cluster_namespace_id")

    @cluster_namespace_id.setter
    def cluster_namespace_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_namespace_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for an omk instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes namespace-name of OMK cluster-namespace.
        """
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace_name", value)

    @_builtins.property
    @pulumi.getter(name="componentValueOverrides")
    def component_value_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOmkComponentValueOverrideArgs']]]]:
        """
        Component overrides for stack specific parameters applied during artifact template rendering.
        """
        return pulumi.get(self, "component_value_overrides")

    @component_value_overrides.setter
    def component_value_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOmkComponentValueOverrideArgs']]]]):
        pulumi.set(self, "component_value_overrides", value)

    @_builtins.property
    @pulumi.getter(name="manifestObjectStoragePath")
    def manifest_object_storage_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object storage path for the deployment manifest.
        """
        return pulumi.get(self, "manifest_object_storage_path")

    @manifest_object_storage_path.setter
    def manifest_object_storage_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "manifest_object_storage_path", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretArgs']]]]:
        """
        List of kubernetes secrets to create or update in the namespace-name of target cluster-namespace. Each entry source secret values from OCI vault.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class DifStackOmkComponentValueOverrideArgsDict(TypedDict):
        component_name: pulumi.Input[_builtins.str]
        """
        Logical name of the grouping independently deployable kubernetes resource artifacts for the current deployment.
        """
        value_overrides: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Free-form value overrides for the component. Each tag is a simple key-value pair with no predefined name, type, or namespace.
        Used for overriding the values in value.yaml artifact of the component.
        Example: `{"WORKER_THREADS": "8"}`
        """
elif False:
    DifStackOmkComponentValueOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOmkComponentValueOverrideArgs:
    def __init__(__self__, *,
                 component_name: pulumi.Input[_builtins.str],
                 value_overrides: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] component_name: Logical name of the grouping independently deployable kubernetes resource artifacts for the current deployment.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] value_overrides: Free-form value overrides for the component. Each tag is a simple key-value pair with no predefined name, type, or namespace.
               Used for overriding the values in value.yaml artifact of the component.
               Example: `{"WORKER_THREADS": "8"}`
        """
        pulumi.set(__self__, "component_name", component_name)
        pulumi.set(__self__, "value_overrides", value_overrides)

    @_builtins.property
    @pulumi.getter(name="componentName")
    def component_name(self) -> pulumi.Input[_builtins.str]:
        """
        Logical name of the grouping independently deployable kubernetes resource artifacts for the current deployment.
        """
        return pulumi.get(self, "component_name")

    @component_name.setter
    def component_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "component_name", value)

    @_builtins.property
    @pulumi.getter(name="valueOverrides")
    def value_overrides(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Free-form value overrides for the component. Each tag is a simple key-value pair with no predefined name, type, or namespace.
        Used for overriding the values in value.yaml artifact of the component.
        Example: `{"WORKER_THREADS": "8"}`
        """
        return pulumi.get(self, "value_overrides")

    @value_overrides.setter
    def value_overrides(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "value_overrides", value)


if not MYPY:
    class DifStackOmkSecretArgsDict(TypedDict):
        secret_datas: pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretSecretDataArgsDict']]]
        """
        List of kubernetes secret data.
        """
        secret_name: pulumi.Input[_builtins.str]
        """
        Name of the kubernetes secret of max length 63 and contain only lowercase alphanumeric characters or '-' and start and end with an alphabetic character.
        """
        template_object_storage_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object storage path for the secret template to be used for creating secret otherwise it will be created with default template.
        """
elif False:
    DifStackOmkSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOmkSecretArgs:
    def __init__(__self__, *,
                 secret_datas: pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretSecretDataArgs']]],
                 secret_name: pulumi.Input[_builtins.str],
                 template_object_storage_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretSecretDataArgs']]] secret_datas: List of kubernetes secret data.
        :param pulumi.Input[_builtins.str] secret_name: Name of the kubernetes secret of max length 63 and contain only lowercase alphanumeric characters or '-' and start and end with an alphabetic character.
        :param pulumi.Input[_builtins.str] template_object_storage_path: Object storage path for the secret template to be used for creating secret otherwise it will be created with default template.
        """
        pulumi.set(__self__, "secret_datas", secret_datas)
        pulumi.set(__self__, "secret_name", secret_name)
        if template_object_storage_path is not None:
            pulumi.set(__self__, "template_object_storage_path", template_object_storage_path)

    @_builtins.property
    @pulumi.getter(name="secretDatas")
    def secret_datas(self) -> pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretSecretDataArgs']]]:
        """
        List of kubernetes secret data.
        """
        return pulumi.get(self, "secret_datas")

    @secret_datas.setter
    def secret_datas(self, value: pulumi.Input[Sequence[pulumi.Input['DifStackOmkSecretSecretDataArgs']]]):
        pulumi.set(self, "secret_datas", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the kubernetes secret of max length 63 and contain only lowercase alphanumeric characters or '-' and start and end with an alphabetic character.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter(name="templateObjectStoragePath")
    def template_object_storage_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object storage path for the secret template to be used for creating secret otherwise it will be created with default template.
        """
        return pulumi.get(self, "template_object_storage_path")

    @template_object_storage_path.setter
    def template_object_storage_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_object_storage_path", value)


if not MYPY:
    class DifStackOmkSecretSecretDataArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Data key in the kubernetes secret.
        """
        secret_id: pulumi.Input[_builtins.str]
        """
        OCID of the Oci vault secret that provides the value for this key. The latest active secret version is used at deploy time unless otherwise configured.
        """
elif False:
    DifStackOmkSecretSecretDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackOmkSecretSecretDataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Data key in the kubernetes secret.
        :param pulumi.Input[_builtins.str] secret_id: OCID of the Oci vault secret that provides the value for this key. The latest active secret version is used at deploy time unless otherwise configured.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Data key in the kubernetes secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        OCID of the Oci vault secret that provides the value for this key. The latest active secret version is used at deploy time unless otherwise configured.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class DifStackServiceDetailArgsDict(TypedDict):
        additional_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailArgsDict']]]]
        """
        Additional details about the provisioned services
        """
        current_artifact_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        name of the service
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user-friendly name. Should be unique per compartment. Avoid entering confidential information.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID for the service instance.
        """
        service_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID for the service
        """
        service_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        name of the cloud service
        """
        service_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        url for the service
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        state of the service
        """
elif False:
    DifStackServiceDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackServiceDetailArgs:
    def __init__(__self__, *,
                 additional_details: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailArgs']]]] = None,
                 current_artifact_path: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_type: Optional[pulumi.Input[_builtins.str]] = None,
                 service_url: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailArgs']]] additional_details: Additional details about the provisioned services
        :param pulumi.Input[_builtins.str] current_artifact_path: name of the service
        :param pulumi.Input[_builtins.str] display_name: A user-friendly name. Should be unique per compartment. Avoid entering confidential information.
        :param pulumi.Input[_builtins.str] instance_id: ID for the service instance.
        :param pulumi.Input[_builtins.str] service_id: ID for the service
        :param pulumi.Input[_builtins.str] service_type: name of the cloud service
        :param pulumi.Input[_builtins.str] service_url: url for the service
        :param pulumi.Input[_builtins.str] status: state of the service
        """
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if current_artifact_path is not None:
            pulumi.set(__self__, "current_artifact_path", current_artifact_path)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailArgs']]]]:
        """
        Additional details about the provisioned services
        """
        return pulumi.get(self, "additional_details")

    @additional_details.setter
    def additional_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailArgs']]]]):
        pulumi.set(self, "additional_details", value)

    @_builtins.property
    @pulumi.getter(name="currentArtifactPath")
    def current_artifact_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        name of the service
        """
        return pulumi.get(self, "current_artifact_path")

    @current_artifact_path.setter
    def current_artifact_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_artifact_path", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user-friendly name. Should be unique per compartment. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID for the service instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID for the service
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        name of the cloud service
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_type", value)

    @_builtins.property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        url for the service
        """
        return pulumi.get(self, "service_url")

    @service_url.setter
    def service_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_url", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        state of the service
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DifStackServiceDetailAdditionalDetailArgsDict(TypedDict):
        assigned_connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailAssignedConnectionArgsDict']]]]
        """
        connections assigned to Golden Gate deployment
        """
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of cluster assigned to OMK cluster-namespace.
        """
        endpoint_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailEndpointDetailArgsDict']]]]
        """
        details of all endpoints assigned to cluster
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of model
        """
        model_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        version of model
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kubernetes namespace-name of omk cluster-namespace.
        """
        oci_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        region of cluster
        """
        private_endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of model
        """
elif False:
    DifStackServiceDetailAdditionalDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackServiceDetailAdditionalDetailArgs:
    def __init__(__self__, *,
                 assigned_connections: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailAssignedConnectionArgs']]]] = None,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_details: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailEndpointDetailArgs']]]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 model_version: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 oci_region: Optional[pulumi.Input[_builtins.str]] = None,
                 private_endpoint_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailAssignedConnectionArgs']]] assigned_connections: connections assigned to Golden Gate deployment
        :param pulumi.Input[_builtins.str] cluster_id: OCID of cluster assigned to OMK cluster-namespace.
        :param pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailEndpointDetailArgs']]] endpoint_details: details of all endpoints assigned to cluster
        :param pulumi.Input[_builtins.str] model_id: OCID of model
        :param pulumi.Input[_builtins.str] model_version: version of model
        :param pulumi.Input[_builtins.str] namespace: Kubernetes namespace-name of omk cluster-namespace.
        :param pulumi.Input[_builtins.str] oci_region: region of cluster
        :param pulumi.Input[_builtins.str] private_endpoint_id: OCID of model
        """
        if assigned_connections is not None:
            pulumi.set(__self__, "assigned_connections", assigned_connections)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if endpoint_details is not None:
            pulumi.set(__self__, "endpoint_details", endpoint_details)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if model_version is not None:
            pulumi.set(__self__, "model_version", model_version)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if oci_region is not None:
            pulumi.set(__self__, "oci_region", oci_region)
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)

    @_builtins.property
    @pulumi.getter(name="assignedConnections")
    def assigned_connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailAssignedConnectionArgs']]]]:
        """
        connections assigned to Golden Gate deployment
        """
        return pulumi.get(self, "assigned_connections")

    @assigned_connections.setter
    def assigned_connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailAssignedConnectionArgs']]]]):
        pulumi.set(self, "assigned_connections", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of cluster assigned to OMK cluster-namespace.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="endpointDetails")
    def endpoint_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailEndpointDetailArgs']]]]:
        """
        details of all endpoints assigned to cluster
        """
        return pulumi.get(self, "endpoint_details")

    @endpoint_details.setter
    def endpoint_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DifStackServiceDetailAdditionalDetailEndpointDetailArgs']]]]):
        pulumi.set(self, "endpoint_details", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of model
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        version of model
        """
        return pulumi.get(self, "model_version")

    @model_version.setter
    def model_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_version", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kubernetes namespace-name of omk cluster-namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="ociRegion")
    def oci_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        region of cluster
        """
        return pulumi.get(self, "oci_region")

    @oci_region.setter
    def oci_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oci_region", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of model
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_id", value)


if not MYPY:
    class DifStackServiceDetailAdditionalDetailAssignedConnectionArgsDict(TypedDict):
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the connection.
        """
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the connection.
        """
        requested_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies who has made this connection.
        """
elif False:
    DifStackServiceDetailAdditionalDetailAssignedConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackServiceDetailAdditionalDetailAssignedConnectionArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 requested_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_id: OCID of the connection.
        :param pulumi.Input[_builtins.str] connection_name: Name of the connection.
        :param pulumi.Input[_builtins.str] requested_by: Specifies who has made this connection.
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if requested_by is not None:
            pulumi.set(__self__, "requested_by", requested_by)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the connection.
        """
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter(name="requestedBy")
    def requested_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies who has made this connection.
        """
        return pulumi.get(self, "requested_by")

    @requested_by.setter
    def requested_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "requested_by", value)


if not MYPY:
    class DifStackServiceDetailAdditionalDetailEndpointDetailArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the endpoint.
        """
        endpoint_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier for each endpoint.
        """
elif False:
    DifStackServiceDetailAdditionalDetailEndpointDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DifStackServiceDetailAdditionalDetailEndpointDetailArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint_id: OCID of the endpoint.
        :param pulumi.Input[_builtins.str] endpoint_name: Identifier for each endpoint.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier for each endpoint.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_name", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundEnvelopeArgsDict(TypedDict):
        reference_endpoint: pulumi.Input[_builtins.str]
        """
        (Updatable) The device endpoint.
        """
        envelope_mapping: NotRequired[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict']]
        """
        (Updatable) Maps the metadata fields from the inbound payload using JQ. These mappings allow you to extract specific metadata such as timestamps using JQ expressions.
        """
        reference_payload: NotRequired[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict']]
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
elif False:
    IotDigitalTwinAdapterInboundEnvelopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundEnvelopeArgs:
    def __init__(__self__, *,
                 reference_endpoint: pulumi.Input[_builtins.str],
                 envelope_mapping: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs']] = None,
                 reference_payload: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] reference_endpoint: (Updatable) The device endpoint.
        :param pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs'] envelope_mapping: (Updatable) Maps the metadata fields from the inbound payload using JQ. These mappings allow you to extract specific metadata such as timestamps using JQ expressions.
        :param pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs'] reference_payload: (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        pulumi.set(__self__, "reference_endpoint", reference_endpoint)
        if envelope_mapping is not None:
            pulumi.set(__self__, "envelope_mapping", envelope_mapping)
        if reference_payload is not None:
            pulumi.set(__self__, "reference_payload", reference_payload)

    @_builtins.property
    @pulumi.getter(name="referenceEndpoint")
    def reference_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The device endpoint.
        """
        return pulumi.get(self, "reference_endpoint")

    @reference_endpoint.setter
    def reference_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reference_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="envelopeMapping")
    def envelope_mapping(self) -> Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs']]:
        """
        (Updatable) Maps the metadata fields from the inbound payload using JQ. These mappings allow you to extract specific metadata such as timestamps using JQ expressions.
        """
        return pulumi.get(self, "envelope_mapping")

    @envelope_mapping.setter
    def envelope_mapping(self, value: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs']]):
        pulumi.set(self, "envelope_mapping", value)

    @_builtins.property
    @pulumi.getter(name="referencePayload")
    def reference_payload(self) -> Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs']]:
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        return pulumi.get(self, "reference_payload")

    @reference_payload.setter
    def reference_payload(self, value: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs']]):
        pulumi.set(self, "reference_payload", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict(TypedDict):
        time_observed: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) JQ expression to extract the observation timestamp from the payload. If not specified, the system will default to using `timeReceived` as the timestamp.  Example: For payload `{"time": "<timestamp>","temp": 65,"hum": 55}` 'timeObserved' can be mapped as [JQ Expression](https://jqplay.org/) `$.time`.
        """
elif False:
    IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs:
    def __init__(__self__, *,
                 time_observed: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_observed: (Updatable) JQ expression to extract the observation timestamp from the payload. If not specified, the system will default to using `timeReceived` as the timestamp.  Example: For payload `{"time": "<timestamp>","temp": 65,"hum": 55}` 'timeObserved' can be mapped as [JQ Expression](https://jqplay.org/) `$.time`.
        """
        if time_observed is not None:
            pulumi.set(__self__, "time_observed", time_observed)

    @_builtins.property
    @pulumi.getter(name="timeObserved")
    def time_observed(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) JQ expression to extract the observation timestamp from the payload. If not specified, the system will default to using `timeReceived` as the timestamp.  Example: For payload `{"time": "<timestamp>","temp": 65,"hum": 55}` 'timeObserved' can be mapped as [JQ Expression](https://jqplay.org/) `$.time`.
        """
        return pulumi.get(self, "time_observed")

    @time_observed.setter
    def time_observed(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_observed", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict(TypedDict):
        data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) JSON raw data.
        """
        data_format: pulumi.Input[_builtins.str]
        """
        (Updatable) Data format of the payload.
        """
elif False:
    IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 data_format: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] data: (Updatable) JSON raw data.
        :param pulumi.Input[_builtins.str] data_format: (Updatable) Data format of the payload.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "data_format", data_format)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) JSON raw data.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Data format of the payload.
        """
        return pulumi.get(self, "data_format")

    @data_format.setter
    def data_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_format", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundRouteArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
        """
        (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Meaningful write up about the inbound route.
        """
        payload_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model's context or schema.

        The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.

        Example: Given payload: { "time": "<timestamp>", "temp": 65, "hum": 55 } And mapping: { "temperature": "$.temp", "humidity": "$.hum", "timeObserved": "$.time" } The output will be: { "temperature": 65, "humidity": 55, "timeObserved": "<timestamp>" }
        """
        reference_payload: NotRequired[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict']]
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
elif False:
    IotDigitalTwinAdapterInboundRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundRouteArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 payload_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 reference_payload: Optional[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] condition: (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
        :param pulumi.Input[_builtins.str] description: (Updatable) Meaningful write up about the inbound route.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] payload_mapping: (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model's context or schema.
               
               The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.
               
               Example: Given payload: { "time": "<timestamp>", "temp": 65, "hum": 55 } And mapping: { "temperature": "$.temp", "humidity": "$.hum", "timeObserved": "$.time" } The output will be: { "temperature": 65, "humidity": 55, "timeObserved": "<timestamp>" }
        :param pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs'] reference_payload: (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if payload_mapping is not None:
            pulumi.set(__self__, "payload_mapping", payload_mapping)
        if reference_payload is not None:
            pulumi.set(__self__, "reference_payload", reference_payload)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Meaningful write up about the inbound route.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="payloadMapping")
    def payload_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model's context or schema.

        The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.

        Example: Given payload: { "time": "<timestamp>", "temp": 65, "hum": 55 } And mapping: { "temperature": "$.temp", "humidity": "$.hum", "timeObserved": "$.time" } The output will be: { "temperature": 65, "humidity": 55, "timeObserved": "<timestamp>" }
        """
        return pulumi.get(self, "payload_mapping")

    @payload_mapping.setter
    def payload_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "payload_mapping", value)

    @_builtins.property
    @pulumi.getter(name="referencePayload")
    def reference_payload(self) -> Optional[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs']]:
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        return pulumi.get(self, "reference_payload")

    @reference_payload.setter
    def reference_payload(self, value: Optional[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs']]):
        pulumi.set(self, "reference_payload", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict(TypedDict):
        data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) JSON raw data.
        """
        data_format: pulumi.Input[_builtins.str]
        """
        (Updatable) Data format of the payload.
        """
elif False:
    IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundRouteReferencePayloadArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 data_format: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] data: (Updatable) JSON raw data.
        :param pulumi.Input[_builtins.str] data_format: (Updatable) Data format of the payload.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "data_format", data_format)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) JSON raw data.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Data format of the payload.
        """
        return pulumi.get(self, "data_format")

    @data_format.setter
    def data_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_format", value)


if not MYPY:
    class IotIotDomainDataRetentionPeriodsInDayArgsDict(TypedDict):
        historized_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any normalized data sent to IoT devices would be retained for.
        """
        raw_command_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any raw command data sent to IoT devices would be retained for.
        """
        raw_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any raw data sent to IoT devices would be retained for.
        """
        rejected_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any data sent to IoT devices would be retained for.
        """
elif False:
    IotIotDomainDataRetentionPeriodsInDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotIotDomainDataRetentionPeriodsInDayArgs:
    def __init__(__self__, *,
                 historized_data: Optional[pulumi.Input[_builtins.int]] = None,
                 raw_command_data: Optional[pulumi.Input[_builtins.int]] = None,
                 raw_data: Optional[pulumi.Input[_builtins.int]] = None,
                 rejected_data: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] historized_data: Number of days for which any normalized data sent to IoT devices would be retained for.
        :param pulumi.Input[_builtins.int] raw_command_data: Number of days for which any raw command data sent to IoT devices would be retained for.
        :param pulumi.Input[_builtins.int] raw_data: Number of days for which any raw data sent to IoT devices would be retained for.
        :param pulumi.Input[_builtins.int] rejected_data: Number of days for which any data sent to IoT devices would be retained for.
        """
        if historized_data is not None:
            pulumi.set(__self__, "historized_data", historized_data)
        if raw_command_data is not None:
            pulumi.set(__self__, "raw_command_data", raw_command_data)
        if raw_data is not None:
            pulumi.set(__self__, "raw_data", raw_data)
        if rejected_data is not None:
            pulumi.set(__self__, "rejected_data", rejected_data)

    @_builtins.property
    @pulumi.getter(name="historizedData")
    def historized_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any normalized data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "historized_data")

    @historized_data.setter
    def historized_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "historized_data", value)

    @_builtins.property
    @pulumi.getter(name="rawCommandData")
    def raw_command_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any raw command data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "raw_command_data")

    @raw_command_data.setter
    def raw_command_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "raw_command_data", value)

    @_builtins.property
    @pulumi.getter(name="rawData")
    def raw_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any raw data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "raw_data")

    @raw_data.setter
    def raw_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "raw_data", value)

    @_builtins.property
    @pulumi.getter(name="rejectedData")
    def rejected_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "rejected_data")

    @rejected_data.setter
    def rejected_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rejected_data", value)


if not MYPY:
    class ManagedKafkaKafkaClusterAccessSubnetArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) Subnets OCIDs
        """
elif False:
    ManagedKafkaKafkaClusterAccessSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterAccessSubnetArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: (Updatable) Subnets OCIDs
        """
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Subnets OCIDs
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ManagedKafkaKafkaClusterBrokerShapeArgsDict(TypedDict):
        node_count: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of Kafka broker nodes
        """
        ocpu_count: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of OCPUs per nodes
        """
        node_shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Node shape for broker is passed as part of cluster creation, similar to VM.Standard.A1.Flex
        """
        storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Size of the storage per nodes.
        """
elif False:
    ManagedKafkaKafkaClusterBrokerShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterBrokerShapeArgs:
    def __init__(__self__, *,
                 node_count: pulumi.Input[_builtins.int],
                 ocpu_count: pulumi.Input[_builtins.int],
                 node_shape: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] node_count: (Updatable) Number of Kafka broker nodes
        :param pulumi.Input[_builtins.int] ocpu_count: (Updatable) Number of OCPUs per nodes
        :param pulumi.Input[_builtins.str] node_shape: (Updatable) Node shape for broker is passed as part of cluster creation, similar to VM.Standard.A1.Flex
        :param pulumi.Input[_builtins.int] storage_size_in_gbs: (Updatable) Size of the storage per nodes.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        if node_shape is not None:
            pulumi.set(__self__, "node_shape", node_shape)
        if storage_size_in_gbs is not None:
            pulumi.set(__self__, "storage_size_in_gbs", storage_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of Kafka broker nodes
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "node_count", value)

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of OCPUs per nodes
        """
        return pulumi.get(self, "ocpu_count")

    @ocpu_count.setter
    def ocpu_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpu_count", value)

    @_builtins.property
    @pulumi.getter(name="nodeShape")
    def node_shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Node shape for broker is passed as part of cluster creation, similar to VM.Standard.A1.Flex
        """
        return pulumi.get(self, "node_shape")

    @node_shape.setter
    def node_shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_shape", value)

    @_builtins.property
    @pulumi.getter(name="storageSizeInGbs")
    def storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Size of the storage per nodes.
        """
        return pulumi.get(self, "storage_size_in_gbs")

    @storage_size_in_gbs.setter
    def storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_size_in_gbs", value)


if not MYPY:
    class ManagedKafkaKafkaClusterConfigLatestConfigArgsDict(TypedDict):
        properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) Cluster configuration key-value pairs
        """
        config_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) ID cluster configuration
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        version_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Version of the cluster configuration


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedKafkaKafkaClusterConfigLatestConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterConfigLatestConfigArgs:
    def __init__(__self__, *,
                 properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 config_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 version_number: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: (Updatable) Cluster configuration key-value pairs
        :param pulumi.Input[_builtins.str] config_id: (Updatable) ID cluster configuration
        :param pulumi.Input[_builtins.str] time_created: (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        :param pulumi.Input[_builtins.int] version_number: (Updatable) Version of the cluster configuration
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "properties", properties)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if version_number is not None:
            pulumi.set(__self__, "version_number", version_number)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Cluster configuration key-value pairs
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) ID cluster configuration
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Version of the cluster configuration


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version_number")

    @version_number.setter
    def version_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version_number", value)


if not MYPY:
    class ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bootstrap URL
        """
elif False:
    ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterKafkaBootstrapUrlArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Kafka listener providing this bootstrap URL
        :param pulumi.Input[_builtins.str] url: Bootstrap URL
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bootstrap URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgsDict(TypedDict):
        password_type: pulumi.Input[_builtins.str]
        """
        Password type
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for the ADW to be created in User Tenancy. The password must be between 12 and 30 characters long, and must contain at least 1 uppercase, 1 lowercase, and 1 numeric character. It cannot contain the double quote symbol (") or the username "admin", regardless of casing.
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vault secret to use as the ADW admin password.
        """
elif False:
    ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgs:
    def __init__(__self__, *,
                 password_type: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password_type: Password type
        :param pulumi.Input[_builtins.str] password: Password for the ADW to be created in User Tenancy. The password must be between 12 and 30 characters long, and must contain at least 1 uppercase, 1 lowercase, and 1 numeric character. It cannot contain the double quote symbol (") or the username "admin", regardless of casing.
        :param pulumi.Input[_builtins.str] secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vault secret to use as the ADW admin password.
        """
        pulumi.set(__self__, "password_type", password_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="passwordType")
    def password_type(self) -> pulumi.Input[_builtins.str]:
        """
        Password type
        """
        return pulumi.get(self, "password_type")

    @password_type.setter
    def password_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for the ADW to be created in User Tenancy. The password must be between 12 and 30 characters long, and must contain at least 1 uppercase, 1 lowercase, and 1 numeric character. It cannot contain the double quote symbol (") or the username "admin", regardless of casing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vault secret to use as the ADW admin password.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgsDict(TypedDict):
        idcs_domain_id: NotRequired[pulumi.Input[_builtins.str]]
        license_model: NotRequired[pulumi.Input[_builtins.str]]
        network_details: NotRequired[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict']]
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgs:
    def __init__(__self__, *,
                 idcs_domain_id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_model: Optional[pulumi.Input[_builtins.str]] = None,
                 network_details: Optional[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs']] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        if idcs_domain_id is not None:
            pulumi.set(__self__, "idcs_domain_id", idcs_domain_id)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)
        if network_details is not None:
            pulumi.set(__self__, "network_details", network_details)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="idcsDomainId")
    def idcs_domain_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "idcs_domain_id")

    @idcs_domain_id.setter
    def idcs_domain_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idcs_domain_id", value)

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_model", value)

    @_builtins.property
    @pulumi.getter(name="networkDetails")
    def network_details(self) -> Optional[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs']]:
        return pulumi.get(self, "network_details")

    @network_details.setter
    def network_details(self, value: Optional[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs']]):
        pulumi.set(self, "network_details", value)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict(TypedDict):
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs:
    def __init__(__self__, *,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class GetAiDataPlatformAiDataPlatformsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAiDataPlatformAiDataPlatformsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAiDataPlatformAiDataPlatformsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiPlatformApiPlatformInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiPlatformApiPlatformInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiPlatformApiPlatformInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadatasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadatasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadatasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiControlsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiRequestsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBatchBatchContextShapesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name identifying the shape.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetBatchBatchContextShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBatchBatchContextShapesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name identifying the shape.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name identifying the shape.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBatchBatchContextsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the service managed fleet.
        """
        values: Sequence[_builtins.str]
        """
        Mapping of tag value to its priority.
        """
        regex: NotRequired[_builtins.bool]
elif False:
    GetBatchBatchContextsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBatchBatchContextsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the service managed fleet.
        :param Sequence[_builtins.str] values: Mapping of tag value to its priority.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the service managed fleet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Mapping of tag value to its priority.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBatchBatchJobPoolsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetBatchBatchJobPoolsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBatchBatchJobPoolsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBatchBatchTaskEnvironmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the NfsVolume.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetBatchBatchTaskEnvironmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBatchBatchTaskEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the NfsVolume.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the NfsVolume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBatchBatchTaskProfilesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetBatchBatchTaskProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBatchBatchTaskProfilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Discovered Resource Name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Discovered Resource Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAwsIdentityConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAwsIdentityConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAwsIdentityConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAwsKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAwsKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAwsKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobContainersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobMountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpKeyRingsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDifStacksFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDifStacksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDifStacksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinAdaptersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinAdaptersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinAdaptersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinRelationshipsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinRelationshipsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinRelationshipsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotIotDomainGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotIotDomainGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotIotDomainGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotIotDomainsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotIotDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotIotDomainsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClusterConfigVersionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClusterConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClusterConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClusterConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClustersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClustersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the Kafka listener providing this bootstrap URL
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaNodeShapesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name to filter on.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaNodeShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaNodeShapesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name to filter on.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name to filter on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudExternalLocationMappingMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudExternalLocationMappingMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudExternalLocationMappingMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudExternalLocationSummariesMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudExternalLocationSummariesMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudExternalLocationSummariesMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudExternalLocationsMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudExternalLocationsMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudExternalLocationsMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudMulticloudsubscriptionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudMulticloudsubscriptionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudMulticloudsubscriptionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudOmHubMulticloudResourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudOmHubMulticloudResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudOmHubMulticloudResourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudResourceAnchorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudResourceAnchorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudResourceAnchorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPsaPrivateServiceAccessesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPsaPrivateServiceAccessesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPsaPrivateServiceAccessesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPsaPsaServicesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPsaPsaServicesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPsaPsaServicesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPsaPsaWorkRequestErrorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPsaPsaWorkRequestErrorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPsaPsaWorkRequestErrorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPsaPsaWorkRequestLogsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPsaPsaWorkRequestLogsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPsaPsaWorkRequestLogsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPsaPsaWorkRequestsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetPsaPsaWorkRequestsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPsaPsaWorkRequestsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceAnalyticsMonitoredRegionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceAnalyticsMonitoredRegionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceAnalyticsMonitoredRegionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceAnalyticsResourceAnalyticsInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceAnalyticsResourceAnalyticsInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceAnalyticsResourceAnalyticsInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceAnalyticsTenancyAttachmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceAnalyticsTenancyAttachmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceAnalyticsTenancyAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainAgreementRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainAgreementRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainAgreementRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainApplicablePatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainApplicablePatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainApplicablePatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerBackupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerBackupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


