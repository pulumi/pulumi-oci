# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiPlatformApiPlatformInstanceIdcsAppArgs',
    'ApiPlatformApiPlatformInstanceIdcsAppArgsDict',
    'ApiPlatformApiPlatformInstanceUriArgs',
    'ApiPlatformApiPlatformInstanceUriArgsDict',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgs',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict',
    'DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgs',
    'DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict',
    'IotDigitalTwinAdapterInboundEnvelopeArgs',
    'IotDigitalTwinAdapterInboundEnvelopeArgsDict',
    'IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs',
    'IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict',
    'IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs',
    'IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict',
    'IotDigitalTwinAdapterInboundRouteArgs',
    'IotDigitalTwinAdapterInboundRouteArgsDict',
    'IotDigitalTwinAdapterInboundRouteReferencePayloadArgs',
    'IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict',
    'IotIotDomainDataRetentionPeriodsInDayArgs',
    'IotIotDomainDataRetentionPeriodsInDayArgsDict',
    'ManagedKafkaKafkaClusterAccessSubnetArgs',
    'ManagedKafkaKafkaClusterAccessSubnetArgsDict',
    'ManagedKafkaKafkaClusterBrokerShapeArgs',
    'ManagedKafkaKafkaClusterBrokerShapeArgsDict',
    'ManagedKafkaKafkaClusterConfigLatestConfigArgs',
    'ManagedKafkaKafkaClusterConfigLatestConfigArgsDict',
    'ManagedKafkaKafkaClusterKafkaBootstrapUrlArgs',
    'ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict',
    'ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgs',
    'ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgsDict',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgs',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgsDict',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs',
    'ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict',
    'GetAiDataPlatformAiDataPlatformsFilterArgs',
    'GetAiDataPlatformAiDataPlatformsFilterArgsDict',
    'GetApiPlatformApiPlatformInstancesFilterArgs',
    'GetApiPlatformApiPlatformInstancesFilterArgsDict',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict',
    'GetApiaccesscontrolApiMetadatasFilterArgs',
    'GetApiaccesscontrolApiMetadatasFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgs',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureKeysFilterArgs',
    'GetDbmulticloudOracleDbAzureKeysFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgs',
    'GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpKeyRingsFilterArgs',
    'GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict',
    'GetDbmulticloudOracleDbGcpKeysFilterArgs',
    'GetDbmulticloudOracleDbGcpKeysFilterArgsDict',
    'GetIotDigitalTwinAdaptersFilterArgs',
    'GetIotDigitalTwinAdaptersFilterArgsDict',
    'GetIotDigitalTwinInstancesFilterArgs',
    'GetIotDigitalTwinInstancesFilterArgsDict',
    'GetIotDigitalTwinModelsFilterArgs',
    'GetIotDigitalTwinModelsFilterArgsDict',
    'GetIotDigitalTwinRelationshipsFilterArgs',
    'GetIotDigitalTwinRelationshipsFilterArgsDict',
    'GetIotIotDomainGroupsFilterArgs',
    'GetIotIotDomainGroupsFilterArgsDict',
    'GetIotIotDomainsFilterArgs',
    'GetIotIotDomainsFilterArgsDict',
    'GetManagedKafkaKafkaClusterConfigVersionsFilterArgs',
    'GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict',
    'GetManagedKafkaKafkaClusterConfigsFilterArgs',
    'GetManagedKafkaKafkaClusterConfigsFilterArgsDict',
    'GetManagedKafkaKafkaClustersFilterArgs',
    'GetManagedKafkaKafkaClustersFilterArgsDict',
    'GetMulticloudExternalLocationMappingMetadataFilterArgs',
    'GetMulticloudExternalLocationMappingMetadataFilterArgsDict',
    'GetMulticloudExternalLocationSummariesMetadataFilterArgs',
    'GetMulticloudExternalLocationSummariesMetadataFilterArgsDict',
    'GetMulticloudExternalLocationsMetadataFilterArgs',
    'GetMulticloudExternalLocationsMetadataFilterArgsDict',
    'GetMulticloudResourceAnchorsFilterArgs',
    'GetMulticloudResourceAnchorsFilterArgsDict',
    'GetResourceAnalyticsMonitoredRegionsFilterArgs',
    'GetResourceAnalyticsMonitoredRegionsFilterArgsDict',
    'GetResourceAnalyticsResourceAnalyticsInstancesFilterArgs',
    'GetResourceAnalyticsResourceAnalyticsInstancesFilterArgsDict',
    'GetResourceAnalyticsTenancyAttachmentsFilterArgs',
    'GetResourceAnalyticsTenancyAttachmentsFilterArgsDict',
    'GetWlmsManagedInstanceScanResultsFilterArgs',
    'GetWlmsManagedInstanceScanResultsFilterArgsDict',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgs',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict',
    'GetWlmsManagedInstanceServersFilterArgs',
    'GetWlmsManagedInstanceServersFilterArgsDict',
    'GetWlmsManagedInstancesFilterArgs',
    'GetWlmsManagedInstancesFilterArgsDict',
    'GetWlmsWlsDomainAgreementRecordsFilterArgs',
    'GetWlmsWlsDomainAgreementRecordsFilterArgsDict',
    'GetWlmsWlsDomainApplicablePatchesFilterArgs',
    'GetWlmsWlsDomainApplicablePatchesFilterArgsDict',
    'GetWlmsWlsDomainScanResultsFilterArgs',
    'GetWlmsWlsDomainScanResultsFilterArgsDict',
    'GetWlmsWlsDomainServerBackupsFilterArgs',
    'GetWlmsWlsDomainServerBackupsFilterArgsDict',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgs',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict',
    'GetWlmsWlsDomainServersFilterArgs',
    'GetWlmsWlsDomainServersFilterArgsDict',
    'GetWlmsWlsDomainsFilterArgs',
    'GetWlmsWlsDomainsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApiPlatformApiPlatformInstanceIdcsAppArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        IDCS URL of the app
        """
elif False:
    ApiPlatformApiPlatformInstanceIdcsAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceIdcsAppArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: IDCS URL of the app
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IDCS URL of the app
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApiPlatformApiPlatformInstanceUriArgsDict(TypedDict):
        developers_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Developer's Portal URI of the instance (/developers)
        """
        management_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Portal URI of the instance (/apiplatform)
        """
elif False:
    ApiPlatformApiPlatformInstanceUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceUriArgs:
    def __init__(__self__, *,
                 developers_portal_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 management_portal_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] developers_portal_uri: Developer's Portal URI of the instance (/developers)
        :param pulumi.Input[_builtins.str] management_portal_uri: Management Portal URI of the instance (/apiplatform)
        """
        if developers_portal_uri is not None:
            pulumi.set(__self__, "developers_portal_uri", developers_portal_uri)
        if management_portal_uri is not None:
            pulumi.set(__self__, "management_portal_uri", management_portal_uri)

    @_builtins.property
    @pulumi.getter(name="developersPortalUri")
    def developers_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Developer's Portal URI of the instance (/developers)
        """
        return pulumi.get(self, "developers_portal_uri")

    @developers_portal_uri.setter
    def developers_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "developers_portal_uri", value)

    @_builtins.property
    @pulumi.getter(name="managementPortalUri")
    def management_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Portal URI of the instance (/apiplatform)
        """
        return pulumi.get(self, "management_portal_uri")

    @management_portal_uri.setter
    def management_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_portal_uri", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        (Updatable) name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) type of the entity which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: (Updatable) name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: (Updatable) list of attributes belonging to the above api which needs to be protected.
        :param pulumi.Input[_builtins.str] entity_type: (Updatable) type of the entity which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) type of the entity which needs to be protected.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict(TypedDict):
        approval_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action done by the approver.
        """
        approval_comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment specified by the approver of the request.
        """
        approver_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The userId of the approver.
        """
        time_approved_for_access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        time_of_authorization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs:
    def __init__(__self__, *,
                 approval_action: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_comment: Optional[pulumi.Input[_builtins.str]] = None,
                 approver_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_approved_for_access: Optional[pulumi.Input[_builtins.str]] = None,
                 time_of_authorization: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_action: The action done by the approver.
        :param pulumi.Input[_builtins.str] approval_comment: Comment specified by the approver of the request.
        :param pulumi.Input[_builtins.str] approver_id: The userId of the approver.
        :param pulumi.Input[_builtins.str] time_approved_for_access: Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        :param pulumi.Input[_builtins.str] time_of_authorization: Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        if approval_action is not None:
            pulumi.set(__self__, "approval_action", approval_action)
        if approval_comment is not None:
            pulumi.set(__self__, "approval_comment", approval_comment)
        if approver_id is not None:
            pulumi.set(__self__, "approver_id", approver_id)
        if time_approved_for_access is not None:
            pulumi.set(__self__, "time_approved_for_access", time_approved_for_access)
        if time_of_authorization is not None:
            pulumi.set(__self__, "time_of_authorization", time_of_authorization)

    @_builtins.property
    @pulumi.getter(name="approvalAction")
    def approval_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action done by the approver.
        """
        return pulumi.get(self, "approval_action")

    @approval_action.setter
    def approval_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_action", value)

    @_builtins.property
    @pulumi.getter(name="approvalComment")
    def approval_comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment specified by the approver of the request.
        """
        return pulumi.get(self, "approval_comment")

    @approval_comment.setter
    def approval_comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_comment", value)

    @_builtins.property
    @pulumi.getter(name="approverId")
    def approver_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The userId of the approver.
        """
        return pulumi.get(self, "approver_id")

    @approver_id.setter
    def approver_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approver_id", value)

    @_builtins.property
    @pulumi.getter(name="timeApprovedForAccess")
    def time_approved_for_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_approved_for_access")

    @time_approved_for_access.setter
    def time_approved_for_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_approved_for_access", value)

    @_builtins.property
    @pulumi.getter(name="timeOfAuthorization")
    def time_of_authorization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_of_authorization")

    @time_of_authorization.setter
    def time_of_authorization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_of_authorization", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of attributes belonging to the above api which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: list of attributes belonging to the above api which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)


if not MYPY:
    class DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Discovered Resource.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Location.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Name.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Discovered Resource's properties.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Group Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Type.
        """
elif False:
    DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudMultiCloudResourceDiscoveryResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the Discovered Resource.
        :param pulumi.Input[_builtins.str] location: Discovered Resource Location.
        :param pulumi.Input[_builtins.str] name: Discovered Resource Name.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: Discovered Resource's properties.
        :param pulumi.Input[_builtins.str] resource_group: Discovered Resource Group Name.
        :param pulumi.Input[_builtins.str] type: Discovered Resource Type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Discovered Resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Discovered Resource's properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Group Name.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict(TypedDict):
        current_arc_agent_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        """
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name or Azure Arc Agent name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the Azure Arc Agent resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs:
    def __init__(__self__, *,
                 current_arc_agent_version: Optional[pulumi.Input[_builtins.str]] = None,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_arc_agent_version: Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host name or Azure Arc Agent name.
        :param pulumi.Input[_builtins.str] status: The current status of the Azure Arc Agent resource.
        :param pulumi.Input[_builtins.str] time_last_checked: Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if current_arc_agent_version is not None:
            pulumi.set(__self__, "current_arc_agent_version", current_arc_agent_version)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="currentArcAgentVersion")
    def current_arc_agent_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current Arc Agent Version installed on this node of Oracle Cloud VM Cluster.
        """
        return pulumi.get(self, "current_arc_agent_version")

    @current_arc_agent_version.setter
    def current_arc_agent_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_arc_agent_version", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name or Azure Arc Agent name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the Azure Arc Agent resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict(TypedDict):
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host Name or Identity Connector name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the GCP Identity Connector resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbGcpIdentityConnectorGcpNodeArgs:
    def __init__(__self__, *,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host Name or Identity Connector name.
        :param pulumi.Input[_builtins.str] status: The current status of the GCP Identity Connector resource.
        :param pulumi.Input[_builtins.str] time_last_checked: time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host Name or Identity Connector name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the GCP Identity Connector resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time when the GCP Identity Connector's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundEnvelopeArgsDict(TypedDict):
        reference_endpoint: pulumi.Input[_builtins.str]
        """
        (Updatable) The device endpoint.
        """
        envelope_mapping: NotRequired[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict']]
        """
        (Updatable) Maps the metadata fields from the inbound payload using JQ. These mappings allow you to extract specific metadata such as timestamps using JQ expressions.
        """
        reference_payload: NotRequired[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict']]
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
elif False:
    IotDigitalTwinAdapterInboundEnvelopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundEnvelopeArgs:
    def __init__(__self__, *,
                 reference_endpoint: pulumi.Input[_builtins.str],
                 envelope_mapping: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs']] = None,
                 reference_payload: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] reference_endpoint: (Updatable) The device endpoint.
        :param pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs'] envelope_mapping: (Updatable) Maps the metadata fields from the inbound payload using JQ. These mappings allow you to extract specific metadata such as timestamps using JQ expressions.
        :param pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs'] reference_payload: (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        pulumi.set(__self__, "reference_endpoint", reference_endpoint)
        if envelope_mapping is not None:
            pulumi.set(__self__, "envelope_mapping", envelope_mapping)
        if reference_payload is not None:
            pulumi.set(__self__, "reference_payload", reference_payload)

    @_builtins.property
    @pulumi.getter(name="referenceEndpoint")
    def reference_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The device endpoint.
        """
        return pulumi.get(self, "reference_endpoint")

    @reference_endpoint.setter
    def reference_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reference_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="envelopeMapping")
    def envelope_mapping(self) -> Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs']]:
        """
        (Updatable) Maps the metadata fields from the inbound payload using JQ. These mappings allow you to extract specific metadata such as timestamps using JQ expressions.
        """
        return pulumi.get(self, "envelope_mapping")

    @envelope_mapping.setter
    def envelope_mapping(self, value: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs']]):
        pulumi.set(self, "envelope_mapping", value)

    @_builtins.property
    @pulumi.getter(name="referencePayload")
    def reference_payload(self) -> Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs']]:
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        return pulumi.get(self, "reference_payload")

    @reference_payload.setter
    def reference_payload(self, value: Optional[pulumi.Input['IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs']]):
        pulumi.set(self, "reference_payload", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict(TypedDict):
        time_observed: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) JQ expression to extract the observation timestamp from the payload. If not specified, the system will default to using `timeReceived` as the timestamp.  Example: For payload `{"time": "<timestamp>","temp": 65,"hum": 55}` 'timeObserved' can be mapped as [JQ Expression](https://jqplay.org/) `$.time`.
        """
elif False:
    IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundEnvelopeEnvelopeMappingArgs:
    def __init__(__self__, *,
                 time_observed: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_observed: (Updatable) JQ expression to extract the observation timestamp from the payload. If not specified, the system will default to using `timeReceived` as the timestamp.  Example: For payload `{"time": "<timestamp>","temp": 65,"hum": 55}` 'timeObserved' can be mapped as [JQ Expression](https://jqplay.org/) `$.time`.
        """
        if time_observed is not None:
            pulumi.set(__self__, "time_observed", time_observed)

    @_builtins.property
    @pulumi.getter(name="timeObserved")
    def time_observed(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) JQ expression to extract the observation timestamp from the payload. If not specified, the system will default to using `timeReceived` as the timestamp.  Example: For payload `{"time": "<timestamp>","temp": 65,"hum": 55}` 'timeObserved' can be mapped as [JQ Expression](https://jqplay.org/) `$.time`.
        """
        return pulumi.get(self, "time_observed")

    @time_observed.setter
    def time_observed(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_observed", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict(TypedDict):
        data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) JSON raw data.
        """
        data_format: pulumi.Input[_builtins.str]
        """
        (Updatable) Data format of the payload.
        """
elif False:
    IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundEnvelopeReferencePayloadArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 data_format: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] data: (Updatable) JSON raw data.
        :param pulumi.Input[_builtins.str] data_format: (Updatable) Data format of the payload.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "data_format", data_format)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) JSON raw data.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Data format of the payload.
        """
        return pulumi.get(self, "data_format")

    @data_format.setter
    def data_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_format", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundRouteArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
        """
        (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Meaningful write up about the inbound route.
        """
        payload_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model's context or schema.

        The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.

        Example: Given payload: { "time": "<timestamp>", "temp": 65, "hum": 55 } And mapping: { "temperature": "$.temp", "humidity": "$.hum", "timeObserved": "$.time" } The output will be: { "temperature": 65, "humidity": 55, "timeObserved": "<timestamp>" }
        """
        reference_payload: NotRequired[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict']]
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
elif False:
    IotDigitalTwinAdapterInboundRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundRouteArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 payload_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 reference_payload: Optional[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] condition: (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
        :param pulumi.Input[_builtins.str] description: (Updatable) Meaningful write up about the inbound route.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] payload_mapping: (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model's context or schema.
               
               The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.
               
               Example: Given payload: { "time": "<timestamp>", "temp": 65, "hum": 55 } And mapping: { "temperature": "$.temp", "humidity": "$.hum", "timeObserved": "$.time" } The output will be: { "temperature": 65, "humidity": 55, "timeObserved": "<timestamp>" }
        :param pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs'] reference_payload: (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if payload_mapping is not None:
            pulumi.set(__self__, "payload_mapping", payload_mapping)
        if reference_payload is not None:
            pulumi.set(__self__, "reference_payload", reference_payload)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Meaningful write up about the inbound route.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="payloadMapping")
    def payload_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model's context or schema.

        The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.

        Example: Given payload: { "time": "<timestamp>", "temp": 65, "hum": 55 } And mapping: { "temperature": "$.temp", "humidity": "$.hum", "timeObserved": "$.time" } The output will be: { "temperature": 65, "humidity": 55, "timeObserved": "<timestamp>" }
        """
        return pulumi.get(self, "payload_mapping")

    @payload_mapping.setter
    def payload_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "payload_mapping", value)

    @_builtins.property
    @pulumi.getter(name="referencePayload")
    def reference_payload(self) -> Optional[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs']]:
        """
        (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
        """
        return pulumi.get(self, "reference_payload")

    @reference_payload.setter
    def reference_payload(self, value: Optional[pulumi.Input['IotDigitalTwinAdapterInboundRouteReferencePayloadArgs']]):
        pulumi.set(self, "reference_payload", value)


if not MYPY:
    class IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict(TypedDict):
        data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) JSON raw data.
        """
        data_format: pulumi.Input[_builtins.str]
        """
        (Updatable) Data format of the payload.
        """
elif False:
    IotDigitalTwinAdapterInboundRouteReferencePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDigitalTwinAdapterInboundRouteReferencePayloadArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 data_format: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] data: (Updatable) JSON raw data.
        :param pulumi.Input[_builtins.str] data_format: (Updatable) Data format of the payload.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "data_format", data_format)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) JSON raw data.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Data format of the payload.
        """
        return pulumi.get(self, "data_format")

    @data_format.setter
    def data_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_format", value)


if not MYPY:
    class IotIotDomainDataRetentionPeriodsInDayArgsDict(TypedDict):
        historized_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any normalized data sent to IoT devices would be retained for.
        """
        raw_command_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any raw command data sent to IoT devices would be retained for.
        """
        raw_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any raw data sent to IoT devices would be retained for.
        """
        rejected_data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days for which any data sent to IoT devices would be retained for.
        """
elif False:
    IotIotDomainDataRetentionPeriodsInDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotIotDomainDataRetentionPeriodsInDayArgs:
    def __init__(__self__, *,
                 historized_data: Optional[pulumi.Input[_builtins.int]] = None,
                 raw_command_data: Optional[pulumi.Input[_builtins.int]] = None,
                 raw_data: Optional[pulumi.Input[_builtins.int]] = None,
                 rejected_data: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] historized_data: Number of days for which any normalized data sent to IoT devices would be retained for.
        :param pulumi.Input[_builtins.int] raw_command_data: Number of days for which any raw command data sent to IoT devices would be retained for.
        :param pulumi.Input[_builtins.int] raw_data: Number of days for which any raw data sent to IoT devices would be retained for.
        :param pulumi.Input[_builtins.int] rejected_data: Number of days for which any data sent to IoT devices would be retained for.
        """
        if historized_data is not None:
            pulumi.set(__self__, "historized_data", historized_data)
        if raw_command_data is not None:
            pulumi.set(__self__, "raw_command_data", raw_command_data)
        if raw_data is not None:
            pulumi.set(__self__, "raw_data", raw_data)
        if rejected_data is not None:
            pulumi.set(__self__, "rejected_data", rejected_data)

    @_builtins.property
    @pulumi.getter(name="historizedData")
    def historized_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any normalized data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "historized_data")

    @historized_data.setter
    def historized_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "historized_data", value)

    @_builtins.property
    @pulumi.getter(name="rawCommandData")
    def raw_command_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any raw command data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "raw_command_data")

    @raw_command_data.setter
    def raw_command_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "raw_command_data", value)

    @_builtins.property
    @pulumi.getter(name="rawData")
    def raw_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any raw data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "raw_data")

    @raw_data.setter
    def raw_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "raw_data", value)

    @_builtins.property
    @pulumi.getter(name="rejectedData")
    def rejected_data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days for which any data sent to IoT devices would be retained for.
        """
        return pulumi.get(self, "rejected_data")

    @rejected_data.setter
    def rejected_data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rejected_data", value)


if not MYPY:
    class ManagedKafkaKafkaClusterAccessSubnetArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) Subnets OCIDs
        """
elif False:
    ManagedKafkaKafkaClusterAccessSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterAccessSubnetArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: (Updatable) Subnets OCIDs
        """
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Subnets OCIDs
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ManagedKafkaKafkaClusterBrokerShapeArgsDict(TypedDict):
        node_count: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of Kafka broker nodes
        """
        ocpu_count: pulumi.Input[_builtins.int]
        """
        (Updatable) Number of OCPUs per nodes
        """
        storage_size_in_gbs: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Size of the storage per nodes.
        """
elif False:
    ManagedKafkaKafkaClusterBrokerShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterBrokerShapeArgs:
    def __init__(__self__, *,
                 node_count: pulumi.Input[_builtins.int],
                 ocpu_count: pulumi.Input[_builtins.int],
                 storage_size_in_gbs: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] node_count: (Updatable) Number of Kafka broker nodes
        :param pulumi.Input[_builtins.int] ocpu_count: (Updatable) Number of OCPUs per nodes
        :param pulumi.Input[_builtins.int] storage_size_in_gbs: (Updatable) Size of the storage per nodes.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "ocpu_count", ocpu_count)
        if storage_size_in_gbs is not None:
            pulumi.set(__self__, "storage_size_in_gbs", storage_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of Kafka broker nodes
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "node_count", value)

    @_builtins.property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Number of OCPUs per nodes
        """
        return pulumi.get(self, "ocpu_count")

    @ocpu_count.setter
    def ocpu_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ocpu_count", value)

    @_builtins.property
    @pulumi.getter(name="storageSizeInGbs")
    def storage_size_in_gbs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Size of the storage per nodes.
        """
        return pulumi.get(self, "storage_size_in_gbs")

    @storage_size_in_gbs.setter
    def storage_size_in_gbs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage_size_in_gbs", value)


if not MYPY:
    class ManagedKafkaKafkaClusterConfigLatestConfigArgsDict(TypedDict):
        properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        (Updatable) Cluster configuration key-value pairs
        """
        config_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) ID cluster configuration
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        version_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Version of the cluster configuration


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ManagedKafkaKafkaClusterConfigLatestConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterConfigLatestConfigArgs:
    def __init__(__self__, *,
                 properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 config_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 version_number: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: (Updatable) Cluster configuration key-value pairs
        :param pulumi.Input[_builtins.str] config_id: (Updatable) ID cluster configuration
        :param pulumi.Input[_builtins.str] time_created: (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        :param pulumi.Input[_builtins.int] version_number: (Updatable) Version of the cluster configuration
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "properties", properties)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if version_number is not None:
            pulumi.set(__self__, "version_number", version_number)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        (Updatable) Cluster configuration key-value pairs
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) ID cluster configuration
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The date and time the KafkaClusterConfigVersion was created, in the format defined by [RFC 3339](https://tools.ietf.org/html/rfc3339). Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Version of the cluster configuration


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "version_number")

    @version_number.setter
    def version_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version_number", value)


if not MYPY:
    class ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bootstrap URL
        """
elif False:
    ManagedKafkaKafkaClusterKafkaBootstrapUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKafkaKafkaClusterKafkaBootstrapUrlArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Kafka listener providing this bootstrap URL
        :param pulumi.Input[_builtins.str] url: Bootstrap URL
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bootstrap URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgsDict(TypedDict):
        password_type: pulumi.Input[_builtins.str]
        """
        Password type
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for the ADW to be created in User Tenancy. The password must be between 12 and 30 characters long, and must contain at least 1 uppercase, 1 lowercase, and 1 numeric character. It cannot contain the double quote symbol (") or the username "admin", regardless of casing.
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vault secret to use as the ADW admin password.
        """
elif False:
    ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAnalyticsResourceAnalyticsInstanceAdwAdminPasswordArgs:
    def __init__(__self__, *,
                 password_type: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password_type: Password type
        :param pulumi.Input[_builtins.str] password: Password for the ADW to be created in User Tenancy. The password must be between 12 and 30 characters long, and must contain at least 1 uppercase, 1 lowercase, and 1 numeric character. It cannot contain the double quote symbol (") or the username "admin", regardless of casing.
        :param pulumi.Input[_builtins.str] secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vault secret to use as the ADW admin password.
        """
        pulumi.set(__self__, "password_type", password_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="passwordType")
    def password_type(self) -> pulumi.Input[_builtins.str]:
        """
        Password type
        """
        return pulumi.get(self, "password_type")

    @password_type.setter
    def password_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for the ADW to be created in User Tenancy. The password must be between 12 and 30 characters long, and must contain at least 1 uppercase, 1 lowercase, and 1 numeric character. It cannot contain the double quote symbol (") or the username "admin", regardless of casing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the vault secret to use as the ADW admin password.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgsDict(TypedDict):
        idcs_domain_id: NotRequired[pulumi.Input[_builtins.str]]
        license_model: NotRequired[pulumi.Input[_builtins.str]]
        network_details: NotRequired[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict']]
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsArgs:
    def __init__(__self__, *,
                 idcs_domain_id: Optional[pulumi.Input[_builtins.str]] = None,
                 license_model: Optional[pulumi.Input[_builtins.str]] = None,
                 network_details: Optional[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs']] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        if idcs_domain_id is not None:
            pulumi.set(__self__, "idcs_domain_id", idcs_domain_id)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)
        if network_details is not None:
            pulumi.set(__self__, "network_details", network_details)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="idcsDomainId")
    def idcs_domain_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "idcs_domain_id")

    @idcs_domain_id.setter
    def idcs_domain_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idcs_domain_id", value)

    @_builtins.property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_model", value)

    @_builtins.property
    @pulumi.getter(name="networkDetails")
    def network_details(self) -> Optional[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs']]:
        return pulumi.get(self, "network_details")

    @network_details.setter
    def network_details(self, value: Optional[pulumi.Input['ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs']]):
        pulumi.set(self, "network_details", value)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict(TypedDict):
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAnalyticsResourceAnalyticsInstanceOacManagementAttachmentDetailsNetworkDetailsArgs:
    def __init__(__self__, *,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class GetAiDataPlatformAiDataPlatformsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetAiDataPlatformAiDataPlatformsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAiDataPlatformAiDataPlatformsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiPlatformApiPlatformInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiPlatformApiPlatformInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiPlatformApiPlatformInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadatasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadatasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadatasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiControlsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiRequestsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Discovered Resource Name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Discovered Resource Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobContainersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobMountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpIdentityConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpKeyRingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpKeyRingsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbGcpKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbGcpKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbGcpKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinAdaptersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinAdaptersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinAdaptersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotDigitalTwinRelationshipsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotDigitalTwinRelationshipsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotDigitalTwinRelationshipsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotIotDomainGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotIotDomainGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotIotDomainGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetIotIotDomainsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetIotIotDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIotIotDomainsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClusterConfigVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClusterConfigVersionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClusterConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClusterConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClusterConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedKafkaKafkaClustersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetManagedKafkaKafkaClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedKafkaKafkaClustersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the Kafka listener providing this bootstrap URL
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Kafka listener providing this bootstrap URL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudExternalLocationMappingMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudExternalLocationMappingMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudExternalLocationMappingMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudExternalLocationSummariesMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudExternalLocationSummariesMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudExternalLocationSummariesMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudExternalLocationsMetadataFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudExternalLocationsMetadataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudExternalLocationsMetadataFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMulticloudResourceAnchorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetMulticloudResourceAnchorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMulticloudResourceAnchorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceAnalyticsMonitoredRegionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceAnalyticsMonitoredRegionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceAnalyticsMonitoredRegionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceAnalyticsResourceAnalyticsInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceAnalyticsResourceAnalyticsInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceAnalyticsResourceAnalyticsInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceAnalyticsTenancyAttachmentsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceAnalyticsTenancyAttachmentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceAnalyticsTenancyAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainAgreementRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainAgreementRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainAgreementRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainApplicablePatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainApplicablePatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainApplicablePatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerBackupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerBackupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


