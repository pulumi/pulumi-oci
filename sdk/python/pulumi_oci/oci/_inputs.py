# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict',
    'GetApiaccesscontrolApiMetadatasFilterArgs',
    'GetApiaccesscontrolApiMetadatasFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict',
    'GetWlmsManagedInstanceScanResultsFilterArgs',
    'GetWlmsManagedInstanceScanResultsFilterArgsDict',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgs',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict',
    'GetWlmsManagedInstanceServersFilterArgs',
    'GetWlmsManagedInstanceServersFilterArgsDict',
    'GetWlmsManagedInstancesFilterArgs',
    'GetWlmsManagedInstancesFilterArgsDict',
    'GetWlmsWlsDomainAgreementRecordsFilterArgs',
    'GetWlmsWlsDomainAgreementRecordsFilterArgsDict',
    'GetWlmsWlsDomainApplicablePatchesFilterArgs',
    'GetWlmsWlsDomainApplicablePatchesFilterArgsDict',
    'GetWlmsWlsDomainScanResultsFilterArgs',
    'GetWlmsWlsDomainScanResultsFilterArgsDict',
    'GetWlmsWlsDomainServerBackupsFilterArgs',
    'GetWlmsWlsDomainServerBackupsFilterArgsDict',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgs',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict',
    'GetWlmsWlsDomainServersFilterArgs',
    'GetWlmsWlsDomainServersFilterArgsDict',
    'GetWlmsWlsDomainsFilterArgs',
    'GetWlmsWlsDomainsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[builtins.str]
        """
        (Updatable) name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        entity_type: NotRequired[pulumi.Input[builtins.str]]
        """
        (Updatable) type of the entity which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 entity_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_name: (Updatable) name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] attribute_names: (Updatable) list of attributes belonging to the above api which needs to be protected.
        :param pulumi.Input[builtins.str] entity_type: (Updatable) type of the entity which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[builtins.str]:
        """
        (Updatable) name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_name", value)

    @property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Updatable) type of the entity which needs to be protected.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict(TypedDict):
        approval_action: NotRequired[pulumi.Input[builtins.str]]
        """
        The action done by the approver.
        """
        approval_comment: NotRequired[pulumi.Input[builtins.str]]
        """
        Comment specified by the approver of the request.
        """
        approver_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The userId of the approver.
        """
        time_approved_for_access: NotRequired[pulumi.Input[builtins.str]]
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        time_of_authorization: NotRequired[pulumi.Input[builtins.str]]
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs:
    def __init__(__self__, *,
                 approval_action: Optional[pulumi.Input[builtins.str]] = None,
                 approval_comment: Optional[pulumi.Input[builtins.str]] = None,
                 approver_id: Optional[pulumi.Input[builtins.str]] = None,
                 time_approved_for_access: Optional[pulumi.Input[builtins.str]] = None,
                 time_of_authorization: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] approval_action: The action done by the approver.
        :param pulumi.Input[builtins.str] approval_comment: Comment specified by the approver of the request.
        :param pulumi.Input[builtins.str] approver_id: The userId of the approver.
        :param pulumi.Input[builtins.str] time_approved_for_access: Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        :param pulumi.Input[builtins.str] time_of_authorization: Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        if approval_action is not None:
            pulumi.set(__self__, "approval_action", approval_action)
        if approval_comment is not None:
            pulumi.set(__self__, "approval_comment", approval_comment)
        if approver_id is not None:
            pulumi.set(__self__, "approver_id", approver_id)
        if time_approved_for_access is not None:
            pulumi.set(__self__, "time_approved_for_access", time_approved_for_access)
        if time_of_authorization is not None:
            pulumi.set(__self__, "time_of_authorization", time_of_authorization)

    @property
    @pulumi.getter(name="approvalAction")
    def approval_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The action done by the approver.
        """
        return pulumi.get(self, "approval_action")

    @approval_action.setter
    def approval_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "approval_action", value)

    @property
    @pulumi.getter(name="approvalComment")
    def approval_comment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comment specified by the approver of the request.
        """
        return pulumi.get(self, "approval_comment")

    @approval_comment.setter
    def approval_comment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "approval_comment", value)

    @property
    @pulumi.getter(name="approverId")
    def approver_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The userId of the approver.
        """
        return pulumi.get(self, "approver_id")

    @approver_id.setter
    def approver_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "approver_id", value)

    @property
    @pulumi.getter(name="timeApprovedForAccess")
    def time_approved_for_access(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_approved_for_access")

    @time_approved_for_access.setter
    def time_approved_for_access(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_approved_for_access", value)

    @property
    @pulumi.getter(name="timeOfAuthorization")
    def time_of_authorization(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_of_authorization")

    @time_of_authorization.setter
    def time_of_authorization(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_of_authorization", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[builtins.str]
        """
        name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        list of attributes belonging to the above api which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] api_name: name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] attribute_names: list of attributes belonging to the above api which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)

    @property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[builtins.str]:
        """
        name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_name", value)

    @property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadatasFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadatasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadatasFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiControlsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiRequestsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceScanResultsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsManagedInstanceScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServersFilterArgsDict(TypedDict):
        name: builtins.str
        """
        The name of the resource.
        """
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsManagedInstanceServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServersFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstancesFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsManagedInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainAgreementRecordsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainAgreementRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainAgreementRecordsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainApplicablePatchesFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainApplicablePatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainApplicablePatchesFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainScanResultsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerBackupsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainServerBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerBackupsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServersFilterArgsDict(TypedDict):
        name: builtins.str
        """
        The name of the resource.
        """
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServersFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainsFilterArgsDict(TypedDict):
        name: builtins.str
        values: Sequence[builtins.str]
        regex: NotRequired[builtins.bool]
elif False:
    GetWlmsWlsDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainsFilterArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str],
                 regex: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[builtins.bool]):
        pulumi.set(self, "regex", value)


