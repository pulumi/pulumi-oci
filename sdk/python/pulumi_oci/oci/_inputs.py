# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiPlatformApiPlatformInstanceIdcsAppArgs',
    'ApiPlatformApiPlatformInstanceIdcsAppArgsDict',
    'ApiPlatformApiPlatformInstanceUriArgs',
    'ApiPlatformApiPlatformInstanceUriArgsDict',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs',
    'ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs',
    'ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgs',
    'DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs',
    'DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict',
    'GetApiPlatformApiPlatformInstancesFilterArgs',
    'GetApiPlatformApiPlatformInstancesFilterArgsDict',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs',
    'GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict',
    'GetApiaccesscontrolApiMetadatasFilterArgs',
    'GetApiaccesscontrolApiMetadatasFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgs',
    'GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs',
    'GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgs',
    'GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgs',
    'GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureKeysFilterArgs',
    'GetDbmulticloudOracleDbAzureKeysFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgs',
    'GetDbmulticloudOracleDbAzureVaultsFilterArgsDict',
    'GetWlmsManagedInstanceScanResultsFilterArgs',
    'GetWlmsManagedInstanceScanResultsFilterArgsDict',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgs',
    'GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict',
    'GetWlmsManagedInstanceServersFilterArgs',
    'GetWlmsManagedInstanceServersFilterArgsDict',
    'GetWlmsManagedInstancesFilterArgs',
    'GetWlmsManagedInstancesFilterArgsDict',
    'GetWlmsWlsDomainAgreementRecordsFilterArgs',
    'GetWlmsWlsDomainAgreementRecordsFilterArgsDict',
    'GetWlmsWlsDomainApplicablePatchesFilterArgs',
    'GetWlmsWlsDomainApplicablePatchesFilterArgsDict',
    'GetWlmsWlsDomainScanResultsFilterArgs',
    'GetWlmsWlsDomainScanResultsFilterArgsDict',
    'GetWlmsWlsDomainServerBackupsFilterArgs',
    'GetWlmsWlsDomainServerBackupsFilterArgsDict',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgs',
    'GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict',
    'GetWlmsWlsDomainServersFilterArgs',
    'GetWlmsWlsDomainServersFilterArgsDict',
    'GetWlmsWlsDomainsFilterArgs',
    'GetWlmsWlsDomainsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApiPlatformApiPlatformInstanceIdcsAppArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        IDCS URL of the app
        """
elif False:
    ApiPlatformApiPlatformInstanceIdcsAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceIdcsAppArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: IDCS URL of the app
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IDCS URL of the app
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApiPlatformApiPlatformInstanceUriArgsDict(TypedDict):
        developers_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Developer's Portal URI of the instance (/developers)
        """
        management_portal_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Management Portal URI of the instance (/apiplatform)
        """
elif False:
    ApiPlatformApiPlatformInstanceUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPlatformApiPlatformInstanceUriArgs:
    def __init__(__self__, *,
                 developers_portal_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 management_portal_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] developers_portal_uri: Developer's Portal URI of the instance (/developers)
        :param pulumi.Input[_builtins.str] management_portal_uri: Management Portal URI of the instance (/apiplatform)
        """
        if developers_portal_uri is not None:
            pulumi.set(__self__, "developers_portal_uri", developers_portal_uri)
        if management_portal_uri is not None:
            pulumi.set(__self__, "management_portal_uri", management_portal_uri)

    @_builtins.property
    @pulumi.getter(name="developersPortalUri")
    def developers_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Developer's Portal URI of the instance (/developers)
        """
        return pulumi.get(self, "developers_portal_uri")

    @developers_portal_uri.setter
    def developers_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "developers_portal_uri", value)

    @_builtins.property
    @pulumi.getter(name="managementPortalUri")
    def management_portal_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Management Portal URI of the instance (/apiplatform)
        """
        return pulumi.get(self, "management_portal_uri")

    @management_portal_uri.setter
    def management_portal_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_portal_uri", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        (Updatable) name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) type of the entity which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiControlPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: (Updatable) name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: (Updatable) list of attributes belonging to the above api which needs to be protected.
        :param pulumi.Input[_builtins.str] entity_type: (Updatable) type of the entity which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) type of the entity which needs to be protected.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict(TypedDict):
        approval_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action done by the approver.
        """
        approval_comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment specified by the approver of the request.
        """
        approver_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The userId of the approver.
        """
        time_approved_for_access: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        time_of_authorization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestApproverDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestApproverDetailArgs:
    def __init__(__self__, *,
                 approval_action: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_comment: Optional[pulumi.Input[_builtins.str]] = None,
                 approver_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_approved_for_access: Optional[pulumi.Input[_builtins.str]] = None,
                 time_of_authorization: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_action: The action done by the approver.
        :param pulumi.Input[_builtins.str] approval_comment: Comment specified by the approver of the request.
        :param pulumi.Input[_builtins.str] approver_id: The userId of the approver.
        :param pulumi.Input[_builtins.str] time_approved_for_access: Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        :param pulumi.Input[_builtins.str] time_of_authorization: Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        if approval_action is not None:
            pulumi.set(__self__, "approval_action", approval_action)
        if approval_comment is not None:
            pulumi.set(__self__, "approval_comment", approval_comment)
        if approver_id is not None:
            pulumi.set(__self__, "approver_id", approver_id)
        if time_approved_for_access is not None:
            pulumi.set(__self__, "time_approved_for_access", time_approved_for_access)
        if time_of_authorization is not None:
            pulumi.set(__self__, "time_of_authorization", time_of_authorization)

    @_builtins.property
    @pulumi.getter(name="approvalAction")
    def approval_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action done by the approver.
        """
        return pulumi.get(self, "approval_action")

    @approval_action.setter
    def approval_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_action", value)

    @_builtins.property
    @pulumi.getter(name="approvalComment")
    def approval_comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment specified by the approver of the request.
        """
        return pulumi.get(self, "approval_comment")

    @approval_comment.setter
    def approval_comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_comment", value)

    @_builtins.property
    @pulumi.getter(name="approverId")
    def approver_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The userId of the approver.
        """
        return pulumi.get(self, "approver_id")

    @approver_id.setter
    def approver_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approver_id", value)

    @_builtins.property
    @pulumi.getter(name="timeApprovedForAccess")
    def time_approved_for_access(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time for when the privilegedApi request should start that is authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_approved_for_access")

    @time_approved_for_access.setter
    def time_approved_for_access(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_approved_for_access", value)

    @_builtins.property
    @pulumi.getter(name="timeOfAuthorization")
    def time_of_authorization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time when the privilegedApi request was authorized by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format.Example: '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_of_authorization")

    @time_of_authorization.setter
    def time_of_authorization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_of_authorization", value)


if not MYPY:
    class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        name of the api which needs to be protected.
        """
        attribute_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of attributes belonging to the above api which needs to be protected.
        """
elif False:
    ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiaccesscontrolPrivilegedApiRequestPrivilegedOperationListArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 attribute_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: name of the api which needs to be protected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attribute_names: list of attributes belonging to the above api which needs to be protected.
        """
        pulumi.set(__self__, "api_name", api_name)
        if attribute_names is not None:
            pulumi.set(__self__, "attribute_names", attribute_names)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        name of the api which needs to be protected.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeNames")
    def attribute_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of attributes belonging to the above api which needs to be protected.
        """
        return pulumi.get(self, "attribute_names")

    @attribute_names.setter
    def attribute_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attribute_names", value)


if not MYPY:
    class DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Discovered Resource.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Location.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Name.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Discovered Resource's properties.
        """
        resource_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Group Name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Discovered Resource Type.
        """
elif False:
    DbmulticloudMultiCloudResourceDiscoveryResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudMultiCloudResourceDiscoveryResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 resource_group: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Discovered Resource.
        :param pulumi.Input[_builtins.str] location: Discovered Resource Location.
        :param pulumi.Input[_builtins.str] name: Discovered Resource Name.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: Discovered Resource's properties.
        :param pulumi.Input[_builtins.str] resource_group: Discovered Resource Group Name.
        :param pulumi.Input[_builtins.str] type: Discovered Resource Type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Discovered Resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Discovered Resource's properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Group Name.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Discovered Resource Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict(TypedDict):
        current_arc_agent_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current Arc Agent Version installed on this node of VM Cluster.
        """
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host ID.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host Name or Azure Arc Agent Name.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the Azure Arc Agent Resource.
        """
        time_last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
elif False:
    DbmulticloudOracleDbAzureConnectorArcAgentNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbmulticloudOracleDbAzureConnectorArcAgentNodeArgs:
    def __init__(__self__, *,
                 current_arc_agent_version: Optional[pulumi.Input[_builtins.str]] = None,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_last_checked: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_arc_agent_version: Current Arc Agent Version installed on this node of VM Cluster.
        :param pulumi.Input[_builtins.str] host_id: Host ID.
        :param pulumi.Input[_builtins.str] host_name: Host Name or Azure Arc Agent Name.
        :param pulumi.Input[_builtins.str] status: The current status of the Azure Arc Agent Resource.
        :param pulumi.Input[_builtins.str] time_last_checked: time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        if current_arc_agent_version is not None:
            pulumi.set(__self__, "current_arc_agent_version", current_arc_agent_version)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_last_checked is not None:
            pulumi.set(__self__, "time_last_checked", time_last_checked)

    @_builtins.property
    @pulumi.getter(name="currentArcAgentVersion")
    def current_arc_agent_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current Arc Agent Version installed on this node of VM Cluster.
        """
        return pulumi.get(self, "current_arc_agent_version")

    @current_arc_agent_version.setter
    def current_arc_agent_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_arc_agent_version", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host ID.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host Name or Azure Arc Agent Name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the Azure Arc Agent Resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeLastChecked")
    def time_last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        time when the Azure Arc Agent's status was checked [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format, e.g. '2020-05-22T21:10:29.600Z'
        """
        return pulumi.get(self, "time_last_checked")

    @time_last_checked.setter
    def time_last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_last_checked", value)


if not MYPY:
    class GetApiPlatformApiPlatformInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        A filter to return only resources that match the given name exactly
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiPlatformApiPlatformInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiPlatformApiPlatformInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A filter to return only resources that match the given name exactly
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A filter to return only resources that match the given name exactly
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadataByEntityTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadataByEntityTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolApiMetadatasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolApiMetadatasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolApiMetadatasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiControlsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiControlsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApiaccesscontrolPrivilegedApiRequestsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiaccesscontrolPrivilegedApiRequestsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Discovered Resource Name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudMultiCloudResourceDiscoveriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Discovered Resource Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Discovered Resource Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobContainersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobContainersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureBlobMountsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureBlobMountsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbmulticloudOracleDbAzureVaultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetDbmulticloudOracleDbAzureVaultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbmulticloudOracleDbAzureVaultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstanceServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstanceServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstanceServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsManagedInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsManagedInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainAgreementRecordsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainAgreementRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainAgreementRecordsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainApplicablePatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainApplicablePatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainApplicablePatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainScanResultsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainScanResultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainScanResultsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerBackupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerBackupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServerInstalledPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServerInstalledPatchesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainServersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the resource.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainServersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlmsWlsDomainsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetWlmsWlsDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlmsWlsDomainsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


