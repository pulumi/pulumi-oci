# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ProfileLevelsConfigurationArgs',
    'ProfileLevelsConfigurationArgsDict',
    'ProfileLevelsConfigurationItemArgs',
    'ProfileLevelsConfigurationItemArgsDict',
    'ProfileTargetCompartmentsArgs',
    'ProfileTargetCompartmentsArgsDict',
    'ProfileTargetTagsArgs',
    'ProfileTargetTagsArgsDict',
    'ProfileTargetTagsItemArgs',
    'ProfileTargetTagsItemArgsDict',
    'RecommendationResourceCountArgs',
    'RecommendationResourceCountArgsDict',
    'RecommendationSupportedLevelArgs',
    'RecommendationSupportedLevelArgsDict',
    'RecommendationSupportedLevelItemArgs',
    'RecommendationSupportedLevelItemArgsDict',
    'ResourceActionActionArgs',
    'ResourceActionActionArgsDict',
    'GetCategoriesFilterArgs',
    'GetCategoriesFilterArgsDict',
    'GetEnrollmentStatusesFilterArgs',
    'GetEnrollmentStatusesFilterArgsDict',
    'GetHistoriesFilterArgs',
    'GetHistoriesFilterArgsDict',
    'GetProfileLevelsFilterArgs',
    'GetProfileLevelsFilterArgsDict',
    'GetProfilesFilterArgs',
    'GetProfilesFilterArgsDict',
    'GetRecommendationStrategiesFilterArgs',
    'GetRecommendationStrategiesFilterArgsDict',
    'GetRecommendationsFilterArgs',
    'GetRecommendationsFilterArgsDict',
    'GetResourceActionsFilterArgs',
    'GetResourceActionsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ProfileLevelsConfigurationArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProfileLevelsConfigurationItemArgsDict']]]]
        """
        (Updatable) The array of configuration levels.
        """
elif False:
    ProfileLevelsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileLevelsConfigurationArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['ProfileLevelsConfigurationItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProfileLevelsConfigurationItemArgs']]] items: (Updatable) The array of configuration levels.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProfileLevelsConfigurationItemArgs']]]]:
        """
        (Updatable) The array of configuration levels.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProfileLevelsConfigurationItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ProfileLevelsConfigurationItemArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The pre-defined profile level.
        """
        recommendation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The unique OCID of the recommendation.
        """
elif False:
    ProfileLevelsConfigurationItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileLevelsConfigurationItemArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.str]] = None,
                 recommendation_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] level: (Updatable) The pre-defined profile level.
        :param pulumi.Input[_builtins.str] recommendation_id: (Updatable) The unique OCID of the recommendation.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if recommendation_id is not None:
            pulumi.set(__self__, "recommendation_id", recommendation_id)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The pre-defined profile level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter(name="recommendationId")
    def recommendation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The unique OCID of the recommendation.
        """
        return pulumi.get(self, "recommendation_id")

    @recommendation_id.setter
    def recommendation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommendation_id", value)


if not MYPY:
    class ProfileTargetCompartmentsArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) The list of OCIDs attached to the compartments specified in the current profile override.
        """
elif False:
    ProfileTargetCompartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileTargetCompartmentsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] items: (Updatable) The list of OCIDs attached to the compartments specified in the current profile override.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) The list of OCIDs attached to the compartments specified in the current profile override.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ProfileTargetTagsArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['ProfileTargetTagsItemArgsDict']]]
        """
        (Updatable) The list of tags specified in the current profile override.
        """
elif False:
    ProfileTargetTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileTargetTagsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ProfileTargetTagsItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProfileTargetTagsItemArgs']]] items: (Updatable) The list of tags specified in the current profile override.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ProfileTargetTagsItemArgs']]]:
        """
        (Updatable) The list of tags specified in the current profile override.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ProfileTargetTagsItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ProfileTargetTagsItemArgsDict(TypedDict):
        tag_definition_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name you use to refer to the tag, also known as the tag key.
        """
        tag_namespace_name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the tag namespace.
        """
        tag_value_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Specifies which tag value types in the `tagValues` field result in overrides of the recommendation criteria.

        When the value for this field is `ANY`, the `tagValues` field should be empty, which enforces overrides to the recommendation for resources with any tag values attached to them.

        When the value for this field value is `VALUE`, the `tagValues` field must include a specific value or list of values. Overrides to the recommendation criteria only occur for resources that match the values in the `tagValues` fields.
        """
        tag_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of tag values. The tag value is the value that the user applying the tag adds to the tag key.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ProfileTargetTagsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileTargetTagsItemArgs:
    def __init__(__self__, *,
                 tag_definition_name: pulumi.Input[_builtins.str],
                 tag_namespace_name: pulumi.Input[_builtins.str],
                 tag_value_type: pulumi.Input[_builtins.str],
                 tag_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] tag_definition_name: (Updatable) The name you use to refer to the tag, also known as the tag key.
        :param pulumi.Input[_builtins.str] tag_namespace_name: (Updatable) The name of the tag namespace.
        :param pulumi.Input[_builtins.str] tag_value_type: (Updatable) Specifies which tag value types in the `tagValues` field result in overrides of the recommendation criteria.
               
               When the value for this field is `ANY`, the `tagValues` field should be empty, which enforces overrides to the recommendation for resources with any tag values attached to them.
               
               When the value for this field value is `VALUE`, the `tagValues` field must include a specific value or list of values. Overrides to the recommendation criteria only occur for resources that match the values in the `tagValues` fields.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tag_values: (Updatable) The list of tag values. The tag value is the value that the user applying the tag adds to the tag key.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "tag_definition_name", tag_definition_name)
        pulumi.set(__self__, "tag_namespace_name", tag_namespace_name)
        pulumi.set(__self__, "tag_value_type", tag_value_type)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)

    @_builtins.property
    @pulumi.getter(name="tagDefinitionName")
    def tag_definition_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name you use to refer to the tag, also known as the tag key.
        """
        return pulumi.get(self, "tag_definition_name")

    @tag_definition_name.setter
    def tag_definition_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_definition_name", value)

    @_builtins.property
    @pulumi.getter(name="tagNamespaceName")
    def tag_namespace_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the tag namespace.
        """
        return pulumi.get(self, "tag_namespace_name")

    @tag_namespace_name.setter
    def tag_namespace_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_namespace_name", value)

    @_builtins.property
    @pulumi.getter(name="tagValueType")
    def tag_value_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Specifies which tag value types in the `tagValues` field result in overrides of the recommendation criteria.

        When the value for this field is `ANY`, the `tagValues` field should be empty, which enforces overrides to the recommendation for resources with any tag values attached to them.

        When the value for this field value is `VALUE`, the `tagValues` field must include a specific value or list of values. Overrides to the recommendation criteria only occur for resources that match the values in the `tagValues` fields.
        """
        return pulumi.get(self, "tag_value_type")

    @tag_value_type.setter
    def tag_value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_value_type", value)

    @_builtins.property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of tag values. The tag value is the value that the user applying the tag adds to the tag key.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "tag_values")

    @tag_values.setter
    def tag_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tag_values", value)


if not MYPY:
    class RecommendationResourceCountArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The count of resources.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The status of the recommendation.
        """
elif False:
    RecommendationResourceCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationResourceCountArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: The count of resources.
        :param pulumi.Input[_builtins.str] status: (Updatable) The status of the recommendation.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The count of resources.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The status of the recommendation.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RecommendationSupportedLevelArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecommendationSupportedLevelItemArgsDict']]]]
        """
        The list of supported levels.
        """
elif False:
    RecommendationSupportedLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationSupportedLevelArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['RecommendationSupportedLevelItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RecommendationSupportedLevelItemArgs']]] items: The list of supported levels.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecommendationSupportedLevelItemArgs']]]]:
        """
        The list of supported levels.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecommendationSupportedLevelItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class RecommendationSupportedLevelItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the profile level.
        """
elif False:
    RecommendationSupportedLevelItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationSupportedLevelItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the profile level.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the profile level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourceActionActionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text describing the recommended action.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the resource action.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path to documentation that explains how to perform the action.
        """
elif False:
    ResourceActionActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceActionActionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Text describing the recommended action.
        :param pulumi.Input[_builtins.str] type: The status of the resource action.
        :param pulumi.Input[_builtins.str] url: The URL path to documentation that explains how to perform the action.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text describing the recommended action.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the resource action.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path to documentation that explains how to perform the action.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetCategoriesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetCategoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCategoriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetEnrollmentStatusesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetEnrollmentStatusesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEnrollmentStatusesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetHistoriesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetHistoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProfileLevelsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProfileLevelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProfileLevelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProfilesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProfilesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProfilesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRecommendationStrategiesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRecommendationStrategiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecommendationStrategiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRecommendationsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRecommendationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecommendationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResourceActionsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Optional. A filter that returns results that match the name specified.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetResourceActionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResourceActionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


