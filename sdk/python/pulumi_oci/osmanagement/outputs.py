# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ManagedInstanceAutonomouse',
    'ManagedInstanceChildSoftwareSource',
    'ManagedInstanceGroupManagedInstance',
    'ManagedInstanceManagedInstanceGroup',
    'ManagedInstanceManagementChildSoftwareSource',
    'ManagedInstanceManagementManagedInstanceGroup',
    'ManagedInstanceManagementParentSoftwareSource',
    'ManagedInstanceParentSoftwareSource',
    'SoftwareSourceAssociatedManagedInstance',
    'GetManagedInstanceAutonomouseResult',
    'GetManagedInstanceChildSoftwareSourceResult',
    'GetManagedInstanceGroupManagedInstanceResult',
    'GetManagedInstanceGroupsFilterResult',
    'GetManagedInstanceGroupsManagedInstanceGroupResult',
    'GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceResult',
    'GetManagedInstanceManagedInstanceGroupResult',
    'GetManagedInstanceModuleStreamsFilterResult',
    'GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceResult',
    'GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileResult',
    'GetManagedInstanceParentSoftwareSourceResult',
    'GetManagedInstanceStreamProfileFilterResult',
    'GetManagedInstanceStreamProfileModuleStreamProfileOnManagedInstanceResult',
    'GetManagedInstancesFilterResult',
    'GetManagedInstancesManagedInstanceResult',
    'GetManagedInstancesManagedInstanceAutonomouseResult',
    'GetManagedInstancesManagedInstanceChildSoftwareSourceResult',
    'GetManagedInstancesManagedInstanceManagedInstanceGroupResult',
    'GetManagedInstancesManagedInstanceParentSoftwareSourceResult',
    'GetSoftwareSourceAssociatedManagedInstanceResult',
    'GetSoftwareSourceStreamProfileFilterResult',
    'GetSoftwareSourceStreamProfileModuleStreamProfileResult',
    'GetSoftwareSourcesFilterResult',
    'GetSoftwareSourcesSoftwareSourceResult',
    'GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceResult',
]

@pulumi.output_type
class ManagedInstanceAutonomouse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAutoUpdateEnabled":
            suggest = "is_auto_update_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedInstanceAutonomouse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedInstanceAutonomouse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedInstanceAutonomouse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_auto_update_enabled: Optional[bool] = None):
        """
        :param bool is_auto_update_enabled: True if daily updates are enabled
        """
        ManagedInstanceAutonomouse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_auto_update_enabled=is_auto_update_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_auto_update_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_auto_update_enabled is None and 'isAutoUpdateEnabled' in kwargs:
            is_auto_update_enabled = kwargs['isAutoUpdateEnabled']

        if is_auto_update_enabled is not None:
            _setter("is_auto_update_enabled", is_auto_update_enabled)

    @property
    @pulumi.getter(name="isAutoUpdateEnabled")
    def is_auto_update_enabled(self) -> Optional[bool]:
        """
        True if daily updates are enabled
        """
        return pulumi.get(self, "is_auto_update_enabled")


@pulumi.output_type
class ManagedInstanceChildSoftwareSource(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: software source identifier
        :param str name: software source name
        """
        ManagedInstanceChildSoftwareSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        software source name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedInstanceGroupManagedInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedInstanceGroupManagedInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedInstanceGroupManagedInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedInstanceGroupManagedInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str display_name: (Updatable) Managed Instance Group identifier
        :param str id: unique identifier that is immutable on creation
        """
        ManagedInstanceGroupManagedInstance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']

        if display_name is not None:
            _setter("display_name", display_name)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Managed Instance Group identifier
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedInstanceManagedInstanceGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedInstanceManagedInstanceGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedInstanceManagedInstanceGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedInstanceManagedInstanceGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str display_name: User friendly name
        :param str id: software source identifier
        """
        ManagedInstanceManagedInstanceGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']

        if display_name is not None:
            _setter("display_name", display_name)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        User friendly name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedInstanceManagementChildSoftwareSource(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: software source identifier
        :param str name: software source name
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        ManagedInstanceManagementChildSoftwareSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        software source name


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedInstanceManagementManagedInstanceGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedInstanceManagementManagedInstanceGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedInstanceManagementManagedInstanceGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedInstanceManagementManagedInstanceGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str display_name: User friendly name
        :param str id: software source identifier
        """
        ManagedInstanceManagementManagedInstanceGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']

        if display_name is not None:
            _setter("display_name", display_name)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        User friendly name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedInstanceManagementParentSoftwareSource(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: software source identifier
        :param str name: software source name
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        ManagedInstanceManagementParentSoftwareSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        software source name


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedInstanceParentSoftwareSource(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: software source identifier
        :param str name: software source name
        """
        ManagedInstanceParentSoftwareSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        software source name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SoftwareSourceAssociatedManagedInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SoftwareSourceAssociatedManagedInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SoftwareSourceAssociatedManagedInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SoftwareSourceAssociatedManagedInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str display_name: (Updatable) User friendly name for the software source
        :param str id: OCID for the Software Source
        """
        SoftwareSourceAssociatedManagedInstance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']

        if display_name is not None:
            _setter("display_name", display_name)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) User friendly name for the software source
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        OCID for the Software Source
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetManagedInstanceAutonomouseResult(dict):
    def __init__(__self__, *,
                 is_auto_update_enabled: bool):
        """
        :param bool is_auto_update_enabled: True if daily updates are enabled
        """
        GetManagedInstanceAutonomouseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_auto_update_enabled=is_auto_update_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_auto_update_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_auto_update_enabled is None and 'isAutoUpdateEnabled' in kwargs:
            is_auto_update_enabled = kwargs['isAutoUpdateEnabled']
        if is_auto_update_enabled is None:
            raise TypeError("Missing 'is_auto_update_enabled' argument")

        _setter("is_auto_update_enabled", is_auto_update_enabled)

    @property
    @pulumi.getter(name="isAutoUpdateEnabled")
    def is_auto_update_enabled(self) -> bool:
        """
        True if daily updates are enabled
        """
        return pulumi.get(self, "is_auto_update_enabled")


@pulumi.output_type
class GetManagedInstanceChildSoftwareSourceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: software source identifier
        :param str name: software source name
        """
        GetManagedInstanceChildSoftwareSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        software source name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetManagedInstanceGroupManagedInstanceResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str):
        """
        :param str display_name: User friendly name
        :param str id: unique identifier that is immutable on creation
        """
        GetManagedInstanceGroupManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        User friendly name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetManagedInstanceGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetManagedInstanceGroupsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedInstanceGroupsManagedInstanceGroupResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 managed_instance_count: int,
                 managed_instances: Sequence['outputs.GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceResult'],
                 os_family: str,
                 state: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: Information specified by the user about the managed instance group
        :param str display_name: A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: unique identifier that is immutable on creation
        :param Sequence['GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceArgs'] managed_instances: list of Managed Instances in the group
        :param str os_family: The OS family for which to list resources.
        :param str state: The current lifecycle state for the object.
        """
        GetManagedInstanceGroupsManagedInstanceGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            managed_instance_count=managed_instance_count,
            managed_instances=managed_instances,
            os_family=os_family,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             managed_instance_count: Optional[int] = None,
             managed_instances: Optional[Sequence['outputs.GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceResult']] = None,
             os_family: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if managed_instance_count is None and 'managedInstanceCount' in kwargs:
            managed_instance_count = kwargs['managedInstanceCount']
        if managed_instance_count is None:
            raise TypeError("Missing 'managed_instance_count' argument")
        if managed_instances is None and 'managedInstances' in kwargs:
            managed_instances = kwargs['managedInstances']
        if managed_instances is None:
            raise TypeError("Missing 'managed_instances' argument")
        if os_family is None and 'osFamily' in kwargs:
            os_family = kwargs['osFamily']
        if os_family is None:
            raise TypeError("Missing 'os_family' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("managed_instance_count", managed_instance_count)
        _setter("managed_instances", managed_instances)
        _setter("os_family", os_family)
        _setter("state", state)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Information specified by the user about the managed instance group
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="managedInstanceCount")
    def managed_instance_count(self) -> int:
        return pulumi.get(self, "managed_instance_count")

    @property
    @pulumi.getter(name="managedInstances")
    def managed_instances(self) -> Sequence['outputs.GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceResult']:
        """
        list of Managed Instances in the group
        """
        return pulumi.get(self, "managed_instances")

    @property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> str:
        """
        The OS family for which to list resources.
        """
        return pulumi.get(self, "os_family")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current lifecycle state for the object.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str):
        """
        :param str display_name: A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        :param str id: unique identifier that is immutable on creation
        """
        GetManagedInstanceGroupsManagedInstanceGroupManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetManagedInstanceManagedInstanceGroupResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str):
        """
        :param str display_name: User friendly name
        :param str id: software source identifier
        """
        GetManagedInstanceManagedInstanceGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        User friendly name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetManagedInstanceModuleStreamsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetManagedInstanceModuleStreamsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceResult(dict):
    def __init__(__self__, *,
                 module_name: str,
                 profiles: Sequence['outputs.GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileResult'],
                 software_source_id: str,
                 status: str,
                 stream_name: str,
                 time_modified: str):
        """
        :param str module_name: The name of a module.  This parameter is required if a streamName is specified.
        :param Sequence['GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileArgs'] profiles: The set of profiles that the module stream contains.
        :param str software_source_id: The OCID of the software source that provides this module stream.
        :param str status: The status of the stream
        :param str stream_name: The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        :param str time_modified: The date and time of the last status change for this profile, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            module_name=module_name,
            profiles=profiles,
            software_source_id=software_source_id,
            status=status,
            stream_name=stream_name,
            time_modified=time_modified,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             module_name: Optional[str] = None,
             profiles: Optional[Sequence['outputs.GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileResult']] = None,
             software_source_id: Optional[str] = None,
             status: Optional[str] = None,
             stream_name: Optional[str] = None,
             time_modified: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if module_name is None and 'moduleName' in kwargs:
            module_name = kwargs['moduleName']
        if module_name is None:
            raise TypeError("Missing 'module_name' argument")
        if profiles is None:
            raise TypeError("Missing 'profiles' argument")
        if software_source_id is None and 'softwareSourceId' in kwargs:
            software_source_id = kwargs['softwareSourceId']
        if software_source_id is None:
            raise TypeError("Missing 'software_source_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")
        if time_modified is None and 'timeModified' in kwargs:
            time_modified = kwargs['timeModified']
        if time_modified is None:
            raise TypeError("Missing 'time_modified' argument")

        _setter("module_name", module_name)
        _setter("profiles", profiles)
        _setter("software_source_id", software_source_id)
        _setter("status", status)
        _setter("stream_name", stream_name)
        _setter("time_modified", time_modified)

    @property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> str:
        """
        The name of a module.  This parameter is required if a streamName is specified.
        """
        return pulumi.get(self, "module_name")

    @property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileResult']:
        """
        The set of profiles that the module stream contains.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter(name="softwareSourceId")
    def software_source_id(self) -> str:
        """
        The OCID of the software source that provides this module stream.
        """
        return pulumi.get(self, "software_source_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the stream
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="timeModified")
    def time_modified(self) -> str:
        """
        The date and time of the last status change for this profile, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        return pulumi.get(self, "time_modified")


@pulumi.output_type
class GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileResult(dict):
    def __init__(__self__, *,
                 module_name: str,
                 profile_name: str,
                 status: str,
                 stream_name: str,
                 time_modified: str):
        """
        :param str module_name: The name of a module.  This parameter is required if a streamName is specified.
        :param str profile_name: The name of the profile
        :param str status: The status of the stream
        :param str stream_name: The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        :param str time_modified: The date and time of the last status change for this profile, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        GetManagedInstanceModuleStreamsModuleStreamOnManagedInstanceProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            module_name=module_name,
            profile_name=profile_name,
            status=status,
            stream_name=stream_name,
            time_modified=time_modified,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             module_name: Optional[str] = None,
             profile_name: Optional[str] = None,
             status: Optional[str] = None,
             stream_name: Optional[str] = None,
             time_modified: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if module_name is None and 'moduleName' in kwargs:
            module_name = kwargs['moduleName']
        if module_name is None:
            raise TypeError("Missing 'module_name' argument")
        if profile_name is None and 'profileName' in kwargs:
            profile_name = kwargs['profileName']
        if profile_name is None:
            raise TypeError("Missing 'profile_name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")
        if time_modified is None and 'timeModified' in kwargs:
            time_modified = kwargs['timeModified']
        if time_modified is None:
            raise TypeError("Missing 'time_modified' argument")

        _setter("module_name", module_name)
        _setter("profile_name", profile_name)
        _setter("status", status)
        _setter("stream_name", stream_name)
        _setter("time_modified", time_modified)

    @property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> str:
        """
        The name of a module.  This parameter is required if a streamName is specified.
        """
        return pulumi.get(self, "module_name")

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> str:
        """
        The name of the profile
        """
        return pulumi.get(self, "profile_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the stream
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="timeModified")
    def time_modified(self) -> str:
        """
        The date and time of the last status change for this profile, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        return pulumi.get(self, "time_modified")


@pulumi.output_type
class GetManagedInstanceParentSoftwareSourceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: software source identifier
        :param str name: software source name
        """
        GetManagedInstanceParentSoftwareSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        software source name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetManagedInstanceStreamProfileFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetManagedInstanceStreamProfileFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedInstanceStreamProfileModuleStreamProfileOnManagedInstanceResult(dict):
    def __init__(__self__, *,
                 module_name: str,
                 profile_name: str,
                 status: str,
                 stream_name: str,
                 time_modified: str):
        """
        :param str module_name: The name of a module.  This parameter is required if a streamName is specified.
        :param str profile_name: The name of the profile of the containing module stream
        :param str status: The status of the profile.
        :param str stream_name: The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        :param str time_modified: The date and time of the last status change for this profile, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        GetManagedInstanceStreamProfileModuleStreamProfileOnManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            module_name=module_name,
            profile_name=profile_name,
            status=status,
            stream_name=stream_name,
            time_modified=time_modified,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             module_name: Optional[str] = None,
             profile_name: Optional[str] = None,
             status: Optional[str] = None,
             stream_name: Optional[str] = None,
             time_modified: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if module_name is None and 'moduleName' in kwargs:
            module_name = kwargs['moduleName']
        if module_name is None:
            raise TypeError("Missing 'module_name' argument")
        if profile_name is None and 'profileName' in kwargs:
            profile_name = kwargs['profileName']
        if profile_name is None:
            raise TypeError("Missing 'profile_name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")
        if time_modified is None and 'timeModified' in kwargs:
            time_modified = kwargs['timeModified']
        if time_modified is None:
            raise TypeError("Missing 'time_modified' argument")

        _setter("module_name", module_name)
        _setter("profile_name", profile_name)
        _setter("status", status)
        _setter("stream_name", stream_name)
        _setter("time_modified", time_modified)

    @property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> str:
        """
        The name of a module.  This parameter is required if a streamName is specified.
        """
        return pulumi.get(self, "module_name")

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> str:
        """
        The name of the profile of the containing module stream
        """
        return pulumi.get(self, "profile_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the profile.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="timeModified")
    def time_modified(self) -> str:
        """
        The date and time of the last status change for this profile, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339), section 14.29.
        """
        return pulumi.get(self, "time_modified")


@pulumi.output_type
class GetManagedInstancesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: software source name
        """
        GetManagedInstancesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        software source name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedInstancesManagedInstanceResult(dict):
    def __init__(__self__, *,
                 autonomouses: Sequence['outputs.GetManagedInstancesManagedInstanceAutonomouseResult'],
                 bug_updates_available: int,
                 child_software_sources: Sequence['outputs.GetManagedInstancesManagedInstanceChildSoftwareSourceResult'],
                 compartment_id: str,
                 description: str,
                 display_name: str,
                 enhancement_updates_available: int,
                 id: str,
                 is_data_collection_authorized: bool,
                 is_reboot_required: bool,
                 ksplice_effective_kernel_version: str,
                 last_boot: str,
                 last_checkin: str,
                 managed_instance_groups: Sequence['outputs.GetManagedInstancesManagedInstanceManagedInstanceGroupResult'],
                 managed_instance_id: str,
                 notification_topic_id: str,
                 os_family: str,
                 os_kernel_version: str,
                 os_name: str,
                 os_version: str,
                 other_updates_available: int,
                 parent_software_sources: Sequence['outputs.GetManagedInstancesManagedInstanceParentSoftwareSourceResult'],
                 scheduled_job_count: int,
                 security_updates_available: int,
                 status: str,
                 updates_available: int,
                 work_request_count: int):
        """
        :param Sequence['GetManagedInstancesManagedInstanceAutonomouseArgs'] autonomouses: if present, indicates the Managed Instance is an autonomous instance. Holds all the Autonomous specific information
        :param int bug_updates_available: Number of bug fix type updates available to be installed
        :param Sequence['GetManagedInstancesManagedInstanceChildSoftwareSourceArgs'] child_software_sources: list of child Software Sources attached to the Managed Instance
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: Information specified by the user about the managed instance
        :param str display_name: A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        :param int enhancement_updates_available: Number of enhancement type updates available to be installed
        :param str id: software source identifier
        :param bool is_data_collection_authorized: True if user allow data collection for this instance
        :param bool is_reboot_required: Indicates whether a reboot is required to complete installation of updates.
        :param str ksplice_effective_kernel_version: The ksplice effective kernel version
        :param str last_boot: Time at which the instance last booted
        :param str last_checkin: Time at which the instance last checked in
        :param Sequence['GetManagedInstancesManagedInstanceManagedInstanceGroupArgs'] managed_instance_groups: The ids of the managed instance groups of which this instance is a member.
        :param str notification_topic_id: OCID of the ONS topic used to send notification to users
        :param str os_family: The OS family for which to list resources.
        :param str os_kernel_version: Operating System Kernel Version
        :param str os_name: Operating System Name
        :param str os_version: Operating System Version
        :param int other_updates_available: Number of non-classified updates available to be installed
        :param Sequence['GetManagedInstancesManagedInstanceParentSoftwareSourceArgs'] parent_software_sources: the parent (base) Software Source attached to the Managed Instance
        :param int scheduled_job_count: Number of scheduled jobs associated with this instance
        :param int security_updates_available: Number of security type updates available to be installed
        :param str status: status of the managed instance.
        :param int updates_available: Number of updates available to be installed
        :param int work_request_count: Number of work requests associated with this instance
        """
        GetManagedInstancesManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomouses=autonomouses,
            bug_updates_available=bug_updates_available,
            child_software_sources=child_software_sources,
            compartment_id=compartment_id,
            description=description,
            display_name=display_name,
            enhancement_updates_available=enhancement_updates_available,
            id=id,
            is_data_collection_authorized=is_data_collection_authorized,
            is_reboot_required=is_reboot_required,
            ksplice_effective_kernel_version=ksplice_effective_kernel_version,
            last_boot=last_boot,
            last_checkin=last_checkin,
            managed_instance_groups=managed_instance_groups,
            managed_instance_id=managed_instance_id,
            notification_topic_id=notification_topic_id,
            os_family=os_family,
            os_kernel_version=os_kernel_version,
            os_name=os_name,
            os_version=os_version,
            other_updates_available=other_updates_available,
            parent_software_sources=parent_software_sources,
            scheduled_job_count=scheduled_job_count,
            security_updates_available=security_updates_available,
            status=status,
            updates_available=updates_available,
            work_request_count=work_request_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomouses: Optional[Sequence['outputs.GetManagedInstancesManagedInstanceAutonomouseResult']] = None,
             bug_updates_available: Optional[int] = None,
             child_software_sources: Optional[Sequence['outputs.GetManagedInstancesManagedInstanceChildSoftwareSourceResult']] = None,
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             enhancement_updates_available: Optional[int] = None,
             id: Optional[str] = None,
             is_data_collection_authorized: Optional[bool] = None,
             is_reboot_required: Optional[bool] = None,
             ksplice_effective_kernel_version: Optional[str] = None,
             last_boot: Optional[str] = None,
             last_checkin: Optional[str] = None,
             managed_instance_groups: Optional[Sequence['outputs.GetManagedInstancesManagedInstanceManagedInstanceGroupResult']] = None,
             managed_instance_id: Optional[str] = None,
             notification_topic_id: Optional[str] = None,
             os_family: Optional[str] = None,
             os_kernel_version: Optional[str] = None,
             os_name: Optional[str] = None,
             os_version: Optional[str] = None,
             other_updates_available: Optional[int] = None,
             parent_software_sources: Optional[Sequence['outputs.GetManagedInstancesManagedInstanceParentSoftwareSourceResult']] = None,
             scheduled_job_count: Optional[int] = None,
             security_updates_available: Optional[int] = None,
             status: Optional[str] = None,
             updates_available: Optional[int] = None,
             work_request_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if autonomouses is None:
            raise TypeError("Missing 'autonomouses' argument")
        if bug_updates_available is None and 'bugUpdatesAvailable' in kwargs:
            bug_updates_available = kwargs['bugUpdatesAvailable']
        if bug_updates_available is None:
            raise TypeError("Missing 'bug_updates_available' argument")
        if child_software_sources is None and 'childSoftwareSources' in kwargs:
            child_software_sources = kwargs['childSoftwareSources']
        if child_software_sources is None:
            raise TypeError("Missing 'child_software_sources' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if enhancement_updates_available is None and 'enhancementUpdatesAvailable' in kwargs:
            enhancement_updates_available = kwargs['enhancementUpdatesAvailable']
        if enhancement_updates_available is None:
            raise TypeError("Missing 'enhancement_updates_available' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_data_collection_authorized is None and 'isDataCollectionAuthorized' in kwargs:
            is_data_collection_authorized = kwargs['isDataCollectionAuthorized']
        if is_data_collection_authorized is None:
            raise TypeError("Missing 'is_data_collection_authorized' argument")
        if is_reboot_required is None and 'isRebootRequired' in kwargs:
            is_reboot_required = kwargs['isRebootRequired']
        if is_reboot_required is None:
            raise TypeError("Missing 'is_reboot_required' argument")
        if ksplice_effective_kernel_version is None and 'kspliceEffectiveKernelVersion' in kwargs:
            ksplice_effective_kernel_version = kwargs['kspliceEffectiveKernelVersion']
        if ksplice_effective_kernel_version is None:
            raise TypeError("Missing 'ksplice_effective_kernel_version' argument")
        if last_boot is None and 'lastBoot' in kwargs:
            last_boot = kwargs['lastBoot']
        if last_boot is None:
            raise TypeError("Missing 'last_boot' argument")
        if last_checkin is None and 'lastCheckin' in kwargs:
            last_checkin = kwargs['lastCheckin']
        if last_checkin is None:
            raise TypeError("Missing 'last_checkin' argument")
        if managed_instance_groups is None and 'managedInstanceGroups' in kwargs:
            managed_instance_groups = kwargs['managedInstanceGroups']
        if managed_instance_groups is None:
            raise TypeError("Missing 'managed_instance_groups' argument")
        if managed_instance_id is None and 'managedInstanceId' in kwargs:
            managed_instance_id = kwargs['managedInstanceId']
        if managed_instance_id is None:
            raise TypeError("Missing 'managed_instance_id' argument")
        if notification_topic_id is None and 'notificationTopicId' in kwargs:
            notification_topic_id = kwargs['notificationTopicId']
        if notification_topic_id is None:
            raise TypeError("Missing 'notification_topic_id' argument")
        if os_family is None and 'osFamily' in kwargs:
            os_family = kwargs['osFamily']
        if os_family is None:
            raise TypeError("Missing 'os_family' argument")
        if os_kernel_version is None and 'osKernelVersion' in kwargs:
            os_kernel_version = kwargs['osKernelVersion']
        if os_kernel_version is None:
            raise TypeError("Missing 'os_kernel_version' argument")
        if os_name is None and 'osName' in kwargs:
            os_name = kwargs['osName']
        if os_name is None:
            raise TypeError("Missing 'os_name' argument")
        if os_version is None and 'osVersion' in kwargs:
            os_version = kwargs['osVersion']
        if os_version is None:
            raise TypeError("Missing 'os_version' argument")
        if other_updates_available is None and 'otherUpdatesAvailable' in kwargs:
            other_updates_available = kwargs['otherUpdatesAvailable']
        if other_updates_available is None:
            raise TypeError("Missing 'other_updates_available' argument")
        if parent_software_sources is None and 'parentSoftwareSources' in kwargs:
            parent_software_sources = kwargs['parentSoftwareSources']
        if parent_software_sources is None:
            raise TypeError("Missing 'parent_software_sources' argument")
        if scheduled_job_count is None and 'scheduledJobCount' in kwargs:
            scheduled_job_count = kwargs['scheduledJobCount']
        if scheduled_job_count is None:
            raise TypeError("Missing 'scheduled_job_count' argument")
        if security_updates_available is None and 'securityUpdatesAvailable' in kwargs:
            security_updates_available = kwargs['securityUpdatesAvailable']
        if security_updates_available is None:
            raise TypeError("Missing 'security_updates_available' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if updates_available is None and 'updatesAvailable' in kwargs:
            updates_available = kwargs['updatesAvailable']
        if updates_available is None:
            raise TypeError("Missing 'updates_available' argument")
        if work_request_count is None and 'workRequestCount' in kwargs:
            work_request_count = kwargs['workRequestCount']
        if work_request_count is None:
            raise TypeError("Missing 'work_request_count' argument")

        _setter("autonomouses", autonomouses)
        _setter("bug_updates_available", bug_updates_available)
        _setter("child_software_sources", child_software_sources)
        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("enhancement_updates_available", enhancement_updates_available)
        _setter("id", id)
        _setter("is_data_collection_authorized", is_data_collection_authorized)
        _setter("is_reboot_required", is_reboot_required)
        _setter("ksplice_effective_kernel_version", ksplice_effective_kernel_version)
        _setter("last_boot", last_boot)
        _setter("last_checkin", last_checkin)
        _setter("managed_instance_groups", managed_instance_groups)
        _setter("managed_instance_id", managed_instance_id)
        _setter("notification_topic_id", notification_topic_id)
        _setter("os_family", os_family)
        _setter("os_kernel_version", os_kernel_version)
        _setter("os_name", os_name)
        _setter("os_version", os_version)
        _setter("other_updates_available", other_updates_available)
        _setter("parent_software_sources", parent_software_sources)
        _setter("scheduled_job_count", scheduled_job_count)
        _setter("security_updates_available", security_updates_available)
        _setter("status", status)
        _setter("updates_available", updates_available)
        _setter("work_request_count", work_request_count)

    @property
    @pulumi.getter
    def autonomouses(self) -> Sequence['outputs.GetManagedInstancesManagedInstanceAutonomouseResult']:
        """
        if present, indicates the Managed Instance is an autonomous instance. Holds all the Autonomous specific information
        """
        return pulumi.get(self, "autonomouses")

    @property
    @pulumi.getter(name="bugUpdatesAvailable")
    def bug_updates_available(self) -> int:
        """
        Number of bug fix type updates available to be installed
        """
        return pulumi.get(self, "bug_updates_available")

    @property
    @pulumi.getter(name="childSoftwareSources")
    def child_software_sources(self) -> Sequence['outputs.GetManagedInstancesManagedInstanceChildSoftwareSourceResult']:
        """
        list of child Software Sources attached to the Managed Instance
        """
        return pulumi.get(self, "child_software_sources")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Information specified by the user about the managed instance
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="enhancementUpdatesAvailable")
    def enhancement_updates_available(self) -> int:
        """
        Number of enhancement type updates available to be installed
        """
        return pulumi.get(self, "enhancement_updates_available")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDataCollectionAuthorized")
    def is_data_collection_authorized(self) -> bool:
        """
        True if user allow data collection for this instance
        """
        return pulumi.get(self, "is_data_collection_authorized")

    @property
    @pulumi.getter(name="isRebootRequired")
    def is_reboot_required(self) -> bool:
        """
        Indicates whether a reboot is required to complete installation of updates.
        """
        return pulumi.get(self, "is_reboot_required")

    @property
    @pulumi.getter(name="kspliceEffectiveKernelVersion")
    def ksplice_effective_kernel_version(self) -> str:
        """
        The ksplice effective kernel version
        """
        return pulumi.get(self, "ksplice_effective_kernel_version")

    @property
    @pulumi.getter(name="lastBoot")
    def last_boot(self) -> str:
        """
        Time at which the instance last booted
        """
        return pulumi.get(self, "last_boot")

    @property
    @pulumi.getter(name="lastCheckin")
    def last_checkin(self) -> str:
        """
        Time at which the instance last checked in
        """
        return pulumi.get(self, "last_checkin")

    @property
    @pulumi.getter(name="managedInstanceGroups")
    def managed_instance_groups(self) -> Sequence['outputs.GetManagedInstancesManagedInstanceManagedInstanceGroupResult']:
        """
        The ids of the managed instance groups of which this instance is a member.
        """
        return pulumi.get(self, "managed_instance_groups")

    @property
    @pulumi.getter(name="managedInstanceId")
    def managed_instance_id(self) -> str:
        return pulumi.get(self, "managed_instance_id")

    @property
    @pulumi.getter(name="notificationTopicId")
    def notification_topic_id(self) -> str:
        """
        OCID of the ONS topic used to send notification to users
        """
        return pulumi.get(self, "notification_topic_id")

    @property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> str:
        """
        The OS family for which to list resources.
        """
        return pulumi.get(self, "os_family")

    @property
    @pulumi.getter(name="osKernelVersion")
    def os_kernel_version(self) -> str:
        """
        Operating System Kernel Version
        """
        return pulumi.get(self, "os_kernel_version")

    @property
    @pulumi.getter(name="osName")
    def os_name(self) -> str:
        """
        Operating System Name
        """
        return pulumi.get(self, "os_name")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> str:
        """
        Operating System Version
        """
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter(name="otherUpdatesAvailable")
    def other_updates_available(self) -> int:
        """
        Number of non-classified updates available to be installed
        """
        return pulumi.get(self, "other_updates_available")

    @property
    @pulumi.getter(name="parentSoftwareSources")
    def parent_software_sources(self) -> Sequence['outputs.GetManagedInstancesManagedInstanceParentSoftwareSourceResult']:
        """
        the parent (base) Software Source attached to the Managed Instance
        """
        return pulumi.get(self, "parent_software_sources")

    @property
    @pulumi.getter(name="scheduledJobCount")
    def scheduled_job_count(self) -> int:
        """
        Number of scheduled jobs associated with this instance
        """
        return pulumi.get(self, "scheduled_job_count")

    @property
    @pulumi.getter(name="securityUpdatesAvailable")
    def security_updates_available(self) -> int:
        """
        Number of security type updates available to be installed
        """
        return pulumi.get(self, "security_updates_available")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        status of the managed instance.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatesAvailable")
    def updates_available(self) -> int:
        """
        Number of updates available to be installed
        """
        return pulumi.get(self, "updates_available")

    @property
    @pulumi.getter(name="workRequestCount")
    def work_request_count(self) -> int:
        """
        Number of work requests associated with this instance
        """
        return pulumi.get(self, "work_request_count")


@pulumi.output_type
class GetManagedInstancesManagedInstanceAutonomouseResult(dict):
    def __init__(__self__, *,
                 is_auto_update_enabled: bool):
        """
        :param bool is_auto_update_enabled: True if daily updates are enabled
        """
        GetManagedInstancesManagedInstanceAutonomouseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_auto_update_enabled=is_auto_update_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_auto_update_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_auto_update_enabled is None and 'isAutoUpdateEnabled' in kwargs:
            is_auto_update_enabled = kwargs['isAutoUpdateEnabled']
        if is_auto_update_enabled is None:
            raise TypeError("Missing 'is_auto_update_enabled' argument")

        _setter("is_auto_update_enabled", is_auto_update_enabled)

    @property
    @pulumi.getter(name="isAutoUpdateEnabled")
    def is_auto_update_enabled(self) -> bool:
        """
        True if daily updates are enabled
        """
        return pulumi.get(self, "is_auto_update_enabled")


@pulumi.output_type
class GetManagedInstancesManagedInstanceChildSoftwareSourceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: software source identifier
        :param str name: software source name
        """
        GetManagedInstancesManagedInstanceChildSoftwareSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        software source name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetManagedInstancesManagedInstanceManagedInstanceGroupResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str):
        """
        :param str display_name: A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        :param str id: software source identifier
        """
        GetManagedInstancesManagedInstanceManagedInstanceGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetManagedInstancesManagedInstanceParentSoftwareSourceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: software source identifier
        :param str name: software source name
        """
        GetManagedInstancesManagedInstanceParentSoftwareSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        software source name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSoftwareSourceAssociatedManagedInstanceResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str):
        """
        :param str display_name: User friendly name for the software source
        :param str id: OCID for the Software Source
        """
        GetSoftwareSourceAssociatedManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        User friendly name for the software source
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        OCID for the Software Source
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSoftwareSourceStreamProfileFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSoftwareSourceStreamProfileFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSoftwareSourceStreamProfileModuleStreamProfileResult(dict):
    def __init__(__self__, *,
                 module_name: str,
                 profile_name: str,
                 stream_name: str):
        """
        :param str module_name: The name of a module.  This parameter is required if a streamName is specified.
        :param str profile_name: The name of the profile of the containing module stream
        :param str stream_name: The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        """
        GetSoftwareSourceStreamProfileModuleStreamProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            module_name=module_name,
            profile_name=profile_name,
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             module_name: Optional[str] = None,
             profile_name: Optional[str] = None,
             stream_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if module_name is None and 'moduleName' in kwargs:
            module_name = kwargs['moduleName']
        if module_name is None:
            raise TypeError("Missing 'module_name' argument")
        if profile_name is None and 'profileName' in kwargs:
            profile_name = kwargs['profileName']
        if profile_name is None:
            raise TypeError("Missing 'profile_name' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")

        _setter("module_name", module_name)
        _setter("profile_name", profile_name)
        _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="moduleName")
    def module_name(self) -> str:
        """
        The name of a module.  This parameter is required if a streamName is specified.
        """
        return pulumi.get(self, "module_name")

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> str:
        """
        The name of the profile of the containing module stream
        """
        return pulumi.get(self, "profile_name")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the stream of the containing module.  This parameter is required if a profileName is specified.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetSoftwareSourcesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSoftwareSourcesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSoftwareSourcesSoftwareSourceResult(dict):
    def __init__(__self__, *,
                 arch_type: str,
                 associated_managed_instances: Sequence['outputs.GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceResult'],
                 checksum_type: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 gpg_key_fingerprint: str,
                 gpg_key_id: str,
                 gpg_key_url: str,
                 id: str,
                 maintainer_email: str,
                 maintainer_name: str,
                 maintainer_phone: str,
                 packages: int,
                 parent_id: str,
                 parent_name: str,
                 repo_type: str,
                 state: str,
                 status: str,
                 url: str):
        """
        :param str arch_type: The architecture type supported by the Software Source
        :param Sequence['GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceArgs'] associated_managed_instances: list of the Managed Instances associated with this Software Sources
        :param str checksum_type: The yum repository checksum type used by this software source
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: Information specified by the user about the software source
        :param str display_name: A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str gpg_key_fingerprint: Fingerprint of the GPG key for this software source
        :param str gpg_key_id: ID of the GPG key for this software source
        :param str gpg_key_url: URL of the GPG key for this software source
        :param str id: OCID for the Software Source
        :param str maintainer_email: Email address of the person maintaining this software source
        :param str maintainer_name: Name of the person maintaining this software source
        :param str maintainer_phone: Phone number of the person maintaining this software source
        :param int packages: Number of packages
        :param str parent_id: OCID for the parent software source, if there is one
        :param str parent_name: Display name the parent software source, if there is one
        :param str repo_type: Type of the Software Source
        :param str state: The current lifecycle state for the object.
        :param str status: status of the software source.
        :param str url: URL for the repostiory
        """
        GetSoftwareSourcesSoftwareSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arch_type=arch_type,
            associated_managed_instances=associated_managed_instances,
            checksum_type=checksum_type,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            gpg_key_fingerprint=gpg_key_fingerprint,
            gpg_key_id=gpg_key_id,
            gpg_key_url=gpg_key_url,
            id=id,
            maintainer_email=maintainer_email,
            maintainer_name=maintainer_name,
            maintainer_phone=maintainer_phone,
            packages=packages,
            parent_id=parent_id,
            parent_name=parent_name,
            repo_type=repo_type,
            state=state,
            status=status,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arch_type: Optional[str] = None,
             associated_managed_instances: Optional[Sequence['outputs.GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceResult']] = None,
             checksum_type: Optional[str] = None,
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             gpg_key_fingerprint: Optional[str] = None,
             gpg_key_id: Optional[str] = None,
             gpg_key_url: Optional[str] = None,
             id: Optional[str] = None,
             maintainer_email: Optional[str] = None,
             maintainer_name: Optional[str] = None,
             maintainer_phone: Optional[str] = None,
             packages: Optional[int] = None,
             parent_id: Optional[str] = None,
             parent_name: Optional[str] = None,
             repo_type: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arch_type is None and 'archType' in kwargs:
            arch_type = kwargs['archType']
        if arch_type is None:
            raise TypeError("Missing 'arch_type' argument")
        if associated_managed_instances is None and 'associatedManagedInstances' in kwargs:
            associated_managed_instances = kwargs['associatedManagedInstances']
        if associated_managed_instances is None:
            raise TypeError("Missing 'associated_managed_instances' argument")
        if checksum_type is None and 'checksumType' in kwargs:
            checksum_type = kwargs['checksumType']
        if checksum_type is None:
            raise TypeError("Missing 'checksum_type' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if gpg_key_fingerprint is None and 'gpgKeyFingerprint' in kwargs:
            gpg_key_fingerprint = kwargs['gpgKeyFingerprint']
        if gpg_key_fingerprint is None:
            raise TypeError("Missing 'gpg_key_fingerprint' argument")
        if gpg_key_id is None and 'gpgKeyId' in kwargs:
            gpg_key_id = kwargs['gpgKeyId']
        if gpg_key_id is None:
            raise TypeError("Missing 'gpg_key_id' argument")
        if gpg_key_url is None and 'gpgKeyUrl' in kwargs:
            gpg_key_url = kwargs['gpgKeyUrl']
        if gpg_key_url is None:
            raise TypeError("Missing 'gpg_key_url' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if maintainer_email is None and 'maintainerEmail' in kwargs:
            maintainer_email = kwargs['maintainerEmail']
        if maintainer_email is None:
            raise TypeError("Missing 'maintainer_email' argument")
        if maintainer_name is None and 'maintainerName' in kwargs:
            maintainer_name = kwargs['maintainerName']
        if maintainer_name is None:
            raise TypeError("Missing 'maintainer_name' argument")
        if maintainer_phone is None and 'maintainerPhone' in kwargs:
            maintainer_phone = kwargs['maintainerPhone']
        if maintainer_phone is None:
            raise TypeError("Missing 'maintainer_phone' argument")
        if packages is None:
            raise TypeError("Missing 'packages' argument")
        if parent_id is None and 'parentId' in kwargs:
            parent_id = kwargs['parentId']
        if parent_id is None:
            raise TypeError("Missing 'parent_id' argument")
        if parent_name is None and 'parentName' in kwargs:
            parent_name = kwargs['parentName']
        if parent_name is None:
            raise TypeError("Missing 'parent_name' argument")
        if repo_type is None and 'repoType' in kwargs:
            repo_type = kwargs['repoType']
        if repo_type is None:
            raise TypeError("Missing 'repo_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")

        _setter("arch_type", arch_type)
        _setter("associated_managed_instances", associated_managed_instances)
        _setter("checksum_type", checksum_type)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("gpg_key_fingerprint", gpg_key_fingerprint)
        _setter("gpg_key_id", gpg_key_id)
        _setter("gpg_key_url", gpg_key_url)
        _setter("id", id)
        _setter("maintainer_email", maintainer_email)
        _setter("maintainer_name", maintainer_name)
        _setter("maintainer_phone", maintainer_phone)
        _setter("packages", packages)
        _setter("parent_id", parent_id)
        _setter("parent_name", parent_name)
        _setter("repo_type", repo_type)
        _setter("state", state)
        _setter("status", status)
        _setter("url", url)

    @property
    @pulumi.getter(name="archType")
    def arch_type(self) -> str:
        """
        The architecture type supported by the Software Source
        """
        return pulumi.get(self, "arch_type")

    @property
    @pulumi.getter(name="associatedManagedInstances")
    def associated_managed_instances(self) -> Sequence['outputs.GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceResult']:
        """
        list of the Managed Instances associated with this Software Sources
        """
        return pulumi.get(self, "associated_managed_instances")

    @property
    @pulumi.getter(name="checksumType")
    def checksum_type(self) -> str:
        """
        The yum repository checksum type used by this software source
        """
        return pulumi.get(self, "checksum_type")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Information specified by the user about the software source
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="gpgKeyFingerprint")
    def gpg_key_fingerprint(self) -> str:
        """
        Fingerprint of the GPG key for this software source
        """
        return pulumi.get(self, "gpg_key_fingerprint")

    @property
    @pulumi.getter(name="gpgKeyId")
    def gpg_key_id(self) -> str:
        """
        ID of the GPG key for this software source
        """
        return pulumi.get(self, "gpg_key_id")

    @property
    @pulumi.getter(name="gpgKeyUrl")
    def gpg_key_url(self) -> str:
        """
        URL of the GPG key for this software source
        """
        return pulumi.get(self, "gpg_key_url")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        OCID for the Software Source
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maintainerEmail")
    def maintainer_email(self) -> str:
        """
        Email address of the person maintaining this software source
        """
        return pulumi.get(self, "maintainer_email")

    @property
    @pulumi.getter(name="maintainerName")
    def maintainer_name(self) -> str:
        """
        Name of the person maintaining this software source
        """
        return pulumi.get(self, "maintainer_name")

    @property
    @pulumi.getter(name="maintainerPhone")
    def maintainer_phone(self) -> str:
        """
        Phone number of the person maintaining this software source
        """
        return pulumi.get(self, "maintainer_phone")

    @property
    @pulumi.getter
    def packages(self) -> int:
        """
        Number of packages
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> str:
        """
        OCID for the parent software source, if there is one
        """
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="parentName")
    def parent_name(self) -> str:
        """
        Display name the parent software source, if there is one
        """
        return pulumi.get(self, "parent_name")

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> str:
        """
        Type of the Software Source
        """
        return pulumi.get(self, "repo_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current lifecycle state for the object.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        status of the software source.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL for the repostiory
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str):
        """
        :param str display_name: A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        :param str id: OCID for the Software Source
        """
        GetSoftwareSourcesSoftwareSourceAssociatedManagedInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name. Does not have to be unique, and it's changeable.  Example: `My new resource`
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        OCID for the Software Source
        """
        return pulumi.get(self, "id")


